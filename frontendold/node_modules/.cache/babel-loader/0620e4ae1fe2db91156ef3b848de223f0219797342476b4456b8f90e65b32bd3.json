{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/layout/Background.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useCallback, useMemo } from 'react';\n\n/**\n * Background Component\n * \n * Creates an immersive star background with stars that drift slowly in various directions.\n * Stars naturally fade out when they leave the viewport and new ones fade in elsewhere.\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Background = ({\n  config = {}\n}) => {\n  _s();\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const starsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimeRef = useRef(0);\n\n  // Use refs instead of state to prevent re-renders\n  const isInitializedRef = useRef(false);\n\n  // Store dimensions in a ref to avoid re-renders when they change\n  const dimensionsRef = useRef({\n    width: 0,\n    height: 0,\n    pixelRatio: 1\n  });\n\n  // Configuration - wrapped in useMemo to prevent recreation on each render\n  // Merge default config with user-provided config\n  const CONFIG = useMemo(() => ({\n    // Star appearance\n    starCount: 200,\n    starSizeMin: 0.8,\n    starSizeMax: 2.5,\n    starOpacityMin: 0.15,\n    starOpacityMax: 0.85,\n    // Movement parameters\n    driftSpeedMin: 0.005,\n    // Very slow minimum drift speed (pixels per second)\n    driftSpeedMax: 0.02,\n    // Maximum drift speed (pixels per second)\n\n    // Twinkling effect parameters\n    twinkleEnabled: true,\n    // Enable stars to fade in and out\n    twinkleProbability: 0.002,\n    // Probability of a star beginning to twinkle each frame\n    twinkleDuration: [3000, 6000],\n    // Min and max duration of a twinkle cycle in ms\n\n    // Fade in/out durations\n    fadeInDuration: 3000,\n    // Time for a new star to fully appear (ms)\n    fadeOutDuration: 3000,\n    // Time for a star to disappear when out of bounds (ms)\n\n    // Star regeneration\n    regenerationDelay: 500,\n    // Delay before creating a new star after one fades out (ms)\n\n    // Performance parameters\n    maxFPS: 60,\n    // Session persistence\n    sessionKey: 'drifting_star_background_config',\n    // Override with user config\n    ...config\n  }), [config]);\n\n  // Warm, golden color palette - wrapped in useMemo\n  const COLORS = useMemo(() => ({\n    // Star colors\n    stars: ['rgba(255, 243, 200, alpha)',\n    // Warm yellow\n    'rgba(255, 231, 164, alpha)',\n    // Golden\n    'rgba(252, 249, 231, alpha)' // Off-white gold\n    ],\n    // Background gradient colors\n    background: {\n      topColor: 'rgb(8, 8, 12)',\n      bottomColor: 'rgb(15, 15, 20)'\n    },\n    // Override with user config if provided\n    ...(config.colors || {})\n  }), [config.colors]);\n\n  // Pre-generated color values to avoid string replacements during animation\n  const colorCache = useMemo(() => {\n    const cache = {};\n    COLORS.stars.forEach(baseColor => {\n      cache[baseColor] = {};\n      for (let opacity = 0; opacity <= 10; opacity++) {\n        const value = opacity / 10;\n        cache[baseColor][value] = baseColor.replace(/alpha\\)$/, `${value})`);\n      }\n    });\n    return cache;\n  }, [COLORS.stars]);\n\n  // Get color with opacity from cache (faster than string replacement)\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    // Round to nearest 0.1 to use cached values\n    const roundedOpacity = Math.round(safeOpacity * 10) / 10;\n    return colorCache[baseColor][roundedOpacity] || baseColor.replace(/alpha\\)$/, `${safeOpacity})`);\n  }, [colorCache]);\n\n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) return false;\n    const canvas = canvasRef.current;\n\n    // Get viewport dimensions\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const pixelRatio = window.devicePixelRatio || 1;\n\n    // Set canvas size accounting for pixel ratio\n    canvas.width = width * pixelRatio;\n    canvas.height = height * pixelRatio;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n\n    // Ensure canvas is visible with a background color\n    const ctx = canvas.getContext('2d', {\n      alpha: false\n    }); // Optimize for non-transparent canvas\n    if (ctx) {\n      // Create gradient background\n      const gradient = ctx.createLinearGradient(0, 0, 0, height * pixelRatio);\n      gradient.addColorStop(0, COLORS.background.topColor);\n      gradient.addColorStop(1, COLORS.background.bottomColor);\n      ctx.fillStyle = gradient;\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n\n    // Update dimensions ref instead of state\n    dimensionsRef.current = {\n      width,\n      height,\n      pixelRatio\n    };\n    return true;\n  }, [COLORS.background]);\n\n  // Create a single star with specified parameters\n  const createStar = useCallback((fadeIn = true, x = null, y = null) => {\n    const {\n      width,\n      height\n    } = dimensionsRef.current;\n    const star = {};\n\n    // Position - random if not specified\n    star.x = x !== null ? x : Math.random() * width;\n    star.y = y !== null ? y : Math.random() * height;\n\n    // Random depth factor (affects size and opacity)\n    star.z = Math.random() * 0.8 + 0.1; // Depth (0.1 to 0.9)\n\n    // Visual properties\n    star.size = (Math.random() * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n    star.baseOpacity = Math.random() * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n\n    // Set initial opacity based on whether we're fading in\n    star.opacity = fadeIn ? 0 : star.baseOpacity;\n\n    // Lifecycle state\n    star.state = fadeIn ? 'fading-in' : 'visible';\n    star.fadeStartTime = Date.now();\n\n    // Direction and speed (in pixels per second)\n    // Random angle for movement direction\n    const angle = Math.random() * Math.PI * 2;\n    const speed = Math.random() * (CONFIG.driftSpeedMax - CONFIG.driftSpeedMin) + CONFIG.driftSpeedMin;\n\n    // Calculate vector components for the angle\n    star.dx = Math.cos(angle) * speed;\n    star.dy = Math.sin(angle) * speed;\n\n    // Twinkling properties\n    star.twinkleState = 'visible'; // 'fading-in', 'visible', 'fading-out', 'hidden'\n    star.twinkleProgress = 0;\n    star.twinkleDuration = Math.random() * (CONFIG.twinkleDuration[1] - CONFIG.twinkleDuration[0]) + CONFIG.twinkleDuration[0];\n\n    // Color variation\n    star.color = COLORS.stars[Math.floor(Math.random() * COLORS.stars.length)];\n    return star;\n  }, [CONFIG, COLORS.stars]);\n\n  // Initialize stars\n  const initializeStars = useCallback(() => {\n    const {\n      width,\n      height\n    } = dimensionsRef.current;\n    if (!width || !height) return;\n\n    // Clear existing stars\n    starsRef.current = [];\n\n    // Create initial set of stars (already visible, no fade-in)\n    for (let i = 0; i < CONFIG.starCount; i++) {\n      const star = createStar(false);\n      starsRef.current.push(star);\n    }\n  }, [CONFIG.starCount, createStar]);\n\n  // Optimized star rendering\n  const drawStar = useCallback((ctx, star) => {\n    // Skip rendering completely invisible stars\n    if (star.opacity < 0.02) return;\n\n    // Simplified star rendering\n    ctx.beginPath();\n    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n    ctx.fillStyle = getColor(star.color, star.opacity);\n    ctx.fill();\n\n    // Simple glow effect for brighter stars\n    if (star.opacity > 0.3) {\n      ctx.beginPath();\n      ctx.arc(star.x, star.y, star.size * 1.8, 0, Math.PI * 2);\n      ctx.fillStyle = getColor(star.color, star.opacity * 0.4);\n      ctx.fill();\n    }\n  }, [getColor]);\n\n  // Render the scene - optimized for performance\n  const renderScene = useCallback(() => {\n    if (!canvasRef.current) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d', {\n      alpha: false\n    });\n    if (!ctx) return;\n    const {\n      width,\n      height,\n      pixelRatio\n    } = dimensionsRef.current;\n\n    // Clear canvas\n    // Create gradient background\n    const gradient = ctx.createLinearGradient(0, 0, 0, height * pixelRatio);\n    gradient.addColorStop(0, COLORS.background.topColor);\n    gradient.addColorStop(1, COLORS.background.bottomColor);\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, width * pixelRatio, height * pixelRatio);\n\n    // Apply device pixel ratio scaling only once\n    ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n\n    // Enable global composition for better glow effect\n    ctx.globalCompositeOperation = 'lighter';\n\n    // Draw stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n      drawStar(ctx, star);\n    }\n\n    // Reset global composition\n    ctx.globalCompositeOperation = 'source-over';\n  }, [COLORS.background, drawStar]);\n\n  // Update animation state - optimized for performance\n  const updateAnimation = useCallback((deltaTime, timestamp) => {\n    const {\n      width,\n      height\n    } = dimensionsRef.current;\n    const currentTime = Date.now();\n\n    // Track stars to remove\n    const starsToRemove = [];\n\n    // Update stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n\n      // Update position based on direction and speed\n      // Convert pixels per second to pixels per frame using deltaTime (in ms)\n      star.x += star.dx * (deltaTime / 1000);\n      star.y += star.dy * (deltaTime / 1000);\n\n      // Check if star is outside viewport bounds with a small buffer\n      const isOutOfBounds = star.x < -star.size * 2 || star.x > width + star.size * 2 || star.y < -star.size * 2 || star.y > height + star.size * 2;\n\n      // Handle lifecycle states\n      switch (star.state) {\n        case 'fading-in':\n          // Gradually increase opacity during fade-in\n          const fadeInProgress = (currentTime - star.fadeStartTime) / CONFIG.fadeInDuration;\n          if (fadeInProgress >= 1) {\n            star.opacity = star.baseOpacity;\n            star.state = 'visible';\n          } else {\n            star.opacity = star.baseOpacity * fadeInProgress;\n          }\n          break;\n        case 'visible':\n          if (isOutOfBounds) {\n            // Start fading out if star moves out of bounds\n            star.state = 'fading-out';\n            star.fadeStartTime = currentTime;\n          } else if (CONFIG.twinkleEnabled && Math.random() < CONFIG.twinkleProbability) {\n            // Occasionally start twinkling\n            star.twinkleState = star.twinkleState === 'visible' ? 'fading-out' : 'visible';\n            star.twinkleProgress = 0;\n          }\n\n          // Update twinkling effect if active\n          if (star.twinkleState !== 'visible') {\n            star.twinkleProgress += deltaTime / star.twinkleDuration;\n            if (star.twinkleProgress >= 1) {\n              // Switch twinkling state\n              if (star.twinkleState === 'fading-out') {\n                star.twinkleState = 'fading-in';\n                star.twinkleProgress = 0;\n              } else {\n                star.twinkleState = 'visible';\n              }\n            }\n\n            // Adjust opacity based on twinkle state\n            if (star.twinkleState === 'fading-out') {\n              star.opacity = star.baseOpacity * (1 - star.twinkleProgress * 0.7);\n            } else if (star.twinkleState === 'fading-in') {\n              star.opacity = star.baseOpacity * (0.3 + star.twinkleProgress * 0.7);\n            }\n          }\n          break;\n        case 'fading-out':\n          // Gradually decrease opacity during fade-out\n          const fadeOutProgress = (currentTime - star.fadeStartTime) / CONFIG.fadeOutDuration;\n          if (fadeOutProgress >= 1) {\n            // Mark for removal when fully faded out\n            starsToRemove.push(i);\n          } else {\n            star.opacity = star.baseOpacity * (1 - fadeOutProgress);\n          }\n          break;\n        default:\n          // Handle any unexpected star state\n          console.warn(`Unexpected star state: ${star.state}`);\n          star.state = 'visible';\n          star.opacity = star.baseOpacity;\n          break;\n      }\n    }\n\n    // Remove stars that have completely faded out (in reverse order to avoid index issues)\n    for (let i = starsToRemove.length - 1; i >= 0; i--) {\n      starsRef.current.splice(starsToRemove[i], 1);\n\n      // Schedule creation of a new star with slight delay\n      setTimeout(() => {\n        if (isInitializedRef.current) {\n          const newStar = createStar(true);\n          starsRef.current.push(newStar);\n        }\n      }, CONFIG.regenerationDelay);\n    }\n  }, [CONFIG, createStar]);\n\n  // Define the animation loop function\n  const animate = useCallback(function animationLoop(timestamp) {\n    if (!isInitializedRef.current) {\n      animationFrameRef.current = requestAnimationFrame(animationLoop);\n      return;\n    }\n\n    // Limit FPS\n    const minFrameTime = 1000 / CONFIG.maxFPS;\n    const elapsed = timestamp - (lastTimeRef.current || 0);\n    if (elapsed < minFrameTime) {\n      animationFrameRef.current = requestAnimationFrame(animationLoop);\n      return;\n    }\n\n    // Calculate delta time with cap to prevent large jumps\n    const deltaTime = lastTimeRef.current ? Math.min(elapsed, 50) : 16;\n    lastTimeRef.current = timestamp;\n\n    // Update animation state\n    updateAnimation(deltaTime, timestamp);\n\n    // Render scene\n    renderScene();\n\n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(animationLoop);\n  }, [CONFIG.maxFPS, updateAnimation, renderScene]);\n\n  // Comprehensive initialization and resize handling\n  useEffect(() => {\n    // One-time initialization function\n    const initialize = () => {\n      if (setupCanvas()) {\n        // Create stars only after canvas is ready\n        initializeStars();\n        // Mark as initialized but don't trigger re-render\n        isInitializedRef.current = true;\n        // Start animation only after everything is ready\n        animationFrameRef.current = requestAnimationFrame(animate);\n      }\n    };\n\n    // Handle resize events\n    const handleResize = () => {\n      // Only re-initialize if already initialized\n      if (isInitializedRef.current) {\n        setupCanvas();\n        initializeStars();\n        // No need to change initialization state\n      }\n    };\n\n    // Throttle resize events\n    let resizeTimer;\n    const throttledResize = () => {\n      if (!resizeTimer) {\n        resizeTimer = setTimeout(() => {\n          resizeTimer = null;\n          handleResize();\n        }, 200); // 200ms throttle\n      }\n    };\n\n    // Add resize listener\n    window.addEventListener('resize', throttledResize);\n\n    // Run initialization after first render is complete\n    // This prevents the \"double load\" effect\n    requestAnimationFrame(() => {\n      initialize();\n    });\n\n    // Cleanup\n    return () => {\n      window.removeEventListener('resize', throttledResize);\n      if (resizeTimer) clearTimeout(resizeTimer);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      isInitializedRef.current = false;\n    };\n  }, [setupCanvas, initializeStars, animate]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      width: '100vw',\n      height: '100vh',\n      overflow: 'hidden',\n      zIndex: -1,\n      pointerEvents: 'none'\n    },\n    \"aria-hidden\": \"true\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 456,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 442,\n    columnNumber: 5\n  }, this);\n};\n_s(Background, \"TgX2SVhpd7z7pFGH5kdO8cQX/Qs=\");\n_c = Background;\nexport default Background;\nvar _c;\n$RefreshReg$(_c, \"Background\");","map":{"version":3,"names":["React","useRef","useEffect","useCallback","useMemo","jsxDEV","_jsxDEV","Background","config","_s","containerRef","canvasRef","starsRef","animationFrameRef","lastTimeRef","isInitializedRef","dimensionsRef","width","height","pixelRatio","CONFIG","starCount","starSizeMin","starSizeMax","starOpacityMin","starOpacityMax","driftSpeedMin","driftSpeedMax","twinkleEnabled","twinkleProbability","twinkleDuration","fadeInDuration","fadeOutDuration","regenerationDelay","maxFPS","sessionKey","COLORS","stars","background","topColor","bottomColor","colors","colorCache","cache","forEach","baseColor","opacity","value","replace","getColor","safeOpacity","Math","max","min","roundedOpacity","round","setupCanvas","current","canvas","window","innerWidth","innerHeight","devicePixelRatio","style","ctx","getContext","alpha","gradient","createLinearGradient","addColorStop","fillStyle","fillRect","createStar","fadeIn","x","y","star","random","z","size","baseOpacity","state","fadeStartTime","Date","now","angle","PI","speed","dx","cos","dy","sin","twinkleState","twinkleProgress","color","floor","length","initializeStars","i","push","drawStar","beginPath","arc","fill","renderScene","setTransform","globalCompositeOperation","updateAnimation","deltaTime","timestamp","currentTime","starsToRemove","isOutOfBounds","fadeInProgress","fadeOutProgress","console","warn","splice","setTimeout","newStar","animate","animationLoop","requestAnimationFrame","minFrameTime","elapsed","initialize","handleResize","resizeTimer","throttledResize","addEventListener","removeEventListener","clearTimeout","cancelAnimationFrame","ref","position","top","left","overflow","zIndex","pointerEvents","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/layout/Background.jsx"],"sourcesContent":["import React, { useRef, useEffect, useCallback, useMemo } from 'react';\n\n/**\n * Background Component\n * \n * Creates an immersive star background with stars that drift slowly in various directions.\n * Stars naturally fade out when they leave the viewport and new ones fade in elsewhere.\n */\nconst Background = ({ config = {} }) => {\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const starsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimeRef = useRef(0);\n  \n  // Use refs instead of state to prevent re-renders\n  const isInitializedRef = useRef(false);\n  \n  // Store dimensions in a ref to avoid re-renders when they change\n  const dimensionsRef = useRef({ width: 0, height: 0, pixelRatio: 1 });\n  \n  // Configuration - wrapped in useMemo to prevent recreation on each render\n  // Merge default config with user-provided config\n  const CONFIG = useMemo(() => ({\n    // Star appearance\n    starCount: 200,\n    starSizeMin: 0.8,\n    starSizeMax: 2.5,\n    starOpacityMin: 0.15,\n    starOpacityMax: 0.85,\n    \n    // Movement parameters\n    driftSpeedMin: 0.005,    // Very slow minimum drift speed (pixels per second)\n    driftSpeedMax: 0.02,     // Maximum drift speed (pixels per second)\n    \n    // Twinkling effect parameters\n    twinkleEnabled: true,          // Enable stars to fade in and out\n    twinkleProbability: 0.002,     // Probability of a star beginning to twinkle each frame\n    twinkleDuration: [3000, 6000], // Min and max duration of a twinkle cycle in ms\n    \n    // Fade in/out durations\n    fadeInDuration: 3000,   // Time for a new star to fully appear (ms)\n    fadeOutDuration: 3000,  // Time for a star to disappear when out of bounds (ms)\n    \n    // Star regeneration\n    regenerationDelay: 500, // Delay before creating a new star after one fades out (ms)\n    \n    // Performance parameters\n    maxFPS: 60,\n    \n    // Session persistence\n    sessionKey: 'drifting_star_background_config',\n    \n    // Override with user config\n    ...config\n  }), [config]);\n  \n  // Warm, golden color palette - wrapped in useMemo\n  const COLORS = useMemo(() => ({\n    // Star colors\n    stars: [\n      'rgba(255, 243, 200, alpha)', // Warm yellow\n      'rgba(255, 231, 164, alpha)', // Golden\n      'rgba(252, 249, 231, alpha)'  // Off-white gold\n    ],\n    \n    // Background gradient colors\n    background: {\n      topColor: 'rgb(8, 8, 12)',\n      bottomColor: 'rgb(15, 15, 20)'\n    },\n    \n    // Override with user config if provided\n    ...(config.colors || {})\n  }), [config.colors]);\n  \n  // Pre-generated color values to avoid string replacements during animation\n  const colorCache = useMemo(() => {\n    const cache = {};\n    COLORS.stars.forEach(baseColor => {\n      cache[baseColor] = {};\n      for (let opacity = 0; opacity <= 10; opacity++) {\n        const value = opacity / 10;\n        cache[baseColor][value] = baseColor.replace(/alpha\\)$/, `${value})`);\n      }\n    });\n    return cache;\n  }, [COLORS.stars]);\n  \n  // Get color with opacity from cache (faster than string replacement)\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    // Round to nearest 0.1 to use cached values\n    const roundedOpacity = Math.round(safeOpacity * 10) / 10;\n    return colorCache[baseColor][roundedOpacity] || baseColor.replace(/alpha\\)$/, `${safeOpacity})`);\n  }, [colorCache]);\n  \n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) return false;\n    \n    const canvas = canvasRef.current;\n    \n    // Get viewport dimensions\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const pixelRatio = window.devicePixelRatio || 1;\n    \n    // Set canvas size accounting for pixel ratio\n    canvas.width = width * pixelRatio;\n    canvas.height = height * pixelRatio;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n    \n    // Ensure canvas is visible with a background color\n    const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for non-transparent canvas\n    if (ctx) {\n      // Create gradient background\n      const gradient = ctx.createLinearGradient(0, 0, 0, height * pixelRatio);\n      gradient.addColorStop(0, COLORS.background.topColor);\n      gradient.addColorStop(1, COLORS.background.bottomColor);\n      \n      ctx.fillStyle = gradient;\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    \n    // Update dimensions ref instead of state\n    dimensionsRef.current = { width, height, pixelRatio };\n    \n    return true;\n  }, [COLORS.background]);\n  \n  // Create a single star with specified parameters\n  const createStar = useCallback((fadeIn = true, x = null, y = null) => {\n    const { width, height } = dimensionsRef.current;\n    \n    const star = {};\n    \n    // Position - random if not specified\n    star.x = x !== null ? x : Math.random() * width;\n    star.y = y !== null ? y : Math.random() * height;\n    \n    // Random depth factor (affects size and opacity)\n    star.z = Math.random() * 0.8 + 0.1; // Depth (0.1 to 0.9)\n    \n    // Visual properties\n    star.size = (Math.random() * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n    star.baseOpacity = Math.random() * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n    \n    // Set initial opacity based on whether we're fading in\n    star.opacity = fadeIn ? 0 : star.baseOpacity;\n    \n    // Lifecycle state\n    star.state = fadeIn ? 'fading-in' : 'visible';\n    star.fadeStartTime = Date.now();\n    \n    // Direction and speed (in pixels per second)\n    // Random angle for movement direction\n    const angle = Math.random() * Math.PI * 2;\n    const speed = Math.random() * (CONFIG.driftSpeedMax - CONFIG.driftSpeedMin) + CONFIG.driftSpeedMin;\n    \n    // Calculate vector components for the angle\n    star.dx = Math.cos(angle) * speed;\n    star.dy = Math.sin(angle) * speed;\n    \n    // Twinkling properties\n    star.twinkleState = 'visible'; // 'fading-in', 'visible', 'fading-out', 'hidden'\n    star.twinkleProgress = 0;\n    star.twinkleDuration = Math.random() * \n      (CONFIG.twinkleDuration[1] - CONFIG.twinkleDuration[0]) + \n      CONFIG.twinkleDuration[0];\n    \n    // Color variation\n    star.color = COLORS.stars[Math.floor(Math.random() * COLORS.stars.length)];\n    \n    return star;\n  }, [CONFIG, COLORS.stars]);\n  \n  // Initialize stars\n  const initializeStars = useCallback(() => {\n    const { width, height } = dimensionsRef.current;\n    if (!width || !height) return;\n    \n    // Clear existing stars\n    starsRef.current = [];\n    \n    // Create initial set of stars (already visible, no fade-in)\n    for (let i = 0; i < CONFIG.starCount; i++) {\n      const star = createStar(false);\n      starsRef.current.push(star);\n    }\n  }, [CONFIG.starCount, createStar]);\n  \n  // Optimized star rendering\n  const drawStar = useCallback((ctx, star) => {\n    // Skip rendering completely invisible stars\n    if (star.opacity < 0.02) return;\n    \n    // Simplified star rendering\n    ctx.beginPath();\n    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n    ctx.fillStyle = getColor(star.color, star.opacity);\n    ctx.fill();\n    \n    // Simple glow effect for brighter stars\n    if (star.opacity > 0.3) {\n      ctx.beginPath();\n      ctx.arc(star.x, star.y, star.size * 1.8, 0, Math.PI * 2);\n      ctx.fillStyle = getColor(star.color, star.opacity * 0.4);\n      ctx.fill();\n    }\n  }, [getColor]);\n  \n  // Render the scene - optimized for performance\n  const renderScene = useCallback(() => {\n    if (!canvasRef.current) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d', { alpha: false });\n    \n    if (!ctx) return;\n    \n    const { width, height, pixelRatio } = dimensionsRef.current;\n    \n    // Clear canvas\n    // Create gradient background\n    const gradient = ctx.createLinearGradient(0, 0, 0, height * pixelRatio);\n    gradient.addColorStop(0, COLORS.background.topColor);\n    gradient.addColorStop(1, COLORS.background.bottomColor);\n    \n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, width * pixelRatio, height * pixelRatio);\n    \n    // Apply device pixel ratio scaling only once\n    ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    \n    // Enable global composition for better glow effect\n    ctx.globalCompositeOperation = 'lighter';\n    \n    // Draw stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n      drawStar(ctx, star);\n    }\n    \n    // Reset global composition\n    ctx.globalCompositeOperation = 'source-over';\n  }, [COLORS.background, drawStar]);\n  \n  // Update animation state - optimized for performance\n  const updateAnimation = useCallback((deltaTime, timestamp) => {\n    const { width, height } = dimensionsRef.current;\n    const currentTime = Date.now();\n    \n    // Track stars to remove\n    const starsToRemove = [];\n    \n    // Update stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n      \n      // Update position based on direction and speed\n      // Convert pixels per second to pixels per frame using deltaTime (in ms)\n      star.x += star.dx * (deltaTime / 1000);\n      star.y += star.dy * (deltaTime / 1000);\n      \n      // Check if star is outside viewport bounds with a small buffer\n      const isOutOfBounds = \n        star.x < -star.size * 2 || \n        star.x > width + star.size * 2 || \n        star.y < -star.size * 2 || \n        star.y > height + star.size * 2;\n      \n      // Handle lifecycle states\n      switch (star.state) {\n        case 'fading-in':\n          // Gradually increase opacity during fade-in\n          const fadeInProgress = (currentTime - star.fadeStartTime) / CONFIG.fadeInDuration;\n          if (fadeInProgress >= 1) {\n            star.opacity = star.baseOpacity;\n            star.state = 'visible';\n          } else {\n            star.opacity = star.baseOpacity * fadeInProgress;\n          }\n          break;\n          \n        case 'visible':\n          if (isOutOfBounds) {\n            // Start fading out if star moves out of bounds\n            star.state = 'fading-out';\n            star.fadeStartTime = currentTime;\n          } else if (CONFIG.twinkleEnabled && Math.random() < CONFIG.twinkleProbability) {\n            // Occasionally start twinkling\n            star.twinkleState = star.twinkleState === 'visible' ? 'fading-out' : 'visible';\n            star.twinkleProgress = 0;\n          }\n          \n          // Update twinkling effect if active\n          if (star.twinkleState !== 'visible') {\n            star.twinkleProgress += deltaTime / star.twinkleDuration;\n            \n            if (star.twinkleProgress >= 1) {\n              // Switch twinkling state\n              if (star.twinkleState === 'fading-out') {\n                star.twinkleState = 'fading-in';\n                star.twinkleProgress = 0;\n              } else {\n                star.twinkleState = 'visible';\n              }\n            }\n            \n            // Adjust opacity based on twinkle state\n            if (star.twinkleState === 'fading-out') {\n              star.opacity = star.baseOpacity * (1 - star.twinkleProgress * 0.7);\n            } else if (star.twinkleState === 'fading-in') {\n              star.opacity = star.baseOpacity * (0.3 + star.twinkleProgress * 0.7);\n            }\n          }\n          break;\n          \n        case 'fading-out':\n          // Gradually decrease opacity during fade-out\n          const fadeOutProgress = (currentTime - star.fadeStartTime) / CONFIG.fadeOutDuration;\n          if (fadeOutProgress >= 1) {\n            // Mark for removal when fully faded out\n            starsToRemove.push(i);\n          } else {\n            star.opacity = star.baseOpacity * (1 - fadeOutProgress);\n          }\n          break;\n          \n        default:\n          // Handle any unexpected star state\n          console.warn(`Unexpected star state: ${star.state}`);\n          star.state = 'visible';\n          star.opacity = star.baseOpacity;\n          break;\n      }\n    }\n    \n    // Remove stars that have completely faded out (in reverse order to avoid index issues)\n    for (let i = starsToRemove.length - 1; i >= 0; i--) {\n      starsRef.current.splice(starsToRemove[i], 1);\n      \n      // Schedule creation of a new star with slight delay\n      setTimeout(() => {\n        if (isInitializedRef.current) {\n          const newStar = createStar(true);\n          starsRef.current.push(newStar);\n        }\n      }, CONFIG.regenerationDelay);\n    }\n  }, [CONFIG, createStar]);\n  \n  // Define the animation loop function\n  const animate = useCallback(function animationLoop(timestamp) {\n    if (!isInitializedRef.current) {\n      animationFrameRef.current = requestAnimationFrame(animationLoop);\n      return;\n    }\n    \n    // Limit FPS\n    const minFrameTime = 1000 / CONFIG.maxFPS;\n    const elapsed = timestamp - (lastTimeRef.current || 0);\n    \n    if (elapsed < minFrameTime) {\n      animationFrameRef.current = requestAnimationFrame(animationLoop);\n      return;\n    }\n    \n    // Calculate delta time with cap to prevent large jumps\n    const deltaTime = lastTimeRef.current ? Math.min(elapsed, 50) : 16;\n    lastTimeRef.current = timestamp;\n    \n    // Update animation state\n    updateAnimation(deltaTime, timestamp);\n    \n    // Render scene\n    renderScene();\n    \n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(animationLoop);\n  }, [CONFIG.maxFPS, updateAnimation, renderScene]);\n  \n  // Comprehensive initialization and resize handling\n  useEffect(() => {\n    // One-time initialization function\n    const initialize = () => {\n      if (setupCanvas()) {\n        // Create stars only after canvas is ready\n        initializeStars();\n        // Mark as initialized but don't trigger re-render\n        isInitializedRef.current = true;\n        // Start animation only after everything is ready\n        animationFrameRef.current = requestAnimationFrame(animate);\n      }\n    };\n    \n    // Handle resize events\n    const handleResize = () => {\n      // Only re-initialize if already initialized\n      if (isInitializedRef.current) {\n        setupCanvas();\n        initializeStars();\n        // No need to change initialization state\n      }\n    };\n    \n    // Throttle resize events\n    let resizeTimer;\n    const throttledResize = () => {\n      if (!resizeTimer) {\n        resizeTimer = setTimeout(() => {\n          resizeTimer = null;\n          handleResize();\n        }, 200); // 200ms throttle\n      }\n    };\n    \n    // Add resize listener\n    window.addEventListener('resize', throttledResize);\n    \n    // Run initialization after first render is complete\n    // This prevents the \"double load\" effect\n    requestAnimationFrame(() => {\n      initialize();\n    });\n    \n    // Cleanup\n    return () => {\n      window.removeEventListener('resize', throttledResize);\n      if (resizeTimer) clearTimeout(resizeTimer);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      isInitializedRef.current = false;\n    };\n  }, [setupCanvas, initializeStars, animate]);\n  \n  return (\n    <div\n      ref={containerRef}\n      style={{\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        width: '100vw',\n        height: '100vh',\n        overflow: 'hidden',\n        zIndex: -1,\n        pointerEvents: 'none'\n      }}\n      aria-hidden=\"true\"\n    >\n      <canvas\n        ref={canvasRef}\n        style={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%'\n        }}\n      />\n    </div>\n  );\n};\n\nexport default Background;"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,MAAM,EAAEC,SAAS,EAAEC,WAAW,EAAEC,OAAO,QAAQ,OAAO;;AAEtE;AACA;AACA;AACA;AACA;AACA;AALA,SAAAC,MAAA,IAAAC,OAAA;AAMA,MAAMC,UAAU,GAAGA,CAAC;EAAEC,MAAM,GAAG,CAAC;AAAE,CAAC,KAAK;EAAAC,EAAA;EACtC;EACA,MAAMC,YAAY,GAAGT,MAAM,CAAC,IAAI,CAAC;EACjC,MAAMU,SAAS,GAAGV,MAAM,CAAC,IAAI,CAAC;EAC9B,MAAMW,QAAQ,GAAGX,MAAM,CAAC,EAAE,CAAC;EAC3B,MAAMY,iBAAiB,GAAGZ,MAAM,CAAC,IAAI,CAAC;EACtC,MAAMa,WAAW,GAAGb,MAAM,CAAC,CAAC,CAAC;;EAE7B;EACA,MAAMc,gBAAgB,GAAGd,MAAM,CAAC,KAAK,CAAC;;EAEtC;EACA,MAAMe,aAAa,GAAGf,MAAM,CAAC;IAAEgB,KAAK,EAAE,CAAC;IAAEC,MAAM,EAAE,CAAC;IAAEC,UAAU,EAAE;EAAE,CAAC,CAAC;;EAEpE;EACA;EACA,MAAMC,MAAM,GAAGhB,OAAO,CAAC,OAAO;IAC5B;IACAiB,SAAS,EAAE,GAAG;IACdC,WAAW,EAAE,GAAG;IAChBC,WAAW,EAAE,GAAG;IAChBC,cAAc,EAAE,IAAI;IACpBC,cAAc,EAAE,IAAI;IAEpB;IACAC,aAAa,EAAE,KAAK;IAAK;IACzBC,aAAa,EAAE,IAAI;IAAM;;IAEzB;IACAC,cAAc,EAAE,IAAI;IAAW;IAC/BC,kBAAkB,EAAE,KAAK;IAAM;IAC/BC,eAAe,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC;IAAE;;IAE/B;IACAC,cAAc,EAAE,IAAI;IAAI;IACxBC,eAAe,EAAE,IAAI;IAAG;;IAExB;IACAC,iBAAiB,EAAE,GAAG;IAAE;;IAExB;IACAC,MAAM,EAAE,EAAE;IAEV;IACAC,UAAU,EAAE,iCAAiC;IAE7C;IACA,GAAG3B;EACL,CAAC,CAAC,EAAE,CAACA,MAAM,CAAC,CAAC;;EAEb;EACA,MAAM4B,MAAM,GAAGhC,OAAO,CAAC,OAAO;IAC5B;IACAiC,KAAK,EAAE,CACL,4BAA4B;IAAE;IAC9B,4BAA4B;IAAE;IAC9B,4BAA4B,CAAE;IAAA,CAC/B;IAED;IACAC,UAAU,EAAE;MACVC,QAAQ,EAAE,eAAe;MACzBC,WAAW,EAAE;IACf,CAAC;IAED;IACA,IAAIhC,MAAM,CAACiC,MAAM,IAAI,CAAC,CAAC;EACzB,CAAC,CAAC,EAAE,CAACjC,MAAM,CAACiC,MAAM,CAAC,CAAC;;EAEpB;EACA,MAAMC,UAAU,GAAGtC,OAAO,CAAC,MAAM;IAC/B,MAAMuC,KAAK,GAAG,CAAC,CAAC;IAChBP,MAAM,CAACC,KAAK,CAACO,OAAO,CAACC,SAAS,IAAI;MAChCF,KAAK,CAACE,SAAS,CAAC,GAAG,CAAC,CAAC;MACrB,KAAK,IAAIC,OAAO,GAAG,CAAC,EAAEA,OAAO,IAAI,EAAE,EAAEA,OAAO,EAAE,EAAE;QAC9C,MAAMC,KAAK,GAAGD,OAAO,GAAG,EAAE;QAC1BH,KAAK,CAACE,SAAS,CAAC,CAACE,KAAK,CAAC,GAAGF,SAAS,CAACG,OAAO,CAAC,UAAU,EAAE,GAAGD,KAAK,GAAG,CAAC;MACtE;IACF,CAAC,CAAC;IACF,OAAOJ,KAAK;EACd,CAAC,EAAE,CAACP,MAAM,CAACC,KAAK,CAAC,CAAC;;EAElB;EACA,MAAMY,QAAQ,GAAG9C,WAAW,CAAC,CAAC0C,SAAS,EAAEC,OAAO,KAAK;IACnD,MAAMI,WAAW,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAAC,CAAC,EAAEP,OAAO,IAAI,CAAC,CAAC,CAAC;IAC1D;IACA,MAAMQ,cAAc,GAAGH,IAAI,CAACI,KAAK,CAACL,WAAW,GAAG,EAAE,CAAC,GAAG,EAAE;IACxD,OAAOR,UAAU,CAACG,SAAS,CAAC,CAACS,cAAc,CAAC,IAAIT,SAAS,CAACG,OAAO,CAAC,UAAU,EAAE,GAAGE,WAAW,GAAG,CAAC;EAClG,CAAC,EAAE,CAACR,UAAU,CAAC,CAAC;;EAEhB;EACA,MAAMc,WAAW,GAAGrD,WAAW,CAAC,MAAM;IACpC,IAAI,CAACQ,SAAS,CAAC8C,OAAO,EAAE,OAAO,KAAK;IAEpC,MAAMC,MAAM,GAAG/C,SAAS,CAAC8C,OAAO;;IAEhC;IACA,MAAMxC,KAAK,GAAG0C,MAAM,CAACC,UAAU;IAC/B,MAAM1C,MAAM,GAAGyC,MAAM,CAACE,WAAW;IACjC,MAAM1C,UAAU,GAAGwC,MAAM,CAACG,gBAAgB,IAAI,CAAC;;IAE/C;IACAJ,MAAM,CAACzC,KAAK,GAAGA,KAAK,GAAGE,UAAU;IACjCuC,MAAM,CAACxC,MAAM,GAAGA,MAAM,GAAGC,UAAU;IACnCuC,MAAM,CAACK,KAAK,CAAC9C,KAAK,GAAG,GAAGA,KAAK,IAAI;IACjCyC,MAAM,CAACK,KAAK,CAAC7C,MAAM,GAAG,GAAGA,MAAM,IAAI;;IAEnC;IACA,MAAM8C,GAAG,GAAGN,MAAM,CAACO,UAAU,CAAC,IAAI,EAAE;MAAEC,KAAK,EAAE;IAAM,CAAC,CAAC,CAAC,CAAC;IACvD,IAAIF,GAAG,EAAE;MACP;MACA,MAAMG,QAAQ,GAAGH,GAAG,CAACI,oBAAoB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAElD,MAAM,GAAGC,UAAU,CAAC;MACvEgD,QAAQ,CAACE,YAAY,CAAC,CAAC,EAAEjC,MAAM,CAACE,UAAU,CAACC,QAAQ,CAAC;MACpD4B,QAAQ,CAACE,YAAY,CAAC,CAAC,EAAEjC,MAAM,CAACE,UAAU,CAACE,WAAW,CAAC;MAEvDwB,GAAG,CAACM,SAAS,GAAGH,QAAQ;MACxBH,GAAG,CAACO,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEb,MAAM,CAACzC,KAAK,EAAEyC,MAAM,CAACxC,MAAM,CAAC;IACjD;;IAEA;IACAF,aAAa,CAACyC,OAAO,GAAG;MAAExC,KAAK;MAAEC,MAAM;MAAEC;IAAW,CAAC;IAErD,OAAO,IAAI;EACb,CAAC,EAAE,CAACiB,MAAM,CAACE,UAAU,CAAC,CAAC;;EAEvB;EACA,MAAMkC,UAAU,GAAGrE,WAAW,CAAC,CAACsE,MAAM,GAAG,IAAI,EAAEC,CAAC,GAAG,IAAI,EAAEC,CAAC,GAAG,IAAI,KAAK;IACpE,MAAM;MAAE1D,KAAK;MAAEC;IAAO,CAAC,GAAGF,aAAa,CAACyC,OAAO;IAE/C,MAAMmB,IAAI,GAAG,CAAC,CAAC;;IAEf;IACAA,IAAI,CAACF,CAAC,GAAGA,CAAC,KAAK,IAAI,GAAGA,CAAC,GAAGvB,IAAI,CAAC0B,MAAM,CAAC,CAAC,GAAG5D,KAAK;IAC/C2D,IAAI,CAACD,CAAC,GAAGA,CAAC,KAAK,IAAI,GAAGA,CAAC,GAAGxB,IAAI,CAAC0B,MAAM,CAAC,CAAC,GAAG3D,MAAM;;IAEhD;IACA0D,IAAI,CAACE,CAAC,GAAG3B,IAAI,CAAC0B,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC;;IAEpC;IACAD,IAAI,CAACG,IAAI,GAAG,CAAC5B,IAAI,CAAC0B,MAAM,CAAC,CAAC,IAAIzD,MAAM,CAACG,WAAW,GAAGH,MAAM,CAACE,WAAW,CAAC,GAAGF,MAAM,CAACE,WAAW,IAAIsD,IAAI,CAACE,CAAC;IACrGF,IAAI,CAACI,WAAW,GAAG7B,IAAI,CAAC0B,MAAM,CAAC,CAAC,IAAIzD,MAAM,CAACK,cAAc,GAAGL,MAAM,CAACI,cAAc,CAAC,GAAGJ,MAAM,CAACI,cAAc;;IAE1G;IACAoD,IAAI,CAAC9B,OAAO,GAAG2B,MAAM,GAAG,CAAC,GAAGG,IAAI,CAACI,WAAW;;IAE5C;IACAJ,IAAI,CAACK,KAAK,GAAGR,MAAM,GAAG,WAAW,GAAG,SAAS;IAC7CG,IAAI,CAACM,aAAa,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;;IAE/B;IACA;IACA,MAAMC,KAAK,GAAGlC,IAAI,CAAC0B,MAAM,CAAC,CAAC,GAAG1B,IAAI,CAACmC,EAAE,GAAG,CAAC;IACzC,MAAMC,KAAK,GAAGpC,IAAI,CAAC0B,MAAM,CAAC,CAAC,IAAIzD,MAAM,CAACO,aAAa,GAAGP,MAAM,CAACM,aAAa,CAAC,GAAGN,MAAM,CAACM,aAAa;;IAElG;IACAkD,IAAI,CAACY,EAAE,GAAGrC,IAAI,CAACsC,GAAG,CAACJ,KAAK,CAAC,GAAGE,KAAK;IACjCX,IAAI,CAACc,EAAE,GAAGvC,IAAI,CAACwC,GAAG,CAACN,KAAK,CAAC,GAAGE,KAAK;;IAEjC;IACAX,IAAI,CAACgB,YAAY,GAAG,SAAS,CAAC,CAAC;IAC/BhB,IAAI,CAACiB,eAAe,GAAG,CAAC;IACxBjB,IAAI,CAAC9C,eAAe,GAAGqB,IAAI,CAAC0B,MAAM,CAAC,CAAC,IACjCzD,MAAM,CAACU,eAAe,CAAC,CAAC,CAAC,GAAGV,MAAM,CAACU,eAAe,CAAC,CAAC,CAAC,CAAC,GACvDV,MAAM,CAACU,eAAe,CAAC,CAAC,CAAC;;IAE3B;IACA8C,IAAI,CAACkB,KAAK,GAAG1D,MAAM,CAACC,KAAK,CAACc,IAAI,CAAC4C,KAAK,CAAC5C,IAAI,CAAC0B,MAAM,CAAC,CAAC,GAAGzC,MAAM,CAACC,KAAK,CAAC2D,MAAM,CAAC,CAAC;IAE1E,OAAOpB,IAAI;EACb,CAAC,EAAE,CAACxD,MAAM,EAAEgB,MAAM,CAACC,KAAK,CAAC,CAAC;;EAE1B;EACA,MAAM4D,eAAe,GAAG9F,WAAW,CAAC,MAAM;IACxC,MAAM;MAAEc,KAAK;MAAEC;IAAO,CAAC,GAAGF,aAAa,CAACyC,OAAO;IAC/C,IAAI,CAACxC,KAAK,IAAI,CAACC,MAAM,EAAE;;IAEvB;IACAN,QAAQ,CAAC6C,OAAO,GAAG,EAAE;;IAErB;IACA,KAAK,IAAIyC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG9E,MAAM,CAACC,SAAS,EAAE6E,CAAC,EAAE,EAAE;MACzC,MAAMtB,IAAI,GAAGJ,UAAU,CAAC,KAAK,CAAC;MAC9B5D,QAAQ,CAAC6C,OAAO,CAAC0C,IAAI,CAACvB,IAAI,CAAC;IAC7B;EACF,CAAC,EAAE,CAACxD,MAAM,CAACC,SAAS,EAAEmD,UAAU,CAAC,CAAC;;EAElC;EACA,MAAM4B,QAAQ,GAAGjG,WAAW,CAAC,CAAC6D,GAAG,EAAEY,IAAI,KAAK;IAC1C;IACA,IAAIA,IAAI,CAAC9B,OAAO,GAAG,IAAI,EAAE;;IAEzB;IACAkB,GAAG,CAACqC,SAAS,CAAC,CAAC;IACfrC,GAAG,CAACsC,GAAG,CAAC1B,IAAI,CAACF,CAAC,EAAEE,IAAI,CAACD,CAAC,EAAEC,IAAI,CAACG,IAAI,EAAE,CAAC,EAAE5B,IAAI,CAACmC,EAAE,GAAG,CAAC,CAAC;IAClDtB,GAAG,CAACM,SAAS,GAAGrB,QAAQ,CAAC2B,IAAI,CAACkB,KAAK,EAAElB,IAAI,CAAC9B,OAAO,CAAC;IAClDkB,GAAG,CAACuC,IAAI,CAAC,CAAC;;IAEV;IACA,IAAI3B,IAAI,CAAC9B,OAAO,GAAG,GAAG,EAAE;MACtBkB,GAAG,CAACqC,SAAS,CAAC,CAAC;MACfrC,GAAG,CAACsC,GAAG,CAAC1B,IAAI,CAACF,CAAC,EAAEE,IAAI,CAACD,CAAC,EAAEC,IAAI,CAACG,IAAI,GAAG,GAAG,EAAE,CAAC,EAAE5B,IAAI,CAACmC,EAAE,GAAG,CAAC,CAAC;MACxDtB,GAAG,CAACM,SAAS,GAAGrB,QAAQ,CAAC2B,IAAI,CAACkB,KAAK,EAAElB,IAAI,CAAC9B,OAAO,GAAG,GAAG,CAAC;MACxDkB,GAAG,CAACuC,IAAI,CAAC,CAAC;IACZ;EACF,CAAC,EAAE,CAACtD,QAAQ,CAAC,CAAC;;EAEd;EACA,MAAMuD,WAAW,GAAGrG,WAAW,CAAC,MAAM;IACpC,IAAI,CAACQ,SAAS,CAAC8C,OAAO,EAAE;IAExB,MAAMC,MAAM,GAAG/C,SAAS,CAAC8C,OAAO;IAChC,MAAMO,GAAG,GAAGN,MAAM,CAACO,UAAU,CAAC,IAAI,EAAE;MAAEC,KAAK,EAAE;IAAM,CAAC,CAAC;IAErD,IAAI,CAACF,GAAG,EAAE;IAEV,MAAM;MAAE/C,KAAK;MAAEC,MAAM;MAAEC;IAAW,CAAC,GAAGH,aAAa,CAACyC,OAAO;;IAE3D;IACA;IACA,MAAMU,QAAQ,GAAGH,GAAG,CAACI,oBAAoB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAElD,MAAM,GAAGC,UAAU,CAAC;IACvEgD,QAAQ,CAACE,YAAY,CAAC,CAAC,EAAEjC,MAAM,CAACE,UAAU,CAACC,QAAQ,CAAC;IACpD4B,QAAQ,CAACE,YAAY,CAAC,CAAC,EAAEjC,MAAM,CAACE,UAAU,CAACE,WAAW,CAAC;IAEvDwB,GAAG,CAACM,SAAS,GAAGH,QAAQ;IACxBH,GAAG,CAACO,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEtD,KAAK,GAAGE,UAAU,EAAED,MAAM,GAAGC,UAAU,CAAC;;IAE3D;IACA6C,GAAG,CAACyC,YAAY,CAACtF,UAAU,EAAE,CAAC,EAAE,CAAC,EAAEA,UAAU,EAAE,CAAC,EAAE,CAAC,CAAC;;IAEpD;IACA6C,GAAG,CAAC0C,wBAAwB,GAAG,SAAS;;IAExC;IACA,KAAK,IAAIR,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGtF,QAAQ,CAAC6C,OAAO,CAACuC,MAAM,EAAEE,CAAC,EAAE,EAAE;MAChD,MAAMtB,IAAI,GAAGhE,QAAQ,CAAC6C,OAAO,CAACyC,CAAC,CAAC;MAChCE,QAAQ,CAACpC,GAAG,EAAEY,IAAI,CAAC;IACrB;;IAEA;IACAZ,GAAG,CAAC0C,wBAAwB,GAAG,aAAa;EAC9C,CAAC,EAAE,CAACtE,MAAM,CAACE,UAAU,EAAE8D,QAAQ,CAAC,CAAC;;EAEjC;EACA,MAAMO,eAAe,GAAGxG,WAAW,CAAC,CAACyG,SAAS,EAAEC,SAAS,KAAK;IAC5D,MAAM;MAAE5F,KAAK;MAAEC;IAAO,CAAC,GAAGF,aAAa,CAACyC,OAAO;IAC/C,MAAMqD,WAAW,GAAG3B,IAAI,CAACC,GAAG,CAAC,CAAC;;IAE9B;IACA,MAAM2B,aAAa,GAAG,EAAE;;IAExB;IACA,KAAK,IAAIb,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGtF,QAAQ,CAAC6C,OAAO,CAACuC,MAAM,EAAEE,CAAC,EAAE,EAAE;MAChD,MAAMtB,IAAI,GAAGhE,QAAQ,CAAC6C,OAAO,CAACyC,CAAC,CAAC;;MAEhC;MACA;MACAtB,IAAI,CAACF,CAAC,IAAIE,IAAI,CAACY,EAAE,IAAIoB,SAAS,GAAG,IAAI,CAAC;MACtChC,IAAI,CAACD,CAAC,IAAIC,IAAI,CAACc,EAAE,IAAIkB,SAAS,GAAG,IAAI,CAAC;;MAEtC;MACA,MAAMI,aAAa,GACjBpC,IAAI,CAACF,CAAC,GAAG,CAACE,IAAI,CAACG,IAAI,GAAG,CAAC,IACvBH,IAAI,CAACF,CAAC,GAAGzD,KAAK,GAAG2D,IAAI,CAACG,IAAI,GAAG,CAAC,IAC9BH,IAAI,CAACD,CAAC,GAAG,CAACC,IAAI,CAACG,IAAI,GAAG,CAAC,IACvBH,IAAI,CAACD,CAAC,GAAGzD,MAAM,GAAG0D,IAAI,CAACG,IAAI,GAAG,CAAC;;MAEjC;MACA,QAAQH,IAAI,CAACK,KAAK;QAChB,KAAK,WAAW;UACd;UACA,MAAMgC,cAAc,GAAG,CAACH,WAAW,GAAGlC,IAAI,CAACM,aAAa,IAAI9D,MAAM,CAACW,cAAc;UACjF,IAAIkF,cAAc,IAAI,CAAC,EAAE;YACvBrC,IAAI,CAAC9B,OAAO,GAAG8B,IAAI,CAACI,WAAW;YAC/BJ,IAAI,CAACK,KAAK,GAAG,SAAS;UACxB,CAAC,MAAM;YACLL,IAAI,CAAC9B,OAAO,GAAG8B,IAAI,CAACI,WAAW,GAAGiC,cAAc;UAClD;UACA;QAEF,KAAK,SAAS;UACZ,IAAID,aAAa,EAAE;YACjB;YACApC,IAAI,CAACK,KAAK,GAAG,YAAY;YACzBL,IAAI,CAACM,aAAa,GAAG4B,WAAW;UAClC,CAAC,MAAM,IAAI1F,MAAM,CAACQ,cAAc,IAAIuB,IAAI,CAAC0B,MAAM,CAAC,CAAC,GAAGzD,MAAM,CAACS,kBAAkB,EAAE;YAC7E;YACA+C,IAAI,CAACgB,YAAY,GAAGhB,IAAI,CAACgB,YAAY,KAAK,SAAS,GAAG,YAAY,GAAG,SAAS;YAC9EhB,IAAI,CAACiB,eAAe,GAAG,CAAC;UAC1B;;UAEA;UACA,IAAIjB,IAAI,CAACgB,YAAY,KAAK,SAAS,EAAE;YACnChB,IAAI,CAACiB,eAAe,IAAIe,SAAS,GAAGhC,IAAI,CAAC9C,eAAe;YAExD,IAAI8C,IAAI,CAACiB,eAAe,IAAI,CAAC,EAAE;cAC7B;cACA,IAAIjB,IAAI,CAACgB,YAAY,KAAK,YAAY,EAAE;gBACtChB,IAAI,CAACgB,YAAY,GAAG,WAAW;gBAC/BhB,IAAI,CAACiB,eAAe,GAAG,CAAC;cAC1B,CAAC,MAAM;gBACLjB,IAAI,CAACgB,YAAY,GAAG,SAAS;cAC/B;YACF;;YAEA;YACA,IAAIhB,IAAI,CAACgB,YAAY,KAAK,YAAY,EAAE;cACtChB,IAAI,CAAC9B,OAAO,GAAG8B,IAAI,CAACI,WAAW,IAAI,CAAC,GAAGJ,IAAI,CAACiB,eAAe,GAAG,GAAG,CAAC;YACpE,CAAC,MAAM,IAAIjB,IAAI,CAACgB,YAAY,KAAK,WAAW,EAAE;cAC5ChB,IAAI,CAAC9B,OAAO,GAAG8B,IAAI,CAACI,WAAW,IAAI,GAAG,GAAGJ,IAAI,CAACiB,eAAe,GAAG,GAAG,CAAC;YACtE;UACF;UACA;QAEF,KAAK,YAAY;UACf;UACA,MAAMqB,eAAe,GAAG,CAACJ,WAAW,GAAGlC,IAAI,CAACM,aAAa,IAAI9D,MAAM,CAACY,eAAe;UACnF,IAAIkF,eAAe,IAAI,CAAC,EAAE;YACxB;YACAH,aAAa,CAACZ,IAAI,CAACD,CAAC,CAAC;UACvB,CAAC,MAAM;YACLtB,IAAI,CAAC9B,OAAO,GAAG8B,IAAI,CAACI,WAAW,IAAI,CAAC,GAAGkC,eAAe,CAAC;UACzD;UACA;QAEF;UACE;UACAC,OAAO,CAACC,IAAI,CAAC,0BAA0BxC,IAAI,CAACK,KAAK,EAAE,CAAC;UACpDL,IAAI,CAACK,KAAK,GAAG,SAAS;UACtBL,IAAI,CAAC9B,OAAO,GAAG8B,IAAI,CAACI,WAAW;UAC/B;MACJ;IACF;;IAEA;IACA,KAAK,IAAIkB,CAAC,GAAGa,aAAa,CAACf,MAAM,GAAG,CAAC,EAAEE,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAClDtF,QAAQ,CAAC6C,OAAO,CAAC4D,MAAM,CAACN,aAAa,CAACb,CAAC,CAAC,EAAE,CAAC,CAAC;;MAE5C;MACAoB,UAAU,CAAC,MAAM;QACf,IAAIvG,gBAAgB,CAAC0C,OAAO,EAAE;UAC5B,MAAM8D,OAAO,GAAG/C,UAAU,CAAC,IAAI,CAAC;UAChC5D,QAAQ,CAAC6C,OAAO,CAAC0C,IAAI,CAACoB,OAAO,CAAC;QAChC;MACF,CAAC,EAAEnG,MAAM,CAACa,iBAAiB,CAAC;IAC9B;EACF,CAAC,EAAE,CAACb,MAAM,EAAEoD,UAAU,CAAC,CAAC;;EAExB;EACA,MAAMgD,OAAO,GAAGrH,WAAW,CAAC,SAASsH,aAAaA,CAACZ,SAAS,EAAE;IAC5D,IAAI,CAAC9F,gBAAgB,CAAC0C,OAAO,EAAE;MAC7B5C,iBAAiB,CAAC4C,OAAO,GAAGiE,qBAAqB,CAACD,aAAa,CAAC;MAChE;IACF;;IAEA;IACA,MAAME,YAAY,GAAG,IAAI,GAAGvG,MAAM,CAACc,MAAM;IACzC,MAAM0F,OAAO,GAAGf,SAAS,IAAI/F,WAAW,CAAC2C,OAAO,IAAI,CAAC,CAAC;IAEtD,IAAImE,OAAO,GAAGD,YAAY,EAAE;MAC1B9G,iBAAiB,CAAC4C,OAAO,GAAGiE,qBAAqB,CAACD,aAAa,CAAC;MAChE;IACF;;IAEA;IACA,MAAMb,SAAS,GAAG9F,WAAW,CAAC2C,OAAO,GAAGN,IAAI,CAACE,GAAG,CAACuE,OAAO,EAAE,EAAE,CAAC,GAAG,EAAE;IAClE9G,WAAW,CAAC2C,OAAO,GAAGoD,SAAS;;IAE/B;IACAF,eAAe,CAACC,SAAS,EAAEC,SAAS,CAAC;;IAErC;IACAL,WAAW,CAAC,CAAC;;IAEb;IACA3F,iBAAiB,CAAC4C,OAAO,GAAGiE,qBAAqB,CAACD,aAAa,CAAC;EAClE,CAAC,EAAE,CAACrG,MAAM,CAACc,MAAM,EAAEyE,eAAe,EAAEH,WAAW,CAAC,CAAC;;EAEjD;EACAtG,SAAS,CAAC,MAAM;IACd;IACA,MAAM2H,UAAU,GAAGA,CAAA,KAAM;MACvB,IAAIrE,WAAW,CAAC,CAAC,EAAE;QACjB;QACAyC,eAAe,CAAC,CAAC;QACjB;QACAlF,gBAAgB,CAAC0C,OAAO,GAAG,IAAI;QAC/B;QACA5C,iBAAiB,CAAC4C,OAAO,GAAGiE,qBAAqB,CAACF,OAAO,CAAC;MAC5D;IACF,CAAC;;IAED;IACA,MAAMM,YAAY,GAAGA,CAAA,KAAM;MACzB;MACA,IAAI/G,gBAAgB,CAAC0C,OAAO,EAAE;QAC5BD,WAAW,CAAC,CAAC;QACbyC,eAAe,CAAC,CAAC;QACjB;MACF;IACF,CAAC;;IAED;IACA,IAAI8B,WAAW;IACf,MAAMC,eAAe,GAAGA,CAAA,KAAM;MAC5B,IAAI,CAACD,WAAW,EAAE;QAChBA,WAAW,GAAGT,UAAU,CAAC,MAAM;UAC7BS,WAAW,GAAG,IAAI;UAClBD,YAAY,CAAC,CAAC;QAChB,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;MACX;IACF,CAAC;;IAED;IACAnE,MAAM,CAACsE,gBAAgB,CAAC,QAAQ,EAAED,eAAe,CAAC;;IAElD;IACA;IACAN,qBAAqB,CAAC,MAAM;MAC1BG,UAAU,CAAC,CAAC;IACd,CAAC,CAAC;;IAEF;IACA,OAAO,MAAM;MACXlE,MAAM,CAACuE,mBAAmB,CAAC,QAAQ,EAAEF,eAAe,CAAC;MACrD,IAAID,WAAW,EAAEI,YAAY,CAACJ,WAAW,CAAC;MAC1C,IAAIlH,iBAAiB,CAAC4C,OAAO,EAAE;QAC7B2E,oBAAoB,CAACvH,iBAAiB,CAAC4C,OAAO,CAAC;MACjD;MACA1C,gBAAgB,CAAC0C,OAAO,GAAG,KAAK;IAClC,CAAC;EACH,CAAC,EAAE,CAACD,WAAW,EAAEyC,eAAe,EAAEuB,OAAO,CAAC,CAAC;EAE3C,oBACElH,OAAA;IACE+H,GAAG,EAAE3H,YAAa;IAClBqD,KAAK,EAAE;MACLuE,QAAQ,EAAE,OAAO;MACjBC,GAAG,EAAE,CAAC;MACNC,IAAI,EAAE,CAAC;MACPvH,KAAK,EAAE,OAAO;MACdC,MAAM,EAAE,OAAO;MACfuH,QAAQ,EAAE,QAAQ;MAClBC,MAAM,EAAE,CAAC,CAAC;MACVC,aAAa,EAAE;IACjB,CAAE;IACF,eAAY,MAAM;IAAAC,QAAA,eAElBtI,OAAA;MACE+H,GAAG,EAAE1H,SAAU;MACfoD,KAAK,EAAE;QACLuE,QAAQ,EAAE,UAAU;QACpBC,GAAG,EAAE,CAAC;QACNC,IAAI,EAAE,CAAC;QACPvH,KAAK,EAAE,MAAM;QACbC,MAAM,EAAE;MACV;IAAE;MAAA2H,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACH;EAAC;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACC,CAAC;AAEV,CAAC;AAACvI,EAAA,CA3cIF,UAAU;AAAA0I,EAAA,GAAV1I,UAAU;AA6chB,eAAeA,UAAU;AAAC,IAAA0I,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}