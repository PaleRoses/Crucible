{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/CosmicStars.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useCallback, useState, useMemo } from 'react';\n\n/**\n * CosmicStars Component\n * \n * Renders a dynamic starfield with twinkling, parallax effects and subtle drift\n * movements. Designed to work as part of a coordinated cosmic background system.\n * \n * Features:\n * - High performance star rendering with optimized canvas operations\n * - Parallax scrolling with physics-based movement\n * - Random twinkling and pulsing effects\n * - Subtle drift movements for stars\n * - Adaptive quality based on device capabilities\n * \n * @param {Object} props - Component props\n * @param {string|number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=1] - Z-index for the container (lower than other cosmic components)\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.starCount=120] - Number of stars to render\n * @param {number} [props.starSizeMin=1.0] - Minimum size of stars\n * @param {number} [props.starSizeMax=1.9] - Maximum size of stars\n * @param {number} [props.starOpacityMin=0.2] - Minimum opacity of stars\n * @param {number} [props.starOpacityMax=0.55] - Maximum opacity of stars\n * @param {boolean} [props.enableParallax=true] - Enable parallax effect on scroll\n * @param {number} [props.parallaxFactor=0.2] - How much stars move relative to scroll (0-1)\n * @param {boolean} [props.trailEnabled=true] - Enable subtle trails behind moving stars\n * @param {number} [props.trailLength=2] - Length of star trails in pixels\n * @param {number} [props.trailOpacityFactor=0.5] - Trail opacity relative to star opacity\n * @param {boolean} [props.twinkleEnabled=true] - Enable stars to fade in and out\n * @param {number} [props.twinkleProbability=0.01] - Probability of a star beginning to twinkle each frame\n * @param {number[]} [props.twinkleDuration=[2000, 4000]] - Min and max duration of a twinkle cycle (ms)\n * @param {boolean} [props.driftEnabled=true] - Enable slow drifting movement of stars\n * @param {number} [props.driftSpeed=0.01] - Base speed of drift movement (pixels per second)\n * @param {number} [props.driftSpeedVariation=0.005] - Variation in drift speed between stars\n * @param {boolean} [props.respectReducedMotion=true] - Respect reduced motion preferences\n * @param {number} [props.maxFPS=60] - Target maximum frames per second\n * @param {boolean} [props.adaptiveQuality=true] - Enable adaptive quality based on device\n * @param {string[]} [props.colors] - Star colors with alpha placeholder (defaults to golden palette)\n * @param {string} [props.backgroundColor='rgb(8, 8, 12)'] - Canvas background color\n * @param {boolean} [props.debug=false] - Enable debug visualization\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CosmicStars = ({\n  height = '100vh',\n  zIndex = 1,\n  active = true,\n  starCount = 120,\n  starSizeMin = 1.0,\n  starSizeMax = 1.9,\n  starOpacityMin = 0.2,\n  starOpacityMax = 0.55,\n  enableParallax = true,\n  parallaxFactor = 0.2,\n  trailEnabled = true,\n  trailLength = 2,\n  trailOpacityFactor = 0.5,\n  twinkleEnabled = true,\n  twinkleProbability = 0.01,\n  twinkleDuration = [2000, 4000],\n  driftEnabled = true,\n  driftSpeed = 0.01,\n  driftSpeedVariation = 0.005,\n  respectReducedMotion = true,\n  maxFPS = 60,\n  adaptiveQuality = true,\n  colors = ['rgba(255, 243, 200, alpha)',\n  // Warm yellow\n  'rgba(255, 231, 164, alpha)',\n  // Golden\n  'rgba(252, 249, 231, alpha)' // Off-white gold\n  ],\n  backgroundColor = 'rgb(8, 8, 12)',\n  debug = false\n}) => {\n  _s();\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const starsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const fpsTimestampRef = useRef(0);\n  const frameCountRef = useRef(0);\n  const currentFpsRef = useRef(60);\n  const scrollPositionRef = useRef(0);\n  const resizeObserverRef = useRef(null);\n  const visibilityObserverRef = useRef(null);\n  const visibilityChangeTimeRef = useRef(0);\n  const qualityChangeTimerRef = useRef(null);\n  const lastQualityFactorRef = useRef(1);\n  const stableFrameCountRef = useRef(0);\n\n  // Use refs instead of state to prevent re-renders\n  const isInitializedRef = useRef(false);\n\n  // Component state\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0,\n    pixelRatio: 1\n  });\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [isVisible, setIsVisible] = useState(false);\n  const [qualityFactor, setQualityFactor] = useState(1);\n\n  // Pre-generated color values to avoid string replacements during animation\n  const colorCache = useMemo(() => {\n    const cache = {};\n    colors.forEach(baseColor => {\n      cache[baseColor] = {};\n      for (let opacity = 0; opacity <= 10; opacity++) {\n        const value = opacity / 10;\n        cache[baseColor][value] = baseColor.replace(/alpha\\)$/, `${value})`);\n      }\n    });\n    return cache;\n  }, [colors]);\n\n  // Adaptive settings based on quality factor\n  const adaptedSettings = useMemo(() => {\n    if (!adaptiveQuality || qualityFactor === 1) {\n      return {\n        starCount,\n        trailEnabled,\n        useHighQualityRendering: true\n      };\n    }\n\n    // Adjust quality-dependent parameters\n    return {\n      starCount: Math.max(40, Math.floor(starCount * qualityFactor)),\n      trailEnabled: qualityFactor > 0.5 && trailEnabled,\n      useHighQualityRendering: qualityFactor > 0.7\n    };\n  }, [adaptiveQuality, qualityFactor, starCount, trailEnabled]);\n\n  // Get color with opacity from cache (faster than string replacement)\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    // Round to nearest 0.1 to use cached values\n    const roundedOpacity = Math.round(safeOpacity * 10) / 10;\n    return colorCache[baseColor][roundedOpacity] || baseColor.replace(/alpha\\)$/, `${safeOpacity})`);\n  }, [colorCache]);\n\n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current || !containerRef.current) return false;\n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    const rect = container.getBoundingClientRect();\n    const pixelRatio = window.devicePixelRatio || 1;\n\n    // Calculate dimensions\n    const displayWidth = Math.floor(rect.width);\n    const displayHeight = typeof height === 'string' && height.endsWith('vh') ? Math.floor(parseInt(height, 10) / 100 * window.innerHeight) : Math.floor(parseInt(height, 10) || window.innerHeight);\n\n    // Set canvas size accounting for pixel ratio\n    canvas.width = displayWidth * pixelRatio;\n    canvas.height = displayHeight * pixelRatio;\n    canvas.style.width = `${displayWidth}px`;\n    canvas.style.height = `${displayHeight}px`;\n\n    // Get 2D context and optimize it\n    const ctx = canvas.getContext('2d', {\n      alpha: false,\n      // Optimize for non-transparent canvas\n      desynchronized: true,\n      // Potential performance boost\n      willReadFrequently: false // Performance hint\n    });\n    if (!ctx) return false;\n\n    // Apply initial background color\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // Scale context for high-DPI displays\n    ctx.scale(pixelRatio, pixelRatio);\n\n    // Configure context for quality\n    if (adaptedSettings.useHighQualityRendering) {\n      ctx.imageSmoothingEnabled = true;\n      ctx.imageSmoothingQuality = 'high';\n    }\n\n    // Update dimensions\n    setDimensions({\n      width: displayWidth,\n      height: displayHeight,\n      pixelRatio\n    });\n    return true;\n  }, [height, backgroundColor, adaptedSettings.useHighQualityRendering]);\n\n  // Create a new star\n  const createStar = useCallback(() => {\n    const {\n      width,\n      height\n    } = dimensions;\n    if (!width || !height) return null;\n\n    // Generate z-depth first (controls parallax and size)\n    const z = Math.random() * 0.8 + 0.1; // 0.1 to 0.9\n\n    // Create star with random properties\n    const star = {\n      // Position\n      x: Math.random() * width,\n      y: Math.random() * height,\n      baseY: Math.random() * height,\n      // Reference position for parallax\n      z,\n      // Visual properties\n      size: (Math.random() * (starSizeMax - starSizeMin) + starSizeMin) * z,\n      baseOpacity: Math.random() * (starOpacityMax - starOpacityMin) + starOpacityMin,\n      opacity: 0,\n      // Start with 0 for fade-in\n      color: colors[Math.floor(Math.random() * colors.length)],\n      // Animation properties\n      pulsePhase: Math.random() * Math.PI * 2,\n      pulseSpeed: Math.random() * 0.002 + 0.001,\n      // Drift movement properties\n      driftDirectionX: Math.random() * 2 - 1,\n      driftDirectionY: Math.random() * 2 - 1,\n      driftSpeed: driftSpeed + (Math.random() * 2 - 1) * driftSpeedVariation,\n      directionChangeTimer: 0,\n      // State tracking properties\n      state: 'fading-in',\n      // fading-in, visible, fading-out\n      fadeProgress: 0,\n      fadeStart: Date.now(),\n      // Physics properties for parallax effect\n      velocity: 0,\n      targetY: Math.random() * height,\n      // Trail properties\n      lastX: Math.random() * width,\n      lastY: Math.random() * height,\n      // Twinkling properties\n      twinkleState: 'visible',\n      // visible, fading-out, hidden, fading-in\n      twinkleProgress: 0,\n      twinkleDuration: Math.random() * (twinkleDuration[1] - twinkleDuration[0]) + twinkleDuration[0],\n      // Parallax factor - deeper stars (higher z) move less\n      parallaxFactor: Math.random() * 0.5 * parallaxFactor * (1 - z * 0.5)\n    };\n\n    // Normalize the drift direction vector\n    const dirMagnitude = Math.sqrt(star.driftDirectionX ** 2 + star.driftDirectionY ** 2) || 1;\n    star.driftDirectionX /= dirMagnitude;\n    star.driftDirectionY /= dirMagnitude;\n    return star;\n  }, [dimensions, starSizeMin, starSizeMax, starOpacityMin, starOpacityMax, colors, driftSpeed, driftSpeedVariation, twinkleDuration, parallaxFactor]);\n\n  // Initialize stars\n  const initializeStars = useCallback(() => {\n    // Clear existing stars\n    starsRef.current = [];\n\n    // Generate stars based on count\n    for (let i = 0; i < adaptedSettings.starCount; i++) {\n      const star = createStar();\n      if (star) {\n        // For initial creation, set some stars to be already visible\n        if (Math.random() < 0.7) {\n          star.state = 'visible';\n          star.opacity = star.baseOpacity;\n          star.fadeProgress = 1;\n        }\n        starsRef.current.push(star);\n      }\n    }\n  }, [adaptedSettings.starCount, createStar]);\n\n  // Check if a star is off-screen\n  const isStarOffScreen = useCallback(star => {\n    const {\n      width,\n      height\n    } = dimensions;\n    const buffer = 50; // Buffer distance to trigger regeneration\n\n    return star.x < -buffer || star.x > width + buffer || star.y < -buffer || star.y > height + buffer;\n  }, [dimensions]);\n\n  // Draw a single star with optional trail\n  const drawStar = useCallback((ctx, star) => {\n    // Skip rendering completely invisible stars\n    if (star.opacity < 0.02) return;\n\n    // Draw subtle trail if enabled and star is moving\n    if (adaptedSettings.trailEnabled && (Math.abs(star.velocity) > 0.001 || Math.abs(star.lastX - star.x) > 0.1)) {\n      // Calculate trail direction based on movement\n      const trailX = star.lastX;\n      const trailY = star.lastY;\n\n      // Draw trail\n      ctx.beginPath();\n      ctx.moveTo(star.x, star.y);\n      ctx.lineTo(trailX, trailY);\n      ctx.strokeStyle = getColor(star.color, star.opacity * trailOpacityFactor);\n      ctx.lineWidth = star.size * 0.6;\n      ctx.lineCap = 'round';\n      ctx.stroke();\n    }\n\n    // Store current position for next frame's trail\n    star.lastX = star.x;\n    star.lastY = star.y;\n\n    // Draw star\n    ctx.beginPath();\n    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n    ctx.fillStyle = getColor(star.color, star.opacity);\n    ctx.fill();\n\n    // Draw glow for larger or brighter stars\n    if (adaptedSettings.useHighQualityRendering && star.opacity > 0.3) {\n      ctx.beginPath();\n      ctx.arc(star.x, star.y, star.size * 1.8, 0, Math.PI * 2);\n      ctx.fillStyle = getColor(star.color, star.opacity * 0.4);\n      ctx.fill();\n    }\n  }, [adaptedSettings.trailEnabled, adaptedSettings.useHighQualityRendering, getColor, trailOpacityFactor]);\n\n  // Render all stars\n  const renderStars = useCallback(() => {\n    if (!canvasRef.current) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d', {\n      alpha: false\n    });\n    if (!ctx) return;\n    const {\n      width,\n      height,\n      pixelRatio\n    } = dimensions;\n\n    // Clear canvas\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, width * pixelRatio, height * pixelRatio);\n\n    // Apply device pixel ratio scaling only once\n    ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n\n    // Enable global composition for better glow effect\n    ctx.globalCompositeOperation = 'lighter';\n\n    // Draw stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n      drawStar(ctx, star);\n    }\n\n    // Reset global composition\n    ctx.globalCompositeOperation = 'source-over';\n\n    // Render debug info if enabled\n    if (debug) {\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n      ctx.font = '12px monospace';\n      ctx.fillText(`FPS: ${currentFpsRef.current}`, 10, 20);\n      ctx.fillText(`Stars: ${starsRef.current.length}/${adaptedSettings.starCount}`, 10, 40);\n      ctx.fillText(`Quality: ${qualityFactor.toFixed(2)}`, 10, 60);\n    }\n  }, [dimensions, backgroundColor, drawStar, debug, qualityFactor, adaptedSettings.starCount]);\n\n  // Update star positions and properties\n  const updateStars = useCallback((deltaTime, timestamp) => {\n    // Get current scroll position\n    const currentScrollY = scrollPositionRef.current;\n\n    // Global time factor for animations\n    const timeFactor = timestamp * 0.001;\n    const currentTime = Date.now();\n\n    // Track stars to replace\n    const starsToReplace = [];\n\n    // Count currently fading stars (for controlling simultaneous fades)\n    let fadingCount = starsRef.current.filter(star => star.state === 'fading-out' || star.state === 'fading-in').length;\n\n    // Maximum simultaneous fading stars\n    const maxSimultaneousFading = 10;\n\n    // Update each star\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n\n      // Handle star state transitions\n      if (star.state === 'fading-in') {\n        // Calculate progress for fade-in\n        const elapsed = currentTime - star.fadeStart;\n        star.fadeProgress = Math.min(1, elapsed / 2000); // 2 second fade-in\n        star.opacity = star.baseOpacity * star.fadeProgress;\n\n        // Complete fade-in\n        if (star.fadeProgress >= 1) {\n          star.state = 'visible';\n          star.opacity = star.baseOpacity;\n        }\n      } else if (star.state === 'fading-out') {\n        // Calculate progress for fade-out\n        const elapsed = currentTime - star.fadeStart;\n        star.fadeProgress = Math.max(0, 1 - elapsed / 1500); // 1.5 second fade-out\n        star.opacity = star.baseOpacity * star.fadeProgress;\n\n        // Complete fade-out - mark for replacement\n        if (star.fadeProgress <= 0) {\n          starsToReplace.push(i);\n        }\n      } else {\n        // Normal visible state\n\n        // Random fading if not too many stars are already fading\n        if (twinkleEnabled && fadingCount < maxSimultaneousFading && Math.random() < twinkleProbability * deltaTime) {\n          // Start fade-out process for random star\n          star.state = 'fading-out';\n          star.fadeStart = currentTime;\n          fadingCount++;\n          continue; // Skip to next star\n        }\n\n        // Calculate parallax effect based on scroll position\n        if (enableParallax) {\n          // Update target position based on scroll\n          star.targetY = star.baseY - currentScrollY * star.parallaxFactor;\n        }\n\n        // Apply spring physics for smooth parallax\n        const displacement = star.targetY - star.y;\n        const springStrength = 0.03; // Higher = snappier\n        const springForce = displacement * springStrength;\n\n        // Update velocity with spring force\n        star.velocity += springForce;\n\n        // Apply damping to velocity\n        star.velocity *= 0.95; // Higher = less bouncy\n\n        // Add velocity clamping to prevent extreme movement\n        const maxVelocity = 1.0;\n        star.velocity = Math.max(-maxVelocity, Math.min(maxVelocity, star.velocity));\n\n        // Update position based on velocity\n        star.y += star.velocity;\n\n        // Apply drift movement if enabled\n        if (driftEnabled) {\n          // Calculate the intended movement\n          const dx = star.driftDirectionX * star.driftSpeed * deltaTime;\n          const dy = star.driftDirectionY * star.driftSpeed * deltaTime;\n\n          // Apply a maximum movement limit to prevent jumps\n          const maxMove = 0.5; // Maximum pixels to move per frame\n          const actualDx = Math.abs(dx) > maxMove ? Math.sign(dx) * maxMove : dx;\n          const actualDy = Math.abs(dy) > maxMove ? Math.sign(dy) * maxMove : dy;\n\n          // Move star\n          star.x += actualDx;\n          star.baseY += actualDy;\n          star.targetY = star.baseY - currentScrollY * star.parallaxFactor;\n\n          // Occasionally change drift direction\n          const directionChangeFrequency = 0.0005; // Probability per frame\n          if (Math.random() < directionChangeFrequency * deltaTime) {\n            // Gradually change direction\n            const directionChangeAmount = 0.05; // How much direction can change at once\n            const changeX = (Math.random() * 2 - 1) * directionChangeAmount;\n            const changeY = (Math.random() * 2 - 1) * directionChangeAmount;\n\n            // Apply change\n            star.driftDirectionX += changeX;\n            star.driftDirectionY += changeY;\n\n            // Re-normalize direction vector\n            const dirMagnitude = Math.sqrt(star.driftDirectionX ** 2 + star.driftDirectionY ** 2) || 1;\n\n            // Prevent jittery movement with small direction vectors\n            if (dirMagnitude < 0.01) {\n              // Reset to random direction\n              star.driftDirectionX = Math.random() * 2 - 1;\n              star.driftDirectionY = Math.random() * 2 - 1;\n              const newMagnitude = Math.sqrt(star.driftDirectionX ** 2 + star.driftDirectionY ** 2) || 1;\n              star.driftDirectionX /= newMagnitude;\n              star.driftDirectionY /= newMagnitude;\n            } else {\n              star.driftDirectionX /= dirMagnitude;\n              star.driftDirectionY /= dirMagnitude;\n            }\n          }\n        }\n\n        // Check if star is now off-screen\n        if (isStarOffScreen(star) && star.state === 'visible') {\n          // Start fade-out process\n          star.state = 'fading-out';\n          star.fadeStart = currentTime;\n        }\n\n        // Apply pulsing effect to visible stars\n        const pulseFactor = Math.sin(timeFactor * star.pulseSpeed + star.pulsePhase) * 0.15 + 0.85;\n        star.opacity = star.baseOpacity * pulseFactor;\n      }\n    }\n\n    // Replace stars that have completed fade-out (in reverse order to avoid index issues)\n    for (let i = starsToReplace.length - 1; i >= 0; i--) {\n      const index = starsToReplace[i];\n      // Create a new star\n      const newStar = createStar();\n      // Replace the star in the array\n      if (newStar) {\n        starsRef.current[index] = newStar;\n      }\n    }\n  }, [createStar, isStarOffScreen, enableParallax, driftEnabled, twinkleEnabled, twinkleProbability]);\n\n  // FPS limiter for consistent animation speed\n  const fpsLimiter = useCallback((timestamp, callback) => {\n    // Skip animation if hidden, inactive, or reduced motion\n    if (!isVisible || !active || respectReducedMotion && prefersReducedMotion || document.hidden) {\n      animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n      return;\n    }\n    const targetFrameTime = 1000 / maxFPS;\n    const elapsed = timestamp - lastTimestampRef.current;\n    if (elapsed >= targetFrameTime || lastTimestampRef.current === 0) {\n      // Calculate correct delta\n      const delta = lastTimestampRef.current === 0 ? 16 : elapsed;\n\n      // Update timestamp, limiting delta to avoid jumps after inactivity\n      lastTimestampRef.current = timestamp - elapsed % targetFrameTime;\n\n      // Run animation callback with capped delta time\n      callback(Math.min(delta, 50), timestamp);\n\n      // FPS tracking for debug and adaptive quality\n      frameCountRef.current++;\n      if (timestamp - fpsTimestampRef.current >= 1000) {\n        currentFpsRef.current = frameCountRef.current;\n        frameCountRef.current = 0;\n        fpsTimestampRef.current = timestamp;\n\n        // Log FPS in debug mode\n        if (debug) {\n          console.log(`CosmicStars FPS: ${currentFpsRef.current}, Quality: ${qualityFactor.toFixed(2)}`);\n        }\n\n        // Dynamic quality adjustment based on performance with debouncing\n        if (adaptiveQuality) {\n          // Check if FPS is stable by counting consecutive frames within target range\n          if (currentFpsRef.current >= maxFPS * 0.95) {\n            stableFrameCountRef.current += 1;\n          } else if (currentFpsRef.current < maxFPS * 0.7) {\n            stableFrameCountRef.current = 0;\n          }\n\n          // Avoid frequent quality changes\n          if (qualityChangeTimerRef.current) {\n            clearTimeout(qualityChangeTimerRef.current);\n          }\n          qualityChangeTimerRef.current = setTimeout(() => {\n            // Only change quality if FPS has been stable or is very low\n            if (currentFpsRef.current < maxFPS * 0.7) {\n              // If FPS is below 70% of target, reduce quality\n              setQualityFactor(prev => {\n                const newQuality = Math.max(0.4, prev * 0.9);\n                lastQualityFactorRef.current = newQuality;\n                return newQuality;\n              });\n            } else if (stableFrameCountRef.current >= 3 && qualityFactor < 1) {\n              // If FPS has been high for several frames, gradually increase quality\n              setQualityFactor(prev => {\n                const newQuality = Math.min(1, prev * 1.05);\n                lastQualityFactorRef.current = newQuality;\n                return newQuality;\n              });\n            }\n          }, 500);\n        }\n      }\n    }\n\n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n  }, [isVisible, active, respectReducedMotion, prefersReducedMotion, maxFPS, debug, adaptiveQuality, qualityFactor]);\n\n  // Main animation handler\n  const handleAnimation = useCallback((deltaTime, timestamp) => {\n    // Skip if component is not ready\n    if (!canvasRef.current || !isInitializedRef.current) return;\n\n    // Update star positions\n    updateStars(deltaTime, timestamp);\n\n    // Render stars\n    renderStars();\n  }, [updateStars, renderStars]);\n\n  // Detect device capabilities and preferences on mount\n  useEffect(() => {\n    // Check for reduced motion preference\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    const handleReducedMotionChange = e => {\n      setPrefersReducedMotion(e.matches);\n    };\n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n\n    // Setup visibility change detection to pause when tab is inactive\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        visibilityChangeTimeRef.current = performance.now();\n      } else {\n        // Adjust timing references after visibility changes\n        const timeDelta = performance.now() - visibilityChangeTimeRef.current;\n        lastTimestampRef.current += timeDelta;\n      }\n    };\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n\n    // Cleanup\n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  }, []);\n\n  // Setup canvas resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Create a ResizeObserver to detect container size changes\n    const resizeObserver = new ResizeObserver(entries => {\n      var _resizeObserverRef$cu;\n      // Debounce resize operations\n      if ((_resizeObserverRef$cu = resizeObserverRef.current) !== null && _resizeObserverRef$cu !== void 0 && _resizeObserverRef$cu.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n      resizeObserverRef.current = resizeObserverRef.current || {};\n      resizeObserverRef.current.timeout = setTimeout(() => {\n        requestAnimationFrame(() => {\n          if (setupCanvas()) {\n            // Reinitialize stars after canvas resize\n            initializeStars();\n            isInitializedRef.current = true;\n          }\n        });\n      }, 100); // 100ms debounce\n    });\n\n    // Start observing the container\n    resizeObserver.observe(containerRef.current);\n    resizeObserverRef.current = {\n      observer: resizeObserver\n    };\n\n    // Initial setup\n    if (setupCanvas()) {\n      initializeStars();\n      isInitializedRef.current = true;\n    }\n    return () => {\n      var _resizeObserverRef$cu2, _resizeObserverRef$cu3;\n      if ((_resizeObserverRef$cu2 = resizeObserverRef.current) !== null && _resizeObserverRef$cu2 !== void 0 && _resizeObserverRef$cu2.observer) {\n        resizeObserverRef.current.observer.disconnect();\n      }\n      if ((_resizeObserverRef$cu3 = resizeObserverRef.current) !== null && _resizeObserverRef$cu3 !== void 0 && _resizeObserverRef$cu3.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n    };\n  }, [setupCanvas, initializeStars]);\n\n  // Setup intersection observer to only animate when visible\n  useEffect(() => {\n    if (!containerRef.current) return;\n    const observer = new IntersectionObserver(entries => {\n      const isIntersecting = entries[0].isIntersecting;\n\n      // Only change state if visibility actually changed\n      if (isIntersecting !== isVisible) {\n        setIsVisible(isIntersecting);\n        if (isIntersecting) {\n          // Reset timing references when becoming visible again\n          lastTimestampRef.current = 0;\n        }\n      }\n    }, {\n      threshold: 0.01,\n      rootMargin: '100px'\n    });\n    observer.observe(containerRef.current);\n    visibilityObserverRef.current = observer;\n    return () => {\n      if (visibilityObserverRef.current) {\n        visibilityObserverRef.current.disconnect();\n      }\n    };\n  }, [isVisible]);\n\n  // Handle parallax effect on scroll if enabled\n  useEffect(() => {\n    if (!enableParallax) return;\n\n    // Use passive event listener for better performance\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    window.addEventListener('scroll', handleScroll, {\n      passive: true\n    });\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [enableParallax]);\n\n  // Main animation loop\n  useEffect(() => {\n    if (!active || !isInitializedRef.current || !dimensions.width || !dimensions.height) {\n      return;\n    }\n\n    // Start animation with FPS limiter\n    fpsTimestampRef.current = performance.now();\n    frameCountRef.current = 0;\n    lastTimestampRef.current = 0;\n    animationFrameRef.current = requestAnimationFrame(timestamp => {\n      fpsLimiter(timestamp, handleAnimation);\n    });\n\n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      if (qualityChangeTimerRef.current) {\n        clearTimeout(qualityChangeTimerRef.current);\n      }\n    };\n  }, [active, dimensions, fpsLimiter, handleAnimation]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: height,\n      overflow: 'hidden',\n      pointerEvents: 'none',\n      zIndex: zIndex,\n      // Hardware acceleration\n      backfaceVisibility: 'hidden',\n      transform: 'translateZ(0)',\n      willChange: 'transform'\n    },\n    \"aria-hidden\": \"true\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        // Additional rendering optimizations\n        imageRendering: 'high-quality',\n        // Hardware acceleration\n        backfaceVisibility: 'hidden',\n        transform: 'translateZ(0)',\n        willChange: 'transform',\n        // Ensures proper subpixel rendering\n        filter: 'none'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 814,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 796,\n    columnNumber: 5\n  }, this);\n};\n_s(CosmicStars, \"9myARh7R31ju1wO1Z2XyfA5jpjw=\");\n_c = CosmicStars;\nexport default CosmicStars;\nvar _c;\n$RefreshReg$(_c, \"CosmicStars\");","map":{"version":3,"names":["React","useRef","useEffect","useCallback","useState","useMemo","jsxDEV","_jsxDEV","CosmicStars","height","zIndex","active","starCount","starSizeMin","starSizeMax","starOpacityMin","starOpacityMax","enableParallax","parallaxFactor","trailEnabled","trailLength","trailOpacityFactor","twinkleEnabled","twinkleProbability","twinkleDuration","driftEnabled","driftSpeed","driftSpeedVariation","respectReducedMotion","maxFPS","adaptiveQuality","colors","backgroundColor","debug","_s","containerRef","canvasRef","starsRef","animationFrameRef","lastTimestampRef","fpsTimestampRef","frameCountRef","currentFpsRef","scrollPositionRef","resizeObserverRef","visibilityObserverRef","visibilityChangeTimeRef","qualityChangeTimerRef","lastQualityFactorRef","stableFrameCountRef","isInitializedRef","dimensions","setDimensions","width","pixelRatio","prefersReducedMotion","setPrefersReducedMotion","isVisible","setIsVisible","qualityFactor","setQualityFactor","colorCache","cache","forEach","baseColor","opacity","value","replace","adaptedSettings","useHighQualityRendering","Math","max","floor","getColor","safeOpacity","min","roundedOpacity","round","setupCanvas","current","canvas","container","rect","getBoundingClientRect","window","devicePixelRatio","displayWidth","displayHeight","endsWith","parseInt","innerHeight","style","ctx","getContext","alpha","desynchronized","willReadFrequently","fillStyle","fillRect","scale","imageSmoothingEnabled","imageSmoothingQuality","createStar","z","random","star","x","y","baseY","size","baseOpacity","color","length","pulsePhase","PI","pulseSpeed","driftDirectionX","driftDirectionY","directionChangeTimer","state","fadeProgress","fadeStart","Date","now","velocity","targetY","lastX","lastY","twinkleState","twinkleProgress","dirMagnitude","sqrt","initializeStars","i","push","isStarOffScreen","buffer","drawStar","abs","trailX","trailY","beginPath","moveTo","lineTo","strokeStyle","lineWidth","lineCap","stroke","arc","fill","renderStars","setTransform","globalCompositeOperation","font","fillText","toFixed","updateStars","deltaTime","timestamp","currentScrollY","timeFactor","currentTime","starsToReplace","fadingCount","filter","maxSimultaneousFading","elapsed","displacement","springStrength","springForce","maxVelocity","dx","dy","maxMove","actualDx","sign","actualDy","directionChangeFrequency","directionChangeAmount","changeX","changeY","newMagnitude","pulseFactor","sin","index","newStar","fpsLimiter","callback","document","hidden","requestAnimationFrame","time","targetFrameTime","delta","console","log","clearTimeout","setTimeout","prev","newQuality","handleAnimation","reducedMotionQuery","matchMedia","matches","handleReducedMotionChange","e","addEventListener","handleVisibilityChange","performance","timeDelta","removeEventListener","resizeObserver","ResizeObserver","entries","_resizeObserverRef$cu","timeout","observe","observer","_resizeObserverRef$cu2","_resizeObserverRef$cu3","disconnect","IntersectionObserver","isIntersecting","threshold","rootMargin","handleScroll","scrollY","passive","cancelAnimationFrame","ref","position","top","left","overflow","pointerEvents","backfaceVisibility","transform","willChange","children","imageRendering","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/CosmicStars.jsx"],"sourcesContent":["import React, { useRef, useEffect, useCallback, useState, useMemo } from 'react';\n\n/**\n * CosmicStars Component\n * \n * Renders a dynamic starfield with twinkling, parallax effects and subtle drift\n * movements. Designed to work as part of a coordinated cosmic background system.\n * \n * Features:\n * - High performance star rendering with optimized canvas operations\n * - Parallax scrolling with physics-based movement\n * - Random twinkling and pulsing effects\n * - Subtle drift movements for stars\n * - Adaptive quality based on device capabilities\n * \n * @param {Object} props - Component props\n * @param {string|number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=1] - Z-index for the container (lower than other cosmic components)\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.starCount=120] - Number of stars to render\n * @param {number} [props.starSizeMin=1.0] - Minimum size of stars\n * @param {number} [props.starSizeMax=1.9] - Maximum size of stars\n * @param {number} [props.starOpacityMin=0.2] - Minimum opacity of stars\n * @param {number} [props.starOpacityMax=0.55] - Maximum opacity of stars\n * @param {boolean} [props.enableParallax=true] - Enable parallax effect on scroll\n * @param {number} [props.parallaxFactor=0.2] - How much stars move relative to scroll (0-1)\n * @param {boolean} [props.trailEnabled=true] - Enable subtle trails behind moving stars\n * @param {number} [props.trailLength=2] - Length of star trails in pixels\n * @param {number} [props.trailOpacityFactor=0.5] - Trail opacity relative to star opacity\n * @param {boolean} [props.twinkleEnabled=true] - Enable stars to fade in and out\n * @param {number} [props.twinkleProbability=0.01] - Probability of a star beginning to twinkle each frame\n * @param {number[]} [props.twinkleDuration=[2000, 4000]] - Min and max duration of a twinkle cycle (ms)\n * @param {boolean} [props.driftEnabled=true] - Enable slow drifting movement of stars\n * @param {number} [props.driftSpeed=0.01] - Base speed of drift movement (pixels per second)\n * @param {number} [props.driftSpeedVariation=0.005] - Variation in drift speed between stars\n * @param {boolean} [props.respectReducedMotion=true] - Respect reduced motion preferences\n * @param {number} [props.maxFPS=60] - Target maximum frames per second\n * @param {boolean} [props.adaptiveQuality=true] - Enable adaptive quality based on device\n * @param {string[]} [props.colors] - Star colors with alpha placeholder (defaults to golden palette)\n * @param {string} [props.backgroundColor='rgb(8, 8, 12)'] - Canvas background color\n * @param {boolean} [props.debug=false] - Enable debug visualization\n */\nconst CosmicStars = ({\n  height = '100vh',\n  zIndex = 1,\n  active = true,\n  starCount = 120,\n  starSizeMin = 1.0,\n  starSizeMax = 1.9,\n  starOpacityMin = 0.2,\n  starOpacityMax = 0.55,\n  enableParallax = true,\n  parallaxFactor = 0.2,\n  trailEnabled = true,\n  trailLength = 2,\n  trailOpacityFactor = 0.5,\n  twinkleEnabled = true,\n  twinkleProbability = 0.01,\n  twinkleDuration = [2000, 4000],\n  driftEnabled = true,\n  driftSpeed = 0.01,\n  driftSpeedVariation = 0.005,\n  respectReducedMotion = true,\n  maxFPS = 60,\n  adaptiveQuality = true,\n  colors = [\n    'rgba(255, 243, 200, alpha)', // Warm yellow\n    'rgba(255, 231, 164, alpha)', // Golden\n    'rgba(252, 249, 231, alpha)'  // Off-white gold\n  ],\n  backgroundColor = 'rgb(8, 8, 12)',\n  debug = false\n}) => {\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const starsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const fpsTimestampRef = useRef(0);\n  const frameCountRef = useRef(0);\n  const currentFpsRef = useRef(60);\n  const scrollPositionRef = useRef(0);\n  const resizeObserverRef = useRef(null);\n  const visibilityObserverRef = useRef(null);\n  const visibilityChangeTimeRef = useRef(0);\n  const qualityChangeTimerRef = useRef(null);\n  const lastQualityFactorRef = useRef(1);\n  const stableFrameCountRef = useRef(0);\n  \n  // Use refs instead of state to prevent re-renders\n  const isInitializedRef = useRef(false);\n  \n  // Component state\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0, pixelRatio: 1 });\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [isVisible, setIsVisible] = useState(false);\n  const [qualityFactor, setQualityFactor] = useState(1);\n  \n  // Pre-generated color values to avoid string replacements during animation\n  const colorCache = useMemo(() => {\n    const cache = {};\n    colors.forEach(baseColor => {\n      cache[baseColor] = {};\n      for (let opacity = 0; opacity <= 10; opacity++) {\n        const value = opacity / 10;\n        cache[baseColor][value] = baseColor.replace(/alpha\\)$/, `${value})`);\n      }\n    });\n    return cache;\n  }, [colors]);\n  \n  // Adaptive settings based on quality factor\n  const adaptedSettings = useMemo(() => {\n    if (!adaptiveQuality || qualityFactor === 1) {\n      return {\n        starCount,\n        trailEnabled,\n        useHighQualityRendering: true\n      };\n    }\n    \n    // Adjust quality-dependent parameters\n    return {\n      starCount: Math.max(40, Math.floor(starCount * qualityFactor)),\n      trailEnabled: qualityFactor > 0.5 && trailEnabled,\n      useHighQualityRendering: qualityFactor > 0.7\n    };\n  }, [adaptiveQuality, qualityFactor, starCount, trailEnabled]);\n  \n  // Get color with opacity from cache (faster than string replacement)\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    // Round to nearest 0.1 to use cached values\n    const roundedOpacity = Math.round(safeOpacity * 10) / 10;\n    return colorCache[baseColor][roundedOpacity] || baseColor.replace(/alpha\\)$/, `${safeOpacity})`);\n  }, [colorCache]);\n  \n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current || !containerRef.current) return false;\n    \n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    const rect = container.getBoundingClientRect();\n    const pixelRatio = window.devicePixelRatio || 1;\n    \n    // Calculate dimensions\n    const displayWidth = Math.floor(rect.width);\n    const displayHeight = typeof height === 'string' && height.endsWith('vh') \n      ? Math.floor((parseInt(height, 10) / 100) * window.innerHeight)\n      : Math.floor(parseInt(height, 10) || window.innerHeight);\n    \n    // Set canvas size accounting for pixel ratio\n    canvas.width = displayWidth * pixelRatio;\n    canvas.height = displayHeight * pixelRatio;\n    canvas.style.width = `${displayWidth}px`;\n    canvas.style.height = `${displayHeight}px`;\n    \n    // Get 2D context and optimize it\n    const ctx = canvas.getContext('2d', { \n      alpha: false, // Optimize for non-transparent canvas\n      desynchronized: true, // Potential performance boost\n      willReadFrequently: false // Performance hint\n    });\n    \n    if (!ctx) return false;\n    \n    // Apply initial background color\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    \n    // Scale context for high-DPI displays\n    ctx.scale(pixelRatio, pixelRatio);\n    \n    // Configure context for quality\n    if (adaptedSettings.useHighQualityRendering) {\n      ctx.imageSmoothingEnabled = true;\n      ctx.imageSmoothingQuality = 'high';\n    }\n    \n    // Update dimensions\n    setDimensions({\n      width: displayWidth,\n      height: displayHeight,\n      pixelRatio\n    });\n    \n    return true;\n  }, [height, backgroundColor, adaptedSettings.useHighQualityRendering]);\n  \n  // Create a new star\n  const createStar = useCallback(() => {\n    const { width, height } = dimensions;\n    if (!width || !height) return null;\n    \n    // Generate z-depth first (controls parallax and size)\n    const z = Math.random() * 0.8 + 0.1; // 0.1 to 0.9\n    \n    // Create star with random properties\n    const star = {\n      // Position\n      x: Math.random() * width,\n      y: Math.random() * height,\n      baseY: Math.random() * height, // Reference position for parallax\n      z,\n      \n      // Visual properties\n      size: (Math.random() * (starSizeMax - starSizeMin) + starSizeMin) * z,\n      baseOpacity: Math.random() * (starOpacityMax - starOpacityMin) + starOpacityMin,\n      opacity: 0, // Start with 0 for fade-in\n      color: colors[Math.floor(Math.random() * colors.length)],\n      \n      // Animation properties\n      pulsePhase: Math.random() * Math.PI * 2,\n      pulseSpeed: Math.random() * 0.002 + 0.001,\n      \n      // Drift movement properties\n      driftDirectionX: Math.random() * 2 - 1,\n      driftDirectionY: Math.random() * 2 - 1,\n      driftSpeed: driftSpeed + (Math.random() * 2 - 1) * driftSpeedVariation,\n      directionChangeTimer: 0,\n      \n      // State tracking properties\n      state: 'fading-in', // fading-in, visible, fading-out\n      fadeProgress: 0,\n      fadeStart: Date.now(),\n      \n      // Physics properties for parallax effect\n      velocity: 0,\n      targetY: Math.random() * height,\n      \n      // Trail properties\n      lastX: Math.random() * width,\n      lastY: Math.random() * height,\n      \n      // Twinkling properties\n      twinkleState: 'visible', // visible, fading-out, hidden, fading-in\n      twinkleProgress: 0,\n      twinkleDuration: Math.random() * (twinkleDuration[1] - twinkleDuration[0]) + twinkleDuration[0],\n      \n      // Parallax factor - deeper stars (higher z) move less\n      parallaxFactor: Math.random() * 0.5 * parallaxFactor * (1 - z * 0.5)\n    };\n    \n    // Normalize the drift direction vector\n    const dirMagnitude = Math.sqrt(star.driftDirectionX ** 2 + star.driftDirectionY ** 2) || 1;\n    star.driftDirectionX /= dirMagnitude;\n    star.driftDirectionY /= dirMagnitude;\n    \n    return star;\n  }, [\n    dimensions, \n    starSizeMin, \n    starSizeMax, \n    starOpacityMin, \n    starOpacityMax, \n    colors, \n    driftSpeed, \n    driftSpeedVariation, \n    twinkleDuration, \n    parallaxFactor\n  ]);\n  \n  // Initialize stars\n  const initializeStars = useCallback(() => {\n    // Clear existing stars\n    starsRef.current = [];\n    \n    // Generate stars based on count\n    for (let i = 0; i < adaptedSettings.starCount; i++) {\n      const star = createStar();\n      if (star) {\n        // For initial creation, set some stars to be already visible\n        if (Math.random() < 0.7) {\n          star.state = 'visible';\n          star.opacity = star.baseOpacity;\n          star.fadeProgress = 1;\n        }\n        starsRef.current.push(star);\n      }\n    }\n  }, [adaptedSettings.starCount, createStar]);\n  \n  // Check if a star is off-screen\n  const isStarOffScreen = useCallback((star) => {\n    const { width, height } = dimensions;\n    const buffer = 50; // Buffer distance to trigger regeneration\n    \n    return (\n      star.x < -buffer ||\n      star.x > width + buffer ||\n      star.y < -buffer ||\n      star.y > height + buffer\n    );\n  }, [dimensions]);\n  \n  // Draw a single star with optional trail\n  const drawStar = useCallback((ctx, star) => {\n    // Skip rendering completely invisible stars\n    if (star.opacity < 0.02) return;\n    \n    // Draw subtle trail if enabled and star is moving\n    if (adaptedSettings.trailEnabled && \n        (Math.abs(star.velocity) > 0.001 || Math.abs(star.lastX - star.x) > 0.1)) {\n      // Calculate trail direction based on movement\n      const trailX = star.lastX;\n      const trailY = star.lastY;\n      \n      // Draw trail\n      ctx.beginPath();\n      ctx.moveTo(star.x, star.y);\n      ctx.lineTo(trailX, trailY);\n      ctx.strokeStyle = getColor(star.color, star.opacity * trailOpacityFactor);\n      ctx.lineWidth = star.size * 0.6;\n      ctx.lineCap = 'round';\n      ctx.stroke();\n    }\n    \n    // Store current position for next frame's trail\n    star.lastX = star.x;\n    star.lastY = star.y;\n    \n    // Draw star\n    ctx.beginPath();\n    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n    ctx.fillStyle = getColor(star.color, star.opacity);\n    ctx.fill();\n    \n    // Draw glow for larger or brighter stars\n    if (adaptedSettings.useHighQualityRendering && star.opacity > 0.3) {\n      ctx.beginPath();\n      ctx.arc(star.x, star.y, star.size * 1.8, 0, Math.PI * 2);\n      ctx.fillStyle = getColor(star.color, star.opacity * 0.4);\n      ctx.fill();\n    }\n  }, [adaptedSettings.trailEnabled, adaptedSettings.useHighQualityRendering, getColor, trailOpacityFactor]);\n  \n  // Render all stars\n  const renderStars = useCallback(() => {\n    if (!canvasRef.current) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d', { alpha: false });\n    \n    if (!ctx) return;\n    \n    const { width, height, pixelRatio } = dimensions;\n    \n    // Clear canvas\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, width * pixelRatio, height * pixelRatio);\n    \n    // Apply device pixel ratio scaling only once\n    ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    \n    // Enable global composition for better glow effect\n    ctx.globalCompositeOperation = 'lighter';\n    \n    // Draw stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n      drawStar(ctx, star);\n    }\n    \n    // Reset global composition\n    ctx.globalCompositeOperation = 'source-over';\n    \n    // Render debug info if enabled\n    if (debug) {\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n      ctx.font = '12px monospace';\n      ctx.fillText(`FPS: ${currentFpsRef.current}`, 10, 20);\n      ctx.fillText(`Stars: ${starsRef.current.length}/${adaptedSettings.starCount}`, 10, 40);\n      ctx.fillText(`Quality: ${qualityFactor.toFixed(2)}`, 10, 60);\n    }\n  }, [dimensions, backgroundColor, drawStar, debug, qualityFactor, adaptedSettings.starCount]);\n  \n  // Update star positions and properties\n  const updateStars = useCallback((deltaTime, timestamp) => {\n    // Get current scroll position\n    const currentScrollY = scrollPositionRef.current;\n    \n    // Global time factor for animations\n    const timeFactor = timestamp * 0.001;\n    const currentTime = Date.now();\n    \n    // Track stars to replace\n    const starsToReplace = [];\n    \n    // Count currently fading stars (for controlling simultaneous fades)\n    let fadingCount = starsRef.current.filter(\n      star => star.state === 'fading-out' || star.state === 'fading-in'\n    ).length;\n    \n    // Maximum simultaneous fading stars\n    const maxSimultaneousFading = 10;\n    \n    // Update each star\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n      \n      // Handle star state transitions\n      if (star.state === 'fading-in') {\n        // Calculate progress for fade-in\n        const elapsed = currentTime - star.fadeStart;\n        star.fadeProgress = Math.min(1, elapsed / 2000); // 2 second fade-in\n        star.opacity = star.baseOpacity * star.fadeProgress;\n        \n        // Complete fade-in\n        if (star.fadeProgress >= 1) {\n          star.state = 'visible';\n          star.opacity = star.baseOpacity;\n        }\n      } else if (star.state === 'fading-out') {\n        // Calculate progress for fade-out\n        const elapsed = currentTime - star.fadeStart;\n        star.fadeProgress = Math.max(0, 1 - (elapsed / 1500)); // 1.5 second fade-out\n        star.opacity = star.baseOpacity * star.fadeProgress;\n        \n        // Complete fade-out - mark for replacement\n        if (star.fadeProgress <= 0) {\n          starsToReplace.push(i);\n        }\n      } else {\n        // Normal visible state\n        \n        // Random fading if not too many stars are already fading\n        if (twinkleEnabled && \n            fadingCount < maxSimultaneousFading && \n            Math.random() < twinkleProbability * deltaTime) {\n          // Start fade-out process for random star\n          star.state = 'fading-out';\n          star.fadeStart = currentTime;\n          fadingCount++;\n          continue; // Skip to next star\n        }\n        \n        // Calculate parallax effect based on scroll position\n        if (enableParallax) {\n          // Update target position based on scroll\n          star.targetY = star.baseY - (currentScrollY * star.parallaxFactor);\n        }\n        \n        // Apply spring physics for smooth parallax\n        const displacement = star.targetY - star.y;\n        const springStrength = 0.03; // Higher = snappier\n        const springForce = displacement * springStrength;\n        \n        // Update velocity with spring force\n        star.velocity += springForce;\n        \n        // Apply damping to velocity\n        star.velocity *= 0.95; // Higher = less bouncy\n        \n        // Add velocity clamping to prevent extreme movement\n        const maxVelocity = 1.0;\n        star.velocity = Math.max(-maxVelocity, Math.min(maxVelocity, star.velocity));\n        \n        // Update position based on velocity\n        star.y += star.velocity;\n        \n        // Apply drift movement if enabled\n        if (driftEnabled) {\n          // Calculate the intended movement\n          const dx = star.driftDirectionX * star.driftSpeed * deltaTime;\n          const dy = star.driftDirectionY * star.driftSpeed * deltaTime;\n          \n          // Apply a maximum movement limit to prevent jumps\n          const maxMove = 0.5; // Maximum pixels to move per frame\n          const actualDx = Math.abs(dx) > maxMove ? Math.sign(dx) * maxMove : dx;\n          const actualDy = Math.abs(dy) > maxMove ? Math.sign(dy) * maxMove : dy;\n          \n          // Move star\n          star.x += actualDx;\n          star.baseY += actualDy;\n          star.targetY = star.baseY - (currentScrollY * star.parallaxFactor);\n          \n          // Occasionally change drift direction\n          const directionChangeFrequency = 0.0005; // Probability per frame\n          if (Math.random() < directionChangeFrequency * deltaTime) {\n            // Gradually change direction\n            const directionChangeAmount = 0.05; // How much direction can change at once\n            const changeX = (Math.random() * 2 - 1) * directionChangeAmount;\n            const changeY = (Math.random() * 2 - 1) * directionChangeAmount;\n            \n            // Apply change\n            star.driftDirectionX += changeX;\n            star.driftDirectionY += changeY;\n            \n            // Re-normalize direction vector\n            const dirMagnitude = Math.sqrt(star.driftDirectionX ** 2 + star.driftDirectionY ** 2) || 1;\n            \n            // Prevent jittery movement with small direction vectors\n            if (dirMagnitude < 0.01) {\n              // Reset to random direction\n              star.driftDirectionX = Math.random() * 2 - 1;\n              star.driftDirectionY = Math.random() * 2 - 1;\n              const newMagnitude = Math.sqrt(star.driftDirectionX ** 2 + star.driftDirectionY ** 2) || 1;\n              star.driftDirectionX /= newMagnitude;\n              star.driftDirectionY /= newMagnitude;\n            } else {\n              star.driftDirectionX /= dirMagnitude;\n              star.driftDirectionY /= dirMagnitude;\n            }\n          }\n        }\n        \n        // Check if star is now off-screen\n        if (isStarOffScreen(star) && star.state === 'visible') {\n          // Start fade-out process\n          star.state = 'fading-out';\n          star.fadeStart = currentTime;\n        }\n        \n        // Apply pulsing effect to visible stars\n        const pulseFactor = Math.sin(timeFactor * star.pulseSpeed + star.pulsePhase) * 0.15 + 0.85;\n        star.opacity = star.baseOpacity * pulseFactor;\n      }\n    }\n    \n    // Replace stars that have completed fade-out (in reverse order to avoid index issues)\n    for (let i = starsToReplace.length - 1; i >= 0; i--) {\n      const index = starsToReplace[i];\n      // Create a new star\n      const newStar = createStar();\n      // Replace the star in the array\n      if (newStar) {\n        starsRef.current[index] = newStar;\n      }\n    }\n  }, [\n    createStar, \n    isStarOffScreen, \n    enableParallax, \n    driftEnabled, \n    twinkleEnabled, \n    twinkleProbability\n  ]);\n  \n  // FPS limiter for consistent animation speed\n  const fpsLimiter = useCallback((timestamp, callback) => {\n    // Skip animation if hidden, inactive, or reduced motion\n    if (!isVisible || !active || (respectReducedMotion && prefersReducedMotion) || document.hidden) {\n      animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n      return;\n    }\n    \n    const targetFrameTime = 1000 / maxFPS;\n    const elapsed = timestamp - lastTimestampRef.current;\n    \n    if (elapsed >= targetFrameTime || lastTimestampRef.current === 0) {\n      // Calculate correct delta\n      const delta = lastTimestampRef.current === 0 ? 16 : elapsed;\n      \n      // Update timestamp, limiting delta to avoid jumps after inactivity\n      lastTimestampRef.current = timestamp - (elapsed % targetFrameTime);\n      \n      // Run animation callback with capped delta time\n      callback(Math.min(delta, 50), timestamp);\n      \n      // FPS tracking for debug and adaptive quality\n      frameCountRef.current++;\n      if (timestamp - fpsTimestampRef.current >= 1000) {\n        currentFpsRef.current = frameCountRef.current;\n        frameCountRef.current = 0;\n        fpsTimestampRef.current = timestamp;\n        \n        // Log FPS in debug mode\n        if (debug) {\n          console.log(`CosmicStars FPS: ${currentFpsRef.current}, Quality: ${qualityFactor.toFixed(2)}`);\n        }\n        \n        // Dynamic quality adjustment based on performance with debouncing\n        if (adaptiveQuality) {\n          // Check if FPS is stable by counting consecutive frames within target range\n          if (currentFpsRef.current >= maxFPS * 0.95) {\n            stableFrameCountRef.current += 1;\n          } else if (currentFpsRef.current < maxFPS * 0.7) {\n            stableFrameCountRef.current = 0;\n          }\n          \n          // Avoid frequent quality changes\n          if (qualityChangeTimerRef.current) {\n            clearTimeout(qualityChangeTimerRef.current);\n          }\n          \n          qualityChangeTimerRef.current = setTimeout(() => {\n            // Only change quality if FPS has been stable or is very low\n            if (currentFpsRef.current < maxFPS * 0.7) {\n              // If FPS is below 70% of target, reduce quality\n              setQualityFactor(prev => {\n                const newQuality = Math.max(0.4, prev * 0.9);\n                lastQualityFactorRef.current = newQuality;\n                return newQuality;\n              });\n            } else if (stableFrameCountRef.current >= 3 && qualityFactor < 1) {\n              // If FPS has been high for several frames, gradually increase quality\n              setQualityFactor(prev => {\n                const newQuality = Math.min(1, prev * 1.05);\n                lastQualityFactorRef.current = newQuality;\n                return newQuality;\n              });\n            }\n          }, 500);\n        }\n      }\n    }\n    \n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n  }, [\n    isVisible,\n    active,\n    respectReducedMotion,\n    prefersReducedMotion,\n    maxFPS,\n    debug,\n    adaptiveQuality,\n    qualityFactor\n  ]);\n  \n  // Main animation handler\n  const handleAnimation = useCallback((deltaTime, timestamp) => {\n    // Skip if component is not ready\n    if (!canvasRef.current || !isInitializedRef.current) return;\n    \n    // Update star positions\n    updateStars(deltaTime, timestamp);\n    \n    // Render stars\n    renderStars();\n  }, [\n    updateStars,\n    renderStars\n  ]);\n  \n  // Detect device capabilities and preferences on mount\n  useEffect(() => {\n    // Check for reduced motion preference\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    \n    const handleReducedMotionChange = (e) => {\n      setPrefersReducedMotion(e.matches);\n    };\n    \n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n    \n    // Setup visibility change detection to pause when tab is inactive\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        visibilityChangeTimeRef.current = performance.now();\n      } else {\n        // Adjust timing references after visibility changes\n        const timeDelta = performance.now() - visibilityChangeTimeRef.current;\n        lastTimestampRef.current += timeDelta;\n      }\n    };\n    \n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    \n    // Cleanup\n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  }, []);\n  \n  // Setup canvas resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n    \n    // Create a ResizeObserver to detect container size changes\n    const resizeObserver = new ResizeObserver(entries => {\n      // Debounce resize operations\n      if (resizeObserverRef.current?.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n      \n      resizeObserverRef.current = resizeObserverRef.current || {};\n      resizeObserverRef.current.timeout = setTimeout(() => {\n        requestAnimationFrame(() => {\n          if (setupCanvas()) {\n            // Reinitialize stars after canvas resize\n            initializeStars();\n            isInitializedRef.current = true;\n          }\n        });\n      }, 100); // 100ms debounce\n    });\n    \n    // Start observing the container\n    resizeObserver.observe(containerRef.current);\n    resizeObserverRef.current = { observer: resizeObserver };\n    \n    // Initial setup\n    if (setupCanvas()) {\n      initializeStars();\n      isInitializedRef.current = true;\n    }\n    \n    return () => {\n      if (resizeObserverRef.current?.observer) {\n        resizeObserverRef.current.observer.disconnect();\n      }\n      if (resizeObserverRef.current?.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n    };\n  }, [setupCanvas, initializeStars]);\n  \n  // Setup intersection observer to only animate when visible\n  useEffect(() => {\n    if (!containerRef.current) return;\n    \n    const observer = new IntersectionObserver(\n      entries => {\n        const isIntersecting = entries[0].isIntersecting;\n        \n        // Only change state if visibility actually changed\n        if (isIntersecting !== isVisible) {\n          setIsVisible(isIntersecting);\n          \n          if (isIntersecting) {\n            // Reset timing references when becoming visible again\n            lastTimestampRef.current = 0;\n          }\n        }\n      },\n      {\n        threshold: 0.01,\n        rootMargin: '100px'\n      }\n    );\n    \n    observer.observe(containerRef.current);\n    visibilityObserverRef.current = observer;\n    \n    return () => {\n      if (visibilityObserverRef.current) {\n        visibilityObserverRef.current.disconnect();\n      }\n    };\n  }, [isVisible]);\n  \n  // Handle parallax effect on scroll if enabled\n  useEffect(() => {\n    if (!enableParallax) return;\n    \n    // Use passive event listener for better performance\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    \n    window.addEventListener('scroll', handleScroll, { passive: true });\n    \n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [enableParallax]);\n  \n  // Main animation loop\n  useEffect(() => {\n    if (!active || !isInitializedRef.current || !dimensions.width || !dimensions.height) {\n      return;\n    }\n    \n    // Start animation with FPS limiter\n    fpsTimestampRef.current = performance.now();\n    frameCountRef.current = 0;\n    lastTimestampRef.current = 0;\n    \n    animationFrameRef.current = requestAnimationFrame(timestamp => {\n      fpsLimiter(timestamp, handleAnimation);\n    });\n    \n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      \n      if (qualityChangeTimerRef.current) {\n        clearTimeout(qualityChangeTimerRef.current);\n      }\n    };\n  }, [\n    active,\n    dimensions,\n    fpsLimiter,\n    handleAnimation\n  ]);\n  \n  return (\n    <div \n      ref={containerRef}\n      style={{ \n        position: 'absolute',\n        top: 0, \n        left: 0, \n        width: '100%', \n        height: height,\n        overflow: 'hidden', \n        pointerEvents: 'none', \n        zIndex: zIndex,\n        // Hardware acceleration\n        backfaceVisibility: 'hidden',\n        transform: 'translateZ(0)',\n        willChange: 'transform'\n      }}\n      aria-hidden=\"true\"\n    >\n      <canvas \n        ref={canvasRef} \n        style={{ \n          position: 'absolute', \n          top: 0, \n          left: 0, \n          width: '100%', \n          height: '100%',\n          // Additional rendering optimizations\n          imageRendering: 'high-quality',\n          // Hardware acceleration\n          backfaceVisibility: 'hidden',\n          transform: 'translateZ(0)',\n          willChange: 'transform',\n          // Ensures proper subpixel rendering\n          filter: 'none'\n        }} \n      />\n    </div>\n  );\n};\n\nexport default CosmicStars;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}