{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/Background.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect, useCallback, useMemo } from 'react';\n\n/**\n * Background Component\n * \n * Creates an immersive stellar background with stars that extend beyond\n * the viewport, allowing for a continuous star field experience when scrolling.\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Background = () => {\n  _s();\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const starsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimeRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n\n  // Component state\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0,\n    pixelRatio: 1\n  });\n  const [isInitialized, setIsInitialized] = useState(false);\n\n  // Configuration - using static values instead of useMemo to simplify\n  const CONFIG = {\n    // Star parameters\n    starCount: 350,\n    // Increased for better density\n    areaMultiplier: 3,\n    // Size multiplier for star field (3x viewport)\n    starSizeMin: 0.8,\n    starSizeMax: 2.5,\n    starOpacityMin: 0.2,\n    // Increased minimum opacity\n    starOpacityMax: 0.9,\n    // Increased maximum opacity\n\n    // Motion and animation\n    baseMovementSpeed: 0.00015,\n    pulseFrequency: 0.00004,\n    pulseIntensity: 0.25,\n    // Parallax effect\n    parallaxIntensity: 0.04,\n    // Colors\n    colors: {\n      stars: ['rgba(255, 243, 200, alpha)',\n      // Warm yellow\n      'rgba(255, 231, 164, alpha)',\n      // Golden\n      'rgba(255, 236, 179, alpha)',\n      // Pale gold\n      'rgba(252, 249, 231, alpha)',\n      // Off-white gold\n      'rgba(255, 225, 205, alpha)' // Warm white (slight orange)\n      ],\n      background: {\n        topColor: 'rgb(8, 8, 12)',\n        bottomColor: 'rgb(15, 15, 20)'\n      }\n    }\n  };\n\n  // Get color with opacity\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    return baseColor.replace(/alpha\\)$/, `${safeOpacity})`);\n  }, []);\n\n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) return;\n    const canvas = canvasRef.current;\n\n    // Get viewport dimensions\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const pixelRatio = window.devicePixelRatio || 1;\n\n    // Set canvas size accounting for pixel ratio\n    canvas.width = width * pixelRatio;\n    canvas.height = height * pixelRatio;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n\n    // Update dimensions state\n    setDimensions({\n      width,\n      height,\n      pixelRatio\n    });\n  }, []);\n\n  // Initialize stars\n  const initializeStars = useCallback(() => {\n    if (!dimensions.width || !dimensions.height) return;\n\n    // Clear existing stars\n    starsRef.current = [];\n\n    // Calculate the area for stars (larger than viewport)\n    const areaWidth = dimensions.width * CONFIG.areaMultiplier;\n    const areaHeight = dimensions.height * CONFIG.areaMultiplier;\n\n    // Create stars\n    for (let i = 0; i < CONFIG.starCount; i++) {\n      const star = {};\n\n      // Position - distribute across the larger area\n      // Center the area relative to initial viewport\n      star.x = Math.random() * areaWidth - (areaWidth - dimensions.width) / 2;\n      star.y = Math.random() * areaHeight - (areaHeight - dimensions.height) / 2;\n      star.z = Math.random() * 0.8 + 0.1; // Depth (0.1 to 0.9)\n\n      // Initial position (for oscillation)\n      star.initialX = star.x;\n      star.initialY = star.y;\n\n      // Visual properties\n      star.size = (Math.random() * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n      star.baseOpacity = Math.random() * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n      star.opacity = star.baseOpacity;\n\n      // Animation properties\n      star.pulsePhase = Math.random() * Math.PI * 2;\n      star.pulseSpeed = Math.random() * 0.002 + 0.001;\n\n      // Star shape properties - add variation for more realistic stars\n      star.rays = Math.random() > 0.7 ? Math.floor(Math.random() * 2) + 4 : 0;\n      star.rayLength = star.size * (Math.random() * 0.7 + 0.3);\n      star.rayIntensity = Math.random() * 0.4 + 0.3;\n\n      // Color variation\n      const colorIndex = Math.floor(Math.random() * CONFIG.colors.stars.length);\n      star.color = CONFIG.colors.stars[colorIndex];\n      starsRef.current.push(star);\n    }\n  }, [dimensions, CONFIG]);\n\n  // Update animation state\n  const updateAnimation = useCallback((deltaTime, timestamp) => {\n    // Global time factor for animations\n    const timeFactor = timestamp * 0.001;\n\n    // Parallax effect from scroll\n    const parallaxOffset = scrollPositionRef.current * CONFIG.parallaxIntensity;\n\n    // Update stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n\n      // Small positional oscillation around initial position\n      star.x = star.initialX + Math.sin(timeFactor * 0.2 + star.pulsePhase) * 0.5;\n      star.y = star.initialY + Math.cos(timeFactor * 0.3 + star.pulsePhase * 1.3) * 0.5;\n\n      // Apply parallax based on depth (z)\n      star.parallaxY = parallaxOffset * (1 - star.z) * 0.5;\n\n      // Pulsing effect - combine multiple sine waves for more natural effect\n      const pulseFactor = (Math.sin(timeFactor * star.pulseSpeed + star.pulsePhase) * 0.5 + Math.sin(timeFactor * star.pulseSpeed * 0.4 + star.pulsePhase * 1.3) * 0.3) * 0.15 + 0.85;\n      star.opacity = star.baseOpacity * pulseFactor;\n\n      // Vary ray intensity based on pulse\n      if (star.rays > 0) {\n        star.currentRayIntensity = star.rayIntensity * pulseFactor;\n      }\n    }\n  }, [CONFIG]);\n\n  // Render stars\n  const renderScene = useCallback(() => {\n    if (!canvasRef.current) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Apply device pixel ratio scaling\n    ctx.setTransform(dimensions.pixelRatio, 0, 0, dimensions.pixelRatio, 0, 0);\n\n    // Clear canvas\n    ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n\n    // Draw background gradient\n    const gradient = ctx.createLinearGradient(0, 0, 0, dimensions.height);\n    gradient.addColorStop(0, CONFIG.colors.background.topColor);\n    gradient.addColorStop(1, CONFIG.colors.background.bottomColor);\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, dimensions.width, dimensions.height);\n\n    // Enable global composition for better glow effect\n    ctx.globalCompositeOperation = 'lighter';\n\n    // Draw stars\n    for (const star of starsRef.current) {\n      // Skip almost invisible stars\n      if (star.opacity < 0.02) continue;\n\n      // Calculate screen position based on scroll\n      const screenY = star.y + (star.parallaxY || 0) - scrollPositionRef.current;\n\n      // Only render stars that are visible in the viewport plus a small buffer\n      if (screenY >= -50 && screenY <= dimensions.height + 50 && star.x >= -50 && star.x <= dimensions.width + 50) {\n        try {\n          // Draw star with glow\n          const glowRadius = Math.max(0.1, star.size * 2);\n\n          // Draw outer glow for all stars\n          const gradient = ctx.createRadialGradient(star.x, screenY, 0, star.x, screenY, glowRadius);\n          gradient.addColorStop(0, getColor(star.color, star.opacity * 0.9));\n          gradient.addColorStop(0.5, getColor(star.color, star.opacity * 0.3));\n          gradient.addColorStop(1, getColor(star.color, 0));\n          ctx.beginPath();\n          ctx.fillStyle = gradient;\n          ctx.arc(star.x, screenY, glowRadius, 0, Math.PI * 2);\n          ctx.fill();\n\n          // Draw bright core\n          ctx.beginPath();\n          ctx.fillStyle = getColor(star.color, star.opacity);\n          ctx.arc(star.x, screenY, Math.max(0.1, star.size * 0.5), 0, Math.PI * 2);\n          ctx.fill();\n\n          // Draw rays for some stars\n          if (star.rays > 0 && star.opacity > 0.3) {\n            ctx.save();\n            ctx.translate(star.x, screenY);\n            ctx.rotate(Math.sin(Date.now() * 0.0001) * 0.05); // Very slight rotation\n\n            for (let i = 0; i < star.rays; i++) {\n              const angle = i / star.rays * Math.PI * 2;\n              const rayLength = Math.max(0.1, star.rayLength * (0.7 + Math.sin(Date.now() * 0.001 + i) * 0.3));\n              ctx.beginPath();\n              ctx.moveTo(0, 0);\n              ctx.lineTo(Math.cos(angle) * rayLength, Math.sin(angle) * rayLength);\n\n              // Create gradient for ray\n              const rayGradient = ctx.createLinearGradient(0, 0, Math.cos(angle) * rayLength, Math.sin(angle) * rayLength);\n              rayGradient.addColorStop(0, getColor(star.color, star.opacity * 0.9));\n              rayGradient.addColorStop(1, getColor(star.color, 0));\n              ctx.strokeStyle = rayGradient;\n              ctx.lineWidth = Math.max(0.1, star.size * 0.3);\n              ctx.stroke();\n            }\n            ctx.restore();\n          }\n        } catch (error) {\n          // Silently handle any canvas drawing errors\n        }\n      }\n    }\n\n    // Reset global composition\n    ctx.globalCompositeOperation = 'source-over';\n  }, [dimensions, CONFIG, getColor]);\n\n  // Main animation loop\n  const animate = useCallback(timestamp => {\n    if (!isInitialized) {\n      animationFrameRef.current = requestAnimationFrame(animate);\n      return;\n    }\n\n    // Calculate delta time with cap to prevent large jumps\n    const deltaTime = lastTimeRef.current ? Math.min(timestamp - lastTimeRef.current, 33) : 16;\n    lastTimeRef.current = timestamp;\n\n    // Update animation state\n    updateAnimation(deltaTime, timestamp);\n\n    // Render scene\n    renderScene();\n\n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(animate);\n  }, [isInitialized, updateAnimation, renderScene]);\n\n  // Track scroll position for parallax\n  useEffect(() => {\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    window.addEventListener('scroll', handleScroll, {\n      passive: true\n    });\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, []);\n\n  // Handle resize events\n  useEffect(() => {\n    const handleResize = () => {\n      setupCanvas();\n      initializeStars();\n    };\n    window.addEventListener('resize', handleResize);\n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, [setupCanvas, initializeStars]);\n\n  // Initialize component\n  useEffect(() => {\n    // Setup canvas\n    setupCanvas();\n\n    // Cleanup function\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [setupCanvas]);\n\n  // Initialize stars once dimensions are set\n  useEffect(() => {\n    if (dimensions.width > 0 && dimensions.height > 0) {\n      // Initialize stars\n      initializeStars();\n      // Mark as initialized\n      setIsInitialized(true);\n    }\n  }, [dimensions, initializeStars]);\n\n  // Start animation once initialized\n  useEffect(() => {\n    if (isInitialized) {\n      // Start animation loop\n      animationFrameRef.current = requestAnimationFrame(animate);\n    }\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [isInitialized, animate]);\n\n  // Update container height to match document height\n  useEffect(() => {\n    const updateDocumentHeight = () => {\n      const documentHeight = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);\n      if (containerRef.current) {\n        containerRef.current.style.height = `${documentHeight}px`;\n      }\n    };\n\n    // Set initial height\n    updateDocumentHeight();\n\n    // Update height when window is resized\n    window.addEventListener('resize', updateDocumentHeight);\n\n    // Create MutationObserver to detect DOM changes that affect height\n    const observer = new MutationObserver(updateDocumentHeight);\n    observer.observe(document.body, {\n      childList: true,\n      subtree: true,\n      attributes: true\n    });\n    return () => {\n      window.removeEventListener('resize', updateDocumentHeight);\n      observer.disconnect();\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      // Will be updated to full document height\n      overflow: 'hidden',\n      zIndex: -1,\n      pointerEvents: 'none'\n    },\n    \"aria-hidden\": \"true\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'fixed',\n        // Canvas stays fixed but renders content based on scroll\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 401,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 387,\n    columnNumber: 5\n  }, this);\n};\n_s(Background, \"vUdZ3sg0hH4Ck1mk5T6y6RH/qIY=\");\n_c = Background;\nexport default Background;\nvar _c;\n$RefreshReg$(_c, \"Background\");","map":{"version":3,"names":["React","useRef","useState","useEffect","useCallback","useMemo","jsxDEV","_jsxDEV","Background","_s","containerRef","canvasRef","starsRef","animationFrameRef","lastTimeRef","scrollPositionRef","dimensions","setDimensions","width","height","pixelRatio","isInitialized","setIsInitialized","CONFIG","starCount","areaMultiplier","starSizeMin","starSizeMax","starOpacityMin","starOpacityMax","baseMovementSpeed","pulseFrequency","pulseIntensity","parallaxIntensity","colors","stars","background","topColor","bottomColor","getColor","baseColor","opacity","safeOpacity","Math","max","min","replace","setupCanvas","current","canvas","window","innerWidth","innerHeight","devicePixelRatio","style","initializeStars","areaWidth","areaHeight","i","star","x","random","y","z","initialX","initialY","size","baseOpacity","pulsePhase","PI","pulseSpeed","rays","floor","rayLength","rayIntensity","colorIndex","length","color","push","updateAnimation","deltaTime","timestamp","timeFactor","parallaxOffset","sin","cos","parallaxY","pulseFactor","currentRayIntensity","renderScene","ctx","getContext","setTransform","clearRect","gradient","createLinearGradient","addColorStop","fillStyle","fillRect","globalCompositeOperation","screenY","glowRadius","createRadialGradient","beginPath","arc","fill","save","translate","rotate","Date","now","angle","moveTo","lineTo","rayGradient","strokeStyle","lineWidth","stroke","restore","error","animate","requestAnimationFrame","handleScroll","scrollY","addEventListener","passive","removeEventListener","handleResize","cancelAnimationFrame","updateDocumentHeight","documentHeight","document","body","scrollHeight","offsetHeight","documentElement","clientHeight","observer","MutationObserver","observe","childList","subtree","attributes","disconnect","ref","position","top","left","overflow","zIndex","pointerEvents","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/Background.jsx"],"sourcesContent":["import React, { useRef, useState, useEffect, useCallback, useMemo } from 'react';\n\n/**\n * Background Component\n * \n * Creates an immersive stellar background with stars that extend beyond\n * the viewport, allowing for a continuous star field experience when scrolling.\n */\nconst Background = () => {\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const starsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimeRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n  \n  // Component state\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0, pixelRatio: 1 });\n  const [isInitialized, setIsInitialized] = useState(false);\n  \n  // Configuration - using static values instead of useMemo to simplify\n  const CONFIG = {\n    // Star parameters\n    starCount: 350,          // Increased for better density\n    areaMultiplier: 3,       // Size multiplier for star field (3x viewport)\n    starSizeMin: 0.8,\n    starSizeMax: 2.5,\n    starOpacityMin: 0.2,     // Increased minimum opacity\n    starOpacityMax: 0.9,     // Increased maximum opacity\n    \n    // Motion and animation\n    baseMovementSpeed: 0.00015,\n    pulseFrequency: 0.00004,\n    pulseIntensity: 0.25,\n    \n    // Parallax effect\n    parallaxIntensity: 0.04,\n    \n    // Colors\n    colors: {\n      stars: [\n        'rgba(255, 243, 200, alpha)', // Warm yellow\n        'rgba(255, 231, 164, alpha)', // Golden\n        'rgba(255, 236, 179, alpha)', // Pale gold\n        'rgba(252, 249, 231, alpha)', // Off-white gold\n        'rgba(255, 225, 205, alpha)'  // Warm white (slight orange)\n      ],\n      background: {\n        topColor: 'rgb(8, 8, 12)',\n        bottomColor: 'rgb(15, 15, 20)'\n      }\n    }\n  };\n  \n  // Get color with opacity\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    return baseColor.replace(/alpha\\)$/, `${safeOpacity})`);\n  }, []);\n  \n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) return;\n    \n    const canvas = canvasRef.current;\n    \n    // Get viewport dimensions\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const pixelRatio = window.devicePixelRatio || 1;\n    \n    // Set canvas size accounting for pixel ratio\n    canvas.width = width * pixelRatio;\n    canvas.height = height * pixelRatio;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n    \n    // Update dimensions state\n    setDimensions({\n      width,\n      height,\n      pixelRatio\n    });\n  }, []);\n  \n  // Initialize stars\n  const initializeStars = useCallback(() => {\n    if (!dimensions.width || !dimensions.height) return;\n    \n    // Clear existing stars\n    starsRef.current = [];\n    \n    // Calculate the area for stars (larger than viewport)\n    const areaWidth = dimensions.width * CONFIG.areaMultiplier;\n    const areaHeight = dimensions.height * CONFIG.areaMultiplier;\n    \n    // Create stars\n    for (let i = 0; i < CONFIG.starCount; i++) {\n      const star = {};\n      \n      // Position - distribute across the larger area\n      // Center the area relative to initial viewport\n      star.x = (Math.random() * areaWidth) - (areaWidth - dimensions.width) / 2;\n      star.y = (Math.random() * areaHeight) - (areaHeight - dimensions.height) / 2;\n      star.z = Math.random() * 0.8 + 0.1; // Depth (0.1 to 0.9)\n      \n      // Initial position (for oscillation)\n      star.initialX = star.x;\n      star.initialY = star.y;\n      \n      // Visual properties\n      star.size = (Math.random() * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n      star.baseOpacity = Math.random() * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n      star.opacity = star.baseOpacity;\n      \n      // Animation properties\n      star.pulsePhase = Math.random() * Math.PI * 2;\n      star.pulseSpeed = Math.random() * 0.002 + 0.001;\n      \n      // Star shape properties - add variation for more realistic stars\n      star.rays = Math.random() > 0.7 ? Math.floor(Math.random() * 2) + 4 : 0;\n      star.rayLength = star.size * (Math.random() * 0.7 + 0.3);\n      star.rayIntensity = Math.random() * 0.4 + 0.3;\n      \n      // Color variation\n      const colorIndex = Math.floor(Math.random() * CONFIG.colors.stars.length);\n      star.color = CONFIG.colors.stars[colorIndex];\n      \n      starsRef.current.push(star);\n    }\n  }, [dimensions, CONFIG]);\n  \n  // Update animation state\n  const updateAnimation = useCallback((deltaTime, timestamp) => {\n    // Global time factor for animations\n    const timeFactor = timestamp * 0.001;\n    \n    // Parallax effect from scroll\n    const parallaxOffset = scrollPositionRef.current * CONFIG.parallaxIntensity;\n    \n    // Update stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n      \n      // Small positional oscillation around initial position\n      star.x = star.initialX + Math.sin(timeFactor * 0.2 + star.pulsePhase) * 0.5;\n      star.y = star.initialY + Math.cos(timeFactor * 0.3 + star.pulsePhase * 1.3) * 0.5;\n      \n      // Apply parallax based on depth (z)\n      star.parallaxY = parallaxOffset * (1 - star.z) * 0.5;\n      \n      // Pulsing effect - combine multiple sine waves for more natural effect\n      const pulseFactor = (\n        Math.sin(timeFactor * star.pulseSpeed + star.pulsePhase) * 0.5 + \n        Math.sin(timeFactor * star.pulseSpeed * 0.4 + star.pulsePhase * 1.3) * 0.3\n      ) * 0.15 + 0.85;\n      \n      star.opacity = star.baseOpacity * pulseFactor;\n      \n      // Vary ray intensity based on pulse\n      if (star.rays > 0) {\n        star.currentRayIntensity = star.rayIntensity * pulseFactor;\n      }\n    }\n  }, [CONFIG]);\n  \n  // Render stars\n  const renderScene = useCallback(() => {\n    if (!canvasRef.current) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    \n    if (!ctx) return;\n    \n    // Apply device pixel ratio scaling\n    ctx.setTransform(dimensions.pixelRatio, 0, 0, dimensions.pixelRatio, 0, 0);\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n    \n    // Draw background gradient\n    const gradient = ctx.createLinearGradient(0, 0, 0, dimensions.height);\n    gradient.addColorStop(0, CONFIG.colors.background.topColor);\n    gradient.addColorStop(1, CONFIG.colors.background.bottomColor);\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, dimensions.width, dimensions.height);\n    \n    // Enable global composition for better glow effect\n    ctx.globalCompositeOperation = 'lighter';\n    \n    // Draw stars\n    for (const star of starsRef.current) {\n      // Skip almost invisible stars\n      if (star.opacity < 0.02) continue;\n      \n      // Calculate screen position based on scroll\n      const screenY = star.y + (star.parallaxY || 0) - scrollPositionRef.current;\n      \n      // Only render stars that are visible in the viewport plus a small buffer\n      if (screenY >= -50 && screenY <= dimensions.height + 50 &&\n          star.x >= -50 && star.x <= dimensions.width + 50) {\n        \n        try {\n          // Draw star with glow\n          const glowRadius = Math.max(0.1, star.size * 2);\n          \n          // Draw outer glow for all stars\n          const gradient = ctx.createRadialGradient(star.x, screenY, 0, star.x, screenY, glowRadius);\n          gradient.addColorStop(0, getColor(star.color, star.opacity * 0.9));\n          gradient.addColorStop(0.5, getColor(star.color, star.opacity * 0.3));\n          gradient.addColorStop(1, getColor(star.color, 0));\n          \n          ctx.beginPath();\n          ctx.fillStyle = gradient;\n          ctx.arc(star.x, screenY, glowRadius, 0, Math.PI * 2);\n          ctx.fill();\n          \n          // Draw bright core\n          ctx.beginPath();\n          ctx.fillStyle = getColor(star.color, star.opacity);\n          ctx.arc(star.x, screenY, Math.max(0.1, star.size * 0.5), 0, Math.PI * 2);\n          ctx.fill();\n          \n          // Draw rays for some stars\n          if (star.rays > 0 && star.opacity > 0.3) {\n            ctx.save();\n            ctx.translate(star.x, screenY);\n            ctx.rotate(Math.sin(Date.now() * 0.0001) * 0.05); // Very slight rotation\n            \n            for (let i = 0; i < star.rays; i++) {\n              const angle = (i / star.rays) * Math.PI * 2;\n              const rayLength = Math.max(0.1, star.rayLength * (0.7 + Math.sin(Date.now() * 0.001 + i) * 0.3));\n              \n              ctx.beginPath();\n              ctx.moveTo(0, 0);\n              ctx.lineTo(Math.cos(angle) * rayLength, Math.sin(angle) * rayLength);\n              \n              // Create gradient for ray\n              const rayGradient = ctx.createLinearGradient(\n                0, 0,\n                Math.cos(angle) * rayLength, Math.sin(angle) * rayLength\n              );\n              rayGradient.addColorStop(0, getColor(star.color, star.opacity * 0.9));\n              rayGradient.addColorStop(1, getColor(star.color, 0));\n              \n              ctx.strokeStyle = rayGradient;\n              ctx.lineWidth = Math.max(0.1, star.size * 0.3);\n              ctx.stroke();\n            }\n            \n            ctx.restore();\n          }\n        } catch (error) {\n          // Silently handle any canvas drawing errors\n        }\n      }\n    }\n    \n    // Reset global composition\n    ctx.globalCompositeOperation = 'source-over';\n  }, [dimensions, CONFIG, getColor]);\n  \n  // Main animation loop\n  const animate = useCallback((timestamp) => {\n    if (!isInitialized) {\n      animationFrameRef.current = requestAnimationFrame(animate);\n      return;\n    }\n    \n    // Calculate delta time with cap to prevent large jumps\n    const deltaTime = lastTimeRef.current ? Math.min(timestamp - lastTimeRef.current, 33) : 16;\n    lastTimeRef.current = timestamp;\n    \n    // Update animation state\n    updateAnimation(deltaTime, timestamp);\n    \n    // Render scene\n    renderScene();\n    \n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(animate);\n  }, [isInitialized, updateAnimation, renderScene]);\n  \n  // Track scroll position for parallax\n  useEffect(() => {\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    \n    window.addEventListener('scroll', handleScroll, { passive: true });\n    \n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, []);\n  \n  // Handle resize events\n  useEffect(() => {\n    const handleResize = () => {\n      setupCanvas();\n      initializeStars();\n    };\n    \n    window.addEventListener('resize', handleResize);\n    \n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, [setupCanvas, initializeStars]);\n  \n  // Initialize component\n  useEffect(() => {\n    // Setup canvas\n    setupCanvas();\n    \n    // Cleanup function\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [setupCanvas]);\n  \n  // Initialize stars once dimensions are set\n  useEffect(() => {\n    if (dimensions.width > 0 && dimensions.height > 0) {\n      // Initialize stars\n      initializeStars();\n      // Mark as initialized\n      setIsInitialized(true);\n    }\n  }, [dimensions, initializeStars]);\n  \n  // Start animation once initialized\n  useEffect(() => {\n    if (isInitialized) {\n      // Start animation loop\n      animationFrameRef.current = requestAnimationFrame(animate);\n    }\n    \n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [isInitialized, animate]);\n  \n  // Update container height to match document height\n  useEffect(() => {\n    const updateDocumentHeight = () => {\n      const documentHeight = Math.max(\n        document.body.scrollHeight,\n        document.body.offsetHeight,\n        document.documentElement.clientHeight,\n        document.documentElement.scrollHeight,\n        document.documentElement.offsetHeight\n      );\n      \n      if (containerRef.current) {\n        containerRef.current.style.height = `${documentHeight}px`;\n      }\n    };\n    \n    // Set initial height\n    updateDocumentHeight();\n    \n    // Update height when window is resized\n    window.addEventListener('resize', updateDocumentHeight);\n    \n    // Create MutationObserver to detect DOM changes that affect height\n    const observer = new MutationObserver(updateDocumentHeight);\n    observer.observe(document.body, { \n      childList: true, \n      subtree: true,\n      attributes: true\n    });\n    \n    return () => {\n      window.removeEventListener('resize', updateDocumentHeight);\n      observer.disconnect();\n    };\n  }, []);\n  \n  return (\n    <div\n      ref={containerRef}\n      style={{\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',  // Will be updated to full document height\n        overflow: 'hidden',\n        zIndex: -1,\n        pointerEvents: 'none'\n      }}\n      aria-hidden=\"true\"\n    >\n      <canvas\n        ref={canvasRef}\n        style={{\n          position: 'fixed',  // Canvas stays fixed but renders content based on scroll\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%'\n        }}\n      />\n    </div>\n  );\n};\n\nexport default Background;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}