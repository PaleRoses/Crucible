{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/Background.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect, useCallback, useMemo } from 'react';\n\n/**\n * Background Component\n * \n * Creates an immersive stellar background that spans the entire document\n * with realistic star rendering and subtle parallax effects.\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Background = () => {\n  _s();\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const starsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimeRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n  const documentHeightRef = useRef(0);\n\n  // Component state\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0,\n    pixelRatio: 1\n  });\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n\n  // Configuration\n  const CONFIG = useMemo(() => ({\n    // Star parameters\n    starCount: 300,\n    // Total stars to generate\n    starDensity: 0.00015,\n    // Stars per pixel area (for density calculation)\n    starSizeMin: 0.8,\n    starSizeMax: 2.5,\n    starOpacityMin: 0.15,\n    starOpacityMax: 0.85,\n    // Motion and animation\n    baseMovementSpeed: 0.00015,\n    // Very subtle movement\n    pulseFrequency: 0.00004,\n    // Slower pulsing\n    pulseIntensity: 0.25,\n    // Subtle pulse\n\n    // Parallax effect\n    parallaxIntensity: 0.04,\n    // Extremely subtle parallax\n\n    // Performance parameters\n    maxFPS: 30,\n    useGlow: true\n  }), []);\n\n  // Warm, golden color palette\n  const COLORS = useMemo(() => ({\n    // Main star colors (warm golden tones)\n    stars: ['rgba(255, 243, 200, alpha)',\n    // Warm yellow\n    'rgba(255, 231, 164, alpha)',\n    // Golden\n    'rgba(255, 236, 179, alpha)',\n    // Pale gold\n    'rgba(252, 249, 231, alpha)',\n    // Off-white gold\n    'rgba(255, 225, 205, alpha)' // Warm white (slight orange)\n    ],\n    // Background gradient colors\n    background: {\n      topColor: 'rgb(8, 8, 12)',\n      bottomColor: 'rgb(15, 15, 20)'\n    }\n  }), []);\n\n  // Get color with opacity\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    return baseColor.replace(/alpha\\)$/, `${safeOpacity})`);\n  }, []);\n\n  // Get the current document height\n  const updateDocumentHeight = useCallback(() => {\n    const documentHeight = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);\n    documentHeightRef.current = documentHeight;\n\n    // Update container height to match document\n    if (containerRef.current) {\n      containerRef.current.style.height = `${documentHeight}px`;\n    }\n    return documentHeight;\n  }, []);\n\n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) return false;\n    const canvas = canvasRef.current;\n\n    // Get viewport dimensions\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const pixelRatio = window.devicePixelRatio || 1;\n\n    // Set canvas size accounting for pixel ratio\n    canvas.width = width * pixelRatio;\n    canvas.height = height * pixelRatio;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n\n    // Update dimensions state\n    setDimensions({\n      width,\n      height,\n      pixelRatio\n    });\n    return true;\n  }, []);\n\n  // Generate stars across the entire document\n  const generateStars = useCallback(() => {\n    // Clear existing stars\n    starsRef.current = [];\n\n    // Get document dimensions\n    const width = window.innerWidth;\n    const documentHeight = updateDocumentHeight();\n\n    // Calculate star count based on document area and density\n    // with a minimum number of stars\n    const documentArea = width * documentHeight;\n    const starCountByArea = Math.floor(documentArea * CONFIG.starDensity);\n    const totalStars = Math.max(CONFIG.starCount, starCountByArea);\n    console.log(`Generating ${totalStars} stars for document height ${documentHeight}px`);\n\n    // Create stars distributed across the entire document\n    for (let i = 0; i < totalStars; i++) {\n      const star = {};\n\n      // Position randomly across entire document\n      star.x = Math.random() * width;\n      star.y = Math.random() * documentHeight;\n      star.z = Math.random() * 0.8 + 0.1; // Depth (0.1 to 0.9)\n\n      // Visual properties\n      star.size = (Math.random() * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n      star.baseOpacity = Math.random() * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n      star.opacity = star.baseOpacity;\n\n      // Animation properties\n      star.pulsePhase = Math.random() * Math.PI * 2;\n      star.pulseSpeed = Math.random() * 0.002 + 0.001;\n\n      // Motion properties\n      star.initialX = star.x;\n      star.initialY = star.y;\n\n      // Star shape properties - add variation for more realistic stars\n      star.rays = Math.random() > 0.7 ? Math.floor(Math.random() * 2) + 4 : 0;\n      star.rayLength = star.size * (Math.random() * 0.7 + 0.3);\n      star.rayIntensity = Math.random() * 0.4 + 0.3;\n\n      // Color variation\n      const colorIndex = Math.floor(Math.random() * COLORS.stars.length);\n      star.color = COLORS.stars[colorIndex];\n      starsRef.current.push(star);\n    }\n  }, [CONFIG, COLORS.stars, updateDocumentHeight]);\n\n  // Update animation state\n  const updateAnimation = useCallback((deltaTime, timestamp) => {\n    // Global time factor for animations\n    const timeFactor = timestamp * 0.001;\n\n    // Parallax effect from scroll - extremely subtle\n    const parallaxOffset = scrollPositionRef.current * CONFIG.parallaxIntensity;\n\n    // Motion dampening for reduced motion preference\n    const motionFactor = prefersReducedMotion ? 0.1 : 1;\n\n    // Current visible area\n    const visibleTop = scrollPositionRef.current;\n    const visibleBottom = visibleTop + window.innerHeight;\n\n    // Update stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n\n      // Skip stars far outside visible area for performance\n      if (star.y < visibleTop - 200 || star.y > visibleBottom + 200) {\n        continue;\n      }\n\n      // Small positional oscillation around initial position\n      star.x = star.initialX + Math.sin(timeFactor * 0.2 + star.pulsePhase) * 0.5 * motionFactor;\n      star.y = star.initialY + Math.cos(timeFactor * 0.3 + star.pulsePhase * 1.3) * 0.5 * motionFactor;\n\n      // Apply parallax offset based on depth (z) - extremely subtle\n      const starParallax = parallaxOffset * (1 - star.z) * 0.5;\n      star.parallaxY = starParallax;\n\n      // Subtle pulsing effect - more natural by combining multiple sine waves\n      const pulseFactor = (Math.sin(timeFactor * star.pulseSpeed + star.pulsePhase) * 0.5 + Math.sin(timeFactor * star.pulseSpeed * 0.4 + star.pulsePhase * 1.3) * 0.3) * 0.15 + 0.85;\n      star.opacity = star.baseOpacity * pulseFactor;\n\n      // Vary ray intensity based on pulse\n      if (star.rays > 0) {\n        star.currentRayIntensity = star.rayIntensity * pulseFactor;\n      }\n    }\n  }, [CONFIG.parallaxIntensity, prefersReducedMotion]);\n\n  // Render a realistic star with optional rays\n  const drawStar = useCallback((ctx, star, y) => {\n    // Ensure we have positive values to prevent \"Negative radius\" errors\n    const glowRadius = Math.max(0.1, star.size * 2);\n    try {\n      // Draw outer glow for all stars\n      const gradient = ctx.createRadialGradient(star.x, y, 0, star.x, y, glowRadius);\n      gradient.addColorStop(0, getColor(star.color, star.opacity * 0.9));\n      gradient.addColorStop(0.5, getColor(star.color, star.opacity * 0.3));\n      gradient.addColorStop(1, getColor(star.color, 0));\n      ctx.beginPath();\n      ctx.fillStyle = gradient;\n      ctx.arc(star.x, y, glowRadius, 0, Math.PI * 2);\n      ctx.fill();\n\n      // Draw bright core\n      ctx.beginPath();\n      ctx.fillStyle = getColor(star.color, star.opacity);\n      ctx.arc(star.x, y, Math.max(0.1, star.size * 0.5), 0, Math.PI * 2);\n      ctx.fill();\n\n      // Draw rays for some stars\n      if (star.rays > 0 && star.opacity > 0.3) {\n        ctx.save();\n        ctx.translate(star.x, y);\n        ctx.rotate(Math.sin(Date.now() * 0.0001) * 0.05); // Very slight rotation\n\n        for (let i = 0; i < star.rays; i++) {\n          const angle = i / star.rays * Math.PI * 2;\n          const rayLength = Math.max(0.1, star.rayLength * (0.7 + Math.sin(Date.now() * 0.001 + i) * 0.3));\n          ctx.beginPath();\n          ctx.moveTo(0, 0);\n          ctx.lineTo(Math.cos(angle) * rayLength, Math.sin(angle) * rayLength);\n\n          // Create gradient for ray\n          const rayGradient = ctx.createLinearGradient(0, 0, Math.cos(angle) * rayLength, Math.sin(angle) * rayLength);\n          rayGradient.addColorStop(0, getColor(star.color, star.opacity * 0.9));\n          rayGradient.addColorStop(1, getColor(star.color, 0));\n          ctx.strokeStyle = rayGradient;\n          ctx.lineWidth = Math.max(0.1, star.size * 0.3);\n          ctx.stroke();\n        }\n        ctx.restore();\n      }\n    } catch (error) {\n      // Silently handle any canvas drawing errors\n      console.warn(\"Star rendering error:\", error);\n    }\n  }, [getColor]);\n\n  // Render the scene\n  const renderScene = useCallback(() => {\n    if (!canvasRef.current) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d', {\n      alpha: true,\n      willReadFrequently: false\n    });\n    if (!ctx) return;\n\n    // Apply device pixel ratio scaling\n    ctx.setTransform(dimensions.pixelRatio, 0, 0, dimensions.pixelRatio, 0, 0);\n\n    // Clear canvas\n    ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n\n    // Draw background gradient\n    const gradient = ctx.createLinearGradient(0, 0, 0, dimensions.height);\n    gradient.addColorStop(0, COLORS.background.topColor);\n    gradient.addColorStop(1, COLORS.background.bottomColor);\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, dimensions.width, dimensions.height);\n\n    // Enable global composition for better glow effect\n    ctx.globalCompositeOperation = 'lighter';\n\n    // Current visible area\n    const visibleTop = scrollPositionRef.current;\n    const visibleBottom = visibleTop + window.innerHeight;\n    const buffer = 100; // Buffer zone above and below viewport\n\n    // Draw stars that are in the visible area\n    for (const star of starsRef.current) {\n      // Skip almost invisible stars or stars far outside viewport\n      if (star.opacity < 0.02) continue;\n      if (star.y < visibleTop - buffer || star.y > visibleBottom + buffer) continue;\n\n      // Apply parallax to y position\n      const adjustedY = star.y - visibleTop + (star.parallaxY || 0);\n\n      // Draw star\n      drawStar(ctx, star, adjustedY);\n    }\n\n    // Reset global composition\n    ctx.globalCompositeOperation = 'source-over';\n  }, [dimensions, COLORS, drawStar]);\n\n  // Main animation loop\n  const animate = useCallback(timestamp => {\n    if (!isInitialized) {\n      animationFrameRef.current = requestAnimationFrame(animate);\n      return;\n    }\n\n    // Calculate delta time with cap to prevent large jumps\n    const deltaTime = lastTimeRef.current ? Math.min(timestamp - lastTimeRef.current, 33) : 16;\n    lastTimeRef.current = timestamp;\n\n    // Update animation state\n    updateAnimation(deltaTime, timestamp);\n\n    // Render scene\n    renderScene();\n\n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(animate);\n  }, [isInitialized, updateAnimation, renderScene]);\n\n  // Detect reduced motion preference\n  useEffect(() => {\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    const handleReducedMotionChange = e => {\n      setPrefersReducedMotion(e.matches);\n    };\n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n    };\n  }, []);\n\n  // Initialize component\n  useEffect(() => {\n    // Setup canvas\n    setupCanvas();\n\n    // Track scroll position\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n\n    // Handle window resize\n    const handleResize = () => {\n      setupCanvas();\n      updateDocumentHeight();\n      generateStars(); // Regenerate stars when window resizes\n    };\n    window.addEventListener('scroll', handleScroll, {\n      passive: true\n    });\n    window.addEventListener('resize', handleResize);\n\n    // Initial call to generate stars\n    generateStars();\n\n    // Set as initialized\n    setIsInitialized(true);\n\n    // Start animation\n    animationFrameRef.current = requestAnimationFrame(animate);\n\n    // Cleanup\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n      window.removeEventListener('resize', handleResize);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [setupCanvas, updateDocumentHeight, generateStars, animate]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      // Will be updated to full document height\n      overflow: 'hidden',\n      zIndex: -1,\n      pointerEvents: 'none'\n    },\n    \"aria-hidden\": \"true\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'fixed',\n        // Canvas stays fixed but content moves\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 416,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 402,\n    columnNumber: 5\n  }, this);\n};\n_s(Background, \"eoySIYcmf89iMvuK09NWxv7pfj8=\");\n_c = Background;\nexport default Background;\nvar _c;\n$RefreshReg$(_c, \"Background\");","map":{"version":3,"names":["React","useRef","useState","useEffect","useCallback","useMemo","jsxDEV","_jsxDEV","Background","_s","containerRef","canvasRef","starsRef","animationFrameRef","lastTimeRef","scrollPositionRef","documentHeightRef","dimensions","setDimensions","width","height","pixelRatio","isInitialized","setIsInitialized","prefersReducedMotion","setPrefersReducedMotion","CONFIG","starCount","starDensity","starSizeMin","starSizeMax","starOpacityMin","starOpacityMax","baseMovementSpeed","pulseFrequency","pulseIntensity","parallaxIntensity","maxFPS","useGlow","COLORS","stars","background","topColor","bottomColor","getColor","baseColor","opacity","safeOpacity","Math","max","min","replace","updateDocumentHeight","documentHeight","document","body","scrollHeight","offsetHeight","documentElement","clientHeight","current","style","setupCanvas","canvas","window","innerWidth","innerHeight","devicePixelRatio","generateStars","documentArea","starCountByArea","floor","totalStars","console","log","i","star","x","random","y","z","size","baseOpacity","pulsePhase","PI","pulseSpeed","initialX","initialY","rays","rayLength","rayIntensity","colorIndex","length","color","push","updateAnimation","deltaTime","timestamp","timeFactor","parallaxOffset","motionFactor","visibleTop","visibleBottom","sin","cos","starParallax","parallaxY","pulseFactor","currentRayIntensity","drawStar","ctx","glowRadius","gradient","createRadialGradient","addColorStop","beginPath","fillStyle","arc","fill","save","translate","rotate","Date","now","angle","moveTo","lineTo","rayGradient","createLinearGradient","strokeStyle","lineWidth","stroke","restore","error","warn","renderScene","getContext","alpha","willReadFrequently","setTransform","clearRect","fillRect","globalCompositeOperation","buffer","adjustedY","animate","requestAnimationFrame","reducedMotionQuery","matchMedia","matches","handleReducedMotionChange","e","addEventListener","removeEventListener","handleScroll","scrollY","handleResize","passive","cancelAnimationFrame","ref","position","top","left","overflow","zIndex","pointerEvents","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/Background.jsx"],"sourcesContent":["import React, { useRef, useState, useEffect, useCallback, useMemo } from 'react';\n\n/**\n * Background Component\n * \n * Creates an immersive stellar background that spans the entire document\n * with realistic star rendering and subtle parallax effects.\n */\nconst Background = () => {\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const starsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimeRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n  const documentHeightRef = useRef(0);\n  \n  // Component state\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0, pixelRatio: 1 });\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  \n  // Configuration\n  const CONFIG = useMemo(() => ({\n    // Star parameters\n    starCount: 300,         // Total stars to generate\n    starDensity: 0.00015,   // Stars per pixel area (for density calculation)\n    starSizeMin: 0.8,\n    starSizeMax: 2.5,\n    starOpacityMin: 0.15,\n    starOpacityMax: 0.85,\n    \n    // Motion and animation\n    baseMovementSpeed: 0.00015,  // Very subtle movement\n    pulseFrequency: 0.00004,     // Slower pulsing\n    pulseIntensity: 0.25,        // Subtle pulse\n    \n    // Parallax effect\n    parallaxIntensity: 0.04,     // Extremely subtle parallax\n    \n    // Performance parameters\n    maxFPS: 30,\n    useGlow: true\n  }), []);\n  \n  // Warm, golden color palette\n  const COLORS = useMemo(() => ({\n    // Main star colors (warm golden tones)\n    stars: [\n      'rgba(255, 243, 200, alpha)', // Warm yellow\n      'rgba(255, 231, 164, alpha)', // Golden\n      'rgba(255, 236, 179, alpha)', // Pale gold\n      'rgba(252, 249, 231, alpha)', // Off-white gold\n      'rgba(255, 225, 205, alpha)'  // Warm white (slight orange)\n    ],\n    \n    // Background gradient colors\n    background: {\n      topColor: 'rgb(8, 8, 12)',\n      bottomColor: 'rgb(15, 15, 20)'\n    }\n  }), []);\n  \n  // Get color with opacity\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    return baseColor.replace(/alpha\\)$/, `${safeOpacity})`);\n  }, []);\n  \n  // Get the current document height\n  const updateDocumentHeight = useCallback(() => {\n    const documentHeight = Math.max(\n      document.body.scrollHeight,\n      document.body.offsetHeight,\n      document.documentElement.clientHeight,\n      document.documentElement.scrollHeight,\n      document.documentElement.offsetHeight\n    );\n    documentHeightRef.current = documentHeight;\n    \n    // Update container height to match document\n    if (containerRef.current) {\n      containerRef.current.style.height = `${documentHeight}px`;\n    }\n    \n    return documentHeight;\n  }, []);\n  \n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) return false;\n    \n    const canvas = canvasRef.current;\n    \n    // Get viewport dimensions\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const pixelRatio = window.devicePixelRatio || 1;\n    \n    // Set canvas size accounting for pixel ratio\n    canvas.width = width * pixelRatio;\n    canvas.height = height * pixelRatio;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n    \n    // Update dimensions state\n    setDimensions({\n      width,\n      height,\n      pixelRatio\n    });\n    \n    return true;\n  }, []);\n  \n  // Generate stars across the entire document\n  const generateStars = useCallback(() => {\n    // Clear existing stars\n    starsRef.current = [];\n    \n    // Get document dimensions\n    const width = window.innerWidth;\n    const documentHeight = updateDocumentHeight();\n    \n    // Calculate star count based on document area and density\n    // with a minimum number of stars\n    const documentArea = width * documentHeight;\n    const starCountByArea = Math.floor(documentArea * CONFIG.starDensity);\n    const totalStars = Math.max(CONFIG.starCount, starCountByArea);\n    \n    console.log(`Generating ${totalStars} stars for document height ${documentHeight}px`);\n    \n    // Create stars distributed across the entire document\n    for (let i = 0; i < totalStars; i++) {\n      const star = {};\n      \n      // Position randomly across entire document\n      star.x = Math.random() * width;\n      star.y = Math.random() * documentHeight;\n      star.z = Math.random() * 0.8 + 0.1; // Depth (0.1 to 0.9)\n      \n      // Visual properties\n      star.size = (Math.random() * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n      star.baseOpacity = Math.random() * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n      star.opacity = star.baseOpacity;\n      \n      // Animation properties\n      star.pulsePhase = Math.random() * Math.PI * 2;\n      star.pulseSpeed = Math.random() * 0.002 + 0.001;\n      \n      // Motion properties\n      star.initialX = star.x;\n      star.initialY = star.y;\n      \n      // Star shape properties - add variation for more realistic stars\n      star.rays = Math.random() > 0.7 ? Math.floor(Math.random() * 2) + 4 : 0;\n      star.rayLength = star.size * (Math.random() * 0.7 + 0.3);\n      star.rayIntensity = Math.random() * 0.4 + 0.3;\n      \n      // Color variation\n      const colorIndex = Math.floor(Math.random() * COLORS.stars.length);\n      star.color = COLORS.stars[colorIndex];\n      \n      starsRef.current.push(star);\n    }\n  }, [CONFIG, COLORS.stars, updateDocumentHeight]);\n  \n  // Update animation state\n  const updateAnimation = useCallback((deltaTime, timestamp) => {\n    // Global time factor for animations\n    const timeFactor = timestamp * 0.001;\n    \n    // Parallax effect from scroll - extremely subtle\n    const parallaxOffset = scrollPositionRef.current * CONFIG.parallaxIntensity;\n    \n    // Motion dampening for reduced motion preference\n    const motionFactor = prefersReducedMotion ? 0.1 : 1;\n    \n    // Current visible area\n    const visibleTop = scrollPositionRef.current;\n    const visibleBottom = visibleTop + window.innerHeight;\n    \n    // Update stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n      \n      // Skip stars far outside visible area for performance\n      if (star.y < visibleTop - 200 || star.y > visibleBottom + 200) {\n        continue;\n      }\n      \n      // Small positional oscillation around initial position\n      star.x = star.initialX + Math.sin(timeFactor * 0.2 + star.pulsePhase) * 0.5 * motionFactor;\n      star.y = star.initialY + Math.cos(timeFactor * 0.3 + star.pulsePhase * 1.3) * 0.5 * motionFactor;\n      \n      // Apply parallax offset based on depth (z) - extremely subtle\n      const starParallax = parallaxOffset * (1 - star.z) * 0.5;\n      star.parallaxY = starParallax;\n      \n      // Subtle pulsing effect - more natural by combining multiple sine waves\n      const pulseFactor = (\n        Math.sin(timeFactor * star.pulseSpeed + star.pulsePhase) * 0.5 + \n        Math.sin(timeFactor * star.pulseSpeed * 0.4 + star.pulsePhase * 1.3) * 0.3\n      ) * 0.15 + 0.85;\n      \n      star.opacity = star.baseOpacity * pulseFactor;\n      \n      // Vary ray intensity based on pulse\n      if (star.rays > 0) {\n        star.currentRayIntensity = star.rayIntensity * pulseFactor;\n      }\n    }\n  }, [CONFIG.parallaxIntensity, prefersReducedMotion]);\n  \n  // Render a realistic star with optional rays\n  const drawStar = useCallback((ctx, star, y) => {\n    // Ensure we have positive values to prevent \"Negative radius\" errors\n    const glowRadius = Math.max(0.1, star.size * 2);\n    \n    try {\n      // Draw outer glow for all stars\n      const gradient = ctx.createRadialGradient(star.x, y, 0, star.x, y, glowRadius);\n      gradient.addColorStop(0, getColor(star.color, star.opacity * 0.9));\n      gradient.addColorStop(0.5, getColor(star.color, star.opacity * 0.3));\n      gradient.addColorStop(1, getColor(star.color, 0));\n      \n      ctx.beginPath();\n      ctx.fillStyle = gradient;\n      ctx.arc(star.x, y, glowRadius, 0, Math.PI * 2);\n      ctx.fill();\n      \n      // Draw bright core\n      ctx.beginPath();\n      ctx.fillStyle = getColor(star.color, star.opacity);\n      ctx.arc(star.x, y, Math.max(0.1, star.size * 0.5), 0, Math.PI * 2);\n      ctx.fill();\n      \n      // Draw rays for some stars\n      if (star.rays > 0 && star.opacity > 0.3) {\n        ctx.save();\n        ctx.translate(star.x, y);\n        ctx.rotate(Math.sin(Date.now() * 0.0001) * 0.05); // Very slight rotation\n        \n        for (let i = 0; i < star.rays; i++) {\n          const angle = (i / star.rays) * Math.PI * 2;\n          const rayLength = Math.max(0.1, star.rayLength * (0.7 + Math.sin(Date.now() * 0.001 + i) * 0.3));\n          \n          ctx.beginPath();\n          ctx.moveTo(0, 0);\n          ctx.lineTo(Math.cos(angle) * rayLength, Math.sin(angle) * rayLength);\n          \n          // Create gradient for ray\n          const rayGradient = ctx.createLinearGradient(\n            0, 0,\n            Math.cos(angle) * rayLength, Math.sin(angle) * rayLength\n          );\n          rayGradient.addColorStop(0, getColor(star.color, star.opacity * 0.9));\n          rayGradient.addColorStop(1, getColor(star.color, 0));\n          \n          ctx.strokeStyle = rayGradient;\n          ctx.lineWidth = Math.max(0.1, star.size * 0.3);\n          ctx.stroke();\n        }\n        \n        ctx.restore();\n      }\n    } catch (error) {\n      // Silently handle any canvas drawing errors\n      console.warn(\"Star rendering error:\", error);\n    }\n  }, [getColor]);\n  \n  // Render the scene\n  const renderScene = useCallback(() => {\n    if (!canvasRef.current) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d', {\n      alpha: true,\n      willReadFrequently: false\n    });\n    \n    if (!ctx) return;\n    \n    // Apply device pixel ratio scaling\n    ctx.setTransform(dimensions.pixelRatio, 0, 0, dimensions.pixelRatio, 0, 0);\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n    \n    // Draw background gradient\n    const gradient = ctx.createLinearGradient(0, 0, 0, dimensions.height);\n    gradient.addColorStop(0, COLORS.background.topColor);\n    gradient.addColorStop(1, COLORS.background.bottomColor);\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, dimensions.width, dimensions.height);\n    \n    // Enable global composition for better glow effect\n    ctx.globalCompositeOperation = 'lighter';\n    \n    // Current visible area\n    const visibleTop = scrollPositionRef.current;\n    const visibleBottom = visibleTop + window.innerHeight;\n    const buffer = 100; // Buffer zone above and below viewport\n    \n    // Draw stars that are in the visible area\n    for (const star of starsRef.current) {\n      // Skip almost invisible stars or stars far outside viewport\n      if (star.opacity < 0.02) continue;\n      if (star.y < visibleTop - buffer || star.y > visibleBottom + buffer) continue;\n      \n      // Apply parallax to y position\n      const adjustedY = star.y - visibleTop + (star.parallaxY || 0);\n      \n      // Draw star\n      drawStar(ctx, star, adjustedY);\n    }\n    \n    // Reset global composition\n    ctx.globalCompositeOperation = 'source-over';\n  }, [dimensions, COLORS, drawStar]);\n  \n  // Main animation loop\n  const animate = useCallback((timestamp) => {\n    if (!isInitialized) {\n      animationFrameRef.current = requestAnimationFrame(animate);\n      return;\n    }\n    \n    // Calculate delta time with cap to prevent large jumps\n    const deltaTime = lastTimeRef.current ? Math.min(timestamp - lastTimeRef.current, 33) : 16;\n    lastTimeRef.current = timestamp;\n    \n    // Update animation state\n    updateAnimation(deltaTime, timestamp);\n    \n    // Render scene\n    renderScene();\n    \n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(animate);\n  }, [isInitialized, updateAnimation, renderScene]);\n  \n  // Detect reduced motion preference\n  useEffect(() => {\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    \n    const handleReducedMotionChange = (e) => {\n      setPrefersReducedMotion(e.matches);\n    };\n    \n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n    \n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n    };\n  }, []);\n  \n  // Initialize component\n  useEffect(() => {\n    // Setup canvas\n    setupCanvas();\n    \n    // Track scroll position\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    \n    // Handle window resize\n    const handleResize = () => {\n      setupCanvas();\n      updateDocumentHeight();\n      generateStars(); // Regenerate stars when window resizes\n    };\n    \n    window.addEventListener('scroll', handleScroll, { passive: true });\n    window.addEventListener('resize', handleResize);\n    \n    // Initial call to generate stars\n    generateStars();\n    \n    // Set as initialized\n    setIsInitialized(true);\n    \n    // Start animation\n    animationFrameRef.current = requestAnimationFrame(animate);\n    \n    // Cleanup\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n      window.removeEventListener('resize', handleResize);\n      \n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [setupCanvas, updateDocumentHeight, generateStars, animate]);\n  \n  return (\n    <div\n      ref={containerRef}\n      style={{\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%', // Will be updated to full document height\n        overflow: 'hidden',\n        zIndex: -1,\n        pointerEvents: 'none'\n      }}\n      aria-hidden=\"true\"\n    >\n      <canvas\n        ref={canvasRef}\n        style={{\n          position: 'fixed', // Canvas stays fixed but content moves\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%'\n        }}\n      />\n    </div>\n  );\n};\n\nexport default Background;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}