{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/layout/Background.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useCallback, useMemo } from 'react';\n\n/**\n * Optimized Background Component with Parallax Effects\n * \n * Creates an immersive stellar background with realistic star particles\n * and scroll-based parallax effects while maintaining performance through canvas.\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Background = () => {\n  _s();\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const starsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimeRef = useRef(0);\n  const scrollYRef = useRef(0);\n  const lastScrollYRef = useRef(0);\n  const scrollVelocityRef = useRef(0);\n\n  // Store dimensions in a ref to avoid re-renders when they change\n  const dimensionsRef = useRef({\n    width: 0,\n    height: 0,\n    pixelRatio: 1\n  });\n\n  // Configuration - wrapped in useMemo to prevent recreation on each render\n  const CONFIG = useMemo(() => ({\n    starCount: 100,\n    starSizeMin: 0.8,\n    starSizeMax: 2.5,\n    starOpacityMin: 0.2,\n    starOpacityMax: 0.9,\n    // Motion parameters\n    baseMovementSpeed: 0.00008,\n    pulseFrequency: 0.00003,\n    // Parallax effect configuration\n    parallaxEnabled: true,\n    parallaxStrength: 0.15,\n    parallaxMaxDisplacement: 25,\n    parallaxLayerCount: 5,\n    // Spring physics for smooth animations\n    springStiffness: 0.08,\n    springDamping: 0.65,\n    // Performance parameters\n    maxFPS: 60,\n    // Session persistence\n    sessionKey: 'star_background_config'\n  }), []);\n\n  // Warm, golden color palette\n  const COLORS = useMemo(() => ({\n    stars: ['rgba(255, 243, 200, alpha)',\n    // Warm yellow\n    'rgba(255, 231, 164, alpha)',\n    // Golden\n    'rgba(252, 249, 231, alpha)' // Off-white gold\n    ],\n    background: {\n      topColor: 'rgb(8, 8, 12)',\n      bottomColor: 'rgb(15, 15, 20)'\n    }\n  }), []);\n\n  // Pre-generated color values to avoid string replacements\n  const colorCache = useMemo(() => {\n    const cache = {};\n    COLORS.stars.forEach(baseColor => {\n      cache[baseColor] = {};\n      for (let opacity = 0; opacity <= 10; opacity++) {\n        const value = opacity / 10;\n        cache[baseColor][value] = baseColor.replace('alpha', value);\n      }\n    });\n    return cache;\n  }, [COLORS.stars]);\n\n  // Get color with opacity from cache\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    const roundedOpacity = Math.round(safeOpacity * 10) / 10;\n    return colorCache[baseColor][roundedOpacity] || baseColor.replace('alpha', safeOpacity);\n  }, [colorCache]);\n\n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) return false;\n    const canvas = canvasRef.current;\n\n    // Get viewport dimensions\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const pixelRatio = window.devicePixelRatio || 1;\n\n    // Set canvas size accounting for pixel ratio\n    canvas.width = width * pixelRatio;\n    canvas.height = height * pixelRatio;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n\n    // Ensure canvas is visible with a background color\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return false;\n    ctx.fillStyle = COLORS.background.bottomColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // Update dimensions ref\n    dimensionsRef.current = {\n      width,\n      height,\n      pixelRatio\n    };\n    return true;\n  }, [COLORS.background.bottomColor]);\n\n  // Generate new star data\n  const generateStars = useCallback(() => {\n    const {\n      width,\n      height\n    } = dimensionsRef.current;\n    if (!width || !height) return [];\n    const stars = [];\n    for (let i = 0; i < CONFIG.starCount; i++) {\n      const star = {\n        // Position\n        baseX: Math.random() * width,\n        baseY: Math.random() * height,\n        z: Math.random() * 0.8 + 0.1,\n        // Depth (0.1 to 0.9)\n\n        // Visual properties\n        size: Math.random() * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin,\n        baseOpacity: Math.random() * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin,\n        // Animation properties\n        pulsePhase: Math.random() * Math.PI * 2,\n        pulseSpeed: Math.random() * 0.002 + 0.001,\n        // Color variation\n        color: COLORS.stars[Math.floor(Math.random() * COLORS.stars.length)],\n        // Parallax properties\n        parallaxLayer: Math.floor(Math.random() * CONFIG.parallaxLayerCount),\n        springOffsetX: 0,\n        springOffsetY: 0,\n        targetOffsetX: 0,\n        targetOffsetY: 0,\n        velocityX: 0,\n        velocityY: 0,\n        accelerationX: 0,\n        accelerationY: 0,\n        // Direction factors for varied movement\n        directionX: Math.random() > 0.5 ? 1 : -1,\n        directionY: Math.random() > 0.5 ? 1 : -1\n      };\n\n      // Calculate derived properties\n      star.x = star.baseX;\n      star.y = star.baseY;\n      star.opacity = star.baseOpacity;\n      star.parallaxFactor = (star.parallaxLayer + 1) / CONFIG.parallaxLayerCount;\n      star.size *= star.z; // Larger stars for closer depths\n\n      stars.push(star);\n    }\n    return stars;\n  }, [CONFIG, COLORS.stars]);\n\n  // Initialize stars\n  const initializeStars = useCallback(() => {\n    starsRef.current = generateStars();\n  }, [generateStars]);\n\n  // Draw a single star\n  const drawStar = useCallback((ctx, star) => {\n    // Skip rendering almost invisible stars\n    if (star.opacity < 0.05) return;\n\n    // Get final position with parallax offsets\n    const x = star.x + (star.springOffsetX || 0);\n    const y = star.y + (star.springOffsetY || 0);\n\n    // Fill circle for the star\n    ctx.beginPath();\n    ctx.arc(x, y, star.size, 0, Math.PI * 2);\n    ctx.fillStyle = getColor(star.color, star.opacity);\n    ctx.fill();\n\n    // Add glow effect for brighter stars\n    if (star.opacity > 0.4) {\n      ctx.beginPath();\n      ctx.arc(x, y, star.size * 1.8, 0, Math.PI * 2);\n      ctx.fillStyle = getColor(star.color, star.opacity * 0.4);\n      ctx.fill();\n    }\n  }, [getColor]);\n\n  // Render the scene\n  const renderScene = useCallback(() => {\n    if (!canvasRef.current) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    const {\n      width,\n      height,\n      pixelRatio\n    } = dimensionsRef.current;\n\n    // Clear canvas\n    ctx.fillStyle = COLORS.background.topColor;\n    ctx.fillRect(0, 0, width * pixelRatio, height * pixelRatio);\n\n    // Apply device pixel ratio scaling\n    ctx.save();\n    ctx.scale(pixelRatio, pixelRatio);\n\n    // Set blending mode for better glow effect\n    ctx.globalCompositeOperation = 'lighter';\n\n    // Draw all stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      drawStar(ctx, starsRef.current[i]);\n    }\n\n    // Reset blending mode\n    ctx.globalCompositeOperation = 'source-over';\n    ctx.restore();\n  }, [COLORS.background.topColor, drawStar]);\n\n  // Apply spring physics to star offsets\n  const applySpringPhysics = useCallback((star, deltaTime) => {\n    // Spring physics constants\n    const stiffness = CONFIG.springStiffness;\n    const damping = CONFIG.springDamping;\n\n    // Calculate spring force for X axis\n    let springForceX = (star.targetOffsetX - star.springOffsetX) * stiffness;\n    let dampingForceX = -star.velocityX * damping;\n    star.accelerationX = springForceX + dampingForceX;\n    star.velocityX += star.accelerationX * deltaTime;\n    star.springOffsetX += star.velocityX * deltaTime;\n\n    // Calculate spring force for Y axis\n    let springForceY = (star.targetOffsetY - star.springOffsetY) * stiffness;\n    let dampingForceY = -star.velocityY * damping;\n    star.accelerationY = springForceY + dampingForceY;\n    star.velocityY += star.accelerationY * deltaTime;\n    star.springOffsetY += star.velocityY * deltaTime;\n  }, [CONFIG.springStiffness, CONFIG.springDamping]);\n\n  // Update animation state\n  const updateAnimation = useCallback((deltaTime, timestamp) => {\n    const {\n      width,\n      height\n    } = dimensionsRef.current;\n    if (!width || !height) return;\n\n    // Global time factor for animations\n    const timeFactor = timestamp * 0.001;\n\n    // Get current scroll position and calculate scroll velocity\n    const currentScrollY = window.scrollY;\n    const scrollDelta = currentScrollY - lastScrollYRef.current;\n\n    // Update scroll velocity with smoothing\n    scrollVelocityRef.current = scrollVelocityRef.current * 0.8 + scrollDelta * 0.2;\n\n    // Store current scroll position for next frame\n    lastScrollYRef.current = currentScrollY;\n    scrollYRef.current = currentScrollY;\n\n    // Maximum displacement based on config\n    const maxDisplacement = CONFIG.parallaxMaxDisplacement;\n\n    // Update stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n\n      // Basic movement based on time\n      star.x = star.baseX + Math.sin(timeFactor * 0.2 + star.pulsePhase) * 2 * star.directionX;\n      star.y = star.baseY + Math.cos(timeFactor * 0.3 + star.pulsePhase * 1.3) * 2 * star.directionY;\n\n      // Parallax effect based on scroll\n      if (CONFIG.parallaxEnabled) {\n        // Calculate target offset based on scroll position\n        const scrollInfluence = scrollYRef.current / height * maxDisplacement;\n        const layerFactor = star.parallaxFactor;\n\n        // Add velocity-based effects for a more dynamic feel\n        const velocityInfluence = scrollVelocityRef.current * 0.1 * layerFactor;\n\n        // Set target offsets\n        star.targetOffsetX = Math.sin(timeFactor * 0.1 + star.pulsePhase) * velocityInfluence * star.directionX;\n        star.targetOffsetY = scrollInfluence * layerFactor + Math.cos(timeFactor * 0.15 + star.pulsePhase) * velocityInfluence * star.directionY;\n\n        // Apply spring physics for smooth transitions\n        applySpringPhysics(star, deltaTime);\n      }\n\n      // Wrap around screen edges\n      if (star.x < -20) star.baseX = width + 20;\n      if (star.x > width + 20) star.baseX = -20;\n      if (star.y < -20) star.baseY = height + 20;\n      if (star.y > height + 20) star.baseY = -20;\n\n      // Simplified pulsing effect\n      const pulseFactor = Math.sin(timeFactor * star.pulseSpeed + star.pulsePhase) * 0.15 + 0.85;\n      star.opacity = star.baseOpacity * pulseFactor;\n    }\n  }, [CONFIG.parallaxEnabled, CONFIG.parallaxMaxDisplacement, applySpringPhysics]);\n\n  // Animation loop function\n  const animate = useCallback(timestamp => {\n    // Calculate delta time with cap to prevent large jumps\n    const deltaTime = lastTimeRef.current ? Math.min(timestamp - lastTimeRef.current, 50) : 16;\n    lastTimeRef.current = timestamp;\n\n    // Update animation state\n    updateAnimation(deltaTime, timestamp);\n\n    // Render scene\n    renderScene();\n\n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(animate);\n  }, [updateAnimation, renderScene]);\n\n  // Track scroll position\n  useEffect(() => {\n    const handleScroll = () => {\n      scrollYRef.current = window.scrollY;\n    };\n    window.addEventListener('scroll', handleScroll, {\n      passive: true\n    });\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, []);\n\n  // Initialize and handle resize\n  useEffect(() => {\n    // Initialize component\n    const initialize = () => {\n      if (setupCanvas()) {\n        initializeStars();\n        animationFrameRef.current = requestAnimationFrame(animate);\n      }\n    };\n\n    // Handle resize\n    const handleResize = () => {\n      setupCanvas();\n      initializeStars();\n    };\n\n    // Throttle resize events\n    let resizeTimer;\n    const throttledResize = () => {\n      if (!resizeTimer) {\n        resizeTimer = setTimeout(() => {\n          resizeTimer = null;\n          handleResize();\n        }, 200);\n      }\n    };\n\n    // Add resize listener\n    window.addEventListener('resize', throttledResize);\n\n    // Initial setup\n    initialize();\n\n    // Cleanup\n    return () => {\n      window.removeEventListener('resize', throttledResize);\n      if (resizeTimer) clearTimeout(resizeTimer);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [setupCanvas, initializeStars, animate]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      width: '100vw',\n      height: '100vh',\n      overflow: 'hidden',\n      zIndex: -1,\n      pointerEvents: 'none'\n    },\n    \"aria-hidden\": \"true\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 397,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 383,\n    columnNumber: 5\n  }, this);\n};\n_s(Background, \"PPCEdrxwHe7Z6hyUG85XaJ1mUoY=\");\n_c = Background;\nexport default Background;\nvar _c;\n$RefreshReg$(_c, \"Background\");","map":{"version":3,"names":["React","useRef","useEffect","useCallback","useMemo","jsxDEV","_jsxDEV","Background","_s","containerRef","canvasRef","starsRef","animationFrameRef","lastTimeRef","scrollYRef","lastScrollYRef","scrollVelocityRef","dimensionsRef","width","height","pixelRatio","CONFIG","starCount","starSizeMin","starSizeMax","starOpacityMin","starOpacityMax","baseMovementSpeed","pulseFrequency","parallaxEnabled","parallaxStrength","parallaxMaxDisplacement","parallaxLayerCount","springStiffness","springDamping","maxFPS","sessionKey","COLORS","stars","background","topColor","bottomColor","colorCache","cache","forEach","baseColor","opacity","value","replace","getColor","safeOpacity","Math","max","min","roundedOpacity","round","setupCanvas","current","canvas","window","innerWidth","innerHeight","devicePixelRatio","style","ctx","getContext","fillStyle","fillRect","generateStars","i","star","baseX","random","baseY","z","size","baseOpacity","pulsePhase","PI","pulseSpeed","color","floor","length","parallaxLayer","springOffsetX","springOffsetY","targetOffsetX","targetOffsetY","velocityX","velocityY","accelerationX","accelerationY","directionX","directionY","x","y","parallaxFactor","push","initializeStars","drawStar","beginPath","arc","fill","renderScene","save","scale","globalCompositeOperation","restore","applySpringPhysics","deltaTime","stiffness","damping","springForceX","dampingForceX","springForceY","dampingForceY","updateAnimation","timestamp","timeFactor","currentScrollY","scrollY","scrollDelta","maxDisplacement","sin","cos","scrollInfluence","layerFactor","velocityInfluence","pulseFactor","animate","requestAnimationFrame","handleScroll","addEventListener","passive","removeEventListener","initialize","handleResize","resizeTimer","throttledResize","setTimeout","clearTimeout","cancelAnimationFrame","ref","position","top","left","overflow","zIndex","pointerEvents","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/layout/Background.jsx"],"sourcesContent":["import React, { useRef, useEffect, useCallback, useMemo } from 'react';\n\n/**\n * Optimized Background Component with Parallax Effects\n * \n * Creates an immersive stellar background with realistic star particles\n * and scroll-based parallax effects while maintaining performance through canvas.\n */\nconst Background = () => {\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const starsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimeRef = useRef(0);\n  const scrollYRef = useRef(0);\n  const lastScrollYRef = useRef(0);\n  const scrollVelocityRef = useRef(0);\n  \n  // Store dimensions in a ref to avoid re-renders when they change\n  const dimensionsRef = useRef({ width: 0, height: 0, pixelRatio: 1 });\n  \n  // Configuration - wrapped in useMemo to prevent recreation on each render\n  const CONFIG = useMemo(() => ({\n    starCount: 100,\n    starSizeMin: 0.8,\n    starSizeMax: 2.5,\n    starOpacityMin: 0.2,\n    starOpacityMax: 0.9,\n    \n    // Motion parameters\n    baseMovementSpeed: 0.00008,\n    pulseFrequency: 0.00003,\n    \n    // Parallax effect configuration\n    parallaxEnabled: true,\n    parallaxStrength: 0.15,\n    parallaxMaxDisplacement: 25,\n    parallaxLayerCount: 5,\n    \n    // Spring physics for smooth animations\n    springStiffness: 0.08,\n    springDamping: 0.65,\n    \n    // Performance parameters\n    maxFPS: 60,\n    \n    // Session persistence\n    sessionKey: 'star_background_config'\n  }), []);\n  \n  // Warm, golden color palette\n  const COLORS = useMemo(() => ({\n    stars: [\n      'rgba(255, 243, 200, alpha)', // Warm yellow\n      'rgba(255, 231, 164, alpha)', // Golden\n      'rgba(252, 249, 231, alpha)'  // Off-white gold\n    ],\n    background: {\n      topColor: 'rgb(8, 8, 12)',\n      bottomColor: 'rgb(15, 15, 20)'\n    }\n  }), []);\n  \n  // Pre-generated color values to avoid string replacements\n  const colorCache = useMemo(() => {\n    const cache = {};\n    COLORS.stars.forEach(baseColor => {\n      cache[baseColor] = {};\n      for (let opacity = 0; opacity <= 10; opacity++) {\n        const value = opacity / 10;\n        cache[baseColor][value] = baseColor.replace('alpha', value);\n      }\n    });\n    return cache;\n  }, [COLORS.stars]);\n  \n  // Get color with opacity from cache\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    const roundedOpacity = Math.round(safeOpacity * 10) / 10;\n    return colorCache[baseColor][roundedOpacity] || baseColor.replace('alpha', safeOpacity);\n  }, [colorCache]);\n  \n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) return false;\n    \n    const canvas = canvasRef.current;\n    \n    // Get viewport dimensions\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const pixelRatio = window.devicePixelRatio || 1;\n    \n    // Set canvas size accounting for pixel ratio\n    canvas.width = width * pixelRatio;\n    canvas.height = height * pixelRatio;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n    \n    // Ensure canvas is visible with a background color\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return false;\n    \n    ctx.fillStyle = COLORS.background.bottomColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    \n    // Update dimensions ref\n    dimensionsRef.current = { width, height, pixelRatio };\n    \n    return true;\n  }, [COLORS.background.bottomColor]);\n  \n  // Generate new star data\n  const generateStars = useCallback(() => {\n    const { width, height } = dimensionsRef.current;\n    if (!width || !height) return [];\n    \n    const stars = [];\n    \n    for (let i = 0; i < CONFIG.starCount; i++) {\n      const star = {\n        // Position\n        baseX: Math.random() * width,\n        baseY: Math.random() * height,\n        z: Math.random() * 0.8 + 0.1, // Depth (0.1 to 0.9)\n        \n        // Visual properties\n        size: Math.random() * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin,\n        baseOpacity: Math.random() * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin,\n        \n        // Animation properties\n        pulsePhase: Math.random() * Math.PI * 2,\n        pulseSpeed: Math.random() * 0.002 + 0.001,\n        \n        // Color variation\n        color: COLORS.stars[Math.floor(Math.random() * COLORS.stars.length)],\n        \n        // Parallax properties\n        parallaxLayer: Math.floor(Math.random() * CONFIG.parallaxLayerCount),\n        springOffsetX: 0,\n        springOffsetY: 0,\n        targetOffsetX: 0,\n        targetOffsetY: 0,\n        velocityX: 0,\n        velocityY: 0,\n        accelerationX: 0,\n        accelerationY: 0,\n        \n        // Direction factors for varied movement\n        directionX: Math.random() > 0.5 ? 1 : -1,\n        directionY: Math.random() > 0.5 ? 1 : -1\n      };\n      \n      // Calculate derived properties\n      star.x = star.baseX;\n      star.y = star.baseY;\n      star.opacity = star.baseOpacity;\n      star.parallaxFactor = (star.parallaxLayer + 1) / CONFIG.parallaxLayerCount;\n      star.size *= star.z; // Larger stars for closer depths\n      \n      stars.push(star);\n    }\n    \n    return stars;\n  }, [CONFIG, COLORS.stars]);\n  \n  // Initialize stars\n  const initializeStars = useCallback(() => {\n    starsRef.current = generateStars();\n  }, [generateStars]);\n  \n  // Draw a single star\n  const drawStar = useCallback((ctx, star) => {\n    // Skip rendering almost invisible stars\n    if (star.opacity < 0.05) return;\n    \n    // Get final position with parallax offsets\n    const x = star.x + (star.springOffsetX || 0);\n    const y = star.y + (star.springOffsetY || 0);\n    \n    // Fill circle for the star\n    ctx.beginPath();\n    ctx.arc(x, y, star.size, 0, Math.PI * 2);\n    ctx.fillStyle = getColor(star.color, star.opacity);\n    ctx.fill();\n    \n    // Add glow effect for brighter stars\n    if (star.opacity > 0.4) {\n      ctx.beginPath();\n      ctx.arc(x, y, star.size * 1.8, 0, Math.PI * 2);\n      ctx.fillStyle = getColor(star.color, star.opacity * 0.4);\n      ctx.fill();\n    }\n  }, [getColor]);\n  \n  // Render the scene\n  const renderScene = useCallback(() => {\n    if (!canvasRef.current) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    \n    if (!ctx) return;\n    \n    const { width, height, pixelRatio } = dimensionsRef.current;\n    \n    // Clear canvas\n    ctx.fillStyle = COLORS.background.topColor;\n    ctx.fillRect(0, 0, width * pixelRatio, height * pixelRatio);\n    \n    // Apply device pixel ratio scaling\n    ctx.save();\n    ctx.scale(pixelRatio, pixelRatio);\n    \n    // Set blending mode for better glow effect\n    ctx.globalCompositeOperation = 'lighter';\n    \n    // Draw all stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      drawStar(ctx, starsRef.current[i]);\n    }\n    \n    // Reset blending mode\n    ctx.globalCompositeOperation = 'source-over';\n    ctx.restore();\n  }, [COLORS.background.topColor, drawStar]);\n  \n  // Apply spring physics to star offsets\n  const applySpringPhysics = useCallback((star, deltaTime) => {\n    // Spring physics constants\n    const stiffness = CONFIG.springStiffness; \n    const damping = CONFIG.springDamping;\n    \n    // Calculate spring force for X axis\n    let springForceX = (star.targetOffsetX - star.springOffsetX) * stiffness;\n    let dampingForceX = -star.velocityX * damping;\n    star.accelerationX = springForceX + dampingForceX;\n    star.velocityX += star.accelerationX * deltaTime;\n    star.springOffsetX += star.velocityX * deltaTime;\n    \n    // Calculate spring force for Y axis\n    let springForceY = (star.targetOffsetY - star.springOffsetY) * stiffness;\n    let dampingForceY = -star.velocityY * damping;\n    star.accelerationY = springForceY + dampingForceY;\n    star.velocityY += star.accelerationY * deltaTime;\n    star.springOffsetY += star.velocityY * deltaTime;\n  }, [CONFIG.springStiffness, CONFIG.springDamping]);\n  \n  // Update animation state\n  const updateAnimation = useCallback((deltaTime, timestamp) => {\n    const { width, height } = dimensionsRef.current;\n    if (!width || !height) return;\n    \n    // Global time factor for animations\n    const timeFactor = timestamp * 0.001;\n    \n    // Get current scroll position and calculate scroll velocity\n    const currentScrollY = window.scrollY;\n    const scrollDelta = currentScrollY - lastScrollYRef.current;\n    \n    // Update scroll velocity with smoothing\n    scrollVelocityRef.current = scrollVelocityRef.current * 0.8 + scrollDelta * 0.2;\n    \n    // Store current scroll position for next frame\n    lastScrollYRef.current = currentScrollY;\n    scrollYRef.current = currentScrollY;\n    \n    // Maximum displacement based on config\n    const maxDisplacement = CONFIG.parallaxMaxDisplacement;\n    \n    // Update stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n      \n      // Basic movement based on time\n      star.x = star.baseX + Math.sin(timeFactor * 0.2 + star.pulsePhase) * 2 * star.directionX;\n      star.y = star.baseY + Math.cos(timeFactor * 0.3 + star.pulsePhase * 1.3) * 2 * star.directionY;\n      \n      // Parallax effect based on scroll\n      if (CONFIG.parallaxEnabled) {\n        // Calculate target offset based on scroll position\n        const scrollInfluence = (scrollYRef.current / height) * maxDisplacement;\n        const layerFactor = star.parallaxFactor;\n        \n        // Add velocity-based effects for a more dynamic feel\n        const velocityInfluence = scrollVelocityRef.current * 0.1 * layerFactor;\n        \n        // Set target offsets\n        star.targetOffsetX = Math.sin(timeFactor * 0.1 + star.pulsePhase) * velocityInfluence * star.directionX;\n        star.targetOffsetY = (scrollInfluence * layerFactor) + (Math.cos(timeFactor * 0.15 + star.pulsePhase) * velocityInfluence * star.directionY);\n        \n        // Apply spring physics for smooth transitions\n        applySpringPhysics(star, deltaTime);\n      }\n      \n      // Wrap around screen edges\n      if (star.x < -20) star.baseX = width + 20;\n      if (star.x > width + 20) star.baseX = -20;\n      if (star.y < -20) star.baseY = height + 20;\n      if (star.y > height + 20) star.baseY = -20;\n      \n      // Simplified pulsing effect\n      const pulseFactor = Math.sin(timeFactor * star.pulseSpeed + star.pulsePhase) * 0.15 + 0.85;\n      star.opacity = star.baseOpacity * pulseFactor;\n    }\n  }, [CONFIG.parallaxEnabled, CONFIG.parallaxMaxDisplacement, applySpringPhysics]);\n  \n  // Animation loop function\n  const animate = useCallback((timestamp) => {\n    // Calculate delta time with cap to prevent large jumps\n    const deltaTime = lastTimeRef.current ? Math.min(timestamp - lastTimeRef.current, 50) : 16;\n    lastTimeRef.current = timestamp;\n    \n    // Update animation state\n    updateAnimation(deltaTime, timestamp);\n    \n    // Render scene\n    renderScene();\n    \n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(animate);\n  }, [updateAnimation, renderScene]);\n  \n  // Track scroll position\n  useEffect(() => {\n    const handleScroll = () => {\n      scrollYRef.current = window.scrollY;\n    };\n    \n    window.addEventListener('scroll', handleScroll, { passive: true });\n    \n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, []);\n  \n  // Initialize and handle resize\n  useEffect(() => {\n    // Initialize component\n    const initialize = () => {\n      if (setupCanvas()) {\n        initializeStars();\n        animationFrameRef.current = requestAnimationFrame(animate);\n      }\n    };\n    \n    // Handle resize\n    const handleResize = () => {\n      setupCanvas();\n      initializeStars();\n    };\n    \n    // Throttle resize events\n    let resizeTimer;\n    const throttledResize = () => {\n      if (!resizeTimer) {\n        resizeTimer = setTimeout(() => {\n          resizeTimer = null;\n          handleResize();\n        }, 200);\n      }\n    };\n    \n    // Add resize listener\n    window.addEventListener('resize', throttledResize);\n    \n    // Initial setup\n    initialize();\n    \n    // Cleanup\n    return () => {\n      window.removeEventListener('resize', throttledResize);\n      if (resizeTimer) clearTimeout(resizeTimer);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [setupCanvas, initializeStars, animate]);\n  \n  return (\n    <div\n      ref={containerRef}\n      style={{\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        width: '100vw',\n        height: '100vh',\n        overflow: 'hidden',\n        zIndex: -1,\n        pointerEvents: 'none'\n      }}\n      aria-hidden=\"true\"\n    >\n      <canvas\n        ref={canvasRef}\n        style={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%'\n        }}\n      />\n    </div>\n  );\n};\n\nexport default Background;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}