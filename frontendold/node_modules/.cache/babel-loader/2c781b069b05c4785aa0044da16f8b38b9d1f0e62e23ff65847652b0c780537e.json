{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/CosmicStars.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useCallback, useMemo } from 'react';\nimport { useScroll, useSpring } from 'framer-motion';\n\n/**\n * CosmicStars Component\n * \n * Renders an immersive, performance-optimized starry background\n * with parallax scrolling, gentle random drifting, and state persistence.\n * \n * @param {Object} config - Configuration options to customize the star field\n * @returns {React.Component} A fixed position canvas element rendering animated stars\n * \n * @example\n * // Basic usage\n * <CosmicStars />\n * \n * @example\n * // Custom configuration\n * <CosmicStars \n *   config={{\n *     starCount: 200,\n *     parallaxFactor: 0.3,\n *     colors: {\n *       stars: ['rgba(255, 243, 200, alpha)', 'rgba(255, 231, 164, alpha)'],\n *       background: { topColor: '#000', bottomColor: '#111' }\n *     }\n *   }}\n * />\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CosmicStars = ({\n  config = {}\n}) => {\n  _s();\n  // Refs for DOM elements and animation state\n  const canvasRef = useRef(null);\n  const starsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimeRef = useRef(0);\n  const lastScrollYRef = useRef(0);\n\n  // Use refs instead of state to prevent re-renders\n  const isInitializedRef = useRef(false);\n  const firstRenderCompleteRef = useRef(false);\n\n  // Store dimensions in a ref to avoid re-renders when they change\n  const dimensionsRef = useRef({\n    width: 0,\n    height: 0,\n    pixelRatio: 1\n  });\n\n  // Get scroll position using framer-motion\n  const {\n    scrollY\n  } = useScroll({\n    smooth: 0.05 // Smoother scrolling for high-framerate animations\n  });\n\n  // Use spring physics for smoother scrolling effect\n  const springScrollY = useSpring(scrollY, {\n    stiffness: 1,\n    damping: 5,\n    mass: 0.5,\n    restDelta: 0.001,\n    restSpeed: 0.001\n  });\n\n  // Track spring scrollY value without causing re-renders\n  const springScrollYRef = useRef(0);\n  useEffect(() => {\n    const unsubscribe = springScrollY.onChange(value => {\n      springScrollYRef.current = value;\n    });\n    return () => unsubscribe();\n  }, [springScrollY]);\n\n  // Configuration - wrapped in useMemo to prevent recreation on each render\n  // Merge default config with user-provided config\n  const CONFIG = useMemo(() => ({\n    // Star appearance\n    starCount: 100,\n    starSizeMin: 1.0,\n    starSizeMax: 1.9,\n    starOpacityMin: 0.2,\n    starOpacityMax: 0.55,\n    // Parallax and movement parameters\n    baseMovementSpeed: 0.00001,\n    // Reduced for slower movement\n    pulseFrequency: 0.00002,\n    // Slower pulsing\n    parallaxEnabled: true,\n    parallaxFactor: 0.2,\n    // How much stars move relative to scroll (0-1)\n\n    // Trail effect parameters\n    trailEnabled: true,\n    // Enable subtle trails\n    trailLength: 2,\n    // Very short trail length (in pixels)\n    trailOpacityFactor: 0.5,\n    // Trail opacity relative to star opacity\n\n    // Twinkling effect parameters\n    twinkleEnabled: true,\n    // Enable stars to fade in and out\n    twinkleProbability: 0.01,\n    // Probability of a star beginning to twinkle each frame\n    twinkleDuration: [2000, 4000],\n    // Min and max duration of a twinkle cycle in ms\n\n    // Random fading parameters\n    randomFadingEnabled: true,\n    // Enable random fading of stars\n    randomFadeOutProbability: 0.0003,\n    // Probability of a star randomly starting to fade out per frame\n    maxSimultaneousFading: 10,\n    // Maximum number of stars that can be fading at once\n\n    // Drifting movement parameters\n    driftEnabled: true,\n    // Enable slow drifting movement\n    driftSpeed: 0.01,\n    // Base speed of drift movement (pixels per second)\n    driftSpeedVariation: 0.005,\n    // Variation in drift speed between stars\n    directionChangeFrequency: 0.0005,\n    // Probability of changing direction each frame\n    directionChangeAmount: 0.05,\n    // How much direction can change at once (lower = smoother)\n\n    // Star regeneration parameters\n    regenerateOffscreenStars: true,\n    // Replace off-screen stars instead of wrapping\n    fadeInDuration: 2000,\n    // Duration for new stars to fade in (ms)\n    fadeOutDuration: 1500,\n    // Duration for off-screen stars to fade out (ms)\n    offscreenBuffer: 50,\n    // Distance beyond viewport to trigger regeneration (px)\n\n    // Physics parameters for bouncy effect\n    springStrength: 0.03,\n    // Higher = snappier\n    dampingFactor: 0.95,\n    // Higher = less bouncy (0-1)\n\n    // Star distribution parameters\n    verticalSpreadFactor: 3,\n    // How many screen heights to spread stars across\n    offscreenBufferFactor: 1,\n    // How many screen heights above viewport to generate stars\n\n    // Performance parameters\n    maxFPS: 60,\n    // Enhanced persistence settings\n    persistenceEnabled: true,\n    // Enable persistence features\n    persistenceInterval: 3000,\n    // Save every 3 seconds (milliseconds)\n    timeBasedFallback: true,\n    // Use time-based generation as fallback\n    persistenceMaxAge: 7 * 24 * 60 * 60 * 1000,\n    // 7 days before regenerating (milliseconds)\n\n    // Session persistence keys\n    sessionKey: 'cosmic_stars_background_config',\n    scrollPositionKey: 'cosmic_stars_background_scroll',\n    lastVisitKey: 'cosmic_stars_background_last_visit',\n    // Override with user config\n    ...config\n  }), [config]);\n\n  // Star colors - wrapped in useMemo\n  const COLORS = useMemo(() => ({\n    // Star colors\n    stars: ['rgba(255, 243, 200, alpha)',\n    // Warm yellow\n    'rgba(255, 231, 164, alpha)',\n    // Golden\n    'rgba(252, 249, 231, alpha)' // Off-white gold\n    ],\n    // Background gradient colors\n    background: {\n      topColor: 'rgb(8, 8, 12)',\n      bottomColor: 'rgb(15, 15, 20)'\n    },\n    // Override with user config if provided\n    ...(config.colors || {})\n  }), [config.colors]);\n\n  // Pre-generated color values to avoid string replacements during animation\n  const colorCache = useMemo(() => {\n    const cache = {};\n    COLORS.stars.forEach(baseColor => {\n      cache[baseColor] = {};\n      for (let opacity = 0; opacity <= 10; opacity++) {\n        const value = opacity / 10;\n        cache[baseColor][value] = baseColor.replace(/alpha\\)$/, `${value})`);\n      }\n    });\n    return cache;\n  }, [COLORS.stars]);\n\n  // Get color with opacity from cache (faster than string replacement)\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    // Round to nearest 0.1 to use cached values\n    const roundedOpacity = Math.round(safeOpacity * 10) / 10;\n    return colorCache[baseColor][roundedOpacity] || baseColor.replace(/alpha\\)$/, `${safeOpacity})`);\n  }, [colorCache]);\n\n  // Create a deterministic seeded random function\n  const seededRandom = useCallback(seed => {\n    return () => {\n      seed = (seed * 9301 + 49297) % 233280;\n      return seed / 233280;\n    };\n  }, []);\n\n  // Get a seed based on current date (changes daily)\n  const getDateSeed = useCallback(() => {\n    const now = new Date();\n    return now.getFullYear() * 10000 + (now.getMonth() + 1) * 100 + now.getDate();\n  }, []);\n\n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) return false;\n    const canvas = canvasRef.current;\n\n    // Get viewport dimensions\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const pixelRatio = window.devicePixelRatio || 1;\n\n    // Set canvas size accounting for pixel ratio\n    canvas.width = width * pixelRatio;\n    canvas.height = height * pixelRatio;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n\n    // Ensure canvas is visible with a background color (use alpha: false for no flicker)\n    const ctx = canvas.getContext('2d', {\n      alpha: false\n    });\n    if (ctx) {\n      // Fill with background color immediately to prevent flickering\n      ctx.fillStyle = COLORS.background.topColor;\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n\n    // Update dimensions ref instead of state\n    dimensionsRef.current = {\n      width,\n      height,\n      pixelRatio\n    };\n    return true;\n  }, [COLORS.background.topColor]);\n\n  // Generate time-based stars for consistency\n  const generateTimeBasedStars = useCallback(() => {\n    const {\n      width,\n      height\n    } = dimensionsRef.current;\n    if (!width || !height) return [];\n\n    // Create seed based on date\n    const dateSeed = getDateSeed();\n\n    // Generate new stars with deterministic positioning\n    const stars = [];\n    for (let i = 0; i < CONFIG.starCount; i++) {\n      // Generate a seed for this specific star (that will be the same each day)\n      const starSeed = dateSeed + i;\n      const starRandom = seededRandom(starSeed);\n\n      // Create the star using deterministic properties\n      const star = {};\n\n      // Position with some variance but tied to the date\n      star.x = starRandom() * width;\n      star.baseY = (starRandom() * CONFIG.verticalSpreadFactor - CONFIG.offscreenBufferFactor) * height;\n      star.y = star.baseY;\n      star.z = starRandom() * 0.8 + 0.1;\n\n      // Visual properties\n      star.size = (starRandom() * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n      star.baseOpacity = starRandom() * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n      star.opacity = star.baseOpacity;\n      star.color = COLORS.stars[Math.floor(starRandom() * COLORS.stars.length)];\n\n      // Animation properties\n      star.pulsePhase = starRandom() * Math.PI * 2;\n      star.pulseSpeed = starRandom() * 0.002 + 0.001;\n      star.movementSpeed = (starRandom() * 0.2 + 0.9) * CONFIG.baseMovementSpeed * (1.1 - star.z);\n\n      // Drift properties\n      star.driftDirectionX = starRandom() * 2 - 1;\n      star.driftDirectionY = starRandom() * 2 - 1;\n      // Normalize direction\n      const dirMagnitude = Math.sqrt(star.driftDirectionX ** 2 + star.driftDirectionY ** 2) || 1;\n      star.driftDirectionX /= dirMagnitude;\n      star.driftDirectionY /= dirMagnitude;\n      star.driftSpeed = CONFIG.driftSpeed + (starRandom() * 2 - 1) * CONFIG.driftSpeedVariation;\n      star.directionChangeTimer = 0;\n\n      // Initial state\n      star.state = 'visible';\n      star.fadeProgress = 1;\n      star.targetY = star.y;\n      star.velocity = 0;\n      star.lastX = star.x;\n      star.lastY = star.y;\n\n      // Parallax properties\n      star.parallaxFactor = starRandom() * 0.5 * CONFIG.parallaxFactor * (1 - star.z * 0.5);\n\n      // Initialize twinkling properties\n      star.twinkleState = 'visible';\n      star.twinkleProgress = 0;\n      star.twinkleDuration = starRandom() * (CONFIG.twinkleDuration[1] - CONFIG.twinkleDuration[0]) + CONFIG.twinkleDuration[0];\n\n      // Store original seed for future reference\n      star.originalSeed = starSeed;\n      stars.push(star);\n    }\n    return stars;\n  }, [CONFIG.starCount, CONFIG.verticalSpreadFactor, CONFIG.offscreenBufferFactor, CONFIG.starSizeMax, CONFIG.starSizeMin, CONFIG.starOpacityMax, CONFIG.starOpacityMin, CONFIG.baseMovementSpeed, CONFIG.driftSpeed, CONFIG.driftSpeedVariation, CONFIG.parallaxFactor, CONFIG.twinkleDuration, COLORS.stars, getDateSeed, seededRandom]);\n\n  // Save the current star state and scroll position\n  const saveCurrentState = useCallback(() => {\n    if (!starsRef.current.length || !dimensionsRef.current.width || !CONFIG.persistenceEnabled) {\n      return;\n    }\n    try {\n      // Record current time\n      const currentTime = Date.now();\n\n      // Save current scroll position separately for quick access\n      sessionStorage.setItem(CONFIG.scrollPositionKey, springScrollYRef.current.toString());\n\n      // Save last visit time\n      sessionStorage.setItem(CONFIG.lastVisitKey, currentTime.toString());\n\n      // Prepare complete star state \n      const completeState = {\n        version: \"1.0\",\n        // For future compatibility\n        timestamp: currentTime,\n        dateSeed: getDateSeed(),\n        // Store the seed for time-based fallback\n        scrollY: springScrollYRef.current,\n        viewport: {\n          width: dimensionsRef.current.width,\n          height: dimensionsRef.current.height,\n          pixelRatio: dimensionsRef.current.pixelRatio\n        },\n        stars: starsRef.current.map(star => ({\n          // Position data\n          x: star.x,\n          y: star.y,\n          baseY: star.baseY,\n          z: star.z,\n          // Visual properties\n          size: star.size,\n          baseOpacity: star.baseOpacity,\n          opacity: star.opacity,\n          color: COLORS.stars.indexOf(star.color),\n          // Animation data\n          pulsePhase: star.pulsePhase,\n          pulseSpeed: star.pulseSpeed,\n          driftDirectionX: star.driftDirectionX,\n          driftDirectionY: star.driftDirectionY,\n          driftSpeed: star.driftSpeed,\n          movementSpeed: star.movementSpeed,\n          parallaxFactor: star.parallaxFactor,\n          // State\n          state: star.state,\n          fadeProgress: star.fadeProgress,\n          fadeStart: star.fadeStart ? currentTime - (currentTime - star.fadeStart) : null,\n          // For fallback/time consistency\n          originalSeed: star.originalSeed || null\n        }))\n      };\n\n      // Save complete state\n      sessionStorage.setItem(CONFIG.sessionKey, JSON.stringify(completeState));\n    } catch (error) {\n      console.warn('Could not save star state to session storage', error);\n    }\n  }, [CONFIG.persistenceEnabled, CONFIG.scrollPositionKey, CONFIG.lastVisitKey, CONFIG.sessionKey, COLORS.stars, getDateSeed]);\n\n  // Create a new star at random position\n  const createNewStar = useCallback((offScreenStar = null) => {\n    const {\n      width,\n      height\n    } = dimensionsRef.current;\n    const star = {};\n\n    // If replacing an existing star, preserve some properties\n    if (offScreenStar) {\n      star.z = offScreenStar.z;\n      star.size = offScreenStar.size;\n      star.baseOpacity = offScreenStar.baseOpacity;\n      star.pulsePhase = Math.random() * Math.PI * 2; // New phase\n      star.color = offScreenStar.color;\n      star.parallaxFactor = offScreenStar.parallaxFactor;\n      star.originalSeed = offScreenStar.originalSeed; // Preserve seed if available\n    } else {\n      // Otherwise generate new properties\n      star.z = Math.random() * 0.8 + 0.1;\n      star.size = (Math.random() * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n      star.baseOpacity = Math.random() * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n      star.pulsePhase = Math.random() * Math.PI * 2;\n      star.color = COLORS.stars[Math.floor(Math.random() * COLORS.stars.length)];\n      star.parallaxFactor = Math.random() * 0.5 * CONFIG.parallaxFactor * (1 - star.z * 0.5);\n      star.originalSeed = Math.random(); // New random seed\n    }\n\n    // Generate position\n    // Avoid edges by using 10% inset from the viewport dimensions\n    const edgeBuffer = Math.min(width, height) * 0.1;\n    star.x = edgeBuffer + Math.random() * (width - 2 * edgeBuffer);\n    star.baseY = edgeBuffer + Math.random() * (height - 2 * edgeBuffer);\n    star.y = star.baseY;\n    star.targetY = star.y;\n\n    // For new stars during runtime, fade them in\n    // For initial stars, start them fully visible\n    const isInitialCreation = !isInitializedRef.current;\n    if (isInitialCreation) {\n      star.opacity = star.baseOpacity;\n      star.state = 'visible';\n      star.fadeProgress = 1;\n    } else {\n      star.opacity = 0;\n      star.state = 'fading-in';\n      star.fadeProgress = 0;\n      star.fadeStart = Date.now();\n    }\n\n    // Movement properties\n    star.pulseSpeed = Math.random() * 0.002 + 0.001;\n    star.movementSpeed = (Math.random() * 0.2 + 0.9) * CONFIG.baseMovementSpeed * (1.1 - star.z);\n\n    // Drift movement properties\n    star.driftDirectionX = Math.random() * 2 - 1;\n    star.driftDirectionY = Math.random() * 2 - 1;\n    // Normalize the direction vector\n    const dirMagnitude = Math.sqrt(star.driftDirectionX ** 2 + star.driftDirectionY ** 2) || 1;\n    star.driftDirectionX /= dirMagnitude;\n    star.driftDirectionY /= dirMagnitude;\n    // Vary the drift speed between stars\n    star.driftSpeed = CONFIG.driftSpeed + (Math.random() * 2 - 1) * CONFIG.driftSpeedVariation;\n    star.directionChangeTimer = 0;\n\n    // Initialize velocity and position tracking for trails\n    star.velocity = 0;\n    star.lastX = star.x;\n    star.lastY = star.y;\n\n    // Initialize twinkling properties\n    star.twinkleState = 'visible';\n    star.twinkleProgress = 0;\n    star.twinkleDuration = Math.random() * (CONFIG.twinkleDuration[1] - CONFIG.twinkleDuration[0]) + CONFIG.twinkleDuration[0];\n\n    // Physics properties\n    star.velocity = 0;\n    return star;\n  }, [CONFIG.starSizeMax, CONFIG.starSizeMin, CONFIG.starOpacityMax, CONFIG.starOpacityMin, CONFIG.baseMovementSpeed, CONFIG.driftSpeed, CONFIG.driftSpeedVariation, CONFIG.parallaxFactor, CONFIG.twinkleDuration, COLORS.stars]);\n\n  // Get previously saved configuration or generate new one\n  const getSessionConfiguration = useCallback(() => {\n    // First ensure dimensions are set\n    if (!dimensionsRef.current.width) return {\n      starSeeds: []\n    };\n\n    // Check if we have a valid stored configuration\n    if (CONFIG.persistenceEnabled) {\n      try {\n        // Try to load existing configuration from sessionStorage\n        const storedState = sessionStorage.getItem(CONFIG.sessionKey);\n        if (storedState) {\n          const savedState = JSON.parse(storedState);\n\n          // Check if the saved state is still valid and not too old\n          const currentTime = Date.now();\n          const stateAge = currentTime - savedState.timestamp;\n\n          // Use saved state if it's not too old and has the right number of stars\n          if (stateAge < CONFIG.persistenceMaxAge && savedState.stars && savedState.stars.length === CONFIG.starCount) {\n            // Retrieve stored scroll position if available\n            if (savedState.scrollY !== undefined) {\n              // Store in ref to use in animation\n              springScrollYRef.current = savedState.scrollY;\n            }\n\n            // Calculate scaling factors if viewport changed\n            const prevViewport = savedState.viewport || {\n              width: dimensionsRef.current.width,\n              height: dimensionsRef.current.height\n            };\n            const scaleX = dimensionsRef.current.width / prevViewport.width;\n            const scaleY = dimensionsRef.current.height / prevViewport.height;\n\n            // Return a starSeeds-compatible object for our existing code\n            return {\n              source: 'sessionStorage',\n              timestamp: savedState.timestamp,\n              starSeeds: savedState.stars.map(star => ({\n                // Convert saved stars to the seed format our initialization expects\n                x: star.x * scaleX,\n                y: star.y * scaleY,\n                baseY: star.baseY * scaleY,\n                z: star.z,\n                size: star.size,\n                baseOpacity: star.baseOpacity,\n                opacity: star.opacity,\n                color: star.color,\n                pulsePhase: star.pulsePhase,\n                pulseSpeed: star.pulseSpeed,\n                driftDirectionX: star.driftDirectionX,\n                driftDirectionY: star.driftDirectionY,\n                driftSpeed: star.driftSpeed,\n                movementSpeed: star.movementSpeed,\n                parallaxFactor: star.parallaxFactor,\n                state: star.state,\n                fadeProgress: star.fadeProgress,\n                fadeStart: star.fadeStart,\n                originalSeed: star.originalSeed\n              }))\n            };\n          }\n        }\n      } catch (error) {\n        console.warn('Could not load star configuration from session storage', error);\n      }\n    }\n\n    // If no valid saved state or persistence disabled, use time-based approach\n    if (CONFIG.timeBasedFallback) {\n      const timeBasedStars = generateTimeBasedStars();\n\n      // Convert to starSeeds format\n      return {\n        source: 'timeBasedGeneration',\n        timestamp: Date.now(),\n        starSeeds: timeBasedStars.map(star => ({\n          x: star.x,\n          y: star.y,\n          baseY: star.baseY,\n          z: star.z,\n          size: star.size,\n          baseOpacity: star.baseOpacity,\n          opacity: star.opacity,\n          color: COLORS.stars.indexOf(star.color),\n          pulsePhase: star.pulsePhase,\n          pulseSpeed: star.pulseSpeed,\n          driftDirectionX: star.driftDirectionX,\n          driftDirectionY: star.driftDirectionY,\n          driftSpeed: star.driftSpeed,\n          movementSpeed: star.movementSpeed,\n          parallaxFactor: star.parallaxFactor,\n          state: star.state,\n          fadeProgress: star.fadeProgress,\n          originalSeed: star.originalSeed\n        }))\n      };\n    }\n\n    // Fallback to completely random generation\n    return {\n      source: 'random',\n      timestamp: Date.now(),\n      starSeeds: Array.from({\n        length: CONFIG.starCount\n      }).map(() => ({\n        // Random properties for each star\n        xSeed: Math.random(),\n        ySeed: Math.random() * CONFIG.verticalSpreadFactor - CONFIG.offscreenBufferFactor,\n        zSeed: Math.random() * 0.8 + 0.1,\n        sizeSeed: Math.random(),\n        opacitySeed: Math.random(),\n        phaseSeed: Math.random() * Math.PI * 2,\n        speedSeed: Math.random() * 0.2 + 0.9,\n        pulseSpeedSeed: Math.random() * 0.002 + 0.001,\n        colorIndex: Math.floor(Math.random() * COLORS.stars.length),\n        parallaxFactorSeed: Math.random() * 0.5 + 0.1,\n        driftDirectionXSeed: Math.random() * 2 - 1,\n        driftDirectionYSeed: Math.random() * 2 - 1,\n        driftSpeedSeed: Math.random()\n      }))\n    };\n  }, [CONFIG.persistenceEnabled, CONFIG.persistenceMaxAge, CONFIG.sessionKey, CONFIG.starCount, CONFIG.timeBasedFallback, CONFIG.verticalSpreadFactor, CONFIG.offscreenBufferFactor, COLORS.stars.length, generateTimeBasedStars]);\n\n  // Initialize stars with persistence handling\n  const initializeStars = useCallback(() => {\n    const {\n      width,\n      height\n    } = dimensionsRef.current;\n    if (!width || !height) return;\n\n    // First check if we already have stars that should be preserved\n    if (starsRef.current.length > 0 && isInitializedRef.current) {\n      // Only reinitialize if screen dimensions have significantly changed\n      const existingWidth = starsRef.current[0].x / (starsRef.current[0].xSeed || 0.5);\n      const existingHeight = starsRef.current[0].baseY / ((starsRef.current[0].ySeed || 0.5) + CONFIG.offscreenBufferFactor);\n      const widthChange = Math.abs(existingWidth - width) / width;\n      const heightChange = Math.abs(existingHeight - height) / height;\n\n      // If dimensions haven't changed much, preserve existing stars\n      if (!isNaN(widthChange) && !isNaN(heightChange) && widthChange < 0.2 && heightChange < 0.2) {\n        // Just update target positions based on new dimensions\n        for (let i = 0; i < starsRef.current.length; i++) {\n          const star = starsRef.current[i];\n          // Scale position to new dimensions\n          if (star.xSeed) {\n            star.x = star.xSeed * width;\n            star.baseY = (star.ySeed + CONFIG.offscreenBufferFactor) * height;\n          } else {\n            // For stars without seeds, scale proportionally\n            star.x = star.x / existingWidth * width;\n            star.baseY = star.baseY / existingHeight * height;\n          }\n          star.y = star.baseY;\n          star.targetY = star.y;\n        }\n        return; // Keep existing stars\n      }\n    }\n\n    // Get session configuration using our enhanced logic\n    const sessionConfig = getSessionConfiguration();\n    const {\n      starSeeds,\n      source\n    } = sessionConfig;\n\n    // Clear existing stars\n    starsRef.current = [];\n\n    // Create stars using the retrieved configuration\n    for (let i = 0; i < starSeeds.length; i++) {\n      const seed = starSeeds[i];\n      const star = {};\n      if (source === 'sessionStorage' || source === 'timeBasedGeneration') {\n        // We have exact star data from session storage or time-based generation\n        star.x = seed.x;\n        star.y = seed.y;\n        star.baseY = seed.baseY;\n        star.z = seed.z;\n        star.size = seed.size;\n        star.baseOpacity = seed.baseOpacity;\n        star.opacity = seed.opacity;\n        star.color = COLORS.stars[seed.color !== undefined ? seed.color : Math.floor(Math.random() * COLORS.stars.length)];\n        star.pulsePhase = seed.pulsePhase;\n        star.pulseSpeed = seed.pulseSpeed;\n        star.movementSpeed = seed.movementSpeed;\n        star.driftDirectionX = seed.driftDirectionX;\n        star.driftDirectionY = seed.driftDirectionY;\n        star.driftSpeed = seed.driftSpeed;\n        star.parallaxFactor = seed.parallaxFactor;\n        star.state = seed.state || 'visible';\n        star.fadeProgress = seed.fadeProgress || 1;\n        star.fadeStart = seed.fadeStart;\n        star.originalSeed = seed.originalSeed;\n      } else {\n        // Original random generation code path\n        // Store original seeds for future reference\n        star.xSeed = seed.xSeed;\n        star.ySeed = seed.ySeed;\n\n        // Position - use seeds but adapt to current screen dimensions\n        star.x = seed.xSeed * width;\n        // Initial y position - distributed vertically across multiple screen heights\n        star.baseY = (seed.ySeed + CONFIG.offscreenBufferFactor) * height;\n        star.y = star.baseY;\n        star.z = seed.zSeed; // Depth (0.1 to 0.9)\n\n        // Visual properties\n        star.size = (seed.sizeSeed * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n        star.baseOpacity = seed.opacitySeed * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n        star.opacity = star.baseOpacity; // Start fully visible\n\n        // Animation properties\n        star.pulsePhase = seed.phaseSeed;\n        star.pulseSpeed = seed.pulseSpeedSeed;\n        star.movementSpeed = seed.speedSeed * CONFIG.baseMovementSpeed * (1.1 - star.z);\n\n        // Drift movement properties (enhanced)\n        star.driftDirectionX = seed.driftDirectionXSeed;\n        star.driftDirectionY = seed.driftDirectionYSeed;\n        // Normalize the direction vector\n        const dirMagnitude = Math.sqrt(star.driftDirectionX ** 2 + star.driftDirectionY ** 2) || 1;\n        star.driftDirectionX /= dirMagnitude;\n        star.driftDirectionY /= dirMagnitude;\n        // Vary the drift speed between stars\n        star.driftSpeed = CONFIG.driftSpeed + (seed.driftSpeedSeed * 2 - 1) * CONFIG.driftSpeedVariation;\n\n        // Star state tracking\n        star.state = 'visible'; // Start visible, not fading in\n        star.fadeProgress = 1; // Fully visible\n\n        // Parallax properties (for scrolling effect)\n        // Make deeper stars (higher z) move less for realistic parallax\n        star.parallaxFactor = seed.parallaxFactorSeed * CONFIG.parallaxFactor * (1 - star.z * 0.5);\n\n        // Color variation\n        star.color = COLORS.stars[seed.colorIndex];\n      }\n\n      // Common initialization for all stars\n      star.directionChangeTimer = 0;\n      star.velocity = 0;\n      star.targetY = star.y;\n      star.lastX = star.x;\n      star.lastY = star.y;\n\n      // Initialize twinkling properties if not already set\n      if (!star.twinkleState) {\n        star.twinkleState = 'visible';\n        star.twinkleProgress = 0;\n        star.twinkleDuration = Math.random() * (CONFIG.twinkleDuration[1] - CONFIG.twinkleDuration[0]) + CONFIG.twinkleDuration[0];\n      }\n\n      // Add to collection\n      starsRef.current.push(star);\n    }\n  }, [CONFIG.offscreenBufferFactor, CONFIG.starSizeMax, CONFIG.starSizeMin, CONFIG.starOpacityMax, CONFIG.starOpacityMin, CONFIG.baseMovementSpeed, CONFIG.driftSpeed, CONFIG.driftSpeedVariation, CONFIG.parallaxFactor, CONFIG.twinkleDuration, COLORS.stars, getSessionConfiguration]);\n\n  // Check if a star is off-screen\n  const isStarOffScreen = useCallback(star => {\n    const {\n      width,\n      height\n    } = dimensionsRef.current;\n    const buffer = CONFIG.offscreenBuffer;\n    return star.x < -buffer || star.x > width + buffer || star.y < -buffer || star.y > height + buffer;\n  }, [CONFIG.offscreenBuffer]);\n\n  // Optimized star rendering with subtle trail effect\n  const drawStar = useCallback((ctx, star) => {\n    // Skip rendering completely invisible stars\n    if (star.opacity < 0.02) return;\n\n    // Draw subtle trail if enabled and star is moving\n    if (CONFIG.trailEnabled && (Math.abs(star.velocity) > 0.001 || Math.abs(star.lastX - star.x) > 0.1)) {\n      // Calculate trail direction based on movement\n      const trailX = star.lastX !== undefined ? star.lastX : star.x - star.velocity * 5;\n      const trailY = star.lastY !== undefined ? star.lastY : star.y - star.velocity * 5;\n\n      // Ensure the trail is very subtle\n      ctx.beginPath();\n      ctx.moveTo(star.x, star.y);\n      ctx.lineTo(trailX, trailY);\n      ctx.strokeStyle = getColor(star.color, star.opacity * CONFIG.trailOpacityFactor);\n      ctx.lineWidth = star.size * 0.6;\n      ctx.lineCap = 'round';\n      ctx.stroke();\n    }\n\n    // Store current position for next frame's trail\n    star.lastX = star.x;\n    star.lastY = star.y;\n\n    // Simplified star rendering without creating new gradients every frame\n    ctx.beginPath();\n    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n    ctx.fillStyle = getColor(star.color, star.opacity);\n    ctx.fill();\n\n    // Simplified glow effect without expensive gradient creation\n    if (star.opacity > 0.3) {\n      ctx.beginPath();\n      ctx.arc(star.x, star.y, star.size * 1.8, 0, Math.PI * 2);\n      ctx.fillStyle = getColor(star.color, star.opacity * 0.4);\n      ctx.fill();\n    }\n  }, [CONFIG.trailEnabled, CONFIG.trailOpacityFactor, getColor]);\n\n  // Render the stars on the canvas\n  const renderStars = useCallback(() => {\n    if (!canvasRef.current) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d', {\n      alpha: false\n    });\n    if (!ctx) return;\n    const {\n      width,\n      height,\n      pixelRatio\n    } = dimensionsRef.current;\n\n    // Fill with background color instead of clearing to prevent flickering\n    ctx.fillStyle = COLORS.background.topColor;\n    ctx.fillRect(0, 0, width * pixelRatio, height * pixelRatio);\n\n    // Apply device pixel ratio scaling only once\n    ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n\n    // Enable global composition for better glow effect\n    ctx.globalCompositeOperation = 'lighter';\n\n    // Draw stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n      drawStar(ctx, star);\n    }\n\n    // Reset global composition\n    ctx.globalCompositeOperation = 'source-over';\n  }, [drawStar, COLORS.background.topColor]);\n\n  // Update animation state - optimized for performance\n  const updateAnimation = useCallback((deltaTime, timestamp) => {\n    const currentScrollY = springScrollYRef.current;\n    lastScrollYRef.current = currentScrollY;\n\n    // Global time factor for animations\n    const timeFactor = timestamp * 0.001;\n    const currentTime = Date.now();\n\n    // Track stars to replace (avoid modifying array during iteration)\n    const starsToReplace = [];\n\n    // Count currently fading stars to manage random fading\n    let fadingCount = 0;\n    if (CONFIG.randomFadingEnabled) {\n      fadingCount = starsRef.current.filter(star => star.state === 'fading-out' || star.state === 'fading-in').length;\n    }\n\n    // Update stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n\n      // Handle star state transitions\n      if (star.state === 'fading-in') {\n        // Calculate progress for fade-in\n        const elapsed = currentTime - star.fadeStart;\n        star.fadeProgress = Math.min(1, elapsed / CONFIG.fadeInDuration);\n        star.opacity = star.baseOpacity * star.fadeProgress;\n\n        // Complete fade-in\n        if (star.fadeProgress >= 1) {\n          star.state = 'visible';\n          star.opacity = star.baseOpacity;\n        }\n      } else if (star.state === 'fading-out') {\n        // Calculate progress for fade-out\n        const elapsed = currentTime - star.fadeStart;\n        star.fadeProgress = Math.max(0, 1 - elapsed / CONFIG.fadeOutDuration);\n        star.opacity = star.baseOpacity * star.fadeProgress;\n\n        // Complete fade-out - mark for replacement\n        if (star.fadeProgress <= 0) {\n          starsToReplace.push(i);\n        }\n      } else {\n        // Normal visible state\n\n        // Random fading (new feature)\n        if (CONFIG.randomFadingEnabled && fadingCount < CONFIG.maxSimultaneousFading && Math.random() < CONFIG.randomFadeOutProbability * deltaTime) {\n          // Start fade-out process for random star\n          star.state = 'fading-out';\n          star.fadeStart = currentTime;\n          fadingCount++;\n          continue; // Skip the rest of the loop for this star\n        }\n\n        // Calculate parallax effect based on scroll position\n        if (CONFIG.parallaxEnabled) {\n          // Update target position based on scroll (parallax effect)\n          star.targetY = star.baseY - currentScrollY * star.parallaxFactor;\n        }\n\n        // Apply spring physics for bouncy effect\n        const displacement = star.targetY - star.y;\n        const springForce = displacement * CONFIG.springStrength;\n\n        // Update velocity with spring force\n        star.velocity += springForce;\n\n        // Apply damping to velocity\n        star.velocity *= CONFIG.dampingFactor;\n\n        // Add velocity clamping to prevent extreme bouncing\n        const maxVelocity = 1.0; // Maximum allowed velocity\n        star.velocity = Math.max(-maxVelocity, Math.min(maxVelocity, star.velocity));\n\n        // Update position based on velocity (for parallax)\n        star.y += star.velocity;\n\n        // Apply drift movement if enabled\n        if (CONFIG.driftEnabled) {\n          // Apply movement with additional smoothing to prevent jumps\n          // Calculate the intended movement\n          const dx = star.driftDirectionX * star.driftSpeed * deltaTime;\n          const dy = star.driftDirectionY * star.driftSpeed * deltaTime;\n\n          // Apply a maximum movement limit to prevent jumps\n          const maxMove = 0.5; // Maximum pixels to move per frame\n          const actualDx = Math.abs(dx) > maxMove ? Math.sign(dx) * maxMove : dx;\n          const actualDy = Math.abs(dy) > maxMove ? Math.sign(dy) * maxMove : dy;\n\n          // Move star based on limited movement\n          star.x += actualDx;\n          // Add the drift to baseY (which is the reference point for parallax)\n          star.baseY += actualDy;\n          star.targetY = star.baseY - currentScrollY * star.parallaxFactor;\n\n          // Occasionally change drift direction with smoother transitions\n          star.directionChangeTimer += deltaTime;\n          if (Math.random() < CONFIG.directionChangeFrequency * deltaTime) {\n            // Gradually change direction by adding a small random vector\n            // Use the directionChangeAmount to limit the magnitude of the change\n            const changeX = (Math.random() * 2 - 1) * CONFIG.directionChangeAmount;\n            const changeY = (Math.random() * 2 - 1) * CONFIG.directionChangeAmount;\n\n            // Apply a small percentage of the change for smoother transitions\n            star.driftDirectionX += changeX;\n            star.driftDirectionY += changeY;\n\n            // Re-normalize the direction vector with safety checks\n            const dirMagnitude = Math.sqrt(star.driftDirectionX ** 2 + star.driftDirectionY ** 2) || 1;\n\n            // Prevent jittery movement by ensuring minimum magnitude\n            if (dirMagnitude < 0.01) {\n              // If direction vector is too small, reset to a random direction\n              star.driftDirectionX = Math.random() * 2 - 1;\n              star.driftDirectionY = Math.random() * 2 - 1;\n              const newMagnitude = Math.sqrt(star.driftDirectionX ** 2 + star.driftDirectionY ** 2) || 1;\n              star.driftDirectionX /= newMagnitude;\n              star.driftDirectionY /= newMagnitude;\n            } else {\n              star.driftDirectionX /= dirMagnitude;\n              star.driftDirectionY /= dirMagnitude;\n            }\n          }\n        }\n\n        // Check if star is now off-screen\n        if (CONFIG.regenerateOffscreenStars && isStarOffScreen(star) && star.state === 'visible') {\n          // Start fade-out process\n          star.state = 'fading-out';\n          star.fadeStart = currentTime;\n        }\n\n        // Simplified pulsing effect\n        const pulseFactor = Math.sin(timeFactor * star.pulseSpeed + star.pulsePhase) * 0.15 + 0.85;\n        // Only apply pulsing if not in a transition state\n        if (star.state === 'visible') {\n          star.opacity = star.baseOpacity * pulseFactor;\n        }\n      }\n    }\n\n    // Replace stars that have completed fade-out (in reverse order to avoid index issues)\n    for (let i = starsToReplace.length - 1; i >= 0; i--) {\n      const index = starsToReplace[i];\n      // Create a new star to replace the off-screen one\n      const newStar = createNewStar(starsRef.current[index]);\n      // Replace the star in the array\n      starsRef.current[index] = newStar;\n    }\n\n    // Save state periodically for persistence\n    if (CONFIG.persistenceEnabled && timestamp % CONFIG.persistenceInterval < 16) {\n      saveCurrentState();\n    }\n  }, [CONFIG.randomFadingEnabled, CONFIG.maxSimultaneousFading, CONFIG.randomFadeOutProbability, CONFIG.fadeInDuration, CONFIG.fadeOutDuration, CONFIG.parallaxEnabled, CONFIG.springStrength, CONFIG.dampingFactor, CONFIG.driftEnabled, CONFIG.directionChangeFrequency, CONFIG.directionChangeAmount, CONFIG.regenerateOffscreenStars, CONFIG.persistenceEnabled, CONFIG.persistenceInterval, isStarOffScreen, createNewStar, saveCurrentState]);\n\n  // Define the animation loop function\n  const animate = useCallback(function animationLoop(timestamp) {\n    if (!isInitializedRef.current) {\n      animationFrameRef.current = requestAnimationFrame(animationLoop);\n      return;\n    }\n\n    // Limit FPS\n    const minFrameTime = 1000 / CONFIG.maxFPS;\n    const elapsed = timestamp - (lastTimeRef.current || 0);\n    if (elapsed < minFrameTime) {\n      animationFrameRef.current = requestAnimationFrame(animationLoop);\n      return;\n    }\n\n    // Calculate delta time with cap to prevent large jumps\n    const deltaTime = lastTimeRef.current ? Math.min(elapsed, 50) : 16;\n    lastTimeRef.current = timestamp;\n\n    // Update animation state\n    updateAnimation(deltaTime, timestamp);\n\n    // Render scene\n    renderStars();\n\n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(animationLoop);\n  }, [CONFIG.maxFPS, updateAnimation, renderStars]);\n\n  // Initialize the stars when component mounts or dimensions change\n  useEffect(() => {\n    // One-time initialization function\n    const initialize = () => {\n      if (setupCanvas()) {\n        // Synchronously restore scroll position before first render if available\n        if (CONFIG.persistenceEnabled) {\n          try {\n            const savedScrollY = sessionStorage.getItem(CONFIG.scrollPositionKey);\n            if (savedScrollY !== null) {\n              // Set both the spring value and the ref value immediately\n              springScrollY.set(parseFloat(savedScrollY));\n              springScrollYRef.current = parseFloat(savedScrollY);\n            }\n          } catch (error) {\n            console.warn('Could not restore scroll position', error);\n          }\n        }\n\n        // Create stars only after canvas is ready\n        initializeStars();\n        // Mark as initialized but don't trigger re-render\n        isInitializedRef.current = true;\n        // Start animation only after everything is ready\n        animationFrameRef.current = requestAnimationFrame(animate);\n      }\n    };\n\n    // Handle resize events\n    const handleResize = () => {\n      // Only re-initialize if already initialized\n      if (isInitializedRef.current) {\n        setupCanvas();\n        initializeStars();\n        // No need to change initialization state\n      }\n    };\n\n    // Throttle resize events\n    let resizeTimer;\n    const throttledResize = () => {\n      if (!resizeTimer) {\n        resizeTimer = setTimeout(() => {\n          resizeTimer = null;\n          handleResize();\n        }, 200); // 200ms throttle\n      }\n    };\n\n    // Add resize listener\n    window.addEventListener('resize', throttledResize);\n\n    // Run initialization after first render is complete\n    // This prevents the \"double load\" effect\n    requestAnimationFrame(() => {\n      firstRenderCompleteRef.current = true;\n      initialize();\n    });\n\n    // Cleanup\n    return () => {\n      window.removeEventListener('resize', throttledResize);\n      if (resizeTimer) clearTimeout(resizeTimer);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [setupCanvas, initializeStars, animate, CONFIG.persistenceEnabled, CONFIG.scrollPositionKey, springScrollY]);\n\n  // Add navigation event handlers to save state when user leaves\n  useEffect(() => {\n    if (!CONFIG.persistenceEnabled) return;\n    const handleVisibilityChange = () => {\n      if (document.visibilityState === 'hidden') {\n        saveCurrentState();\n      }\n    };\n    const handleBeforeUnload = () => {\n      saveCurrentState();\n    };\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    window.addEventListener('beforeunload', handleBeforeUnload);\n    return () => {\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n      saveCurrentState();\n    };\n  }, [CONFIG.persistenceEnabled, saveCurrentState]);\n\n  // Calculate background colors\n  const backgroundColors = useMemo(() => {\n    var _COLORS$background, _COLORS$background2;\n    return {\n      topColor: ((_COLORS$background = COLORS.background) === null || _COLORS$background === void 0 ? void 0 : _COLORS$background.topColor) || 'rgb(8, 8, 12)',\n      bottomColor: ((_COLORS$background2 = COLORS.background) === null || _COLORS$background2 === void 0 ? void 0 : _COLORS$background2.bottomColor) || 'rgb(15, 15, 20)'\n    };\n  }, [COLORS.background]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      width: '100vw',\n      height: '100vh',\n      overflow: 'hidden',\n      zIndex: -1,\n      pointerEvents: 'none',\n      background: `linear-gradient(to bottom, ${backgroundColors.topColor}, ${backgroundColors.bottomColor})`\n    },\n    \"aria-hidden\": \"true\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1166,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1152,\n    columnNumber: 5\n  }, this);\n};\n_s(CosmicStars, \"Mchfg5GMmWUE217Y7AUY0YRTRTk=\", false, function () {\n  return [useScroll, useSpring];\n});\n_c = CosmicStars;\nexport default CosmicStars;\nvar _c;\n$RefreshReg$(_c, \"CosmicStars\");","map":{"version":3,"names":["React","useRef","useEffect","useCallback","useMemo","useScroll","useSpring","jsxDEV","_jsxDEV","CosmicStars","config","_s","canvasRef","starsRef","animationFrameRef","lastTimeRef","lastScrollYRef","isInitializedRef","firstRenderCompleteRef","dimensionsRef","width","height","pixelRatio","scrollY","smooth","springScrollY","stiffness","damping","mass","restDelta","restSpeed","springScrollYRef","unsubscribe","onChange","value","current","CONFIG","starCount","starSizeMin","starSizeMax","starOpacityMin","starOpacityMax","baseMovementSpeed","pulseFrequency","parallaxEnabled","parallaxFactor","trailEnabled","trailLength","trailOpacityFactor","twinkleEnabled","twinkleProbability","twinkleDuration","randomFadingEnabled","randomFadeOutProbability","maxSimultaneousFading","driftEnabled","driftSpeed","driftSpeedVariation","directionChangeFrequency","directionChangeAmount","regenerateOffscreenStars","fadeInDuration","fadeOutDuration","offscreenBuffer","springStrength","dampingFactor","verticalSpreadFactor","offscreenBufferFactor","maxFPS","persistenceEnabled","persistenceInterval","timeBasedFallback","persistenceMaxAge","sessionKey","scrollPositionKey","lastVisitKey","COLORS","stars","background","topColor","bottomColor","colors","colorCache","cache","forEach","baseColor","opacity","replace","getColor","safeOpacity","Math","max","min","roundedOpacity","round","seededRandom","seed","getDateSeed","now","Date","getFullYear","getMonth","getDate","setupCanvas","canvas","window","innerWidth","innerHeight","devicePixelRatio","style","ctx","getContext","alpha","fillStyle","fillRect","generateTimeBasedStars","dateSeed","i","starSeed","starRandom","star","x","baseY","y","z","size","baseOpacity","color","floor","length","pulsePhase","PI","pulseSpeed","movementSpeed","driftDirectionX","driftDirectionY","dirMagnitude","sqrt","directionChangeTimer","state","fadeProgress","targetY","velocity","lastX","lastY","twinkleState","twinkleProgress","originalSeed","push","saveCurrentState","currentTime","sessionStorage","setItem","toString","completeState","version","timestamp","viewport","map","indexOf","fadeStart","JSON","stringify","error","console","warn","createNewStar","offScreenStar","random","edgeBuffer","isInitialCreation","getSessionConfiguration","starSeeds","storedState","getItem","savedState","parse","stateAge","undefined","prevViewport","scaleX","scaleY","source","timeBasedStars","Array","from","xSeed","ySeed","zSeed","sizeSeed","opacitySeed","phaseSeed","speedSeed","pulseSpeedSeed","colorIndex","parallaxFactorSeed","driftDirectionXSeed","driftDirectionYSeed","driftSpeedSeed","initializeStars","existingWidth","existingHeight","widthChange","abs","heightChange","isNaN","sessionConfig","isStarOffScreen","buffer","drawStar","trailX","trailY","beginPath","moveTo","lineTo","strokeStyle","lineWidth","lineCap","stroke","arc","fill","renderStars","setTransform","globalCompositeOperation","updateAnimation","deltaTime","currentScrollY","timeFactor","starsToReplace","fadingCount","filter","elapsed","displacement","springForce","maxVelocity","dx","dy","maxMove","actualDx","sign","actualDy","changeX","changeY","newMagnitude","pulseFactor","sin","index","newStar","animate","animationLoop","requestAnimationFrame","minFrameTime","initialize","savedScrollY","set","parseFloat","handleResize","resizeTimer","throttledResize","setTimeout","addEventListener","removeEventListener","clearTimeout","cancelAnimationFrame","handleVisibilityChange","document","visibilityState","handleBeforeUnload","backgroundColors","_COLORS$background","_COLORS$background2","position","top","left","overflow","zIndex","pointerEvents","children","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/CosmicStars.jsx"],"sourcesContent":["import React, { useRef, useEffect, useCallback, useMemo } from 'react';\nimport { useScroll, useSpring } from 'framer-motion';\n\n/**\n * CosmicStars Component\n * \n * Renders an immersive, performance-optimized starry background\n * with parallax scrolling, gentle random drifting, and state persistence.\n * \n * @param {Object} config - Configuration options to customize the star field\n * @returns {React.Component} A fixed position canvas element rendering animated stars\n * \n * @example\n * // Basic usage\n * <CosmicStars />\n * \n * @example\n * // Custom configuration\n * <CosmicStars \n *   config={{\n *     starCount: 200,\n *     parallaxFactor: 0.3,\n *     colors: {\n *       stars: ['rgba(255, 243, 200, alpha)', 'rgba(255, 231, 164, alpha)'],\n *       background: { topColor: '#000', bottomColor: '#111' }\n *     }\n *   }}\n * />\n */\nconst CosmicStars = ({ config = {} }) => {\n  // Refs for DOM elements and animation state\n  const canvasRef = useRef(null);\n  const starsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimeRef = useRef(0);\n  const lastScrollYRef = useRef(0);\n  \n  // Use refs instead of state to prevent re-renders\n  const isInitializedRef = useRef(false);\n  const firstRenderCompleteRef = useRef(false);\n  \n  // Store dimensions in a ref to avoid re-renders when they change\n  const dimensionsRef = useRef({ width: 0, height: 0, pixelRatio: 1 });\n  \n  // Get scroll position using framer-motion\n  const { scrollY } = useScroll({\n    smooth: 0.05  // Smoother scrolling for high-framerate animations\n  });\n  \n  // Use spring physics for smoother scrolling effect\n  const springScrollY = useSpring(scrollY, {\n    stiffness: 1,\n    damping: 5,\n    mass: 0.5,\n    restDelta: 0.001,\n    restSpeed: 0.001\n  });\n  \n  // Track spring scrollY value without causing re-renders\n  const springScrollYRef = useRef(0);\n  useEffect(() => {\n    const unsubscribe = springScrollY.onChange(value => {\n      springScrollYRef.current = value;\n    });\n    return () => unsubscribe();\n  }, [springScrollY]);\n  \n  // Configuration - wrapped in useMemo to prevent recreation on each render\n  // Merge default config with user-provided config\n  const CONFIG = useMemo(() => ({\n    // Star appearance\n    starCount: 100,\n    starSizeMin: 1.0,\n    starSizeMax: 1.9,\n    starOpacityMin: 0.2,\n    starOpacityMax: 0.55,\n    \n    // Parallax and movement parameters\n    baseMovementSpeed: 0.00001,  // Reduced for slower movement\n    pulseFrequency: 0.00002,     // Slower pulsing\n    parallaxEnabled: true,\n    parallaxFactor: 0.2,  // How much stars move relative to scroll (0-1)\n    \n    // Trail effect parameters\n    trailEnabled: true,          // Enable subtle trails\n    trailLength: 2,              // Very short trail length (in pixels)\n    trailOpacityFactor: 0.5,     // Trail opacity relative to star opacity\n    \n    // Twinkling effect parameters\n    twinkleEnabled: true,        // Enable stars to fade in and out\n    twinkleProbability: 0.01,    // Probability of a star beginning to twinkle each frame\n    twinkleDuration: [2000, 4000], // Min and max duration of a twinkle cycle in ms\n    \n    // Random fading parameters\n    randomFadingEnabled: true,    // Enable random fading of stars\n    randomFadeOutProbability: 0.0003, // Probability of a star randomly starting to fade out per frame\n    maxSimultaneousFading: 10,    // Maximum number of stars that can be fading at once\n    \n    // Drifting movement parameters\n    driftEnabled: true,            // Enable slow drifting movement\n    driftSpeed: 0.01,              // Base speed of drift movement (pixels per second)\n    driftSpeedVariation: 0.005,    // Variation in drift speed between stars\n    directionChangeFrequency: 0.0005, // Probability of changing direction each frame\n    directionChangeAmount: 0.05,   // How much direction can change at once (lower = smoother)\n    \n    // Star regeneration parameters\n    regenerateOffscreenStars: true, // Replace off-screen stars instead of wrapping\n    fadeInDuration: 2000,          // Duration for new stars to fade in (ms)\n    fadeOutDuration: 1500,         // Duration for off-screen stars to fade out (ms)\n    offscreenBuffer: 50,           // Distance beyond viewport to trigger regeneration (px)\n    \n    // Physics parameters for bouncy effect\n    springStrength: 0.03,  // Higher = snappier\n    dampingFactor: 0.95,    // Higher = less bouncy (0-1)\n    \n    // Star distribution parameters\n    verticalSpreadFactor: 3,  // How many screen heights to spread stars across\n    offscreenBufferFactor: 1, // How many screen heights above viewport to generate stars\n    \n    // Performance parameters\n    maxFPS: 60,\n    \n    // Enhanced persistence settings\n    persistenceEnabled: true,        // Enable persistence features\n    persistenceInterval: 3000,       // Save every 3 seconds (milliseconds)\n    timeBasedFallback: true,         // Use time-based generation as fallback\n    persistenceMaxAge: 7 * 24 * 60 * 60 * 1000, // 7 days before regenerating (milliseconds)\n    \n    // Session persistence keys\n    sessionKey: 'cosmic_stars_background_config',\n    scrollPositionKey: 'cosmic_stars_background_scroll',\n    lastVisitKey: 'cosmic_stars_background_last_visit',\n    \n    // Override with user config\n    ...config\n  }), [config]);\n  \n  // Star colors - wrapped in useMemo\n  const COLORS = useMemo(() => ({\n    // Star colors\n    stars: [\n      'rgba(255, 243, 200, alpha)', // Warm yellow\n      'rgba(255, 231, 164, alpha)', // Golden\n      'rgba(252, 249, 231, alpha)'  // Off-white gold\n    ],\n    \n    // Background gradient colors\n    background: {\n      topColor: 'rgb(8, 8, 12)',\n      bottomColor: 'rgb(15, 15, 20)'\n    },\n    \n    // Override with user config if provided\n    ...(config.colors || {})\n  }), [config.colors]);\n  \n  // Pre-generated color values to avoid string replacements during animation\n  const colorCache = useMemo(() => {\n    const cache = {};\n    COLORS.stars.forEach(baseColor => {\n      cache[baseColor] = {};\n      for (let opacity = 0; opacity <= 10; opacity++) {\n        const value = opacity / 10;\n        cache[baseColor][value] = baseColor.replace(/alpha\\)$/, `${value})`);\n      }\n    });\n    return cache;\n  }, [COLORS.stars]);\n  \n  // Get color with opacity from cache (faster than string replacement)\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    // Round to nearest 0.1 to use cached values\n    const roundedOpacity = Math.round(safeOpacity * 10) / 10;\n    return colorCache[baseColor][roundedOpacity] || baseColor.replace(/alpha\\)$/, `${safeOpacity})`);\n  }, [colorCache]);\n  \n  // Create a deterministic seeded random function\n  const seededRandom = useCallback((seed) => {\n    return () => {\n      seed = (seed * 9301 + 49297) % 233280;\n      return seed / 233280;\n    };\n  }, []);\n\n  // Get a seed based on current date (changes daily)\n  const getDateSeed = useCallback(() => {\n    const now = new Date();\n    return now.getFullYear() * 10000 + (now.getMonth() + 1) * 100 + now.getDate();\n  }, []);\n  \n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) return false;\n    \n    const canvas = canvasRef.current;\n    \n    // Get viewport dimensions\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const pixelRatio = window.devicePixelRatio || 1;\n    \n    // Set canvas size accounting for pixel ratio\n    canvas.width = width * pixelRatio;\n    canvas.height = height * pixelRatio;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n    \n    // Ensure canvas is visible with a background color (use alpha: false for no flicker)\n    const ctx = canvas.getContext('2d', { alpha: false });\n    if (ctx) {\n      // Fill with background color immediately to prevent flickering\n      ctx.fillStyle = COLORS.background.topColor;\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    \n    // Update dimensions ref instead of state\n    dimensionsRef.current = { width, height, pixelRatio };\n    \n    return true;\n  }, [COLORS.background.topColor]);\n  \n  // Generate time-based stars for consistency\n  const generateTimeBasedStars = useCallback(() => {\n    const { width, height } = dimensionsRef.current;\n    if (!width || !height) return [];\n    \n    // Create seed based on date\n    const dateSeed = getDateSeed();\n    \n    // Generate new stars with deterministic positioning\n    const stars = [];\n    \n    for (let i = 0; i < CONFIG.starCount; i++) {\n      // Generate a seed for this specific star (that will be the same each day)\n      const starSeed = dateSeed + i;\n      const starRandom = seededRandom(starSeed);\n      \n      // Create the star using deterministic properties\n      const star = {};\n      \n      // Position with some variance but tied to the date\n      star.x = starRandom() * width;\n      star.baseY = (starRandom() * CONFIG.verticalSpreadFactor - CONFIG.offscreenBufferFactor) * height;\n      star.y = star.baseY;\n      star.z = starRandom() * 0.8 + 0.1;\n      \n      // Visual properties\n      star.size = (starRandom() * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n      star.baseOpacity = starRandom() * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n      star.opacity = star.baseOpacity;\n      star.color = COLORS.stars[Math.floor(starRandom() * COLORS.stars.length)];\n      \n      // Animation properties\n      star.pulsePhase = starRandom() * Math.PI * 2;\n      star.pulseSpeed = starRandom() * 0.002 + 0.001;\n      star.movementSpeed = (starRandom() * 0.2 + 0.9) * CONFIG.baseMovementSpeed * (1.1 - star.z);\n      \n      // Drift properties\n      star.driftDirectionX = starRandom() * 2 - 1;\n      star.driftDirectionY = starRandom() * 2 - 1;\n      // Normalize direction\n      const dirMagnitude = Math.sqrt(star.driftDirectionX ** 2 + star.driftDirectionY ** 2) || 1;\n      star.driftDirectionX /= dirMagnitude;\n      star.driftDirectionY /= dirMagnitude;\n      star.driftSpeed = CONFIG.driftSpeed + (starRandom() * 2 - 1) * CONFIG.driftSpeedVariation;\n      star.directionChangeTimer = 0;\n      \n      // Initial state\n      star.state = 'visible';\n      star.fadeProgress = 1;\n      star.targetY = star.y;\n      star.velocity = 0;\n      star.lastX = star.x;\n      star.lastY = star.y;\n      \n      // Parallax properties\n      star.parallaxFactor = starRandom() * 0.5 * CONFIG.parallaxFactor * (1 - star.z * 0.5);\n      \n      // Initialize twinkling properties\n      star.twinkleState = 'visible';\n      star.twinkleProgress = 0;\n      star.twinkleDuration = starRandom() * \n        (CONFIG.twinkleDuration[1] - CONFIG.twinkleDuration[0]) + \n        CONFIG.twinkleDuration[0];\n      \n      // Store original seed for future reference\n      star.originalSeed = starSeed;\n      \n      stars.push(star);\n    }\n    \n    return stars;\n  }, [\n    CONFIG.starCount, \n    CONFIG.verticalSpreadFactor, \n    CONFIG.offscreenBufferFactor,\n    CONFIG.starSizeMax,\n    CONFIG.starSizeMin,\n    CONFIG.starOpacityMax,\n    CONFIG.starOpacityMin,\n    CONFIG.baseMovementSpeed,\n    CONFIG.driftSpeed,\n    CONFIG.driftSpeedVariation,\n    CONFIG.parallaxFactor,\n    CONFIG.twinkleDuration,\n    COLORS.stars,\n    getDateSeed,\n    seededRandom\n  ]);\n  \n  // Save the current star state and scroll position\n  const saveCurrentState = useCallback(() => {\n    if (!starsRef.current.length || !dimensionsRef.current.width || !CONFIG.persistenceEnabled) {\n      return;\n    }\n    \n    try {\n      // Record current time\n      const currentTime = Date.now();\n      \n      // Save current scroll position separately for quick access\n      sessionStorage.setItem(CONFIG.scrollPositionKey, springScrollYRef.current.toString());\n      \n      // Save last visit time\n      sessionStorage.setItem(CONFIG.lastVisitKey, currentTime.toString());\n      \n      // Prepare complete star state \n      const completeState = {\n        version: \"1.0\", // For future compatibility\n        timestamp: currentTime,\n        dateSeed: getDateSeed(), // Store the seed for time-based fallback\n        scrollY: springScrollYRef.current,\n        viewport: {\n          width: dimensionsRef.current.width,\n          height: dimensionsRef.current.height,\n          pixelRatio: dimensionsRef.current.pixelRatio\n        },\n        stars: starsRef.current.map(star => ({\n          // Position data\n          x: star.x,\n          y: star.y, \n          baseY: star.baseY,\n          z: star.z,\n          \n          // Visual properties\n          size: star.size,\n          baseOpacity: star.baseOpacity,\n          opacity: star.opacity,\n          color: COLORS.stars.indexOf(star.color),\n          \n          // Animation data\n          pulsePhase: star.pulsePhase,\n          pulseSpeed: star.pulseSpeed,\n          driftDirectionX: star.driftDirectionX,\n          driftDirectionY: star.driftDirectionY,\n          driftSpeed: star.driftSpeed,\n          movementSpeed: star.movementSpeed,\n          parallaxFactor: star.parallaxFactor,\n          \n          // State\n          state: star.state,\n          fadeProgress: star.fadeProgress,\n          fadeStart: star.fadeStart ? currentTime - (currentTime - star.fadeStart) : null,\n          \n          // For fallback/time consistency\n          originalSeed: star.originalSeed || null\n        }))\n      };\n      \n      // Save complete state\n      sessionStorage.setItem(CONFIG.sessionKey, JSON.stringify(completeState));\n      \n    } catch (error) {\n      console.warn('Could not save star state to session storage', error);\n    }\n  }, [CONFIG.persistenceEnabled, CONFIG.scrollPositionKey, CONFIG.lastVisitKey, CONFIG.sessionKey, COLORS.stars, getDateSeed]);\n  \n  // Create a new star at random position\n  const createNewStar = useCallback((offScreenStar = null) => {\n    const { width, height } = dimensionsRef.current;\n    const star = {};\n    \n    // If replacing an existing star, preserve some properties\n    if (offScreenStar) {\n      star.z = offScreenStar.z;\n      star.size = offScreenStar.size;\n      star.baseOpacity = offScreenStar.baseOpacity;\n      star.pulsePhase = Math.random() * Math.PI * 2; // New phase\n      star.color = offScreenStar.color;\n      star.parallaxFactor = offScreenStar.parallaxFactor;\n      star.originalSeed = offScreenStar.originalSeed; // Preserve seed if available\n    } else {\n      // Otherwise generate new properties\n      star.z = Math.random() * 0.8 + 0.1;\n      star.size = (Math.random() * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n      star.baseOpacity = Math.random() * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n      star.pulsePhase = Math.random() * Math.PI * 2;\n      star.color = COLORS.stars[Math.floor(Math.random() * COLORS.stars.length)];\n      star.parallaxFactor = Math.random() * 0.5 * CONFIG.parallaxFactor * (1 - star.z * 0.5);\n      star.originalSeed = Math.random(); // New random seed\n    }\n    \n    // Generate position\n    // Avoid edges by using 10% inset from the viewport dimensions\n    const edgeBuffer = Math.min(width, height) * 0.1;\n    star.x = edgeBuffer + Math.random() * (width - 2 * edgeBuffer);\n    star.baseY = edgeBuffer + Math.random() * (height - 2 * edgeBuffer);\n    star.y = star.baseY;\n    star.targetY = star.y;\n    \n    // For new stars during runtime, fade them in\n    // For initial stars, start them fully visible\n    const isInitialCreation = !isInitializedRef.current;\n    if (isInitialCreation) {\n      star.opacity = star.baseOpacity;\n      star.state = 'visible';\n      star.fadeProgress = 1;\n    } else {\n      star.opacity = 0;\n      star.state = 'fading-in';\n      star.fadeProgress = 0;\n      star.fadeStart = Date.now();\n    }\n    \n    // Movement properties\n    star.pulseSpeed = Math.random() * 0.002 + 0.001;\n    star.movementSpeed = (Math.random() * 0.2 + 0.9) * CONFIG.baseMovementSpeed * (1.1 - star.z);\n    \n    // Drift movement properties\n    star.driftDirectionX = Math.random() * 2 - 1;\n    star.driftDirectionY = Math.random() * 2 - 1;\n    // Normalize the direction vector\n    const dirMagnitude = Math.sqrt(star.driftDirectionX ** 2 + star.driftDirectionY ** 2) || 1;\n    star.driftDirectionX /= dirMagnitude;\n    star.driftDirectionY /= dirMagnitude;\n    // Vary the drift speed between stars\n    star.driftSpeed = CONFIG.driftSpeed + (Math.random() * 2 - 1) * CONFIG.driftSpeedVariation;\n    star.directionChangeTimer = 0;\n    \n    // Initialize velocity and position tracking for trails\n    star.velocity = 0;\n    star.lastX = star.x;\n    star.lastY = star.y;\n    \n    // Initialize twinkling properties\n    star.twinkleState = 'visible';\n    star.twinkleProgress = 0;\n    star.twinkleDuration = Math.random() * \n      (CONFIG.twinkleDuration[1] - CONFIG.twinkleDuration[0]) + \n      CONFIG.twinkleDuration[0];\n    \n    // Physics properties\n    star.velocity = 0;\n    \n    return star;\n  }, [\n    CONFIG.starSizeMax, \n    CONFIG.starSizeMin, \n    CONFIG.starOpacityMax, \n    CONFIG.starOpacityMin,\n    CONFIG.baseMovementSpeed,\n    CONFIG.driftSpeed,\n    CONFIG.driftSpeedVariation,\n    CONFIG.parallaxFactor,\n    CONFIG.twinkleDuration,\n    COLORS.stars\n  ]);\n  \n  // Get previously saved configuration or generate new one\n  const getSessionConfiguration = useCallback(() => {\n    // First ensure dimensions are set\n    if (!dimensionsRef.current.width) return { starSeeds: [] };\n    \n    // Check if we have a valid stored configuration\n    if (CONFIG.persistenceEnabled) {\n      try {\n        // Try to load existing configuration from sessionStorage\n        const storedState = sessionStorage.getItem(CONFIG.sessionKey);\n        \n        if (storedState) {\n          const savedState = JSON.parse(storedState);\n          \n          // Check if the saved state is still valid and not too old\n          const currentTime = Date.now();\n          const stateAge = currentTime - savedState.timestamp;\n          \n          // Use saved state if it's not too old and has the right number of stars\n          if (stateAge < CONFIG.persistenceMaxAge && \n              savedState.stars && \n              savedState.stars.length === CONFIG.starCount) {\n            \n            // Retrieve stored scroll position if available\n            if (savedState.scrollY !== undefined) {\n              // Store in ref to use in animation\n              springScrollYRef.current = savedState.scrollY;\n            }\n            \n            // Calculate scaling factors if viewport changed\n            const prevViewport = savedState.viewport || { \n              width: dimensionsRef.current.width, \n              height: dimensionsRef.current.height \n            };\n            \n            const scaleX = dimensionsRef.current.width / prevViewport.width;\n            const scaleY = dimensionsRef.current.height / prevViewport.height;\n            \n            // Return a starSeeds-compatible object for our existing code\n            return {\n              source: 'sessionStorage',\n              timestamp: savedState.timestamp,\n              starSeeds: savedState.stars.map(star => ({\n                // Convert saved stars to the seed format our initialization expects\n                x: star.x * scaleX,\n                y: star.y * scaleY,\n                baseY: star.baseY * scaleY,\n                z: star.z,\n                size: star.size,\n                baseOpacity: star.baseOpacity,\n                opacity: star.opacity,\n                color: star.color,\n                pulsePhase: star.pulsePhase,\n                pulseSpeed: star.pulseSpeed,\n                driftDirectionX: star.driftDirectionX,\n                driftDirectionY: star.driftDirectionY,\n                driftSpeed: star.driftSpeed,\n                movementSpeed: star.movementSpeed,\n                parallaxFactor: star.parallaxFactor,\n                state: star.state,\n                fadeProgress: star.fadeProgress,\n                fadeStart: star.fadeStart,\n                originalSeed: star.originalSeed\n              }))\n            };\n          }\n        }\n      } catch (error) {\n        console.warn('Could not load star configuration from session storage', error);\n      }\n    }\n    \n    // If no valid saved state or persistence disabled, use time-based approach\n    if (CONFIG.timeBasedFallback) {\n      const timeBasedStars = generateTimeBasedStars();\n      \n      // Convert to starSeeds format\n      return {\n        source: 'timeBasedGeneration',\n        timestamp: Date.now(),\n        starSeeds: timeBasedStars.map(star => ({\n          x: star.x,\n          y: star.y,\n          baseY: star.baseY,\n          z: star.z,\n          size: star.size,\n          baseOpacity: star.baseOpacity,\n          opacity: star.opacity,\n          color: COLORS.stars.indexOf(star.color),\n          pulsePhase: star.pulsePhase,\n          pulseSpeed: star.pulseSpeed,\n          driftDirectionX: star.driftDirectionX,\n          driftDirectionY: star.driftDirectionY,\n          driftSpeed: star.driftSpeed,\n          movementSpeed: star.movementSpeed,\n          parallaxFactor: star.parallaxFactor,\n          state: star.state,\n          fadeProgress: star.fadeProgress,\n          originalSeed: star.originalSeed\n        }))\n      };\n    }\n    \n    // Fallback to completely random generation\n    return { \n      source: 'random', \n      timestamp: Date.now(),\n      starSeeds: Array.from({ length: CONFIG.starCount }).map(() => ({\n        // Random properties for each star\n        xSeed: Math.random(),\n        ySeed: Math.random() * CONFIG.verticalSpreadFactor - CONFIG.offscreenBufferFactor,\n        zSeed: Math.random() * 0.8 + 0.1,\n        sizeSeed: Math.random(),\n        opacitySeed: Math.random(),\n        phaseSeed: Math.random() * Math.PI * 2,\n        speedSeed: Math.random() * 0.2 + 0.9,\n        pulseSpeedSeed: Math.random() * 0.002 + 0.001,\n        colorIndex: Math.floor(Math.random() * COLORS.stars.length),\n        parallaxFactorSeed: Math.random() * 0.5 + 0.1,\n        driftDirectionXSeed: Math.random() * 2 - 1,\n        driftDirectionYSeed: Math.random() * 2 - 1,\n        driftSpeedSeed: Math.random()\n      }))\n    };\n  }, [\n    CONFIG.persistenceEnabled, \n    CONFIG.persistenceMaxAge, \n    CONFIG.sessionKey, \n    CONFIG.starCount,\n    CONFIG.timeBasedFallback,\n    CONFIG.verticalSpreadFactor,\n    CONFIG.offscreenBufferFactor,\n    COLORS.stars.length,\n    generateTimeBasedStars\n  ]);\n  \n  // Initialize stars with persistence handling\n  const initializeStars = useCallback(() => {\n    const { width, height } = dimensionsRef.current;\n    if (!width || !height) return;\n    \n    // First check if we already have stars that should be preserved\n    if (starsRef.current.length > 0 && isInitializedRef.current) {\n      // Only reinitialize if screen dimensions have significantly changed\n      const existingWidth = starsRef.current[0].x / (starsRef.current[0].xSeed || 0.5);\n      const existingHeight = starsRef.current[0].baseY / ((starsRef.current[0].ySeed || 0.5) + CONFIG.offscreenBufferFactor);\n      \n      const widthChange = Math.abs(existingWidth - width) / width;\n      const heightChange = Math.abs(existingHeight - height) / height;\n      \n      // If dimensions haven't changed much, preserve existing stars\n      if (!isNaN(widthChange) && !isNaN(heightChange) && widthChange < 0.2 && heightChange < 0.2) {\n        // Just update target positions based on new dimensions\n        for (let i = 0; i < starsRef.current.length; i++) {\n          const star = starsRef.current[i];\n          // Scale position to new dimensions\n          if (star.xSeed) {\n            star.x = star.xSeed * width;\n            star.baseY = (star.ySeed + CONFIG.offscreenBufferFactor) * height;\n          } else {\n            // For stars without seeds, scale proportionally\n            star.x = (star.x / existingWidth) * width;\n            star.baseY = (star.baseY / existingHeight) * height;\n          }\n          star.y = star.baseY;\n          star.targetY = star.y;\n        }\n        return; // Keep existing stars\n      }\n    }\n    \n    // Get session configuration using our enhanced logic\n    const sessionConfig = getSessionConfiguration();\n    const { starSeeds, source } = sessionConfig;\n    \n    // Clear existing stars\n    starsRef.current = [];\n    \n    // Create stars using the retrieved configuration\n    for (let i = 0; i < starSeeds.length; i++) {\n      const seed = starSeeds[i];\n      const star = {};\n      \n      if (source === 'sessionStorage' || source === 'timeBasedGeneration') {\n        // We have exact star data from session storage or time-based generation\n        star.x = seed.x;\n        star.y = seed.y;\n        star.baseY = seed.baseY;\n        star.z = seed.z;\n        star.size = seed.size;\n        star.baseOpacity = seed.baseOpacity;\n        star.opacity = seed.opacity;\n        star.color = COLORS.stars[seed.color !== undefined ? seed.color : Math.floor(Math.random() * COLORS.stars.length)];\n        star.pulsePhase = seed.pulsePhase;\n        star.pulseSpeed = seed.pulseSpeed;\n        star.movementSpeed = seed.movementSpeed;\n        star.driftDirectionX = seed.driftDirectionX;\n        star.driftDirectionY = seed.driftDirectionY;\n        star.driftSpeed = seed.driftSpeed;\n        star.parallaxFactor = seed.parallaxFactor;\n        star.state = seed.state || 'visible';\n        star.fadeProgress = seed.fadeProgress || 1;\n        star.fadeStart = seed.fadeStart;\n        star.originalSeed = seed.originalSeed;\n      } else {\n        // Original random generation code path\n        // Store original seeds for future reference\n        star.xSeed = seed.xSeed;\n        star.ySeed = seed.ySeed;\n        \n        // Position - use seeds but adapt to current screen dimensions\n        star.x = seed.xSeed * width;\n        // Initial y position - distributed vertically across multiple screen heights\n        star.baseY = (seed.ySeed + CONFIG.offscreenBufferFactor) * height;\n        star.y = star.baseY;\n        star.z = seed.zSeed; // Depth (0.1 to 0.9)\n        \n        // Visual properties\n        star.size = (seed.sizeSeed * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n        star.baseOpacity = seed.opacitySeed * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n        star.opacity = star.baseOpacity; // Start fully visible\n        \n        // Animation properties\n        star.pulsePhase = seed.phaseSeed;\n        star.pulseSpeed = seed.pulseSpeedSeed;\n        star.movementSpeed = seed.speedSeed * CONFIG.baseMovementSpeed * (1.1 - star.z);\n        \n        // Drift movement properties (enhanced)\n        star.driftDirectionX = seed.driftDirectionXSeed;\n        star.driftDirectionY = seed.driftDirectionYSeed;\n        // Normalize the direction vector\n        const dirMagnitude = Math.sqrt(star.driftDirectionX ** 2 + star.driftDirectionY ** 2) || 1;\n        star.driftDirectionX /= dirMagnitude;\n        star.driftDirectionY /= dirMagnitude;\n        // Vary the drift speed between stars\n        star.driftSpeed = CONFIG.driftSpeed + (seed.driftSpeedSeed * 2 - 1) * CONFIG.driftSpeedVariation;\n        \n        // Star state tracking\n        star.state = 'visible'; // Start visible, not fading in\n        star.fadeProgress = 1; // Fully visible\n        \n        // Parallax properties (for scrolling effect)\n        // Make deeper stars (higher z) move less for realistic parallax\n        star.parallaxFactor = seed.parallaxFactorSeed * CONFIG.parallaxFactor * (1 - star.z * 0.5);\n        \n        // Color variation\n        star.color = COLORS.stars[seed.colorIndex];\n      }\n      \n      // Common initialization for all stars\n      star.directionChangeTimer = 0;\n      star.velocity = 0;\n      star.targetY = star.y;\n      star.lastX = star.x;\n      star.lastY = star.y;\n      \n      // Initialize twinkling properties if not already set\n      if (!star.twinkleState) {\n        star.twinkleState = 'visible';\n        star.twinkleProgress = 0;\n        star.twinkleDuration = Math.random() * \n          (CONFIG.twinkleDuration[1] - CONFIG.twinkleDuration[0]) + \n          CONFIG.twinkleDuration[0];\n      }\n      \n      // Add to collection\n      starsRef.current.push(star);\n    }\n  }, [\n    CONFIG.offscreenBufferFactor,\n    CONFIG.starSizeMax,\n    CONFIG.starSizeMin,\n    CONFIG.starOpacityMax,\n    CONFIG.starOpacityMin,\n    CONFIG.baseMovementSpeed,\n    CONFIG.driftSpeed,\n    CONFIG.driftSpeedVariation,\n    CONFIG.parallaxFactor,\n    CONFIG.twinkleDuration,\n    COLORS.stars,\n    getSessionConfiguration\n  ]);\n  \n  // Check if a star is off-screen\n  const isStarOffScreen = useCallback((star) => {\n    const { width, height } = dimensionsRef.current;\n    const buffer = CONFIG.offscreenBuffer;\n    \n    return (\n      star.x < -buffer ||\n      star.x > width + buffer ||\n      star.y < -buffer ||\n      star.y > height + buffer\n    );\n  }, [CONFIG.offscreenBuffer]);\n  \n  // Optimized star rendering with subtle trail effect\n  const drawStar = useCallback((ctx, star) => {\n    // Skip rendering completely invisible stars\n    if (star.opacity < 0.02) return;\n    \n    // Draw subtle trail if enabled and star is moving\n    if (CONFIG.trailEnabled && (Math.abs(star.velocity) > 0.001 || Math.abs(star.lastX - star.x) > 0.1)) {\n      // Calculate trail direction based on movement\n      const trailX = star.lastX !== undefined ? star.lastX : star.x - star.velocity * 5;\n      const trailY = star.lastY !== undefined ? star.lastY : star.y - star.velocity * 5;\n      \n      // Ensure the trail is very subtle\n      ctx.beginPath();\n      ctx.moveTo(star.x, star.y);\n      ctx.lineTo(trailX, trailY);\n      ctx.strokeStyle = getColor(star.color, star.opacity * CONFIG.trailOpacityFactor);\n      ctx.lineWidth = star.size * 0.6;\n      ctx.lineCap = 'round';\n      ctx.stroke();\n    }\n    \n    // Store current position for next frame's trail\n    star.lastX = star.x;\n    star.lastY = star.y;\n    \n    // Simplified star rendering without creating new gradients every frame\n    ctx.beginPath();\n    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n    ctx.fillStyle = getColor(star.color, star.opacity);\n    ctx.fill();\n    \n    // Simplified glow effect without expensive gradient creation\n    if (star.opacity > 0.3) {\n      ctx.beginPath();\n      ctx.arc(star.x, star.y, star.size * 1.8, 0, Math.PI * 2);\n      ctx.fillStyle = getColor(star.color, star.opacity * 0.4);\n      ctx.fill();\n    }\n  }, [CONFIG.trailEnabled, CONFIG.trailOpacityFactor, getColor]);\n  \n  // Render the stars on the canvas\n  const renderStars = useCallback(() => {\n    if (!canvasRef.current) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d', { alpha: false });\n    \n    if (!ctx) return;\n    \n    const { width, height, pixelRatio } = dimensionsRef.current;\n    \n    // Fill with background color instead of clearing to prevent flickering\n    ctx.fillStyle = COLORS.background.topColor;\n    ctx.fillRect(0, 0, width * pixelRatio, height * pixelRatio);\n    \n    // Apply device pixel ratio scaling only once\n    ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    \n    // Enable global composition for better glow effect\n    ctx.globalCompositeOperation = 'lighter';\n    \n    // Draw stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n      drawStar(ctx, star);\n    }\n    \n    // Reset global composition\n    ctx.globalCompositeOperation = 'source-over';\n  }, [drawStar, COLORS.background.topColor]);\n  \n  // Update animation state - optimized for performance\n  const updateAnimation = useCallback((deltaTime, timestamp) => {\n    const currentScrollY = springScrollYRef.current;\n    lastScrollYRef.current = currentScrollY;\n    \n    // Global time factor for animations\n    const timeFactor = timestamp * 0.001;\n    const currentTime = Date.now();\n    \n    // Track stars to replace (avoid modifying array during iteration)\n    const starsToReplace = [];\n    \n    // Count currently fading stars to manage random fading\n    let fadingCount = 0;\n    if (CONFIG.randomFadingEnabled) {\n      fadingCount = starsRef.current.filter(star => star.state === 'fading-out' || star.state === 'fading-in').length;\n    }\n    \n    // Update stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n      \n      // Handle star state transitions\n      if (star.state === 'fading-in') {\n        // Calculate progress for fade-in\n        const elapsed = currentTime - star.fadeStart;\n        star.fadeProgress = Math.min(1, elapsed / CONFIG.fadeInDuration);\n        star.opacity = star.baseOpacity * star.fadeProgress;\n        \n        // Complete fade-in\n        if (star.fadeProgress >= 1) {\n          star.state = 'visible';\n          star.opacity = star.baseOpacity;\n        }\n      } else if (star.state === 'fading-out') {\n        // Calculate progress for fade-out\n        const elapsed = currentTime - star.fadeStart;\n        star.fadeProgress = Math.max(0, 1 - (elapsed / CONFIG.fadeOutDuration));\n        star.opacity = star.baseOpacity * star.fadeProgress;\n        \n        // Complete fade-out - mark for replacement\n        if (star.fadeProgress <= 0) {\n          starsToReplace.push(i);\n        }\n      } else {\n        // Normal visible state\n        \n        // Random fading (new feature)\n        if (CONFIG.randomFadingEnabled && \n            fadingCount < CONFIG.maxSimultaneousFading && \n            Math.random() < CONFIG.randomFadeOutProbability * deltaTime) {\n          // Start fade-out process for random star\n          star.state = 'fading-out';\n          star.fadeStart = currentTime;\n          fadingCount++;\n          continue; // Skip the rest of the loop for this star\n        }\n        \n        // Calculate parallax effect based on scroll position\n        if (CONFIG.parallaxEnabled) {\n          // Update target position based on scroll (parallax effect)\n          star.targetY = star.baseY - (currentScrollY * star.parallaxFactor);\n        }\n        \n        // Apply spring physics for bouncy effect\n        const displacement = star.targetY - star.y;\n        const springForce = displacement * CONFIG.springStrength;\n        \n        // Update velocity with spring force\n        star.velocity += springForce;\n        \n        // Apply damping to velocity\n        star.velocity *= CONFIG.dampingFactor;\n        \n        // Add velocity clamping to prevent extreme bouncing\n        const maxVelocity = 1.0; // Maximum allowed velocity\n        star.velocity = Math.max(-maxVelocity, Math.min(maxVelocity, star.velocity));\n        \n        // Update position based on velocity (for parallax)\n        star.y += star.velocity;\n        \n        // Apply drift movement if enabled\n        if (CONFIG.driftEnabled) {\n          // Apply movement with additional smoothing to prevent jumps\n          // Calculate the intended movement\n          const dx = star.driftDirectionX * star.driftSpeed * deltaTime;\n          const dy = star.driftDirectionY * star.driftSpeed * deltaTime;\n          \n          // Apply a maximum movement limit to prevent jumps\n          const maxMove = 0.5; // Maximum pixels to move per frame\n          const actualDx = Math.abs(dx) > maxMove ? Math.sign(dx) * maxMove : dx;\n          const actualDy = Math.abs(dy) > maxMove ? Math.sign(dy) * maxMove : dy;\n          \n          // Move star based on limited movement\n          star.x += actualDx;\n          // Add the drift to baseY (which is the reference point for parallax)\n          star.baseY += actualDy;\n          star.targetY = star.baseY - (currentScrollY * star.parallaxFactor);\n          \n          // Occasionally change drift direction with smoother transitions\n          star.directionChangeTimer += deltaTime;\n          if (Math.random() < CONFIG.directionChangeFrequency * deltaTime) {\n            // Gradually change direction by adding a small random vector\n            // Use the directionChangeAmount to limit the magnitude of the change\n            const changeX = (Math.random() * 2 - 1) * CONFIG.directionChangeAmount;\n            const changeY = (Math.random() * 2 - 1) * CONFIG.directionChangeAmount;\n            \n            // Apply a small percentage of the change for smoother transitions\n            star.driftDirectionX += changeX;\n            star.driftDirectionY += changeY;\n            \n            // Re-normalize the direction vector with safety checks\n            const dirMagnitude = Math.sqrt(star.driftDirectionX ** 2 + star.driftDirectionY ** 2) || 1;\n            \n            // Prevent jittery movement by ensuring minimum magnitude\n            if (dirMagnitude < 0.01) {\n              // If direction vector is too small, reset to a random direction\n              star.driftDirectionX = Math.random() * 2 - 1;\n              star.driftDirectionY = Math.random() * 2 - 1;\n              const newMagnitude = Math.sqrt(star.driftDirectionX ** 2 + star.driftDirectionY ** 2) || 1;\n              star.driftDirectionX /= newMagnitude;\n              star.driftDirectionY /= newMagnitude;\n            } else {\n              star.driftDirectionX /= dirMagnitude;\n              star.driftDirectionY /= dirMagnitude;\n            }\n          }\n        }\n        \n        // Check if star is now off-screen\n        if (CONFIG.regenerateOffscreenStars && isStarOffScreen(star) && star.state === 'visible') {\n          // Start fade-out process\n          star.state = 'fading-out';\n          star.fadeStart = currentTime;\n        }\n        \n        // Simplified pulsing effect\n        const pulseFactor = Math.sin(timeFactor * star.pulseSpeed + star.pulsePhase) * 0.15 + 0.85;\n        // Only apply pulsing if not in a transition state\n        if (star.state === 'visible') {\n          star.opacity = star.baseOpacity * pulseFactor;\n        }\n      }\n    }\n    \n    // Replace stars that have completed fade-out (in reverse order to avoid index issues)\n    for (let i = starsToReplace.length - 1; i >= 0; i--) {\n      const index = starsToReplace[i];\n      // Create a new star to replace the off-screen one\n      const newStar = createNewStar(starsRef.current[index]);\n      // Replace the star in the array\n      starsRef.current[index] = newStar;\n    }\n    \n    // Save state periodically for persistence\n    if (CONFIG.persistenceEnabled && timestamp % CONFIG.persistenceInterval < 16) {\n      saveCurrentState();\n    }\n  }, [\n    CONFIG.randomFadingEnabled,\n    CONFIG.maxSimultaneousFading,\n    CONFIG.randomFadeOutProbability,\n    CONFIG.fadeInDuration,\n    CONFIG.fadeOutDuration,\n    CONFIG.parallaxEnabled,\n    CONFIG.springStrength,\n    CONFIG.dampingFactor,\n    CONFIG.driftEnabled,\n    CONFIG.directionChangeFrequency,\n    CONFIG.directionChangeAmount,\n    CONFIG.regenerateOffscreenStars,\n    CONFIG.persistenceEnabled,\n    CONFIG.persistenceInterval,\n    isStarOffScreen,\n    createNewStar,\n    saveCurrentState\n  ]);\n  \n  // Define the animation loop function\n  const animate = useCallback(function animationLoop(timestamp) {\n    if (!isInitializedRef.current) {\n      animationFrameRef.current = requestAnimationFrame(animationLoop);\n      return;\n    }\n    \n    // Limit FPS\n    const minFrameTime = 1000 / CONFIG.maxFPS;\n    const elapsed = timestamp - (lastTimeRef.current || 0);\n    \n    if (elapsed < minFrameTime) {\n      animationFrameRef.current = requestAnimationFrame(animationLoop);\n      return;\n    }\n    \n    // Calculate delta time with cap to prevent large jumps\n    const deltaTime = lastTimeRef.current ? Math.min(elapsed, 50) : 16;\n    lastTimeRef.current = timestamp;\n    \n    // Update animation state\n    updateAnimation(deltaTime, timestamp);\n    \n    // Render scene\n    renderStars();\n    \n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(animationLoop);\n  }, [CONFIG.maxFPS, updateAnimation, renderStars]);\n  \n  // Initialize the stars when component mounts or dimensions change\n  useEffect(() => {\n    // One-time initialization function\n    const initialize = () => {\n      if (setupCanvas()) {\n        // Synchronously restore scroll position before first render if available\n        if (CONFIG.persistenceEnabled) {\n          try {\n            const savedScrollY = sessionStorage.getItem(CONFIG.scrollPositionKey);\n            if (savedScrollY !== null) {\n              // Set both the spring value and the ref value immediately\n              springScrollY.set(parseFloat(savedScrollY));\n              springScrollYRef.current = parseFloat(savedScrollY);\n            }\n          } catch (error) {\n            console.warn('Could not restore scroll position', error);\n          }\n        }\n        \n        // Create stars only after canvas is ready\n        initializeStars();\n        // Mark as initialized but don't trigger re-render\n        isInitializedRef.current = true;\n        // Start animation only after everything is ready\n        animationFrameRef.current = requestAnimationFrame(animate);\n      }\n    };\n    \n    // Handle resize events\n    const handleResize = () => {\n      // Only re-initialize if already initialized\n      if (isInitializedRef.current) {\n        setupCanvas();\n        initializeStars();\n        // No need to change initialization state\n      }\n    };\n    \n    // Throttle resize events\n    let resizeTimer;\n    const throttledResize = () => {\n      if (!resizeTimer) {\n        resizeTimer = setTimeout(() => {\n          resizeTimer = null;\n          handleResize();\n        }, 200); // 200ms throttle\n      }\n    };\n    \n    // Add resize listener\n    window.addEventListener('resize', throttledResize);\n    \n    // Run initialization after first render is complete\n    // This prevents the \"double load\" effect\n    requestAnimationFrame(() => {\n      firstRenderCompleteRef.current = true;\n      initialize();\n    });\n    \n    // Cleanup\n    return () => {\n      window.removeEventListener('resize', throttledResize);\n      if (resizeTimer) clearTimeout(resizeTimer);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [\n    setupCanvas, \n    initializeStars, \n    animate, \n    CONFIG.persistenceEnabled, \n    CONFIG.scrollPositionKey, \n    springScrollY\n  ]);\n  \n  // Add navigation event handlers to save state when user leaves\n  useEffect(() => {\n    if (!CONFIG.persistenceEnabled) return;\n    \n    const handleVisibilityChange = () => {\n      if (document.visibilityState === 'hidden') {\n        saveCurrentState();\n      }\n    };\n    \n    const handleBeforeUnload = () => {\n      saveCurrentState();\n    };\n    \n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    window.addEventListener('beforeunload', handleBeforeUnload);\n    \n    return () => {\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n      saveCurrentState();\n    };\n  }, [CONFIG.persistenceEnabled, saveCurrentState]);\n  \n  // Calculate background colors\n  const backgroundColors = useMemo(() => ({\n    topColor: COLORS.background?.topColor || 'rgb(8, 8, 12)',\n    bottomColor: COLORS.background?.bottomColor || 'rgb(15, 15, 20)'\n  }), [COLORS.background]);\n  \n  return (\n    <div\n      style={{\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        width: '100vw',\n        height: '100vh',\n        overflow: 'hidden',\n        zIndex: -1,\n        pointerEvents: 'none',\n        background: `linear-gradient(to bottom, ${backgroundColors.topColor}, ${backgroundColors.bottomColor})`\n      }}\n      aria-hidden=\"true\"\n    >\n      <canvas\n        ref={canvasRef}\n        style={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%'\n        }}\n      />\n    </div>\n  );\n};\n\nexport default CosmicStars;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}