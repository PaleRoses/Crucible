{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/Background.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';\nimport { createUseStyles } from 'react-jss';\n\n// Enhanced CSS-in-JS styles with hardware acceleration and performance optimizations\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst useStyles = createUseStyles({\n  backgroundWrapper: {\n    position: 'fixed',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n    zIndex: 1,\n    pointerEvents: 'none',\n    overflow: 'hidden',\n    // Hardware acceleration\n    transform: 'translateZ(0)',\n    backfaceVisibility: 'hidden',\n    perspective: 1000,\n    willChange: 'transform'\n  },\n  backgroundBlack: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n    backgroundColor: '#000000',\n    zIndex: 1\n  },\n  backgroundCanvas: {\n    position: 'fixed',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n    zIndex: 1,\n    pointerEvents: 'none',\n    // Hardware acceleration\n    transform: 'translateZ(0)',\n    backfaceVisibility: 'hidden',\n    perspective: 1000,\n    willChange: 'transform',\n    // Ensure proper rendering\n    imageRendering: 'high-quality'\n  }\n});\n\n// Enhanced constellation definitions with more stars and connections\nconst CONSTELLATIONS = [{\n  name: 'Ursa Major',\n  vertices: [{\n    x: 0.2,\n    y: 0.3\n  }, {\n    x: 0.25,\n    y: 0.28\n  }, {\n    x: 0.3,\n    y: 0.25\n  }, {\n    x: 0.35,\n    y: 0.23\n  }, {\n    x: 0.37,\n    y: 0.18\n  }, {\n    x: 0.33,\n    y: 0.15\n  }, {\n    x: 0.28,\n    y: 0.15\n  }],\n  edges: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]\n}, {\n  name: 'Cassiopeia',\n  vertices: [{\n    x: 0.7,\n    y: 0.15\n  }, {\n    x: 0.75,\n    y: 0.2\n  }, {\n    x: 0.8,\n    y: 0.15\n  }, {\n    x: 0.85,\n    y: 0.2\n  }, {\n    x: 0.9,\n    y: 0.15\n  }],\n  edges: [[0, 1], [1, 2], [2, 3], [3, 4]]\n}, {\n  name: 'Orion',\n  vertices: [{\n    x: 0.5,\n    y: 0.5\n  }, {\n    x: 0.48,\n    y: 0.45\n  }, {\n    x: 0.52,\n    y: 0.45\n  }, {\n    x: 0.51,\n    y: 0.4\n  }, {\n    x: 0.5,\n    y: 0.35\n  }, {\n    x: 0.53,\n    y: 0.32\n  }, {\n    x: 0.47,\n    y: 0.32\n  }],\n  edges: [[0, 1], [0, 2], [1, 3], [2, 3], [3, 4], [4, 5], [4, 6]]\n}, {\n  name: 'Cygnus',\n  vertices: [{\n    x: 0.15,\n    y: 0.65\n  }, {\n    x: 0.2,\n    y: 0.6\n  }, {\n    x: 0.25,\n    y: 0.55\n  }, {\n    x: 0.3,\n    y: 0.5\n  }, {\n    x: 0.35,\n    y: 0.45\n  }, {\n    x: 0.25,\n    y: 0.5\n  }, {\n    x: 0.15,\n    y: 0.5\n  }],\n  edges: [[0, 1], [1, 2], [2, 3], [3, 4], [2, 5], [5, 6]]\n}];\n\n/**\n * Enterprise-grade Background Component\n * \n * Creates a high-performance animated starry background with constellations,\n * interactive cursor effects, and optimized rendering for all devices.\n * \n * Features:\n * - Hardware accelerated rendering with Canvas 2D or WebGL\n * - Device-adaptive quality settings for better performance\n * - Optimized memory usage with object pooling\n * - Battery-aware rendering for mobile devices\n * - Smooth animations with efficient frame management\n * - Enhanced visual effects with adaptive detail levels\n * \n * @param {Object} props - Component props\n * @param {Object} props.cursorPosition - Current cursor coordinates\n * @param {Function} props.setCursorPosition - Function to update cursor position\n * @param {boolean} [props.enableWebGL=false] - Enable WebGL rendering for better performance\n * @param {boolean} [props.adaptiveQuality=true] - Enable adaptive quality based on device\n * @param {boolean} [props.enableParallax=true] - Enable parallax effect on scroll/cursor\n * @param {boolean} [props.respectReducedMotion=true] - Respect reduced motion preferences\n * @param {number} [props.particleCount=80] - Number of background particles\n * @param {boolean} [props.enableCursorGlow=true] - Enable cursor glow effect\n * @param {number} [props.targetFPS=30] - Target frame rate\n * @param {boolean} [props.enableStarBurst=true] - Enable occasional star burst effects\n */\nconst Background = ({\n  cursorPosition,\n  setCursorPosition,\n  enableWebGL = false,\n  adaptiveQuality = true,\n  enableParallax = true,\n  respectReducedMotion = true,\n  particleCount = 80,\n  enableCursorGlow = true,\n  targetFPS = 30,\n  enableStarBurst = true\n}) => {\n  _s();\n  // Styles and refs\n  const classes = useStyles();\n  const canvasRef = useRef(null);\n  const particlesRef = useRef([]);\n  const constellationsRef = useRef([]);\n  const requestRef = useRef(null);\n  const timeRef = useRef(0);\n  const lastFrameTimeRef = useRef(0);\n  const frameCountRef = useRef(0);\n  const fpsCounterRef = useRef(0);\n  const lastRenderTimeRef = useRef(0);\n  const webGLRef = useRef(null);\n\n  // Component state\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0,\n    pixelRatio: 1\n  });\n  const [isVisible, setIsVisible] = useState(true);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [qualityFactor, setQualityFactor] = useState(1);\n  const [renderingMode, setRenderingMode] = useState('2d');\n\n  // Device capabilities state - used throughout the component\n  const [deviceCapabilities, setDeviceCapabilities] = useState({\n    isMobile: false,\n    batteryLevel: 1,\n    isCharging: true,\n    memoryLimit: false\n  });\n\n  // Optimized cursor position with interpolation for smoother movement\n  const smoothCursorPosition = useRef({\n    x: 0,\n    y: 0\n  });\n\n  // Particle and star burst object pools\n  const particlePoolRef = useRef([]);\n  const starBurstPoolRef = useRef([]);\n  const activeStarBurstsRef = useRef([]);\n\n  // Color caching to avoid string operations during rendering\n  const colorCacheRef = useRef(new Map());\n\n  // Get cached color with opacity\n  const getCachedColor = useCallback((baseColor, opacity) => {\n    // Ensure opacity is within valid range\n    const safeOpacity = Math.max(0, Math.min(1, opacity));\n\n    // Round opacity to reduce cache size (0.01 precision is enough for visual effects)\n    const roundedOpacity = Math.round(safeOpacity * 100) / 100;\n    const key = `${baseColor}-${roundedOpacity}`;\n    if (!colorCacheRef.current.has(key)) {\n      const newColor = baseColor + roundedOpacity + ')';\n      colorCacheRef.current.set(key, newColor);\n    }\n    return colorCacheRef.current.get(key);\n  }, []);\n\n  // Detect device capabilities and set appropriate quality levels\n  const detectCapabilities = useCallback(() => {\n    // Check for mobile devices\n    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n\n    // Check for WebGL support\n    let webGLSupported = false;\n    if (enableWebGL) {\n      try {\n        const canvas = document.createElement('canvas');\n        webGLSupported = !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));\n      } catch (e) {\n        webGLSupported = false;\n      }\n    }\n\n    // Set rendering mode based on capabilities\n    setRenderingMode(webGLSupported && enableWebGL ? 'webgl' : '2d');\n\n    // Set device capability state\n    setDeviceCapabilities(prev => ({\n      ...prev,\n      isMobile\n    }));\n\n    // Determine quality factor based on device capabilities\n    if (adaptiveQuality) {\n      const memory = navigator.deviceMemory || 4; // Default to 4GB if not available\n      const cores = navigator.hardwareConcurrency || 4; // Default to 4 cores\n\n      // Calculate performance score\n      const performanceScore = memory * cores / (isMobile ? 2 : 1);\n\n      // Scale quality based on performance score\n      let quality = 1;\n      if (performanceScore > 16) {\n        quality = 1; // High-end devices\n      } else if (performanceScore > 8) {\n        quality = 0.85; // Mid-range devices\n      } else if (performanceScore > 4) {\n        quality = 0.7; // Low-end devices\n      } else {\n        quality = 0.5; // Very low-end devices\n      }\n      setQualityFactor(quality);\n    }\n\n    // Check battery status if available\n    if (navigator.getBattery) {\n      navigator.getBattery().then(battery => {\n        const updateBattery = () => {\n          setDeviceCapabilities(prev => ({\n            ...prev,\n            batteryLevel: battery.level,\n            isCharging: battery.charging\n          }));\n\n          // Reduce quality if on low battery and not charging\n          if (!battery.charging && battery.level < 0.3 && adaptiveQuality) {\n            setQualityFactor(prev => Math.min(prev, 0.6));\n          }\n        };\n\n        // Add battery event listeners\n        battery.addEventListener('levelchange', updateBattery);\n        battery.addEventListener('chargingchange', updateBattery);\n\n        // Initial update\n        updateBattery();\n      }).catch(() => {\n        // Battery API failed, continue without battery optimization\n      });\n    }\n  }, [enableWebGL, adaptiveQuality]);\n\n  // Calculate adaptive settings based on device capabilities and quality factor\n  const adaptiveSettings = useMemo(() => {\n    // Drastically reduce particle count to lower visual noise\n    const actualParticleCount = Math.max(25, Math.floor(particleCount * 0.4));\n    return {\n      particleCount: actualParticleCount,\n      starSize: 1,\n      useGlow: qualityFactor > 0.6,\n      useHighQualityEdges: qualityFactor > 0.7,\n      constellationOpacity: 0.1 * qualityFactor,\n      // Extremely low twinkling frequency\n      twinkleFrequency: 0.00002,\n      // Nearly static particles\n      particleSpeed: 0.01\n    };\n  }, [qualityFactor, particleCount]);\n\n  // Initialize particles with appropriate pooling\n  const initializeParticles = useCallback(() => {\n    if (!dimensions.width || !dimensions.height) return;\n    const width = dimensions.width;\n    const height = dimensions.height;\n\n    // Create a stable set of particles\n    const newParticles = [];\n\n    // Create long-lasting twinkling for a small subset of stars\n    const totalParticles = adaptiveSettings.particleCount;\n    const maxTwinklingStars = Math.floor(totalParticles * 0.07); // Limit to 7% of stars\n    const twinklingIndices = new Set();\n    while (twinklingIndices.size < maxTwinklingStars) {\n      twinklingIndices.add(Math.floor(Math.random() * totalParticles));\n    }\n\n    // Try to get from pool first, then create new ones if needed\n    for (let i = 0; i < adaptiveSettings.particleCount; i++) {\n      let particle;\n      if (particlePoolRef.current.length > 0) {\n        // Reuse from pool\n        particle = particlePoolRef.current.pop();\n\n        // Reset particle properties\n        particle.x = Math.random() * width;\n        particle.y = Math.random() * height;\n        particle.isTwinkling = false;\n      } else {\n        // Determine if this particle can twinkle\n        const canTwinkle = twinklingIndices.has(i);\n\n        // Create new particle with significantly reduced movement and effects\n        particle = {\n          x: Math.random() * width,\n          y: Math.random() * height,\n          size: Math.random() * 1.2 + 0.5,\n          baseSize: Math.random() * 1.2 + 0.5,\n          // Almost static particles\n          speedX: (Math.random() - 0.5) * adaptiveSettings.particleSpeed * 0.5,\n          speedY: (Math.random() - 0.5) * adaptiveSettings.particleSpeed * 0.5,\n          opacity: Math.random() * 0.25 + 0.05,\n          baseOpacity: Math.random() * 0.25 + 0.05,\n          // Only allow selected particles to twinkle at all\n          canTwinkle: canTwinkle,\n          // Very slow twinkling for a gentle effect\n          isTwinkling: false,\n          twinkleStartTime: 0,\n          twinkleDuration: Math.random() * 4000 + 3000,\n          // 3-7 second twinkle\n          lastTwinkleTime: -1 * (Math.random() * 15000),\n          // Stagger initial twinkles\n          nextTwinkleTime: Math.random() * 20000 + 15000,\n          // 15-35 seconds between twinkles\n          // For star bursts - only 3% of stars can burst\n          canBurst: Math.random() < 0.03,\n          burstThreshold: Math.random() * 0.0001,\n          lastBurstTime: 0,\n          burstCooldown: Math.random() * 45000 + 30000 // 30-75 second cooldown\n        };\n      }\n      newParticles.push(particle);\n    }\n    particlesRef.current = newParticles;\n  }, [dimensions, adaptiveSettings]);\n\n  // Initialize constellations\n  const initializeConstellations = useCallback(() => {\n    if (!dimensions.width || !dimensions.height) return;\n\n    // Initialize constellations with actual screen positions\n    constellationsRef.current = CONSTELLATIONS.map(constellation => {\n      const vertices = constellation.vertices.map(vertex => ({\n        x: vertex.x * dimensions.width,\n        y: vertex.y * dimensions.height,\n        size: 1.8 * adaptiveSettings.starSize,\n        baseSize: 1.8 * adaptiveSettings.starSize,\n        opacity: 0.2 * qualityFactor,\n        baseOpacity: 0.2 * qualityFactor,\n        isTwinkling: false,\n        twinkleProgress: 0,\n        // Extremely slow twinkling for stability\n        twinkleSpeed: Math.random() * 0.005 + 0.001,\n        lastTwinkle: Math.random() * 10000,\n        // Stagger initial twinkles\n        // Very long intervals between twinkles\n        twinkleInterval: Math.random() * 20000 + 15000,\n        // Minimal parallax effect\n        originalX: vertex.x * dimensions.width,\n        originalY: vertex.y * dimensions.height,\n        parallaxFactor: Math.random() * 0.02 + 0.01 // 1/10th the original parallax factor\n      }));\n      return {\n        name: constellation.name,\n        vertices,\n        edges: constellation.edges,\n        // Rare constellation highlighting\n        isHighlighted: false,\n        highlightProgress: 0,\n        highlightSpeed: 0.001,\n        // 10x slower than original\n        lastHighlight: Math.random() * 30000,\n        // Stagger initial highlights\n        highlightInterval: Math.random() * 120000 + 90000 // Very long intervals (1.5-3.5 minutes)\n      };\n    });\n  }, [dimensions, adaptiveSettings.starSize, qualityFactor]);\n\n  // Create star burst effect at a specific position - gentle version\n  // Create star burst effect at a specific position - gentle version\n  const createStarBurst = useCallback((x, y, size = 2, particleCount = 8) => {\n    if (!enableStarBurst) return;\n\n    // Limit the total number of active bursts to prevent overdraw\n    if (activeStarBurstsRef.current.length > 10) return;\n\n    // Use a reasonable number of particles\n    const actualParticleCount = Math.min(particleCount, 5);\n    for (let i = 0; i < actualParticleCount; i++) {\n      // Try to get from pool first\n      let burst;\n      if (starBurstPoolRef.current.length > 0) {\n        burst = starBurstPoolRef.current.pop();\n\n        // Reset burst properties\n        burst.life = 1.0;\n        burst.x = x;\n        burst.y = y;\n      } else {\n        // Create new burst particle\n        burst = {\n          x,\n          y,\n          vx: 0,\n          vy: 0,\n          size: 0,\n          life: 1.0,\n          decay: 0,\n          startTime: 0,\n          duration: 0\n        };\n      }\n\n      // Randomize burst parameters with slower speeds\n      const angle = Math.random() * Math.PI * 2;\n      const speed = Math.random() * 0.5 + 0.2; // Very slow movement\n\n      burst.vx = Math.cos(angle) * speed;\n      burst.vy = Math.sin(angle) * speed;\n      burst.size = size * (0.3 + Math.random() * 0.3); // Smaller particles\n      burst.startTime = performance.now();\n      burst.duration = Math.random() * 3000 + 2000; // 2-5 second duration\n\n      activeStarBurstsRef.current.push(burst);\n    }\n  }, [enableStarBurst]);\n\n  // Initialize WebGL context if enabled\n  const initWebGL = useCallback(() => {\n    if (!canvasRef.current || renderingMode !== 'webgl') return false;\n    try {\n      const gl = canvasRef.current.getContext('webgl', {\n        alpha: true,\n        antialias: true,\n        premultipliedAlpha: false,\n        depth: false,\n        powerPreference: 'default'\n      });\n      if (!gl) return false;\n      webGLRef.current = gl;\n\n      // Basic WebGL setup (simplified)\n      gl.enable(gl.BLEND);\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n      gl.clearColor(0.0, 0.0, 0.0, 1.0);\n      return true;\n    } catch (error) {\n      console.error('WebGL initialization error:', error);\n      setRenderingMode('2d');\n      return false;\n    }\n  }, [renderingMode]);\n\n  // Canvas setup with proper scaling for high-DPI displays\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) return false;\n    const canvas = canvasRef.current;\n    const pixelRatio = window.devicePixelRatio || 1;\n\n    // Get display dimensions\n    const displayWidth = window.innerWidth;\n    const displayHeight = window.innerHeight;\n\n    // Set canvas rendering size (accounting for pixel ratio)\n    canvas.width = displayWidth * pixelRatio;\n    canvas.height = displayHeight * pixelRatio;\n\n    // Set display size via CSS\n    canvas.style.width = `${displayWidth}px`;\n    canvas.style.height = `${displayHeight}px`;\n\n    // Store dimensions\n    setDimensions({\n      width: displayWidth,\n      height: displayHeight,\n      pixelRatio\n    });\n\n    // Initialize appropriate rendering context\n    if (renderingMode === 'webgl') {\n      if (!initWebGL()) {\n        // Fallback to 2D if WebGL fails\n        const ctx = canvas.getContext('2d');\n        ctx.scale(pixelRatio, pixelRatio);\n      }\n    } else {\n      // 2D Canvas context\n      const ctx = canvas.getContext('2d', {\n        alpha: true,\n        desynchronized: true,\n        willReadFrequently: false\n      });\n      if (!ctx) return false;\n\n      // Scale context for high-DPI displays\n      ctx.scale(pixelRatio, pixelRatio);\n\n      // Enable high-quality rendering if device can handle it\n      if (qualityFactor > 0.7) {\n        ctx.imageSmoothingEnabled = true;\n        ctx.imageSmoothingQuality = 'high';\n      }\n    }\n    return true;\n  }, [qualityFactor, renderingMode, initWebGL]);\n\n  // Handle window resize\n  const handleResize = useCallback(() => {\n    if (setupCanvas()) {\n      // Reinitialize particles and constellations\n      initializeParticles();\n      initializeConstellations();\n    }\n  }, [setupCanvas, initializeParticles, initializeConstellations]);\n\n  // Detect device capabilities and preferences\n  useEffect(() => {\n    // Check for reduced motion preference\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    const handleReducedMotionChange = e => {\n      setPrefersReducedMotion(e.matches);\n    };\n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n\n    // Detect device capabilities\n    detectCapabilities();\n\n    // Handle visibility changes\n    const handleVisibilityChange = () => {\n      setIsVisible(!document.hidden);\n    };\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  }, [detectCapabilities]);\n\n  // Set up responsive canvas and initialize particles\n  useEffect(() => {\n    // Initial setup\n    setupCanvas();\n\n    // Add resize listener\n    window.addEventListener('resize', handleResize);\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      if (requestRef.current) {\n        cancelAnimationFrame(requestRef.current);\n      }\n    };\n  }, [setupCanvas, handleResize]);\n\n  // Initialize particles and constellations when dimensions are available\n  useEffect(() => {\n    if (dimensions.width && dimensions.height) {\n      initializeParticles();\n      initializeConstellations();\n    }\n  }, [dimensions, initializeParticles, initializeConstellations]);\n\n  // Draw 2D canvas background\n  const drawBackground2D = useCallback((ctx, timestamp, deltaTime) => {\n    // Start with black background\n    ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n    ctx.fillStyle = '#000000';\n    ctx.fillRect(0, 0, dimensions.width, dimensions.height);\n\n    // Calculate interpolated cursor position for smoother effects\n    if (cursorPosition.x && cursorPosition.y) {\n      smoothCursorPosition.current.x += (cursorPosition.x - smoothCursorPosition.current.x) * 0.1;\n      smoothCursorPosition.current.y += (cursorPosition.y - smoothCursorPosition.current.y) * 0.1;\n    }\n\n    // Calculate parallax offset based on cursor position\n    const parallaxOffsetX = enableParallax ? (smoothCursorPosition.current.x - dimensions.width / 2) / 20 : 0;\n    const parallaxOffsetY = enableParallax ? (smoothCursorPosition.current.y - dimensions.height / 2) / 20 : 0;\n\n    // Draw regular particles\n    particlesRef.current.forEach(particle => {\n      // Skip updates if reduced motion is preferred\n      if (!(respectReducedMotion && prefersReducedMotion)) {\n        // Update position\n        particle.x += particle.speedX;\n        particle.y += particle.speedY;\n\n        // Wrap around screen with buffer\n        if (particle.x < -20) particle.x = dimensions.width + 20;\n        if (particle.x > dimensions.width + 20) particle.x = -20;\n        if (particle.y < -20) particle.y = dimensions.height + 20;\n        if (particle.y > dimensions.height + 20) particle.y = -20;\n      }\n\n      // Handle twinkling effect - with lower probability\n      if (Math.random() < particle.twinkleProbability * 0.2) {\n        // Further reduce by 80%\n        // Only start twinkling if not already twinkling\n        if (!particle.isTwinkling) {\n          particle.isTwinkling = true;\n          particle.twinklePhase = Math.random() * Math.PI * 2;\n        }\n      }\n      let particleOpacity = particle.opacity;\n      let particleSize = particle.size;\n      if (particle.isTwinkling) {\n        // Use sine wave for smooth twinkling effect\n        const twinkleFactor = Math.sin(timestamp * 0.001 * particle.twinkleSpeed + particle.twinklePhase);\n        const normalizedTwinkle = (twinkleFactor + 1) / 2; // Convert from [-1,1] to [0,1]\n\n        particleSize = particle.baseSize + particle.baseSize * 0.7 * normalizedTwinkle;\n        particleOpacity = particle.baseOpacity + 0.4 * normalizedTwinkle;\n\n        // Complete one twinkle cycle\n        if (timestamp * 0.001 * particle.twinkleSpeed + particle.twinklePhase > particle.twinklePhase + Math.PI * 2) {\n          particle.isTwinkling = false;\n          particle.twinklePhase = Math.random() * Math.PI * 2; // Reset phase for next time\n        }\n      }\n\n      // Check for star burst with longer durations\n      if (enableStarBurst && particle.canBurst && Math.random() < particle.burstThreshold * 0.25 && timestamp - particle.lastBurstTime > particle.burstCooldown) {\n        createStarBurst(particle.x, particle.y, particle.size * 1.2, 3);\n        particle.lastBurstTime = timestamp;\n      }\n\n      // Compute final position with parallax\n      const drawX = particle.x + parallaxOffsetX * 0.5;\n      const drawY = particle.y + parallaxOffsetY * 0.5;\n\n      // Draw particle\n      ctx.beginPath();\n      ctx.arc(drawX, drawY, particleSize, 0, Math.PI * 2);\n      ctx.fillStyle = getCachedColor('rgba(191, 173, 127, ', particleOpacity);\n      ctx.fill();\n\n      // Add glow effect for larger or twinkling particles if quality permits\n      if (adaptiveSettings.useGlow && (particleSize > 1.3 || particle.isTwinkling)) {\n        ctx.beginPath();\n        ctx.arc(drawX, drawY, particleSize * 2, 0, Math.PI * 2);\n\n        // Create safe radial gradient\n        try {\n          const gradient = ctx.createRadialGradient(drawX, drawY, particleSize * 0.5, drawX, drawY, particleSize * 2);\n          gradient.addColorStop(0, getCachedColor('rgba(191, 173, 127, ', particleOpacity * 0.4));\n          gradient.addColorStop(1, getCachedColor('rgba(191, 173, 127, ', 0));\n          ctx.fillStyle = gradient;\n          ctx.fill();\n        } catch (e) {\n          // Fallback if gradient creation fails\n          ctx.fillStyle = getCachedColor('rgba(191, 173, 127, ', particleOpacity * 0.2);\n          ctx.fill();\n        }\n      }\n    });\n\n    // Draw constellations\n    constellationsRef.current.forEach(constellation => {\n      const now = timestamp;\n      let edgeOpacity = adaptiveSettings.constellationOpacity;\n      let vertexMultiplier = 1;\n\n      // Check if it's time to highlight this constellation\n      if (now - constellation.lastHighlight > constellation.highlightInterval) {\n        constellation.isHighlighted = true;\n        constellation.highlightProgress = 0;\n        constellation.lastHighlight = now;\n      }\n\n      // Handle highlighting animation\n      if (constellation.isHighlighted) {\n        constellation.highlightProgress += constellation.highlightSpeed * (deltaTime / 16);\n\n        // Create a pulse effect for highlighting\n        const highlightPulse = Math.sin(constellation.highlightProgress * Math.PI);\n        edgeOpacity += highlightPulse * 0.15;\n        vertexMultiplier += highlightPulse * 0.5;\n\n        // End highlighting after one cycle\n        if (constellation.highlightProgress >= 1) {\n          constellation.isHighlighted = false;\n        }\n      }\n\n      // Draw edges (lines) first so they appear behind vertices\n      if (adaptiveSettings.useHighQualityEdges) {\n        // Enhanced edges with gradient for higher quality settings\n        constellation.edges.forEach(edge => {\n          const startVertex = constellation.vertices[edge[0]];\n          const endVertex = constellation.vertices[edge[1]];\n\n          // Apply parallax to edge vertices\n          const startX = startVertex.x + parallaxOffsetX * startVertex.parallaxFactor;\n          const startY = startVertex.y + parallaxOffsetY * startVertex.parallaxFactor;\n          const endX = endVertex.x + parallaxOffsetX * endVertex.parallaxFactor;\n          const endY = endVertex.y + parallaxOffsetY * endVertex.parallaxFactor;\n\n          // Create gradient along the line\n          try {\n            const gradient = ctx.createLinearGradient(startX, startY, endX, endY);\n            gradient.addColorStop(0, getCachedColor('rgba(191, 173, 127, ', edgeOpacity));\n            gradient.addColorStop(0.5, getCachedColor('rgba(191, 173, 127, ', edgeOpacity * 1.3));\n            gradient.addColorStop(1, getCachedColor('rgba(191, 173, 127, ', edgeOpacity));\n            ctx.beginPath();\n            ctx.moveTo(startX, startY);\n            ctx.lineTo(endX, endY);\n            ctx.strokeStyle = gradient;\n            ctx.lineWidth = 0.5;\n            ctx.stroke();\n          } catch (e) {\n            // Fallback to simple line if gradient fails\n            ctx.beginPath();\n            ctx.moveTo(startX, startY);\n            ctx.lineTo(endX, endY);\n            ctx.strokeStyle = getCachedColor('rgba(191, 173, 127, ', edgeOpacity);\n            ctx.lineWidth = 0.5;\n            ctx.stroke();\n          }\n        });\n      } else {\n        // Simple edges for lower quality settings\n        ctx.beginPath();\n        ctx.strokeStyle = getCachedColor('rgba(191, 173, 127, ', edgeOpacity);\n        ctx.lineWidth = 0.5;\n        constellation.edges.forEach(edge => {\n          const startVertex = constellation.vertices[edge[0]];\n          const endVertex = constellation.vertices[edge[1]];\n\n          // Apply parallax\n          const startX = startVertex.x + parallaxOffsetX * startVertex.parallaxFactor;\n          const startY = startVertex.y + parallaxOffsetY * startVertex.parallaxFactor;\n          const endX = endVertex.x + parallaxOffsetX * endVertex.parallaxFactor;\n          const endY = endVertex.y + parallaxOffsetY * endVertex.parallaxFactor;\n          ctx.moveTo(startX, startY);\n          ctx.lineTo(endX, endY);\n        });\n        ctx.stroke();\n      }\n\n      // Draw and update vertices\n      constellation.vertices.forEach(vertex => {\n        // Occasional twinkling for constellation stars\n        if (timestamp - vertex.lastTwinkle > vertex.twinkleInterval) {\n          vertex.isTwinkling = true;\n          vertex.twinkleProgress = 0;\n          vertex.lastTwinkle = timestamp;\n        }\n        let vertexSize = vertex.size * vertexMultiplier;\n        let vertexOpacity = vertex.opacity * vertexMultiplier;\n        if (vertex.isTwinkling) {\n          vertex.twinkleProgress += vertex.twinkleSpeed * (deltaTime / 16);\n\n          // Create a pulse effect\n          const pulseFactor = Math.sin(vertex.twinkleProgress * Math.PI);\n          vertexSize += vertex.baseSize * pulseFactor * 0.5;\n          vertexOpacity += 0.3 * pulseFactor;\n\n          // End twinkling after one cycle\n          if (vertex.twinkleProgress >= 1) {\n            vertex.isTwinkling = false;\n          }\n        }\n\n        // Apply parallax to vertex position\n        const drawX = vertex.x + parallaxOffsetX * vertex.parallaxFactor;\n        const drawY = vertex.y + parallaxOffsetY * vertex.parallaxFactor;\n\n        // Draw constellation vertex\n        ctx.beginPath();\n        ctx.arc(drawX, drawY, vertexSize, 0, Math.PI * 2);\n        ctx.fillStyle = getCachedColor('rgba(207, 185, 130, ', vertexOpacity);\n        ctx.fill();\n\n        // Add glow for constellation vertices if quality permits\n        if (adaptiveSettings.useGlow) {\n          ctx.beginPath();\n          ctx.arc(drawX, drawY, vertexSize * 3, 0, Math.PI * 2);\n          try {\n            const gradient = ctx.createRadialGradient(drawX, drawY, vertexSize * 0.5, drawX, drawY, vertexSize * 3);\n            gradient.addColorStop(0, getCachedColor('rgba(207, 185, 130, ', vertexOpacity * 0.4));\n            gradient.addColorStop(1, getCachedColor('rgba(207, 185, 130, ', 0));\n            ctx.fillStyle = gradient;\n            ctx.fill();\n          } catch (e) {\n            // Fallback if gradient creation fails\n            ctx.fillStyle = getCachedColor('rgba(207, 185, 130, ', vertexOpacity * 0.2);\n            ctx.fill();\n          }\n        }\n      });\n    });\n\n    // Draw active star bursts with gentle transitions\n    activeStarBurstsRef.current.forEach((burst, index) => {\n      if (!burst) return;\n      const now = performance.now();\n      const startTime = burst.startTime || now;\n      const elapsed = now - startTime;\n\n      // Use smooth easing for burst life\n      if (burst.duration) {\n        // Progress based on duration\n        const progress = Math.min(1, elapsed / burst.duration);\n\n        // Ease in, then ease out\n        if (progress < 0.3) {\n          // Fade in (first 30%)\n          burst.life = progress / 0.3;\n        } else if (progress > 0.7) {\n          // Fade out (last 30%)\n          burst.life = (1 - progress) / 0.3;\n        } else {\n          // Stay bright in the middle\n          burst.life = 1.0;\n        }\n\n        // Remove if complete\n        if (progress >= 1) {\n          // Return to pool\n          starBurstPoolRef.current.push(burst);\n          activeStarBurstsRef.current.splice(index, 1);\n          return;\n        }\n      } else {\n        // Legacy support for bursts without duration\n        burst.life -= burst.decay * (deltaTime / 16);\n\n        // Remove if life is depleted\n        if (burst.life <= 0) {\n          // Return to pool\n          starBurstPoolRef.current.push(burst);\n          activeStarBurstsRef.current.splice(index, 1);\n          return;\n        }\n      }\n\n      // Update position\n      burst.x += burst.vx * (deltaTime / 16);\n      burst.y += burst.vy * (deltaTime / 16);\n\n      // Draw burst particle with smooth opacity\n      ctx.beginPath();\n      ctx.arc(burst.x, burst.y, burst.size * burst.life, 0, Math.PI * 2);\n      ctx.fillStyle = getCachedColor('rgba(207, 185, 130, ', burst.life * 0.6);\n      ctx.fill();\n\n      // Add glow for bursts\n      if (adaptiveSettings.useGlow) {\n        ctx.beginPath();\n        ctx.arc(burst.x, burst.y, burst.size * burst.life * 2, 0, Math.PI * 2);\n        try {\n          const gradient = ctx.createRadialGradient(burst.x, burst.y, burst.size * burst.life * 0.5, burst.x, burst.y, burst.size * burst.life * 2);\n          gradient.addColorStop(0, getCachedColor('rgba(207, 185, 130, ', burst.life * 0.3));\n          gradient.addColorStop(1, getCachedColor('rgba(207, 185, 130, ', 0));\n          ctx.fillStyle = gradient;\n          ctx.fill();\n        } catch (e) {\n          // Fallback if gradient creation fails\n          ctx.fillStyle = getCachedColor('rgba(207, 185, 130, ', burst.life * 0.15);\n          ctx.fill();\n        }\n      }\n    });\n\n    // Draw cursor influence - enhanced glow effect\n    if (enableCursorGlow && smoothCursorPosition.current.x && smoothCursorPosition.current.y) {\n      // Outer glow\n      const glowRadius = 120;\n      try {\n        const gradient = ctx.createRadialGradient(smoothCursorPosition.current.x, smoothCursorPosition.current.y, 0, smoothCursorPosition.current.x, smoothCursorPosition.current.y, glowRadius);\n        gradient.addColorStop(0, getCachedColor('rgba(160, 142, 97, ', 0.05));\n        gradient.addColorStop(0.5, getCachedColor('rgba(160, 142, 97, ', 0.02));\n        gradient.addColorStop(1, getCachedColor('rgba(160, 142, 97, ', 0));\n        ctx.beginPath();\n        ctx.arc(smoothCursorPosition.current.x, smoothCursorPosition.current.y, glowRadius, 0, Math.PI * 2);\n        ctx.fillStyle = gradient;\n        ctx.fill();\n      } catch (e) {\n        // Fallback to simple glow if gradient fails\n        ctx.beginPath();\n        ctx.arc(smoothCursorPosition.current.x, smoothCursorPosition.current.y, glowRadius / 2, 0, Math.PI * 2);\n        ctx.fillStyle = getCachedColor('rgba(160, 142, 97, ', 0.02);\n        ctx.fill();\n      }\n\n      // Create occasional particles at cursor position with longer lifespans\n      if (enableStarBurst && Math.random() < 0.001) {\n        createStarBurst(smoothCursorPosition.current.x, smoothCursorPosition.current.y, 0.8 + Math.random() * 0.4, Math.min(2, Math.floor(Math.random() * 2) + 1));\n      }\n    }\n  }, [dimensions, cursorPosition, enableParallax, respectReducedMotion, prefersReducedMotion, adaptiveSettings, getCachedColor, enableStarBurst, createStarBurst, enableCursorGlow]);\n\n  // FPS limiter for consistent animation rate\n  const fpsLimiter = useCallback((timestamp, callback) => {\n    // Skip animation if hidden, inactive, or reduced motion\n    if (!isVisible || respectReducedMotion && prefersReducedMotion) {\n      requestRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n      return;\n    }\n\n    // Force a very low FPS (15 FPS maximum) for stable, non-jittery animation\n    const fixedTargetFPS = 15;\n    const targetFrameTime = 1000 / fixedTargetFPS;\n    const elapsed = timestamp - lastFrameTimeRef.current;\n    if (elapsed >= targetFrameTime || lastFrameTimeRef.current === 0) {\n      // Calculate correct delta time, but significantly slow down all animations\n      const deltaTime = Math.min(elapsed, 50) * 0.25; // Cap and slow down by 75%\n\n      // Update timestamps\n      lastFrameTimeRef.current = timestamp;\n      lastRenderTimeRef.current = timestamp;\n\n      // Run animation callback with heavily reduced delta time\n      callback(timestamp, deltaTime);\n\n      // FPS measurement\n      frameCountRef.current++;\n      if (timestamp - fpsCounterRef.current >= 1000) {\n        // Reset counter\n        frameCountRef.current = 0;\n        fpsCounterRef.current = timestamp;\n      }\n    }\n\n    // Schedule next frame\n    requestRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n  }, [isVisible, respectReducedMotion, prefersReducedMotion]);\n\n  // Main animation function\n  const animate = useCallback((timestamp, deltaTime) => {\n    timeRef.current = timestamp;\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    if (renderingMode === 'webgl' && webGLRef.current) {\n      // WebGL rendering path (simplified)\n      const gl = webGLRef.current;\n      gl.clear(gl.COLOR_BUFFER_BIT);\n\n      // In a real implementation, this would render the scene using WebGL\n      // Currently falls back to 2D Canvas as WebGL implementation is a placeholder\n      const ctx = canvas.getContext('2d');\n      if (ctx) {\n        drawBackground2D(ctx, timestamp, deltaTime);\n      }\n    } else {\n      // Canvas 2D rendering path\n      const ctx = canvas.getContext('2d');\n      if (ctx) {\n        drawBackground2D(ctx, timestamp, deltaTime);\n      }\n    }\n  }, [renderingMode, drawBackground2D]);\n\n  // Start animation loop\n  useEffect(() => {\n    if (!dimensions.width || !dimensions.height) return;\n\n    // Start animation with FPS limiter\n    lastFrameTimeRef.current = 0;\n    fpsCounterRef.current = performance.now();\n    frameCountRef.current = 0;\n    requestRef.current = requestAnimationFrame(timestamp => {\n      fpsLimiter(timestamp, animate);\n    });\n    return () => {\n      if (requestRef.current) {\n        cancelAnimationFrame(requestRef.current);\n      }\n    };\n  }, [dimensions, fpsLimiter, animate]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: classes.backgroundWrapper,\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: classes.backgroundBlack\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1041,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      className: classes.backgroundCanvas\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1043,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1039,\n    columnNumber: 5\n  }, this);\n};\n_s(Background, \"6Ln1Tqyx+3kFL+6GZoIR/hFEraE=\", false, function () {\n  return [useStyles];\n});\n_c = Background;\nexport default Background;\nvar _c;\n$RefreshReg$(_c, \"Background\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useCallback","useMemo","createUseStyles","jsxDEV","_jsxDEV","useStyles","backgroundWrapper","position","top","left","width","height","zIndex","pointerEvents","overflow","transform","backfaceVisibility","perspective","willChange","backgroundBlack","backgroundColor","backgroundCanvas","imageRendering","CONSTELLATIONS","name","vertices","x","y","edges","Background","cursorPosition","setCursorPosition","enableWebGL","adaptiveQuality","enableParallax","respectReducedMotion","particleCount","enableCursorGlow","targetFPS","enableStarBurst","_s","classes","canvasRef","particlesRef","constellationsRef","requestRef","timeRef","lastFrameTimeRef","frameCountRef","fpsCounterRef","lastRenderTimeRef","webGLRef","dimensions","setDimensions","pixelRatio","isVisible","setIsVisible","prefersReducedMotion","setPrefersReducedMotion","qualityFactor","setQualityFactor","renderingMode","setRenderingMode","deviceCapabilities","setDeviceCapabilities","isMobile","batteryLevel","isCharging","memoryLimit","smoothCursorPosition","particlePoolRef","starBurstPoolRef","activeStarBurstsRef","colorCacheRef","Map","getCachedColor","baseColor","opacity","safeOpacity","Math","max","min","roundedOpacity","round","key","current","has","newColor","set","get","detectCapabilities","test","navigator","userAgent","webGLSupported","canvas","document","createElement","window","WebGLRenderingContext","getContext","e","prev","memory","deviceMemory","cores","hardwareConcurrency","performanceScore","quality","getBattery","then","battery","updateBattery","level","charging","addEventListener","catch","adaptiveSettings","actualParticleCount","floor","starSize","useGlow","useHighQualityEdges","constellationOpacity","twinkleFrequency","particleSpeed","initializeParticles","newParticles","totalParticles","maxTwinklingStars","twinklingIndices","Set","size","add","random","i","particle","length","pop","isTwinkling","canTwinkle","baseSize","speedX","speedY","baseOpacity","twinkleStartTime","twinkleDuration","lastTwinkleTime","nextTwinkleTime","canBurst","burstThreshold","lastBurstTime","burstCooldown","push","initializeConstellations","map","constellation","vertex","twinkleProgress","twinkleSpeed","lastTwinkle","twinkleInterval","originalX","originalY","parallaxFactor","isHighlighted","highlightProgress","highlightSpeed","lastHighlight","highlightInterval","createStarBurst","burst","life","vx","vy","decay","startTime","duration","angle","PI","speed","cos","sin","performance","now","initWebGL","gl","alpha","antialias","premultipliedAlpha","depth","powerPreference","enable","BLEND","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","clearColor","error","console","setupCanvas","devicePixelRatio","displayWidth","innerWidth","displayHeight","innerHeight","style","ctx","scale","desynchronized","willReadFrequently","imageSmoothingEnabled","imageSmoothingQuality","handleResize","reducedMotionQuery","matchMedia","matches","handleReducedMotionChange","handleVisibilityChange","hidden","removeEventListener","cancelAnimationFrame","drawBackground2D","timestamp","deltaTime","clearRect","fillStyle","fillRect","parallaxOffsetX","parallaxOffsetY","forEach","twinkleProbability","twinklePhase","particleOpacity","particleSize","twinkleFactor","normalizedTwinkle","drawX","drawY","beginPath","arc","fill","gradient","createRadialGradient","addColorStop","edgeOpacity","vertexMultiplier","highlightPulse","edge","startVertex","endVertex","startX","startY","endX","endY","createLinearGradient","moveTo","lineTo","strokeStyle","lineWidth","stroke","vertexSize","vertexOpacity","pulseFactor","index","elapsed","progress","splice","glowRadius","fpsLimiter","callback","requestAnimationFrame","time","fixedTargetFPS","targetFrameTime","animate","clear","COLOR_BUFFER_BIT","className","children","fileName","_jsxFileName","lineNumber","columnNumber","ref","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/Background.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';\nimport { createUseStyles } from 'react-jss';\n\n// Enhanced CSS-in-JS styles with hardware acceleration and performance optimizations\nconst useStyles = createUseStyles({\n  backgroundWrapper: {\n    position: 'fixed',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n    zIndex: 1,\n    pointerEvents: 'none',\n    overflow: 'hidden',\n    // Hardware acceleration\n    transform: 'translateZ(0)',\n    backfaceVisibility: 'hidden',\n    perspective: 1000,\n    willChange: 'transform'\n  },\n  backgroundBlack: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n    backgroundColor: '#000000',\n    zIndex: 1,\n  },\n  backgroundCanvas: {\n    position: 'fixed',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n    zIndex: 1,\n    pointerEvents: 'none',\n    // Hardware acceleration\n    transform: 'translateZ(0)',\n    backfaceVisibility: 'hidden',\n    perspective: 1000,\n    willChange: 'transform',\n    // Ensure proper rendering\n    imageRendering: 'high-quality'\n  }\n});\n\n// Enhanced constellation definitions with more stars and connections\nconst CONSTELLATIONS = [\n  {\n    name: 'Ursa Major',\n    vertices: [\n      { x: 0.2, y: 0.3 }, { x: 0.25, y: 0.28 }, { x: 0.3, y: 0.25 },\n      { x: 0.35, y: 0.23 }, { x: 0.37, y: 0.18 }, { x: 0.33, y: 0.15 },\n      { x: 0.28, y: 0.15 }\n    ],\n    edges: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]\n  },\n  {\n    name: 'Cassiopeia',\n    vertices: [\n      { x: 0.7, y: 0.15 }, { x: 0.75, y: 0.2 }, { x: 0.8, y: 0.15 },\n      { x: 0.85, y: 0.2 }, { x: 0.9, y: 0.15 }\n    ],\n    edges: [[0, 1], [1, 2], [2, 3], [3, 4]]\n  },\n  {\n    name: 'Orion',\n    vertices: [\n      { x: 0.5, y: 0.5 }, { x: 0.48, y: 0.45 }, { x: 0.52, y: 0.45 },\n      { x: 0.51, y: 0.4 }, { x: 0.5, y: 0.35 }, { x: 0.53, y: 0.32 },\n      { x: 0.47, y: 0.32 }\n    ],\n    edges: [[0, 1], [0, 2], [1, 3], [2, 3], [3, 4], [4, 5], [4, 6]]\n  },\n  {\n    name: 'Cygnus',\n    vertices: [\n      { x: 0.15, y: 0.65 }, { x: 0.2, y: 0.6 }, { x: 0.25, y: 0.55 },\n      { x: 0.3, y: 0.5 }, { x: 0.35, y: 0.45 }, { x: 0.25, y: 0.5 },\n      { x: 0.15, y: 0.5 }\n    ],\n    edges: [[0, 1], [1, 2], [2, 3], [3, 4], [2, 5], [5, 6]]\n  }\n];\n\n/**\n * Enterprise-grade Background Component\n * \n * Creates a high-performance animated starry background with constellations,\n * interactive cursor effects, and optimized rendering for all devices.\n * \n * Features:\n * - Hardware accelerated rendering with Canvas 2D or WebGL\n * - Device-adaptive quality settings for better performance\n * - Optimized memory usage with object pooling\n * - Battery-aware rendering for mobile devices\n * - Smooth animations with efficient frame management\n * - Enhanced visual effects with adaptive detail levels\n * \n * @param {Object} props - Component props\n * @param {Object} props.cursorPosition - Current cursor coordinates\n * @param {Function} props.setCursorPosition - Function to update cursor position\n * @param {boolean} [props.enableWebGL=false] - Enable WebGL rendering for better performance\n * @param {boolean} [props.adaptiveQuality=true] - Enable adaptive quality based on device\n * @param {boolean} [props.enableParallax=true] - Enable parallax effect on scroll/cursor\n * @param {boolean} [props.respectReducedMotion=true] - Respect reduced motion preferences\n * @param {number} [props.particleCount=80] - Number of background particles\n * @param {boolean} [props.enableCursorGlow=true] - Enable cursor glow effect\n * @param {number} [props.targetFPS=30] - Target frame rate\n * @param {boolean} [props.enableStarBurst=true] - Enable occasional star burst effects\n */\nconst Background = ({\n  cursorPosition, \n  setCursorPosition,\n  enableWebGL = false,\n  adaptiveQuality = true,\n  enableParallax = true,\n  respectReducedMotion = true,\n  particleCount = 80,\n  enableCursorGlow = true,\n  targetFPS = 30,\n  enableStarBurst = true\n}) => {\n  // Styles and refs\n  const classes = useStyles();\n  const canvasRef = useRef(null);\n  const particlesRef = useRef([]);\n  const constellationsRef = useRef([]);\n  const requestRef = useRef(null);\n  const timeRef = useRef(0);\n  const lastFrameTimeRef = useRef(0);\n  const frameCountRef = useRef(0);\n  const fpsCounterRef = useRef(0);\n  const lastRenderTimeRef = useRef(0);\n  const webGLRef = useRef(null);\n  \n  // Component state\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0, pixelRatio: 1 });\n  const [isVisible, setIsVisible] = useState(true);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [qualityFactor, setQualityFactor] = useState(1);\n  const [renderingMode, setRenderingMode] = useState('2d');\n  \n  // Device capabilities state - used throughout the component\n  const [deviceCapabilities, setDeviceCapabilities] = useState({\n    isMobile: false,\n    batteryLevel: 1,\n    isCharging: true,\n    memoryLimit: false\n  });\n  \n  // Optimized cursor position with interpolation for smoother movement\n  const smoothCursorPosition = useRef({ x: 0, y: 0 });\n  \n  // Particle and star burst object pools\n  const particlePoolRef = useRef([]);\n  const starBurstPoolRef = useRef([]);\n  const activeStarBurstsRef = useRef([]);\n  \n  // Color caching to avoid string operations during rendering\n  const colorCacheRef = useRef(new Map());\n  \n  // Get cached color with opacity\n  const getCachedColor = useCallback((baseColor, opacity) => {\n    // Ensure opacity is within valid range\n    const safeOpacity = Math.max(0, Math.min(1, opacity));\n    \n    // Round opacity to reduce cache size (0.01 precision is enough for visual effects)\n    const roundedOpacity = Math.round(safeOpacity * 100) / 100;\n    const key = `${baseColor}-${roundedOpacity}`;\n    \n    if (!colorCacheRef.current.has(key)) {\n      const newColor = baseColor + roundedOpacity + ')';\n      colorCacheRef.current.set(key, newColor);\n    }\n    \n    return colorCacheRef.current.get(key);\n  }, []);\n  \n  // Detect device capabilities and set appropriate quality levels\n  const detectCapabilities = useCallback(() => {\n    // Check for mobile devices\n    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n    \n    // Check for WebGL support\n    let webGLSupported = false;\n    if (enableWebGL) {\n      try {\n        const canvas = document.createElement('canvas');\n        webGLSupported = !!(window.WebGLRenderingContext && \n          (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));\n      } catch (e) {\n        webGLSupported = false;\n      }\n    }\n    \n    // Set rendering mode based on capabilities\n    setRenderingMode(webGLSupported && enableWebGL ? 'webgl' : '2d');\n    \n    // Set device capability state\n    setDeviceCapabilities(prev => ({\n      ...prev,\n      isMobile\n    }));\n    \n    // Determine quality factor based on device capabilities\n    if (adaptiveQuality) {\n      const memory = navigator.deviceMemory || 4; // Default to 4GB if not available\n      const cores = navigator.hardwareConcurrency || 4; // Default to 4 cores\n      \n      // Calculate performance score\n      const performanceScore = (memory * cores) / (isMobile ? 2 : 1);\n      \n      // Scale quality based on performance score\n      let quality = 1;\n      \n      if (performanceScore > 16) {\n        quality = 1; // High-end devices\n      } else if (performanceScore > 8) {\n        quality = 0.85; // Mid-range devices\n      } else if (performanceScore > 4) {\n        quality = 0.7; // Low-end devices\n      } else {\n        quality = 0.5; // Very low-end devices\n      }\n      \n      setQualityFactor(quality);\n    }\n    \n    // Check battery status if available\n    if (navigator.getBattery) {\n      navigator.getBattery().then(battery => {\n        const updateBattery = () => {\n          setDeviceCapabilities(prev => ({\n            ...prev,\n            batteryLevel: battery.level,\n            isCharging: battery.charging\n          }));\n          \n          // Reduce quality if on low battery and not charging\n          if (!battery.charging && battery.level < 0.3 && adaptiveQuality) {\n            setQualityFactor(prev => Math.min(prev, 0.6));\n          }\n        };\n        \n        // Add battery event listeners\n        battery.addEventListener('levelchange', updateBattery);\n        battery.addEventListener('chargingchange', updateBattery);\n        \n        // Initial update\n        updateBattery();\n      }).catch(() => {\n        // Battery API failed, continue without battery optimization\n      });\n    }\n  }, [enableWebGL, adaptiveQuality]);\n  \n  // Calculate adaptive settings based on device capabilities and quality factor\n  const adaptiveSettings = useMemo(() => {\n    // Drastically reduce particle count to lower visual noise\n    const actualParticleCount = Math.max(25, Math.floor(particleCount * 0.4));\n    \n    return {\n      particleCount: actualParticleCount,\n      starSize: 1,\n      useGlow: qualityFactor > 0.6,\n      useHighQualityEdges: qualityFactor > 0.7,\n      constellationOpacity: 0.1 * qualityFactor,\n      // Extremely low twinkling frequency\n      twinkleFrequency: 0.00002,\n      // Nearly static particles\n      particleSpeed: 0.01\n    };\n  }, [qualityFactor, particleCount]);\n  \n  // Initialize particles with appropriate pooling\n  const initializeParticles = useCallback(() => {\n    if (!dimensions.width || !dimensions.height) return;\n    \n    const width = dimensions.width;\n    const height = dimensions.height;\n    \n    // Create a stable set of particles\n    const newParticles = [];\n    \n    // Create long-lasting twinkling for a small subset of stars\n    const totalParticles = adaptiveSettings.particleCount;\n    const maxTwinklingStars = Math.floor(totalParticles * 0.07); // Limit to 7% of stars\n    const twinklingIndices = new Set();\n    \n    while (twinklingIndices.size < maxTwinklingStars) {\n      twinklingIndices.add(Math.floor(Math.random() * totalParticles));\n    }\n    \n    // Try to get from pool first, then create new ones if needed\n    for (let i = 0; i < adaptiveSettings.particleCount; i++) {\n      let particle;\n      \n      if (particlePoolRef.current.length > 0) {\n        // Reuse from pool\n        particle = particlePoolRef.current.pop();\n        \n        // Reset particle properties\n        particle.x = Math.random() * width;\n        particle.y = Math.random() * height;\n        particle.isTwinkling = false;\n      } else {\n        // Determine if this particle can twinkle\n        const canTwinkle = twinklingIndices.has(i);\n        \n        // Create new particle with significantly reduced movement and effects\n        particle = {\n          x: Math.random() * width,\n          y: Math.random() * height,\n          size: Math.random() * 1.2 + 0.5,\n          baseSize: Math.random() * 1.2 + 0.5,\n          // Almost static particles\n          speedX: (Math.random() - 0.5) * adaptiveSettings.particleSpeed * 0.5,\n          speedY: (Math.random() - 0.5) * adaptiveSettings.particleSpeed * 0.5,\n          opacity: Math.random() * 0.25 + 0.05,\n          baseOpacity: Math.random() * 0.25 + 0.05,\n          // Only allow selected particles to twinkle at all\n          canTwinkle: canTwinkle,\n          // Very slow twinkling for a gentle effect\n          isTwinkling: false,\n          twinkleStartTime: 0,\n          twinkleDuration: Math.random() * 4000 + 3000, // 3-7 second twinkle\n          lastTwinkleTime: -1 * (Math.random() * 15000), // Stagger initial twinkles\n          nextTwinkleTime: Math.random() * 20000 + 15000, // 15-35 seconds between twinkles\n          // For star bursts - only 3% of stars can burst\n          canBurst: Math.random() < 0.03,\n          burstThreshold: Math.random() * 0.0001,\n          lastBurstTime: 0,\n          burstCooldown: Math.random() * 45000 + 30000 // 30-75 second cooldown\n        };\n      }\n      \n      newParticles.push(particle);\n    }\n    \n    particlesRef.current = newParticles;\n  }, [dimensions, adaptiveSettings]);\n  \n  // Initialize constellations\n  const initializeConstellations = useCallback(() => {\n    if (!dimensions.width || !dimensions.height) return;\n    \n    // Initialize constellations with actual screen positions\n    constellationsRef.current = CONSTELLATIONS.map(constellation => {\n      const vertices = constellation.vertices.map(vertex => ({\n        x: vertex.x * dimensions.width,\n        y: vertex.y * dimensions.height,\n        size: 1.8 * adaptiveSettings.starSize,\n        baseSize: 1.8 * adaptiveSettings.starSize,\n        opacity: 0.2 * qualityFactor,\n        baseOpacity: 0.2 * qualityFactor,\n        isTwinkling: false,\n        twinkleProgress: 0,\n        // Extremely slow twinkling for stability\n        twinkleSpeed: Math.random() * 0.005 + 0.001,\n        lastTwinkle: Math.random() * 10000, // Stagger initial twinkles\n        // Very long intervals between twinkles\n        twinkleInterval: Math.random() * 20000 + 15000,\n        // Minimal parallax effect\n        originalX: vertex.x * dimensions.width,\n        originalY: vertex.y * dimensions.height,\n        parallaxFactor: Math.random() * 0.02 + 0.01 // 1/10th the original parallax factor\n      }));\n      \n      return {\n        name: constellation.name,\n        vertices,\n        edges: constellation.edges,\n        // Rare constellation highlighting\n        isHighlighted: false,\n        highlightProgress: 0,\n        highlightSpeed: 0.001, // 10x slower than original\n        lastHighlight: Math.random() * 30000, // Stagger initial highlights\n        highlightInterval: Math.random() * 120000 + 90000 // Very long intervals (1.5-3.5 minutes)\n      };\n    });\n  }, [dimensions, adaptiveSettings.starSize, qualityFactor]);\n  \n  // Create star burst effect at a specific position - gentle version\n  // Create star burst effect at a specific position - gentle version\nconst createStarBurst = useCallback((x, y, size = 2, particleCount = 8) => {\n  if (!enableStarBurst) return;\n  \n  // Limit the total number of active bursts to prevent overdraw\n  if (activeStarBurstsRef.current.length > 10) return;\n  \n  // Use a reasonable number of particles\n  const actualParticleCount = Math.min(particleCount, 5);\n  \n  for (let i = 0; i < actualParticleCount; i++) {\n    // Try to get from pool first\n    let burst;\n    \n    if (starBurstPoolRef.current.length > 0) {\n      burst = starBurstPoolRef.current.pop();\n      \n      // Reset burst properties\n      burst.life = 1.0;\n      burst.x = x;\n      burst.y = y;\n    } else {\n      // Create new burst particle\n      burst = {\n        x,\n        y,\n        vx: 0,\n        vy: 0,\n        size: 0,\n        life: 1.0,\n        decay: 0,\n        startTime: 0,\n        duration: 0\n      };\n    }\n    \n    // Randomize burst parameters with slower speeds\n    const angle = Math.random() * Math.PI * 2;\n    const speed = Math.random() * 0.5 + 0.2; // Very slow movement\n    \n    burst.vx = Math.cos(angle) * speed;\n    burst.vy = Math.sin(angle) * speed;\n    burst.size = size * (0.3 + Math.random() * 0.3); // Smaller particles\n    burst.startTime = performance.now();\n    burst.duration = Math.random() * 3000 + 2000; // 2-5 second duration\n    \n    activeStarBurstsRef.current.push(burst);\n  }\n}, [enableStarBurst]);\n  \n  // Initialize WebGL context if enabled\n  const initWebGL = useCallback(() => {\n    if (!canvasRef.current || renderingMode !== 'webgl') return false;\n    \n    try {\n      const gl = canvasRef.current.getContext('webgl', {\n        alpha: true,\n        antialias: true,\n        premultipliedAlpha: false,\n        depth: false,\n        powerPreference: 'default'\n      });\n      \n      if (!gl) return false;\n      \n      webGLRef.current = gl;\n      \n      // Basic WebGL setup (simplified)\n      gl.enable(gl.BLEND);\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n      gl.clearColor(0.0, 0.0, 0.0, 1.0);\n      \n      return true;\n    } catch (error) {\n      console.error('WebGL initialization error:', error);\n      setRenderingMode('2d');\n      return false;\n    }\n  }, [renderingMode]);\n  \n  // Canvas setup with proper scaling for high-DPI displays\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) return false;\n    \n    const canvas = canvasRef.current;\n    const pixelRatio = window.devicePixelRatio || 1;\n    \n    // Get display dimensions\n    const displayWidth = window.innerWidth;\n    const displayHeight = window.innerHeight;\n    \n    // Set canvas rendering size (accounting for pixel ratio)\n    canvas.width = displayWidth * pixelRatio;\n    canvas.height = displayHeight * pixelRatio;\n    \n    // Set display size via CSS\n    canvas.style.width = `${displayWidth}px`;\n    canvas.style.height = `${displayHeight}px`;\n    \n    // Store dimensions\n    setDimensions({\n      width: displayWidth,\n      height: displayHeight,\n      pixelRatio\n    });\n    \n    // Initialize appropriate rendering context\n    if (renderingMode === 'webgl') {\n      if (!initWebGL()) {\n        // Fallback to 2D if WebGL fails\n        const ctx = canvas.getContext('2d');\n        ctx.scale(pixelRatio, pixelRatio);\n      }\n    } else {\n      // 2D Canvas context\n      const ctx = canvas.getContext('2d', {\n        alpha: true,\n        desynchronized: true,\n        willReadFrequently: false\n      });\n      \n      if (!ctx) return false;\n      \n      // Scale context for high-DPI displays\n      ctx.scale(pixelRatio, pixelRatio);\n      \n      // Enable high-quality rendering if device can handle it\n      if (qualityFactor > 0.7) {\n        ctx.imageSmoothingEnabled = true;\n        ctx.imageSmoothingQuality = 'high';\n      }\n    }\n    \n    return true;\n  }, [qualityFactor, renderingMode, initWebGL]);\n  \n  // Handle window resize\n  const handleResize = useCallback(() => {\n    if (setupCanvas()) {\n      // Reinitialize particles and constellations\n      initializeParticles();\n      initializeConstellations();\n    }\n  }, [setupCanvas, initializeParticles, initializeConstellations]);\n  \n  // Detect device capabilities and preferences\n  useEffect(() => {\n    // Check for reduced motion preference\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    \n    const handleReducedMotionChange = (e) => {\n      setPrefersReducedMotion(e.matches);\n    };\n    \n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n    \n    // Detect device capabilities\n    detectCapabilities();\n    \n    // Handle visibility changes\n    const handleVisibilityChange = () => {\n      setIsVisible(!document.hidden);\n    };\n    \n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    \n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  }, [detectCapabilities]);\n  \n  // Set up responsive canvas and initialize particles\n  useEffect(() => {\n    // Initial setup\n    setupCanvas();\n    \n    // Add resize listener\n    window.addEventListener('resize', handleResize);\n    \n    return () => {\n      window.removeEventListener('resize', handleResize);\n      if (requestRef.current) {\n        cancelAnimationFrame(requestRef.current);\n      }\n    };\n  }, [setupCanvas, handleResize]);\n  \n  // Initialize particles and constellations when dimensions are available\n  useEffect(() => {\n    if (dimensions.width && dimensions.height) {\n      initializeParticles();\n      initializeConstellations();\n    }\n  }, [dimensions, initializeParticles, initializeConstellations]);\n  \n  // Draw 2D canvas background\n  const drawBackground2D = useCallback((ctx, timestamp, deltaTime) => {\n    // Start with black background\n    ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n    ctx.fillStyle = '#000000';\n    ctx.fillRect(0, 0, dimensions.width, dimensions.height);\n    \n    // Calculate interpolated cursor position for smoother effects\n    if (cursorPosition.x && cursorPosition.y) {\n      smoothCursorPosition.current.x += (cursorPosition.x - smoothCursorPosition.current.x) * 0.1;\n      smoothCursorPosition.current.y += (cursorPosition.y - smoothCursorPosition.current.y) * 0.1;\n    }\n    \n    // Calculate parallax offset based on cursor position\n    const parallaxOffsetX = enableParallax ? (smoothCursorPosition.current.x - dimensions.width / 2) / 20 : 0;\n    const parallaxOffsetY = enableParallax ? (smoothCursorPosition.current.y - dimensions.height / 2) / 20 : 0;\n    \n    // Draw regular particles\n    particlesRef.current.forEach(particle => {\n      // Skip updates if reduced motion is preferred\n      if (!(respectReducedMotion && prefersReducedMotion)) {\n        // Update position\n        particle.x += particle.speedX;\n        particle.y += particle.speedY;\n        \n        // Wrap around screen with buffer\n        if (particle.x < -20) particle.x = dimensions.width + 20;\n        if (particle.x > dimensions.width + 20) particle.x = -20;\n        if (particle.y < -20) particle.y = dimensions.height + 20;\n        if (particle.y > dimensions.height + 20) particle.y = -20;\n      }\n      \n      // Handle twinkling effect - with lower probability\n      if (Math.random() < particle.twinkleProbability * 0.2) { // Further reduce by 80%\n        // Only start twinkling if not already twinkling\n        if (!particle.isTwinkling) {\n          particle.isTwinkling = true;\n          particle.twinklePhase = Math.random() * Math.PI * 2;\n        }\n      }\n      \n      let particleOpacity = particle.opacity;\n      let particleSize = particle.size;\n      \n      if (particle.isTwinkling) {\n        // Use sine wave for smooth twinkling effect\n        const twinkleFactor = Math.sin(timestamp * 0.001 * particle.twinkleSpeed + particle.twinklePhase);\n        const normalizedTwinkle = (twinkleFactor + 1) / 2; // Convert from [-1,1] to [0,1]\n        \n        particleSize = particle.baseSize + (particle.baseSize * 0.7 * normalizedTwinkle);\n        particleOpacity = particle.baseOpacity + (0.4 * normalizedTwinkle);\n        \n        // Complete one twinkle cycle\n        if (timestamp * 0.001 * particle.twinkleSpeed + particle.twinklePhase > particle.twinklePhase + Math.PI * 2) {\n          particle.isTwinkling = false;\n          particle.twinklePhase = Math.random() * Math.PI * 2; // Reset phase for next time\n        }\n      }\n      \n      // Check for star burst with longer durations\n      if (enableStarBurst && particle.canBurst && \n          Math.random() < particle.burstThreshold * 0.25 && \n          timestamp - particle.lastBurstTime > particle.burstCooldown) {\n        createStarBurst(particle.x, particle.y, particle.size * 1.2, 3);\n        particle.lastBurstTime = timestamp;\n      }\n      \n      // Compute final position with parallax\n      const drawX = particle.x + parallaxOffsetX * 0.5;\n      const drawY = particle.y + parallaxOffsetY * 0.5;\n      \n      // Draw particle\n      ctx.beginPath();\n      ctx.arc(drawX, drawY, particleSize, 0, Math.PI * 2);\n      ctx.fillStyle = getCachedColor('rgba(191, 173, 127, ', particleOpacity);\n      ctx.fill();\n      \n      // Add glow effect for larger or twinkling particles if quality permits\n      if (adaptiveSettings.useGlow && (particleSize > 1.3 || particle.isTwinkling)) {\n        ctx.beginPath();\n        ctx.arc(drawX, drawY, particleSize * 2, 0, Math.PI * 2);\n        \n        // Create safe radial gradient\n        try {\n          const gradient = ctx.createRadialGradient(\n            drawX, drawY, particleSize * 0.5,\n            drawX, drawY, particleSize * 2\n          );\n          gradient.addColorStop(0, getCachedColor('rgba(191, 173, 127, ', particleOpacity * 0.4));\n          gradient.addColorStop(1, getCachedColor('rgba(191, 173, 127, ', 0));\n          ctx.fillStyle = gradient;\n          ctx.fill();\n        } catch (e) {\n          // Fallback if gradient creation fails\n          ctx.fillStyle = getCachedColor('rgba(191, 173, 127, ', particleOpacity * 0.2);\n          ctx.fill();\n        }\n      }\n    });\n    \n    // Draw constellations\n    constellationsRef.current.forEach(constellation => {\n      const now = timestamp;\n      let edgeOpacity = adaptiveSettings.constellationOpacity;\n      let vertexMultiplier = 1;\n      \n      // Check if it's time to highlight this constellation\n      if (now - constellation.lastHighlight > constellation.highlightInterval) {\n        constellation.isHighlighted = true;\n        constellation.highlightProgress = 0;\n        constellation.lastHighlight = now;\n      }\n      \n      // Handle highlighting animation\n      if (constellation.isHighlighted) {\n        constellation.highlightProgress += constellation.highlightSpeed * (deltaTime / 16);\n        \n        // Create a pulse effect for highlighting\n        const highlightPulse = Math.sin(constellation.highlightProgress * Math.PI);\n        edgeOpacity += highlightPulse * 0.15;\n        vertexMultiplier += highlightPulse * 0.5;\n        \n        // End highlighting after one cycle\n        if (constellation.highlightProgress >= 1) {\n          constellation.isHighlighted = false;\n        }\n      }\n      \n      // Draw edges (lines) first so they appear behind vertices\n      if (adaptiveSettings.useHighQualityEdges) {\n        // Enhanced edges with gradient for higher quality settings\n        constellation.edges.forEach(edge => {\n          const startVertex = constellation.vertices[edge[0]];\n          const endVertex = constellation.vertices[edge[1]];\n          \n          // Apply parallax to edge vertices\n          const startX = startVertex.x + parallaxOffsetX * startVertex.parallaxFactor;\n          const startY = startVertex.y + parallaxOffsetY * startVertex.parallaxFactor;\n          const endX = endVertex.x + parallaxOffsetX * endVertex.parallaxFactor;\n          const endY = endVertex.y + parallaxOffsetY * endVertex.parallaxFactor;\n          \n          // Create gradient along the line\n          try {\n            const gradient = ctx.createLinearGradient(startX, startY, endX, endY);\n            gradient.addColorStop(0, getCachedColor('rgba(191, 173, 127, ', edgeOpacity));\n            gradient.addColorStop(0.5, getCachedColor('rgba(191, 173, 127, ', edgeOpacity * 1.3));\n            gradient.addColorStop(1, getCachedColor('rgba(191, 173, 127, ', edgeOpacity));\n            \n            ctx.beginPath();\n            ctx.moveTo(startX, startY);\n            ctx.lineTo(endX, endY);\n            ctx.strokeStyle = gradient;\n            ctx.lineWidth = 0.5;\n            ctx.stroke();\n          } catch (e) {\n            // Fallback to simple line if gradient fails\n            ctx.beginPath();\n            ctx.moveTo(startX, startY);\n            ctx.lineTo(endX, endY);\n            ctx.strokeStyle = getCachedColor('rgba(191, 173, 127, ', edgeOpacity);\n            ctx.lineWidth = 0.5;\n            ctx.stroke();\n          }\n        });\n      } else {\n        // Simple edges for lower quality settings\n        ctx.beginPath();\n        ctx.strokeStyle = getCachedColor('rgba(191, 173, 127, ', edgeOpacity);\n        ctx.lineWidth = 0.5;\n        \n        constellation.edges.forEach(edge => {\n          const startVertex = constellation.vertices[edge[0]];\n          const endVertex = constellation.vertices[edge[1]];\n          \n          // Apply parallax\n          const startX = startVertex.x + parallaxOffsetX * startVertex.parallaxFactor;\n          const startY = startVertex.y + parallaxOffsetY * startVertex.parallaxFactor;\n          const endX = endVertex.x + parallaxOffsetX * endVertex.parallaxFactor;\n          const endY = endVertex.y + parallaxOffsetY * endVertex.parallaxFactor;\n          \n          ctx.moveTo(startX, startY);\n          ctx.lineTo(endX, endY);\n        });\n        ctx.stroke();\n      }\n      \n      // Draw and update vertices\n      constellation.vertices.forEach(vertex => {\n        // Occasional twinkling for constellation stars\n        if (timestamp - vertex.lastTwinkle > vertex.twinkleInterval) {\n          vertex.isTwinkling = true;\n          vertex.twinkleProgress = 0;\n          vertex.lastTwinkle = timestamp;\n        }\n        \n        let vertexSize = vertex.size * vertexMultiplier;\n        let vertexOpacity = vertex.opacity * vertexMultiplier;\n        \n        if (vertex.isTwinkling) {\n          vertex.twinkleProgress += vertex.twinkleSpeed * (deltaTime / 16);\n          \n          // Create a pulse effect\n          const pulseFactor = Math.sin(vertex.twinkleProgress * Math.PI);\n          vertexSize += vertex.baseSize * pulseFactor * 0.5;\n          vertexOpacity += 0.3 * pulseFactor;\n          \n          // End twinkling after one cycle\n          if (vertex.twinkleProgress >= 1) {\n            vertex.isTwinkling = false;\n          }\n        }\n        \n        // Apply parallax to vertex position\n        const drawX = vertex.x + parallaxOffsetX * vertex.parallaxFactor;\n        const drawY = vertex.y + parallaxOffsetY * vertex.parallaxFactor;\n        \n        // Draw constellation vertex\n        ctx.beginPath();\n        ctx.arc(drawX, drawY, vertexSize, 0, Math.PI * 2);\n        ctx.fillStyle = getCachedColor('rgba(207, 185, 130, ', vertexOpacity);\n        ctx.fill();\n        \n        // Add glow for constellation vertices if quality permits\n        if (adaptiveSettings.useGlow) {\n          ctx.beginPath();\n          ctx.arc(drawX, drawY, vertexSize * 3, 0, Math.PI * 2);\n          \n          try {\n            const gradient = ctx.createRadialGradient(\n              drawX, drawY, vertexSize * 0.5,\n              drawX, drawY, vertexSize * 3\n            );\n            gradient.addColorStop(0, getCachedColor('rgba(207, 185, 130, ', vertexOpacity * 0.4));\n            gradient.addColorStop(1, getCachedColor('rgba(207, 185, 130, ', 0));\n            ctx.fillStyle = gradient;\n            ctx.fill();\n          } catch (e) {\n            // Fallback if gradient creation fails\n            ctx.fillStyle = getCachedColor('rgba(207, 185, 130, ', vertexOpacity * 0.2);\n            ctx.fill();\n          }\n        }\n      });\n    });\n    \n    // Draw active star bursts with gentle transitions\n    activeStarBurstsRef.current.forEach((burst, index) => {\n      if (!burst) return;\n      \n      const now = performance.now();\n      const startTime = burst.startTime || now;\n      const elapsed = now - startTime;\n      \n      // Use smooth easing for burst life\n      if (burst.duration) {\n        // Progress based on duration\n        const progress = Math.min(1, elapsed / burst.duration);\n        \n        // Ease in, then ease out\n        if (progress < 0.3) {\n          // Fade in (first 30%)\n          burst.life = progress / 0.3;\n        } else if (progress > 0.7) {\n          // Fade out (last 30%)\n          burst.life = (1 - progress) / 0.3;\n        } else {\n          // Stay bright in the middle\n          burst.life = 1.0;\n        }\n        \n        // Remove if complete\n        if (progress >= 1) {\n          // Return to pool\n          starBurstPoolRef.current.push(burst);\n          activeStarBurstsRef.current.splice(index, 1);\n          return;\n        }\n      } else {\n        // Legacy support for bursts without duration\n        burst.life -= burst.decay * (deltaTime / 16);\n        \n        // Remove if life is depleted\n        if (burst.life <= 0) {\n          // Return to pool\n          starBurstPoolRef.current.push(burst);\n          activeStarBurstsRef.current.splice(index, 1);\n          return;\n        }\n      }\n      \n      // Update position\n      burst.x += burst.vx * (deltaTime / 16);\n      burst.y += burst.vy * (deltaTime / 16);\n      \n      // Draw burst particle with smooth opacity\n      ctx.beginPath();\n      ctx.arc(burst.x, burst.y, burst.size * burst.life, 0, Math.PI * 2);\n      ctx.fillStyle = getCachedColor('rgba(207, 185, 130, ', burst.life * 0.6);\n      ctx.fill();\n      \n      // Add glow for bursts\n      if (adaptiveSettings.useGlow) {\n        ctx.beginPath();\n        ctx.arc(burst.x, burst.y, burst.size * burst.life * 2, 0, Math.PI * 2);\n        \n        try {\n          const gradient = ctx.createRadialGradient(\n            burst.x, burst.y, burst.size * burst.life * 0.5,\n            burst.x, burst.y, burst.size * burst.life * 2\n          );\n          gradient.addColorStop(0, getCachedColor('rgba(207, 185, 130, ', burst.life * 0.3));\n          gradient.addColorStop(1, getCachedColor('rgba(207, 185, 130, ', 0));\n          ctx.fillStyle = gradient;\n          ctx.fill();\n        } catch (e) {\n          // Fallback if gradient creation fails\n          ctx.fillStyle = getCachedColor('rgba(207, 185, 130, ', burst.life * 0.15);\n          ctx.fill();\n        }\n      }\n    });\n    \n    // Draw cursor influence - enhanced glow effect\n    if (enableCursorGlow && smoothCursorPosition.current.x && smoothCursorPosition.current.y) {\n      // Outer glow\n      const glowRadius = 120;\n      \n      try {\n        const gradient = ctx.createRadialGradient(\n          smoothCursorPosition.current.x, smoothCursorPosition.current.y, 0,\n          smoothCursorPosition.current.x, smoothCursorPosition.current.y, glowRadius\n        );\n        gradient.addColorStop(0, getCachedColor('rgba(160, 142, 97, ', 0.05));\n        gradient.addColorStop(0.5, getCachedColor('rgba(160, 142, 97, ', 0.02));\n        gradient.addColorStop(1, getCachedColor('rgba(160, 142, 97, ', 0));\n        \n        ctx.beginPath();\n        ctx.arc(smoothCursorPosition.current.x, smoothCursorPosition.current.y, glowRadius, 0, Math.PI * 2);\n        ctx.fillStyle = gradient;\n        ctx.fill();\n      } catch (e) {\n        // Fallback to simple glow if gradient fails\n        ctx.beginPath();\n        ctx.arc(smoothCursorPosition.current.x, smoothCursorPosition.current.y, glowRadius / 2, 0, Math.PI * 2);\n        ctx.fillStyle = getCachedColor('rgba(160, 142, 97, ', 0.02);\n        ctx.fill();\n      }\n      \n      // Create occasional particles at cursor position with longer lifespans\n      if (enableStarBurst && Math.random() < 0.001) {\n        createStarBurst(\n          smoothCursorPosition.current.x, \n          smoothCursorPosition.current.y, \n          0.8 + Math.random() * 0.4,\n          Math.min(2, Math.floor(Math.random() * 2) + 1) \n        );\n      }\n    }\n  }, [\n    dimensions, \n    cursorPosition,\n    enableParallax,\n    respectReducedMotion,\n    prefersReducedMotion,\n    adaptiveSettings,\n    getCachedColor,\n    enableStarBurst,\n    createStarBurst,\n    enableCursorGlow\n  ]);\n  \n  // FPS limiter for consistent animation rate\n  const fpsLimiter = useCallback((timestamp, callback) => {\n    // Skip animation if hidden, inactive, or reduced motion\n    if (!isVisible || (respectReducedMotion && prefersReducedMotion)) {\n      requestRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n      return;\n    }\n    \n    // Force a very low FPS (15 FPS maximum) for stable, non-jittery animation\n    const fixedTargetFPS = 15;\n    const targetFrameTime = 1000 / fixedTargetFPS;\n    const elapsed = timestamp - lastFrameTimeRef.current;\n    \n    if (elapsed >= targetFrameTime || lastFrameTimeRef.current === 0) {\n      // Calculate correct delta time, but significantly slow down all animations\n      const deltaTime = Math.min(elapsed, 50) * 0.25; // Cap and slow down by 75%\n      \n      // Update timestamps\n      lastFrameTimeRef.current = timestamp;\n      lastRenderTimeRef.current = timestamp;\n      \n      // Run animation callback with heavily reduced delta time\n      callback(timestamp, deltaTime);\n      \n      // FPS measurement\n      frameCountRef.current++;\n      if (timestamp - fpsCounterRef.current >= 1000) {\n        // Reset counter\n        frameCountRef.current = 0;\n        fpsCounterRef.current = timestamp;\n      }\n    }\n    \n    // Schedule next frame\n    requestRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n  }, [isVisible, respectReducedMotion, prefersReducedMotion]);\n  \n  // Main animation function\n  const animate = useCallback((timestamp, deltaTime) => {\n    timeRef.current = timestamp;\n    \n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    if (renderingMode === 'webgl' && webGLRef.current) {\n      // WebGL rendering path (simplified)\n      const gl = webGLRef.current;\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      \n      // In a real implementation, this would render the scene using WebGL\n      // Currently falls back to 2D Canvas as WebGL implementation is a placeholder\n      const ctx = canvas.getContext('2d');\n      if (ctx) {\n        drawBackground2D(ctx, timestamp, deltaTime);\n      }\n    } else {\n      // Canvas 2D rendering path\n      const ctx = canvas.getContext('2d');\n      if (ctx) {\n        drawBackground2D(ctx, timestamp, deltaTime);\n      }\n    }\n  }, [renderingMode, drawBackground2D]);\n  \n  // Start animation loop\n  useEffect(() => {\n    if (!dimensions.width || !dimensions.height) return;\n    \n    // Start animation with FPS limiter\n    lastFrameTimeRef.current = 0;\n    fpsCounterRef.current = performance.now();\n    frameCountRef.current = 0;\n    \n    requestRef.current = requestAnimationFrame(timestamp => {\n      fpsLimiter(timestamp, animate);\n    });\n    \n    return () => {\n      if (requestRef.current) {\n        cancelAnimationFrame(requestRef.current);\n      }\n    };\n  }, [dimensions, fpsLimiter, animate]);\n  \n  return (\n    <div className={classes.backgroundWrapper}>\n      {/* Black background layer */}\n      <div className={classes.backgroundBlack}></div>\n      {/* Canvas for stars and constellations */}\n      <canvas ref={canvasRef} className={classes.backgroundCanvas} />\n    </div>\n  );\n};\n\nexport default Background;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}