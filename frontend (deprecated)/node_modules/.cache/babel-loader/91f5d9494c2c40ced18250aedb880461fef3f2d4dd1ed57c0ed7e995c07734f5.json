{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/effects/scrollingeffects/SlidingBackground.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\n\n/**\n * SlidingBackground Component\n * \n * A highly configurable component that creates a parallax background with fade effects\n * that can be positioned at the top, middle, or bottom of the viewport.\n * \n * @param {Object} props - Component props\n * @param {string} props.image - URL of the background image\n * @param {string} [props.position='top'] - Position of the focused area ('top', 'middle', 'bottom')\n * @param {string|number} [props.height='33vh'] - Height of the component\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of the parallax effect (0-1)\n * @param {number} [props.fadeSize=0.4] - Size of the fade effect (0-1, as a fraction of the component)\n * @param {string} [props.backgroundColor='#000'] - Background color for the fade effect\n * @param {number} [props.zIndex=0] - z-index of the component\n * @param {number} [props.blurAmount=0] - Amount of blur for the fade transition (px)\n * @param {number} [props.opacity=1] - Opacity of the background image\n * @param {string} [props.backgroundSize='cover'] - Background size property\n * @param {string} [props.backgroundPosition] - Background position (overrides position setting)\n * @param {string} [props.transitionEffect='gradient'] - Type of transition effect ('gradient', 'dissolve')\n * @param {React.ReactNode} [props.children] - Content to render on top of the background\n */\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst SlidingBackground = ({\n  image,\n  position = 'top',\n  height = '33vh',\n  parallaxIntensity = 0.2,\n  fadeSize = 0.4,\n  backgroundColor = '#000',\n  zIndex = 0,\n  blurAmount = 0,\n  opacity = 1,\n  backgroundSize = 'cover',\n  backgroundPosition,\n  transitionEffect = 'gradient',\n  children\n}) => {\n  _s();\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const [scrollPosition, setScrollPosition] = useState(0);\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0\n  });\n  const [imageLoaded, setImageLoaded] = useState(false);\n  const imageRef = useRef(null);\n  const animationFrameRef = useRef(null);\n\n  // Define renderDissolveEffect with useCallback BEFORE it's used in any useEffect\n  const renderDissolveEffect = useCallback(() => {\n    if (!canvasRef.current || !imageRef.current || !dimensions.width || !dimensions.height) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const img = imageRef.current;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Calculate parallax offset\n    const parallaxOffset = scrollPosition * parallaxIntensity;\n\n    // Calculate image dimensions to maintain aspect ratio while covering the canvas\n    const imgAspect = img.width / img.height;\n    const canvasAspect = canvas.width / canvas.height;\n    let drawWidth, drawHeight, offsetX, offsetY;\n    if (imgAspect > canvasAspect) {\n      // Image is wider than canvas (relative to height)\n      drawHeight = canvas.height;\n      drawWidth = drawHeight * imgAspect;\n      offsetX = (canvas.width - drawWidth) / 2;\n      offsetY = 0;\n    } else {\n      // Image is taller than canvas (relative to width)\n      drawWidth = canvas.width;\n      drawHeight = drawWidth / imgAspect;\n      offsetX = 0;\n      offsetY = (canvas.height - drawHeight) / 2;\n    }\n\n    // Adjust based on position setting\n    if (position === 'top') {\n      offsetY = 0;\n    } else if (position === 'bottom') {\n      offsetY = canvas.height - drawHeight;\n    }\n\n    // Apply parallax\n    offsetY += parallaxOffset;\n\n    // Draw the image\n    ctx.globalAlpha = opacity;\n    ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);\n\n    // Apply blur if specified\n    if (blurAmount > 0) {\n      ctx.filter = `blur(${blurAmount}px)`;\n      ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);\n      ctx.filter = 'none';\n    }\n\n    // Determine which edges should fade based on position\n    const shouldFadeTop = position === 'bottom' || position === 'middle';\n    const shouldFadeBottom = position === 'top' || position === 'middle';\n\n    // Top dissolve effect\n    if (shouldFadeTop) {\n      const fadeHeight = Math.floor(canvas.height * fadeSize);\n      const imageData = ctx.getImageData(0, 0, canvas.width, fadeHeight);\n      const pixels = imageData.data;\n      for (let y = 0; y < fadeHeight; y++) {\n        const fadeRatio = 1 - y / fadeHeight;\n        for (let x = 0; x < canvas.width; x++) {\n          const pixelIndex = (y * canvas.width + x) * 4;\n\n          // Apply dissolve effect with random pattern\n          if (Math.random() < fadeRatio * 0.8) {\n            pixels[pixelIndex + 3] = 0; // Set alpha to 0 (transparent)\n          } else {\n            // Gradually decrease opacity\n            pixels[pixelIndex + 3] = pixels[pixelIndex + 3] * (1 - fadeRatio);\n          }\n        }\n      }\n      ctx.putImageData(imageData, 0, 0);\n\n      // Add gradient overlay\n      const gradient = ctx.createLinearGradient(0, 0, 0, fadeHeight);\n      gradient.addColorStop(0, backgroundColor);\n      gradient.addColorStop(1, 'rgba(0,0,0,0)');\n      ctx.fillStyle = gradient;\n      ctx.globalAlpha = 0.7;\n      ctx.fillRect(0, 0, canvas.width, fadeHeight);\n    }\n\n    // Bottom dissolve effect\n    if (shouldFadeBottom) {\n      const fadeHeight = Math.floor(canvas.height * fadeSize);\n      const startY = canvas.height - fadeHeight;\n      const imageData = ctx.getImageData(0, startY, canvas.width, fadeHeight);\n      const pixels = imageData.data;\n      for (let y = 0; y < fadeHeight; y++) {\n        const fadeRatio = y / fadeHeight;\n        for (let x = 0; x < canvas.width; x++) {\n          const pixelIndex = (y * canvas.width + x) * 4;\n\n          // Apply dissolve effect with random pattern\n          if (Math.random() < fadeRatio * 0.8) {\n            pixels[pixelIndex + 3] = 0; // Set alpha to 0 (transparent)\n          } else {\n            // Gradually decrease opacity\n            pixels[pixelIndex + 3] = pixels[pixelIndex + 3] * (1 - fadeRatio);\n          }\n        }\n      }\n      ctx.putImageData(imageData, 0, startY);\n\n      // Add gradient overlay\n      const gradient = ctx.createLinearGradient(0, startY, 0, canvas.height);\n      gradient.addColorStop(0, 'rgba(0,0,0,0)');\n      gradient.addColorStop(1, backgroundColor);\n      ctx.fillStyle = gradient;\n      ctx.globalAlpha = 0.7;\n      ctx.fillRect(0, startY, canvas.width, fadeHeight);\n    }\n  }, [scrollPosition, parallaxIntensity, position, opacity, blurAmount, fadeSize, backgroundColor, dimensions.width, dimensions.height]);\n\n  // Handle scroll events for parallax\n  useEffect(() => {\n    const handleScroll = () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      animationFrameRef.current = requestAnimationFrame(() => {\n        setScrollPosition(window.scrollY);\n      });\n    };\n    window.addEventListener('scroll', handleScroll, {\n      passive: true\n    });\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, []);\n\n  // Update canvas when scroll position changes (for parallax)\n  useEffect(() => {\n    if (imageLoaded && transitionEffect === 'dissolve') {\n      renderDissolveEffect();\n    }\n  }, [scrollPosition, imageLoaded, transitionEffect, renderDissolveEffect]);\n\n  // Update dimensions on resize and initialize canvas\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (containerRef.current) {\n        const rect = containerRef.current.getBoundingClientRect();\n        const newDimensions = {\n          width: rect.width,\n          height: rect.height\n        };\n        setDimensions(newDimensions);\n        if (canvasRef.current && transitionEffect === 'dissolve') {\n          canvasRef.current.width = newDimensions.width;\n          canvasRef.current.height = newDimensions.height;\n          if (imageLoaded) {\n            renderDissolveEffect();\n          }\n        }\n      }\n    };\n\n    // Load image if using canvas-based effects\n    if (transitionEffect === 'dissolve') {\n      const img = new Image();\n      img.crossOrigin = \"Anonymous\";\n      img.src = image;\n      img.onload = () => {\n        imageRef.current = img;\n        setImageLoaded(true);\n        updateDimensions();\n      };\n    }\n    updateDimensions();\n    window.addEventListener('resize', updateDimensions);\n    return () => {\n      window.removeEventListener('resize', updateDimensions);\n    };\n  }, [image, transitionEffect, renderDissolveEffect, imageLoaded]);\n\n  // Calculate parallax transformation for CSS-based version\n  const parallaxOffset = scrollPosition * parallaxIntensity;\n\n  // Determine background position based on position setting\n  let bgPosition = backgroundPosition;\n  if (!bgPosition) {\n    switch (position) {\n      case 'top':\n        bgPosition = 'center top';\n        break;\n      case 'bottom':\n        bgPosition = 'center bottom';\n        break;\n      case 'middle':\n      default:\n        bgPosition = 'center center';\n    }\n  }\n\n  // Determine which edges should fade based on position setting\n  const shouldFadeTop = position === 'bottom' || position === 'middle';\n  const shouldFadeBottom = position === 'top' || position === 'middle';\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'relative',\n      width: '100%',\n      height,\n      overflow: 'hidden',\n      zIndex\n    },\n    children: [transitionEffect === 'gradient' && /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%',\n          backgroundImage: `url(${image})`,\n          backgroundSize,\n          backgroundRepeat: 'no-repeat',\n          backgroundPosition: bgPosition,\n          transform: `translateY(${parallaxOffset}px)`,\n          transition: 'transform 0.1s ease-out',\n          opacity,\n          filter: blurAmount > 0 ? `blur(${blurAmount}px)` : 'none'\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 294,\n        columnNumber: 11\n      }, this), shouldFadeTop && /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: `${fadeSize * 100}%`,\n          background: `linear-gradient(to bottom, ${backgroundColor} 0%, rgba(0,0,0,0) 100%)`,\n          pointerEvents: 'none'\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 314,\n        columnNumber: 13\n      }, this), shouldFadeBottom && /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: 'absolute',\n          bottom: 0,\n          left: 0,\n          width: '100%',\n          height: `${fadeSize * 100}%`,\n          background: `linear-gradient(to top, ${backgroundColor} 0%, rgba(0,0,0,0) 100%)`,\n          pointerEvents: 'none'\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 329,\n        columnNumber: 13\n      }, this)]\n    }, void 0, true), transitionEffect === 'dissolve' && /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 346,\n      columnNumber: 9\n    }, this), children && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: 'relative',\n        zIndex: 1,\n        width: '100%',\n        height: '100%'\n      },\n      children: children\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 360,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 281,\n    columnNumber: 5\n  }, this);\n};\n_s(SlidingBackground, \"LDoSKgKDReXShZyKLDGoDJW0aVI=\");\n_c = SlidingBackground;\nexport default SlidingBackground;\nvar _c;\n$RefreshReg$(_c, \"SlidingBackground\");","map":{"version":3,"names":["React","useRef","useEffect","useState","useCallback","jsxDEV","_jsxDEV","Fragment","_Fragment","SlidingBackground","image","position","height","parallaxIntensity","fadeSize","backgroundColor","zIndex","blurAmount","opacity","backgroundSize","backgroundPosition","transitionEffect","children","_s","containerRef","canvasRef","scrollPosition","setScrollPosition","dimensions","setDimensions","width","imageLoaded","setImageLoaded","imageRef","animationFrameRef","renderDissolveEffect","current","canvas","ctx","getContext","img","clearRect","parallaxOffset","imgAspect","canvasAspect","drawWidth","drawHeight","offsetX","offsetY","globalAlpha","drawImage","filter","shouldFadeTop","shouldFadeBottom","fadeHeight","Math","floor","imageData","getImageData","pixels","data","y","fadeRatio","x","pixelIndex","random","putImageData","gradient","createLinearGradient","addColorStop","fillStyle","fillRect","startY","handleScroll","cancelAnimationFrame","requestAnimationFrame","window","scrollY","addEventListener","passive","removeEventListener","updateDimensions","rect","getBoundingClientRect","newDimensions","Image","crossOrigin","src","onload","bgPosition","ref","style","overflow","top","left","backgroundImage","backgroundRepeat","transform","transition","fileName","_jsxFileName","lineNumber","columnNumber","background","pointerEvents","bottom","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/effects/scrollingeffects/SlidingBackground.jsx"],"sourcesContent":["import React, { useRef, useEffect, useState, useCallback } from 'react';\n\n/**\n * SlidingBackground Component\n * \n * A highly configurable component that creates a parallax background with fade effects\n * that can be positioned at the top, middle, or bottom of the viewport.\n * \n * @param {Object} props - Component props\n * @param {string} props.image - URL of the background image\n * @param {string} [props.position='top'] - Position of the focused area ('top', 'middle', 'bottom')\n * @param {string|number} [props.height='33vh'] - Height of the component\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of the parallax effect (0-1)\n * @param {number} [props.fadeSize=0.4] - Size of the fade effect (0-1, as a fraction of the component)\n * @param {string} [props.backgroundColor='#000'] - Background color for the fade effect\n * @param {number} [props.zIndex=0] - z-index of the component\n * @param {number} [props.blurAmount=0] - Amount of blur for the fade transition (px)\n * @param {number} [props.opacity=1] - Opacity of the background image\n * @param {string} [props.backgroundSize='cover'] - Background size property\n * @param {string} [props.backgroundPosition] - Background position (overrides position setting)\n * @param {string} [props.transitionEffect='gradient'] - Type of transition effect ('gradient', 'dissolve')\n * @param {React.ReactNode} [props.children] - Content to render on top of the background\n */\nconst SlidingBackground = ({\n  image,\n  position = 'top',\n  height = '33vh',\n  parallaxIntensity = 0.2,\n  fadeSize = 0.4,\n  backgroundColor = '#000',\n  zIndex = 0,\n  blurAmount = 0,\n  opacity = 1,\n  backgroundSize = 'cover',\n  backgroundPosition,\n  transitionEffect = 'gradient',\n  children\n}) => {\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const [scrollPosition, setScrollPosition] = useState(0);\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n  const [imageLoaded, setImageLoaded] = useState(false);\n  const imageRef = useRef(null);\n  const animationFrameRef = useRef(null);\n  \n  // Define renderDissolveEffect with useCallback BEFORE it's used in any useEffect\n  const renderDissolveEffect = useCallback(() => {\n    if (!canvasRef.current || !imageRef.current || !dimensions.width || !dimensions.height) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const img = imageRef.current;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // Calculate parallax offset\n    const parallaxOffset = scrollPosition * parallaxIntensity;\n    \n    // Calculate image dimensions to maintain aspect ratio while covering the canvas\n    const imgAspect = img.width / img.height;\n    const canvasAspect = canvas.width / canvas.height;\n    \n    let drawWidth, drawHeight, offsetX, offsetY;\n    \n    if (imgAspect > canvasAspect) {\n      // Image is wider than canvas (relative to height)\n      drawHeight = canvas.height;\n      drawWidth = drawHeight * imgAspect;\n      offsetX = (canvas.width - drawWidth) / 2;\n      offsetY = 0;\n    } else {\n      // Image is taller than canvas (relative to width)\n      drawWidth = canvas.width;\n      drawHeight = drawWidth / imgAspect;\n      offsetX = 0;\n      offsetY = (canvas.height - drawHeight) / 2;\n    }\n    \n    // Adjust based on position setting\n    if (position === 'top') {\n      offsetY = 0;\n    } else if (position === 'bottom') {\n      offsetY = canvas.height - drawHeight;\n    }\n    \n    // Apply parallax\n    offsetY += parallaxOffset;\n    \n    // Draw the image\n    ctx.globalAlpha = opacity;\n    ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);\n    \n    // Apply blur if specified\n    if (blurAmount > 0) {\n      ctx.filter = `blur(${blurAmount}px)`;\n      ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);\n      ctx.filter = 'none';\n    }\n    \n    // Determine which edges should fade based on position\n    const shouldFadeTop = position === 'bottom' || position === 'middle';\n    const shouldFadeBottom = position === 'top' || position === 'middle';\n    \n    // Top dissolve effect\n    if (shouldFadeTop) {\n      const fadeHeight = Math.floor(canvas.height * fadeSize);\n      const imageData = ctx.getImageData(0, 0, canvas.width, fadeHeight);\n      const pixels = imageData.data;\n      \n      for (let y = 0; y < fadeHeight; y++) {\n        const fadeRatio = 1 - (y / fadeHeight);\n        \n        for (let x = 0; x < canvas.width; x++) {\n          const pixelIndex = (y * canvas.width + x) * 4;\n          \n          // Apply dissolve effect with random pattern\n          if (Math.random() < fadeRatio * 0.8) {\n            pixels[pixelIndex + 3] = 0; // Set alpha to 0 (transparent)\n          } else {\n            // Gradually decrease opacity\n            pixels[pixelIndex + 3] = pixels[pixelIndex + 3] * (1 - fadeRatio);\n          }\n        }\n      }\n      \n      ctx.putImageData(imageData, 0, 0);\n      \n      // Add gradient overlay\n      const gradient = ctx.createLinearGradient(0, 0, 0, fadeHeight);\n      gradient.addColorStop(0, backgroundColor);\n      gradient.addColorStop(1, 'rgba(0,0,0,0)');\n      \n      ctx.fillStyle = gradient;\n      ctx.globalAlpha = 0.7;\n      ctx.fillRect(0, 0, canvas.width, fadeHeight);\n    }\n    \n    // Bottom dissolve effect\n    if (shouldFadeBottom) {\n      const fadeHeight = Math.floor(canvas.height * fadeSize);\n      const startY = canvas.height - fadeHeight;\n      const imageData = ctx.getImageData(0, startY, canvas.width, fadeHeight);\n      const pixels = imageData.data;\n      \n      for (let y = 0; y < fadeHeight; y++) {\n        const fadeRatio = y / fadeHeight;\n        \n        for (let x = 0; x < canvas.width; x++) {\n          const pixelIndex = (y * canvas.width + x) * 4;\n          \n          // Apply dissolve effect with random pattern\n          if (Math.random() < fadeRatio * 0.8) {\n            pixels[pixelIndex + 3] = 0; // Set alpha to 0 (transparent)\n          } else {\n            // Gradually decrease opacity\n            pixels[pixelIndex + 3] = pixels[pixelIndex + 3] * (1 - fadeRatio);\n          }\n        }\n      }\n      \n      ctx.putImageData(imageData, 0, startY);\n      \n      // Add gradient overlay\n      const gradient = ctx.createLinearGradient(0, startY, 0, canvas.height);\n      gradient.addColorStop(0, 'rgba(0,0,0,0)');\n      gradient.addColorStop(1, backgroundColor);\n      \n      ctx.fillStyle = gradient;\n      ctx.globalAlpha = 0.7;\n      ctx.fillRect(0, startY, canvas.width, fadeHeight);\n    }\n  }, [\n    scrollPosition,\n    parallaxIntensity,\n    position,\n    opacity,\n    blurAmount,\n    fadeSize,\n    backgroundColor,\n    dimensions.width,\n    dimensions.height\n  ]);\n  \n  // Handle scroll events for parallax\n  useEffect(() => {\n    const handleScroll = () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      \n      animationFrameRef.current = requestAnimationFrame(() => {\n        setScrollPosition(window.scrollY);\n      });\n    };\n    \n    window.addEventListener('scroll', handleScroll, { passive: true });\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, []);\n  \n  // Update canvas when scroll position changes (for parallax)\n  useEffect(() => {\n    if (imageLoaded && transitionEffect === 'dissolve') {\n      renderDissolveEffect();\n    }\n  }, [scrollPosition, imageLoaded, transitionEffect, renderDissolveEffect]);\n  \n  // Update dimensions on resize and initialize canvas\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (containerRef.current) {\n        const rect = containerRef.current.getBoundingClientRect();\n        const newDimensions = { \n          width: rect.width, \n          height: rect.height \n        };\n        \n        setDimensions(newDimensions);\n        \n        if (canvasRef.current && transitionEffect === 'dissolve') {\n          canvasRef.current.width = newDimensions.width;\n          canvasRef.current.height = newDimensions.height;\n          \n          if (imageLoaded) {\n            renderDissolveEffect();\n          }\n        }\n      }\n    };\n    \n    // Load image if using canvas-based effects\n    if (transitionEffect === 'dissolve') {\n      const img = new Image();\n      img.crossOrigin = \"Anonymous\";\n      img.src = image;\n      img.onload = () => {\n        imageRef.current = img;\n        setImageLoaded(true);\n        updateDimensions();\n      };\n    }\n    \n    updateDimensions();\n    window.addEventListener('resize', updateDimensions);\n    \n    return () => {\n      window.removeEventListener('resize', updateDimensions);\n    };\n  }, [image, transitionEffect, renderDissolveEffect, imageLoaded]);\n  \n  // Calculate parallax transformation for CSS-based version\n  const parallaxOffset = scrollPosition * parallaxIntensity;\n  \n  // Determine background position based on position setting\n  let bgPosition = backgroundPosition;\n  if (!bgPosition) {\n    switch (position) {\n      case 'top':\n        bgPosition = 'center top';\n        break;\n      case 'bottom':\n        bgPosition = 'center bottom';\n        break;\n      case 'middle':\n      default:\n        bgPosition = 'center center';\n    }\n  }\n  \n  // Determine which edges should fade based on position setting\n  const shouldFadeTop = position === 'bottom' || position === 'middle';\n  const shouldFadeBottom = position === 'top' || position === 'middle';\n  \n  return (\n    <div\n      ref={containerRef}\n      style={{\n        position: 'relative',\n        width: '100%',\n        height,\n        overflow: 'hidden',\n        zIndex\n      }}\n    >\n      {/* CSS-based gradient transition */}\n      {transitionEffect === 'gradient' && (\n        <>\n          <div\n            style={{\n              position: 'absolute',\n              top: 0,\n              left: 0,\n              width: '100%',\n              height: '100%',\n              backgroundImage: `url(${image})`,\n              backgroundSize,\n              backgroundRepeat: 'no-repeat',\n              backgroundPosition: bgPosition,\n              transform: `translateY(${parallaxOffset}px)`,\n              transition: 'transform 0.1s ease-out',\n              opacity,\n              filter: blurAmount > 0 ? `blur(${blurAmount}px)` : 'none'\n            }}\n          />\n          \n          {/* Top fade gradient */}\n          {shouldFadeTop && (\n            <div\n              style={{\n                position: 'absolute',\n                top: 0,\n                left: 0,\n                width: '100%',\n                height: `${fadeSize * 100}%`,\n                background: `linear-gradient(to bottom, ${backgroundColor} 0%, rgba(0,0,0,0) 100%)`,\n                pointerEvents: 'none'\n              }}\n            />\n          )}\n          \n          {/* Bottom fade gradient */}\n          {shouldFadeBottom && (\n            <div\n              style={{\n                position: 'absolute',\n                bottom: 0,\n                left: 0,\n                width: '100%',\n                height: `${fadeSize * 100}%`,\n                background: `linear-gradient(to top, ${backgroundColor} 0%, rgba(0,0,0,0) 100%)`,\n                pointerEvents: 'none'\n              }}\n            />\n          )}\n        </>\n      )}\n      \n      {/* Canvas-based dissolve transition */}\n      {transitionEffect === 'dissolve' && (\n        <canvas\n          ref={canvasRef}\n          style={{\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            width: '100%',\n            height: '100%'\n          }}\n        />\n      )}\n      \n      {/* Content container */}\n      {children && (\n        <div\n          style={{\n            position: 'relative',\n            zIndex: 1,\n            width: '100%',\n            height: '100%'\n          }}\n        >\n          {children}\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default SlidingBackground;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}