{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/Background.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect, useCallback, useMemo } from 'react';\n\n/**\n * Background Component\n * \n * Creates an immersive stellar background with realistic star particles\n * that provide depth without distracting from content.\n * \n * Features:\n * - Full viewport coverage with proper positioning\n * - Realistic star rendering with proper glow effects\n * - Extremely subtle parallax effect on scroll\n * - Optimized for performance across devices\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Background = () => {\n  _s();\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const starsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimeRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n\n  // Component state\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0,\n    pixelRatio: 1\n  });\n  const [isInitialized, setIsInitialized] = useState(false);\n  // Removed prefersReducedMotion state since it wasn't being used\n\n  // Configuration - wrapped in useMemo to prevent recreation on each render\n  const CONFIG = useMemo(() => ({\n    // Star parameters - reduced count for performance\n    starCount: 100,\n    // Reduced for better performance\n    starSizeMin: 0.8,\n    starSizeMax: 2.5,\n    starOpacityMin: 0.15,\n    starOpacityMax: 0.85,\n    // Motion and animation - slowed for performance\n    baseMovementSpeed: 0.00008,\n    // Very subtle movement, reduced for performance\n    pulseFrequency: 0.00004,\n    // Slower pulsing\n    pulseIntensity: 0.25,\n    // Subtle pulse\n\n    // Parallax effect\n    parallaxIntensity: 0.03,\n    // Reduced for performance\n\n    // Performance parameters\n    maxFPS: 20,\n    // Reduced for performance\n    useGlow: window.innerWidth > 768,\n    // Disable glow on mobile devices\n    skipFrames: 2 // Skip frames for better performance\n  }), []);\n\n  // Warm, golden color palette - wrapped in useMemo\n  const COLORS = useMemo(() => ({\n    // Main star colors (warm golden tones)\n    stars: ['rgba(255, 243, 200, alpha)',\n    // Warm yellow\n    'rgba(255, 231, 164, alpha)',\n    // Golden\n    'rgba(255, 236, 179, alpha)',\n    // Pale gold\n    'rgba(252, 249, 231, alpha)',\n    // Off-white gold\n    'rgba(255, 225, 205, alpha)' // Warm white (slight orange)\n    ],\n    // Background gradient colors\n    background: {\n      topColor: 'rgb(8, 8, 12)',\n      bottomColor: 'rgb(15, 15, 20)'\n    }\n  }), []);\n\n  // Get color with opacity\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    return baseColor.replace(/alpha\\)$/, `${safeOpacity})`);\n  }, []);\n\n  // No longer tracking reduced motion preference since it's not being used\n  useEffect(() => {\n    // Initial setup to ensure canvas is visible and rendered properly\n    const checkCanvas = () => {\n      if (canvasRef.current) {\n        const ctx = canvasRef.current.getContext('2d');\n        if (ctx) {\n          // Draw a simple test to ensure canvas is working\n          ctx.fillStyle = COLORS.background.topColor;\n          ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n        }\n      }\n    };\n    checkCanvas();\n  }, [COLORS.background.topColor]);\n\n  // Track scroll position for parallax\n  useEffect(() => {\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    window.addEventListener('scroll', handleScroll, {\n      passive: true\n    });\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, []);\n\n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) {\n      console.error('Canvas ref is null during setup');\n      return false;\n    }\n    const canvas = canvasRef.current;\n\n    // Get viewport dimensions to ensure full coverage\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const pixelRatio = window.devicePixelRatio || 1;\n\n    // Set canvas size accounting for pixel ratio\n    canvas.width = width * pixelRatio;\n    canvas.height = height * pixelRatio;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n\n    // Ensure canvas is visible with a background color\n    const ctx = canvas.getContext('2d');\n    if (ctx) {\n      ctx.fillStyle = 'rgb(15, 15, 20)'; // Fallback dark color\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n\n    // Update dimensions state\n    setDimensions({\n      width,\n      height,\n      pixelRatio\n    });\n    console.log(`Canvas initialized: ${width}x${height}, ratio: ${pixelRatio}`);\n    return true;\n  }, []);\n\n  // Initialize stars with optimized properties for better performance\n  const initializeStars = useCallback(() => {\n    if (!dimensions.width || !dimensions.height) return;\n\n    // Clear existing stars\n    starsRef.current = [];\n\n    // Create stars, ensuring good distribution across viewport\n    for (let i = 0; i < CONFIG.starCount; i++) {\n      const star = {};\n\n      // Position - use a more balanced distribution strategy for better coverage\n      star.x = Math.random() * dimensions.width;\n      star.y = Math.random() * dimensions.height;\n\n      // Simplify depth calculation - reduces computational complexity\n      star.z = Math.random() * 0.7 + 0.2; // Depth (0.2 to 0.9) - narrower range for better performance\n\n      // Visual properties - simplified calculations\n      star.size = (Math.random() * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n      star.baseOpacity = CONFIG.starOpacityMin + Math.random() * (CONFIG.starOpacityMax - CONFIG.starOpacityMin);\n      star.opacity = star.baseOpacity;\n\n      // Animation properties - optimize for performance\n      star.pulsePhase = i * (Math.PI * 2 / CONFIG.starCount); // Distribute phases evenly\n      star.pulseSpeed = 0.001 + i % 5 * 0.0001; // Fewer unique speeds for better batching\n      star.movementSpeed = CONFIG.baseMovementSpeed * (1 - star.z * 0.5); // Simpler motion calculation\n\n      // Reduce the number of stars with rays for better performance\n      star.rays = Math.random() > 0.9 ? 4 : 0; // Only 10% of stars have rays, all with 4 rays\n      star.rayLength = star.size * 3;\n\n      // Color variation - reduced color options for better batching\n      const colorIndex = Math.min(i % COLORS.stars.length, COLORS.stars.length - 1);\n      star.color = COLORS.stars[colorIndex];\n\n      // Store in ref\n      starsRef.current.push(star);\n    }\n  }, [dimensions, CONFIG, COLORS.stars]);\n\n  // Setup canvas resize observer\n  useEffect(() => {\n    const handleResize = () => {\n      if (setupCanvas()) {\n        // Reinitialize stars after resize\n        initializeStars();\n        setIsInitialized(true);\n      }\n    };\n    window.addEventListener('resize', handleResize);\n\n    // Initial setup\n    setupCanvas();\n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, [setupCanvas, initializeStars]);\n\n  // Optimized animation update for better performance\n  const updateAnimation = useCallback((deltaTime, timestamp) => {\n    // Only update every other frame for performance\n    if (timestamp % 2 === 0) return;\n\n    // Global time factor for animations - simplified calculation\n    const timeFactor = timestamp * 0.0005; // Reduced precision for better performance\n\n    // Parallax effect from scroll - extremely subtle\n    const parallaxOffset = scrollPositionRef.current * CONFIG.parallaxIntensity;\n\n    // Update stars with optimized calculations\n    const len = starsRef.current.length;\n    for (let i = 0; i < len; i++) {\n      const star = starsRef.current[i];\n\n      // Update position less frequently for better performance\n      if (i % 2 === 0) {\n        // Simplified movement calculation - reduced trigonometric calls\n        const moveFactor = star.movementSpeed * deltaTime;\n        star.x += Math.sin(timeFactor + star.pulsePhase) * moveFactor;\n        star.y += Math.cos(timeFactor + star.pulsePhase) * moveFactor * 0.5;\n      }\n\n      // Apply parallax offset - simplified calculation\n      star.parallaxY = parallaxOffset * (1 - star.z) * 0.3;\n\n      // Wrap around screen edges with padding - only check when needed\n      const padding = 20;\n      if (star.x < -padding || star.x > dimensions.width + padding) {\n        star.x = star.x < 0 ? dimensions.width + padding : -padding;\n      }\n      if (star.y < -padding || star.y > dimensions.height + padding) {\n        star.y = star.y < 0 ? dimensions.height + padding : -padding;\n      }\n\n      // Simplified pulsing effect - single sine wave instead of multiple\n      // Update only on certain frames for better performance\n      if (i % 3 === timestamp % 3) {\n        const pulseFactor = Math.sin(timeFactor * star.pulseSpeed + star.pulsePhase) * 0.15 + 0.85;\n        star.opacity = star.baseOpacity * pulseFactor;\n      }\n    }\n  }, [dimensions, CONFIG]);\n\n  // Optimized star rendering for better performance\n  const drawStar = useCallback((ctx, star, y) => {\n    if (CONFIG.useGlow) {\n      // Simplified glow effect for better performance\n      const glowRadius = star.size * 1.5; // Reduced from 2x to 1.5x\n      const gradient = ctx.createRadialGradient(star.x, y, 0, star.x, y, glowRadius);\n      gradient.addColorStop(0, getColor(star.color, star.opacity * 0.9));\n      gradient.addColorStop(1, getColor(star.color, 0));\n      ctx.beginPath();\n      ctx.fillStyle = gradient;\n      ctx.arc(star.x, y, glowRadius, 0, Math.PI * 2);\n      ctx.fill();\n    } else {\n      // Simplified non-glow version for lower-end devices\n      ctx.beginPath();\n      ctx.fillStyle = getColor(star.color, star.opacity * 0.7);\n      ctx.arc(star.x, y, star.size * 0.8, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // Draw bright core\n    ctx.beginPath();\n    ctx.fillStyle = getColor(star.color, star.opacity);\n    ctx.arc(star.x, y, star.size * 0.4, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Only draw rays for larger stars and limit the number of rays for performance\n    if (star.rays > 0 && star.opacity > 0.4 && star.size > 1.5) {\n      ctx.save();\n      ctx.translate(star.x, y);\n\n      // Simplified ray drawing - no rotation, fewer rays\n      const rayCount = Math.min(star.rays, 4); // Limit to max 4 rays\n      for (let i = 0; i < rayCount; i++) {\n        const angle = i / rayCount * Math.PI * 2;\n        const rayLength = star.rayLength * 0.8; // Fixed length for performance\n\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(Math.cos(angle) * rayLength, Math.sin(angle) * rayLength);\n\n        // Simplified ray rendering - no gradient\n        ctx.strokeStyle = getColor(star.color, star.opacity * 0.6);\n        ctx.lineWidth = star.size * 0.2;\n        ctx.stroke();\n      }\n      ctx.restore();\n    }\n  }, [getColor, CONFIG.useGlow]);\n\n  // Cache flag for gradient\n  const gradientCachedRef = useRef(false);\n\n  // Optimized scene rendering for better performance\n  const renderScene = useCallback(() => {\n    if (!canvasRef.current) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d', {\n      alpha: false\n    }); // Non-alpha context for better performance\n\n    if (!ctx || canvas.width === 0 || canvas.height === 0) return;\n\n    // Apply device pixel ratio scaling\n    ctx.setTransform(dimensions.pixelRatio, 0, 0, dimensions.pixelRatio, 0, 0);\n\n    // Clear canvas - using fillRect instead of clearRect for better performance\n    ctx.fillStyle = COLORS.background.bottomColor;\n    ctx.fillRect(0, 0, dimensions.width, dimensions.height);\n\n    // Draw background gradient only on first render or resize to improve performance\n    if (!gradientCachedRef.current) {\n      const gradient = ctx.createLinearGradient(0, 0, 0, dimensions.height);\n      gradient.addColorStop(0, COLORS.background.topColor);\n      gradient.addColorStop(1, COLORS.background.bottomColor);\n      ctx.fillStyle = gradient;\n      ctx.fillRect(0, 0, dimensions.width, dimensions.height);\n      gradientCachedRef.current = true;\n    }\n\n    // Enable global composition for glow effect only if enabled\n    if (CONFIG.useGlow) {\n      ctx.globalCompositeOperation = 'lighter';\n    }\n\n    // Draw visible stars only - batched by size for better performance\n    const visibleStars = [];\n    const len = starsRef.current.length;\n\n    // Filter visible stars\n    for (let i = 0; i < len; i++) {\n      const star = starsRef.current[i];\n\n      // Skip almost invisible stars\n      if (star.opacity < 0.05) continue;\n      const x = star.x;\n      const y = star.y + (star.parallaxY || 0);\n\n      // Skip stars outside viewport (with padding) for better performance\n      const padding = star.size * 4;\n      if (x < -padding || x > dimensions.width + padding || y < -padding || y > dimensions.height + padding) {\n        continue;\n      }\n      visibleStars.push({\n        star,\n        y\n      });\n    }\n\n    // Draw stars in batches by size for better performance\n    for (let i = 0; i < visibleStars.length; i++) {\n      const {\n        star,\n        y\n      } = visibleStars[i];\n      drawStar(ctx, star, y);\n    }\n\n    // Reset global composition if needed\n    if (CONFIG.useGlow) {\n      ctx.globalCompositeOperation = 'source-over';\n    }\n  }, [dimensions, COLORS, drawStar, CONFIG.useGlow]);\n\n  // Frame counter for animation throttling\n  const frameCounterRef = useRef(0);\n\n  // Main animation loop with optimized performance\n  const animate = useCallback(timestamp => {\n    if (!isInitialized) {\n      animationFrameRef.current = requestAnimationFrame(animate);\n      return;\n    }\n\n    // Calculate delta time with cap to prevent large jumps\n    const deltaTime = lastTimeRef.current ? Math.min(timestamp - lastTimeRef.current, 50) : 16;\n    lastTimeRef.current = timestamp;\n\n    // Update frame counter for throttling\n    frameCounterRef.current = (frameCounterRef.current + 1) % (CONFIG.skipFrames + 1);\n\n    // Always update animation for smooth movement\n    updateAnimation(deltaTime, timestamp);\n\n    // Only render on certain frames for better performance\n    if (frameCounterRef.current === 0) {\n      renderScene();\n    }\n\n    // Request next frame with throttling for consistent frame rate\n    if (CONFIG.maxFPS < 60) {\n      const nextFrameDelay = Math.max(0, 1000 / CONFIG.maxFPS - deltaTime);\n      setTimeout(() => {\n        if (animationFrameRef.current) {\n          cancelAnimationFrame(animationFrameRef.current);\n        }\n        animationFrameRef.current = requestAnimationFrame(animate);\n      }, nextFrameDelay);\n    } else {\n      animationFrameRef.current = requestAnimationFrame(animate);\n    }\n  }, [isInitialized, updateAnimation, renderScene, CONFIG.maxFPS, CONFIG.skipFrames]);\n\n  // Initialize animation when component is ready\n  useEffect(() => {\n    if (!isInitialized && dimensions.width && dimensions.height) {\n      initializeStars();\n      setIsInitialized(true);\n    }\n  }, [dimensions, isInitialized, initializeStars]);\n\n  // Start animation loop\n  useEffect(() => {\n    if (!isInitialized) return;\n\n    // Start animation\n    animationFrameRef.current = requestAnimationFrame(animate);\n\n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [isInitialized, animate]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      width: '100vw',\n      height: '100vh',\n      overflow: 'hidden',\n      zIndex: -1,\n      pointerEvents: 'none'\n    },\n    \"aria-hidden\": \"true\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 449,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 435,\n    columnNumber: 5\n  }, this);\n};\n_s(Background, \"T3t+e8mGU2gyfSdxhUmre7uaqa8=\");\n_c = Background;\nexport default Background;\nvar _c;\n$RefreshReg$(_c, \"Background\");","map":{"version":3,"names":["React","useRef","useState","useEffect","useCallback","useMemo","jsxDEV","_jsxDEV","Background","_s","containerRef","canvasRef","starsRef","animationFrameRef","lastTimeRef","scrollPositionRef","dimensions","setDimensions","width","height","pixelRatio","isInitialized","setIsInitialized","CONFIG","starCount","starSizeMin","starSizeMax","starOpacityMin","starOpacityMax","baseMovementSpeed","pulseFrequency","pulseIntensity","parallaxIntensity","maxFPS","useGlow","window","innerWidth","skipFrames","COLORS","stars","background","topColor","bottomColor","getColor","baseColor","opacity","safeOpacity","Math","max","min","replace","checkCanvas","current","ctx","getContext","fillStyle","fillRect","handleScroll","scrollY","addEventListener","passive","removeEventListener","setupCanvas","console","error","canvas","innerHeight","devicePixelRatio","style","log","initializeStars","i","star","x","random","y","z","size","baseOpacity","pulsePhase","PI","pulseSpeed","movementSpeed","rays","rayLength","colorIndex","length","color","push","handleResize","updateAnimation","deltaTime","timestamp","timeFactor","parallaxOffset","len","moveFactor","sin","cos","parallaxY","padding","pulseFactor","drawStar","glowRadius","gradient","createRadialGradient","addColorStop","beginPath","arc","fill","save","translate","rayCount","angle","moveTo","lineTo","strokeStyle","lineWidth","stroke","restore","gradientCachedRef","renderScene","alpha","setTransform","createLinearGradient","globalCompositeOperation","visibleStars","frameCounterRef","animate","requestAnimationFrame","nextFrameDelay","setTimeout","cancelAnimationFrame","ref","position","top","left","overflow","zIndex","pointerEvents","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/Background.jsx"],"sourcesContent":["import React, { useRef, useState, useEffect, useCallback, useMemo } from 'react';\n\n/**\n * Background Component\n * \n * Creates an immersive stellar background with realistic star particles\n * that provide depth without distracting from content.\n * \n * Features:\n * - Full viewport coverage with proper positioning\n * - Realistic star rendering with proper glow effects\n * - Extremely subtle parallax effect on scroll\n * - Optimized for performance across devices\n */\nconst Background = () => {\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const starsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimeRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n  \n  // Component state\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0, pixelRatio: 1 });\n  const [isInitialized, setIsInitialized] = useState(false);\n  // Removed prefersReducedMotion state since it wasn't being used\n  \n  // Configuration - wrapped in useMemo to prevent recreation on each render\n  const CONFIG = useMemo(() => ({\n    // Star parameters - reduced count for performance\n    starCount: 100,       // Reduced for better performance\n    starSizeMin: 0.8,\n    starSizeMax: 2.5,\n    starOpacityMin: 0.15,\n    starOpacityMax: 0.85,\n    \n    // Motion and animation - slowed for performance\n    baseMovementSpeed: 0.00008,  // Very subtle movement, reduced for performance\n    pulseFrequency: 0.00004,     // Slower pulsing\n    pulseIntensity: 0.25,        // Subtle pulse\n    \n    // Parallax effect\n    parallaxIntensity: 0.03,     // Reduced for performance\n    \n    // Performance parameters\n    maxFPS: 20,           // Reduced for performance\n    useGlow: window.innerWidth > 768, // Disable glow on mobile devices\n    skipFrames: 2         // Skip frames for better performance\n  }), []);\n  \n  // Warm, golden color palette - wrapped in useMemo\n  const COLORS = useMemo(() => ({\n    // Main star colors (warm golden tones)\n    stars: [\n      'rgba(255, 243, 200, alpha)', // Warm yellow\n      'rgba(255, 231, 164, alpha)', // Golden\n      'rgba(255, 236, 179, alpha)', // Pale gold\n      'rgba(252, 249, 231, alpha)', // Off-white gold\n      'rgba(255, 225, 205, alpha)'  // Warm white (slight orange)\n    ],\n    \n    // Background gradient colors\n    background: {\n      topColor: 'rgb(8, 8, 12)',\n      bottomColor: 'rgb(15, 15, 20)'\n    }\n  }), []);\n  \n  // Get color with opacity\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    return baseColor.replace(/alpha\\)$/, `${safeOpacity})`);\n  }, []);\n  \n  // No longer tracking reduced motion preference since it's not being used\n  useEffect(() => {\n    // Initial setup to ensure canvas is visible and rendered properly\n    const checkCanvas = () => {\n      if (canvasRef.current) {\n        const ctx = canvasRef.current.getContext('2d');\n        if (ctx) {\n          // Draw a simple test to ensure canvas is working\n          ctx.fillStyle = COLORS.background.topColor;\n          ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n        }\n      }\n    };\n    \n    checkCanvas();\n  }, [COLORS.background.topColor]);\n  \n  // Track scroll position for parallax\n  useEffect(() => {\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    \n    window.addEventListener('scroll', handleScroll, { passive: true });\n    \n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, []);\n  \n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) {\n      console.error('Canvas ref is null during setup');\n      return false;\n    }\n    \n    const canvas = canvasRef.current;\n    \n    // Get viewport dimensions to ensure full coverage\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const pixelRatio = window.devicePixelRatio || 1;\n    \n    // Set canvas size accounting for pixel ratio\n    canvas.width = width * pixelRatio;\n    canvas.height = height * pixelRatio;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n    \n    // Ensure canvas is visible with a background color\n    const ctx = canvas.getContext('2d');\n    if (ctx) {\n      ctx.fillStyle = 'rgb(15, 15, 20)';  // Fallback dark color\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    \n    // Update dimensions state\n    setDimensions({\n      width,\n      height,\n      pixelRatio\n    });\n    \n    console.log(`Canvas initialized: ${width}x${height}, ratio: ${pixelRatio}`);\n    return true;\n  }, []);\n  \n  // Initialize stars with optimized properties for better performance\n  const initializeStars = useCallback(() => {\n    if (!dimensions.width || !dimensions.height) return;\n    \n    // Clear existing stars\n    starsRef.current = [];\n    \n    // Create stars, ensuring good distribution across viewport\n    for (let i = 0; i < CONFIG.starCount; i++) {\n      const star = {};\n      \n      // Position - use a more balanced distribution strategy for better coverage\n      star.x = Math.random() * dimensions.width;\n      star.y = Math.random() * dimensions.height;\n      \n      // Simplify depth calculation - reduces computational complexity\n      star.z = Math.random() * 0.7 + 0.2; // Depth (0.2 to 0.9) - narrower range for better performance\n      \n      // Visual properties - simplified calculations\n      star.size = (Math.random() * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n      star.baseOpacity = CONFIG.starOpacityMin + Math.random() * (CONFIG.starOpacityMax - CONFIG.starOpacityMin);\n      star.opacity = star.baseOpacity;\n      \n      // Animation properties - optimize for performance\n      star.pulsePhase = i * (Math.PI * 2 / CONFIG.starCount); // Distribute phases evenly\n      star.pulseSpeed = 0.001 + (i % 5) * 0.0001; // Fewer unique speeds for better batching\n      star.movementSpeed = CONFIG.baseMovementSpeed * (1 - star.z * 0.5); // Simpler motion calculation\n      \n      // Reduce the number of stars with rays for better performance\n      star.rays = Math.random() > 0.9 ? 4 : 0; // Only 10% of stars have rays, all with 4 rays\n      star.rayLength = star.size * 3;\n      \n      // Color variation - reduced color options for better batching\n      const colorIndex = Math.min(i % COLORS.stars.length, COLORS.stars.length - 1);\n      star.color = COLORS.stars[colorIndex];\n      \n      // Store in ref\n      starsRef.current.push(star);\n    }\n  }, [dimensions, CONFIG, COLORS.stars]);\n  \n  // Setup canvas resize observer\n  useEffect(() => {\n    const handleResize = () => {\n      if (setupCanvas()) {\n        // Reinitialize stars after resize\n        initializeStars();\n        setIsInitialized(true);\n      }\n    };\n    \n    window.addEventListener('resize', handleResize);\n    \n    // Initial setup\n    setupCanvas();\n    \n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, [setupCanvas, initializeStars]);\n  \n  // Optimized animation update for better performance\n  const updateAnimation = useCallback((deltaTime, timestamp) => {\n    // Only update every other frame for performance\n    if (timestamp % 2 === 0) return;\n    \n    // Global time factor for animations - simplified calculation\n    const timeFactor = timestamp * 0.0005; // Reduced precision for better performance\n    \n    // Parallax effect from scroll - extremely subtle\n    const parallaxOffset = scrollPositionRef.current * CONFIG.parallaxIntensity;\n    \n    // Update stars with optimized calculations\n    const len = starsRef.current.length;\n    for (let i = 0; i < len; i++) {\n      const star = starsRef.current[i];\n      \n      // Update position less frequently for better performance\n      if (i % 2 === 0) {\n        // Simplified movement calculation - reduced trigonometric calls\n        const moveFactor = star.movementSpeed * deltaTime;\n        star.x += (Math.sin(timeFactor + star.pulsePhase) * moveFactor);\n        star.y += (Math.cos(timeFactor + star.pulsePhase) * moveFactor * 0.5);\n      }\n      \n      // Apply parallax offset - simplified calculation\n      star.parallaxY = parallaxOffset * (1 - star.z) * 0.3;\n      \n      // Wrap around screen edges with padding - only check when needed\n      const padding = 20;\n      if (star.x < -padding || star.x > dimensions.width + padding) {\n        star.x = (star.x < 0) ? dimensions.width + padding : -padding;\n      }\n      if (star.y < -padding || star.y > dimensions.height + padding) {\n        star.y = (star.y < 0) ? dimensions.height + padding : -padding;\n      }\n      \n      // Simplified pulsing effect - single sine wave instead of multiple\n      // Update only on certain frames for better performance\n      if (i % 3 === timestamp % 3) {\n        const pulseFactor = (Math.sin(timeFactor * star.pulseSpeed + star.pulsePhase) * 0.15) + 0.85;\n        star.opacity = star.baseOpacity * pulseFactor;\n      }\n    }\n  }, [dimensions, CONFIG]);\n  \n  // Optimized star rendering for better performance\n  const drawStar = useCallback((ctx, star, y) => {\n    if (CONFIG.useGlow) {\n      // Simplified glow effect for better performance\n      const glowRadius = star.size * 1.5; // Reduced from 2x to 1.5x\n      const gradient = ctx.createRadialGradient(star.x, y, 0, star.x, y, glowRadius);\n      gradient.addColorStop(0, getColor(star.color, star.opacity * 0.9));\n      gradient.addColorStop(1, getColor(star.color, 0));\n      \n      ctx.beginPath();\n      ctx.fillStyle = gradient;\n      ctx.arc(star.x, y, glowRadius, 0, Math.PI * 2);\n      ctx.fill();\n    } else {\n      // Simplified non-glow version for lower-end devices\n      ctx.beginPath();\n      ctx.fillStyle = getColor(star.color, star.opacity * 0.7);\n      ctx.arc(star.x, y, star.size * 0.8, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    \n    // Draw bright core\n    ctx.beginPath();\n    ctx.fillStyle = getColor(star.color, star.opacity);\n    ctx.arc(star.x, y, star.size * 0.4, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Only draw rays for larger stars and limit the number of rays for performance\n    if (star.rays > 0 && star.opacity > 0.4 && star.size > 1.5) {\n      ctx.save();\n      ctx.translate(star.x, y);\n      \n      // Simplified ray drawing - no rotation, fewer rays\n      const rayCount = Math.min(star.rays, 4); // Limit to max 4 rays\n      for (let i = 0; i < rayCount; i++) {\n        const angle = (i / rayCount) * Math.PI * 2;\n        const rayLength = star.rayLength * 0.8; // Fixed length for performance\n        \n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(Math.cos(angle) * rayLength, Math.sin(angle) * rayLength);\n        \n        // Simplified ray rendering - no gradient\n        ctx.strokeStyle = getColor(star.color, star.opacity * 0.6);\n        ctx.lineWidth = star.size * 0.2;\n        ctx.stroke();\n      }\n      \n      ctx.restore();\n    }\n  }, [getColor, CONFIG.useGlow]);\n  \n  // Cache flag for gradient\n  const gradientCachedRef = useRef(false);\n  \n  // Optimized scene rendering for better performance\n  const renderScene = useCallback(() => {\n    if (!canvasRef.current) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d', { alpha: false }); // Non-alpha context for better performance\n    \n    if (!ctx || canvas.width === 0 || canvas.height === 0) return;\n    \n    // Apply device pixel ratio scaling\n    ctx.setTransform(dimensions.pixelRatio, 0, 0, dimensions.pixelRatio, 0, 0);\n    \n    // Clear canvas - using fillRect instead of clearRect for better performance\n    ctx.fillStyle = COLORS.background.bottomColor;\n    ctx.fillRect(0, 0, dimensions.width, dimensions.height);\n    \n    // Draw background gradient only on first render or resize to improve performance\n    if (!gradientCachedRef.current) {\n      const gradient = ctx.createLinearGradient(0, 0, 0, dimensions.height);\n      gradient.addColorStop(0, COLORS.background.topColor);\n      gradient.addColorStop(1, COLORS.background.bottomColor);\n      ctx.fillStyle = gradient;\n      ctx.fillRect(0, 0, dimensions.width, dimensions.height);\n      gradientCachedRef.current = true;\n    }\n    \n    // Enable global composition for glow effect only if enabled\n    if (CONFIG.useGlow) {\n      ctx.globalCompositeOperation = 'lighter';\n    }\n    \n    // Draw visible stars only - batched by size for better performance\n    const visibleStars = [];\n    const len = starsRef.current.length;\n    \n    // Filter visible stars\n    for (let i = 0; i < len; i++) {\n      const star = starsRef.current[i];\n      \n      // Skip almost invisible stars\n      if (star.opacity < 0.05) continue;\n      \n      const x = star.x;\n      const y = star.y + (star.parallaxY || 0);\n      \n      // Skip stars outside viewport (with padding) for better performance\n      const padding = star.size * 4;\n      if (x < -padding || x > dimensions.width + padding || \n          y < -padding || y > dimensions.height + padding) {\n        continue;\n      }\n      \n      visibleStars.push({ star, y });\n    }\n    \n    // Draw stars in batches by size for better performance\n    for (let i = 0; i < visibleStars.length; i++) {\n      const { star, y } = visibleStars[i];\n      drawStar(ctx, star, y);\n    }\n    \n    // Reset global composition if needed\n    if (CONFIG.useGlow) {\n      ctx.globalCompositeOperation = 'source-over';\n    }\n  }, [dimensions, COLORS, drawStar, CONFIG.useGlow]);\n  \n  // Frame counter for animation throttling\n  const frameCounterRef = useRef(0);\n  \n  // Main animation loop with optimized performance\n  const animate = useCallback((timestamp) => {\n    if (!isInitialized) {\n      animationFrameRef.current = requestAnimationFrame(animate);\n      return;\n    }\n    \n    // Calculate delta time with cap to prevent large jumps\n    const deltaTime = lastTimeRef.current ? Math.min(timestamp - lastTimeRef.current, 50) : 16;\n    lastTimeRef.current = timestamp;\n    \n    // Update frame counter for throttling\n    frameCounterRef.current = (frameCounterRef.current + 1) % (CONFIG.skipFrames + 1);\n    \n    // Always update animation for smooth movement\n    updateAnimation(deltaTime, timestamp);\n    \n    // Only render on certain frames for better performance\n    if (frameCounterRef.current === 0) {\n      renderScene();\n    }\n    \n    // Request next frame with throttling for consistent frame rate\n    if (CONFIG.maxFPS < 60) {\n      const nextFrameDelay = Math.max(0, 1000 / CONFIG.maxFPS - deltaTime);\n      setTimeout(() => {\n        if (animationFrameRef.current) {\n          cancelAnimationFrame(animationFrameRef.current);\n        }\n        animationFrameRef.current = requestAnimationFrame(animate);\n      }, nextFrameDelay);\n    } else {\n      animationFrameRef.current = requestAnimationFrame(animate);\n    }\n  }, [isInitialized, updateAnimation, renderScene, CONFIG.maxFPS, CONFIG.skipFrames]);\n  \n  // Initialize animation when component is ready\n  useEffect(() => {\n    if (!isInitialized && dimensions.width && dimensions.height) {\n      initializeStars();\n      setIsInitialized(true);\n    }\n  }, [dimensions, isInitialized, initializeStars]);\n  \n  // Start animation loop\n  useEffect(() => {\n    if (!isInitialized) return;\n    \n    // Start animation\n    animationFrameRef.current = requestAnimationFrame(animate);\n    \n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [isInitialized, animate]);\n  \n  return (\n    <div\n      ref={containerRef}\n      style={{\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        width: '100vw',\n        height: '100vh',\n        overflow: 'hidden',\n        zIndex: -1,\n        pointerEvents: 'none'\n      }}\n      aria-hidden=\"true\"\n    >\n      <canvas\n        ref={canvasRef}\n        style={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%'\n        }}\n      />\n    </div>\n  );\n};\n\nexport default Background;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}