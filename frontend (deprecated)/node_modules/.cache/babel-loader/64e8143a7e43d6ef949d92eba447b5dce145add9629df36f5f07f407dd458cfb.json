{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/effects/scrollingeffects/SlidingBackground.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\n\n/**\n * PainterlyBackground Component\n * \n * A smooth, high-quality background component with painterly fade effects and \n * fluid parallax scrolling that properly handles high-resolution images.\n * \n * @param {Object} props - Component props\n * @param {string} props.image - URL of the background image\n * @param {string} [props.position='top'] - Position of the focused area ('top', 'middle', 'bottom')\n * @param {string|number} [props.height='33vh'] - Height of the component\n * @param {number} [props.parallaxFactor=0.4] - How much the image moves relative to scroll (lower = smoother)\n * @param {string} [props.backgroundColor='#000'] - Background color\n * @param {number} [props.zIndex=0] - z-index of the component\n * @param {number} [props.fadeSize=0.4] - Size of the fade effect (0-1)\n * @param {number} [props.opacity=1] - Overall opacity of the component\n * @param {React.ReactNode} [props.children] - Content to render on top of the background\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SlidingBackground = ({\n  image,\n  position = 'top',\n  height = '33vh',\n  parallaxFactor = 0.4,\n  backgroundColor = '#000',\n  zIndex = 0,\n  fadeSize = 0.4,\n  opacity = 1,\n  children\n}) => {\n  _s();\n  // Refs\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const imageRef = useRef(null);\n  const rafRef = useRef(null);\n  const prevScrollY = useRef(0);\n  const targetScrollY = useRef(0);\n  const currentScrollY = useRef(0);\n\n  // State\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0\n  });\n  const [isImageLoaded, setIsImageLoaded] = useState(false);\n  const [imageAspect, setImageAspect] = useState(0);\n\n  // Calculate dimensions for the image and canvas\n  const calculateDimensions = useCallback(() => {\n    if (!containerRef.current) return;\n    const rect = containerRef.current.getBoundingClientRect();\n    setDimensions({\n      width: rect.width,\n      height: rect.height\n    });\n  }, []);\n\n  // Load high-quality image with proper handling\n  useEffect(() => {\n    const img = new Image();\n    img.crossOrigin = \"Anonymous\";\n    img.onload = () => {\n      imageRef.current = img;\n      setImageAspect(img.width / img.height);\n      setIsImageLoaded(true);\n    };\n    img.onerror = err => {\n      console.error(\"Failed to load image:\", err);\n    };\n    img.src = image;\n    return () => {\n      img.onload = null;\n      img.onerror = null;\n    };\n  }, [image]);\n\n  // Set up canvas dimensions and handle resize\n  useEffect(() => {\n    calculateDimensions();\n    const handleResize = () => {\n      calculateDimensions();\n\n      // Immediately render after resize to prevent flickering\n      if (isImageLoaded) {\n        renderCanvas();\n      }\n    };\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, [calculateDimensions, isImageLoaded]);\n\n  // Update canvas based on current dimensions\n  useEffect(() => {\n    if (canvasRef.current && dimensions.width && dimensions.height) {\n      const canvas = canvasRef.current;\n      const dpr = window.devicePixelRatio || 1;\n\n      // Set display size\n      canvas.style.width = `${dimensions.width}px`;\n      canvas.style.height = `${dimensions.height}px`;\n\n      // Set actual size with high DPR for retina displays\n      canvas.width = dimensions.width * dpr;\n      canvas.height = dimensions.height * dpr;\n\n      // Scale all drawing operations for high DPR\n      const ctx = canvas.getContext('2d');\n      ctx.scale(dpr, dpr);\n    }\n  }, [dimensions]);\n\n  // Smooth scroll animation using easing\n  const animateScroll = useCallback(() => {\n    // LERP (Linear Interpolation) for smooth transitions\n    const ease = 0.08; // Lower = smoother but slower\n\n    // Calculate new position with easing\n    const delta = targetScrollY.current - currentScrollY.current;\n    currentScrollY.current += delta * ease;\n\n    // Only render if changed enough to be visible\n    if (Math.abs(delta) > 0.1) {\n      renderCanvas();\n      rafRef.current = requestAnimationFrame(animateScroll);\n    } else {\n      // Snap to target when very close to avoid tiny movements\n      currentScrollY.current = targetScrollY.current;\n      renderCanvas();\n    }\n  }, []);\n\n  // Render the canvas with painterly effects\n  const renderCanvas = useCallback(() => {\n    if (!canvasRef.current || !imageRef.current || !dimensions.width || !dimensions.height) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const dpr = window.devicePixelRatio || 1;\n\n    // Calculate the rendering context size (accounting for DPR)\n    const renderWidth = dimensions.width;\n    const renderHeight = dimensions.height;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, renderWidth, renderHeight);\n\n    // Calculate parallax offset based on current interpolated scroll position\n    const parallaxOffset = currentScrollY.current * parallaxFactor;\n\n    // Calculate image dimensions to maintain aspect ratio\n    const canvasAspect = renderWidth / renderHeight;\n    let drawWidth, drawHeight, offsetX, offsetY;\n\n    // Ensure image covers the entire canvas with some overflow for parallax\n    if (imageAspect > canvasAspect) {\n      // Image is wider than canvas (relative to height)\n      drawHeight = renderHeight * 1.1; // Add 10% to allow for parallax movement\n      drawWidth = drawHeight * imageAspect;\n      offsetX = (renderWidth - drawWidth) / 2;\n      offsetY = 0;\n    } else {\n      // Image is taller than canvas (relative to width)\n      drawWidth = renderWidth * 1.1; // Add 10% to allow for parallax movement\n      drawHeight = drawWidth / imageAspect;\n      offsetX = 0;\n      offsetY = (renderHeight - drawHeight) / 2;\n    }\n\n    // Adjust based on position setting\n    if (position === 'top') {\n      offsetY = 0;\n    } else if (position === 'bottom') {\n      offsetY = renderHeight - drawHeight;\n    } else if (position === 'middle') {\n      offsetY = (renderHeight - drawHeight) / 2;\n    }\n\n    // Apply parallax offset\n    offsetY += parallaxOffset;\n\n    // Global opacity\n    ctx.globalAlpha = opacity;\n\n    // Draw the image\n    ctx.drawImage(imageRef.current, offsetX, offsetY, drawWidth, drawHeight);\n\n    // Helper function to convert color to rgba with opacity\n    const withOpacity = (color, opacity) => {\n      // Handle hex colors\n      if (color.startsWith('#')) {\n        // Convert hex to rgb\n        let r = 0,\n          g = 0,\n          b = 0;\n\n        // Handle #RGB format\n        if (color.length === 4) {\n          r = parseInt(color[1] + color[1], 16);\n          g = parseInt(color[2] + color[2], 16);\n          b = parseInt(color[3] + color[3], 16);\n        }\n        // Handle #RRGGBB format\n        else if (color.length === 7) {\n          r = parseInt(color.substring(1, 3), 16);\n          g = parseInt(color.substring(3, 5), 16);\n          b = parseInt(color.substring(5, 7), 16);\n        }\n        return `rgba(${r}, ${g}, ${b}, ${opacity})`;\n      }\n\n      // Handle rgb/rgba colors\n      if (color.startsWith('rgb')) {\n        // If already rgba, replace the opacity\n        if (color.startsWith('rgba')) {\n          return color.replace(/rgba\\((.+?),\\s*[\\d.]+\\)/, `rgba($1, ${opacity})`);\n        }\n        // Convert rgb to rgba\n        return color.replace(/rgb\\((.+?)\\)/, `rgba($1, ${opacity})`);\n      }\n\n      // Handle named colors by using a semi-transparent black as fallback\n      return `rgba(0, 0, 0, ${opacity})`;\n    };\n\n    // Painterly fade effects\n    const fadeTopHeight = Math.floor(renderHeight * fadeSize);\n    const fadeBottomHeight = Math.floor(renderHeight * fadeSize);\n    const shouldFadeTop = position === 'bottom' || position === 'middle';\n    const shouldFadeBottom = position === 'top' || position === 'middle';\n\n    // Top fade\n    if (shouldFadeTop) {\n      const gradient = ctx.createLinearGradient(0, 0, 0, fadeTopHeight);\n      gradient.addColorStop(0, backgroundColor);\n      gradient.addColorStop(0.7, withOpacity(backgroundColor, 0.5)); // 50% opacity\n      gradient.addColorStop(1, withOpacity(backgroundColor, 0)); // 0% opacity\n\n      ctx.fillStyle = gradient;\n      ctx.beginPath();\n\n      // Create a wavy, painterly bottom edge for the gradient\n      ctx.moveTo(0, 0);\n      ctx.lineTo(renderWidth, 0);\n\n      // Wavy bottom edge with bezier curves\n      let x = 0;\n      const segmentWidth = renderWidth / 8;\n      const variance = fadeTopHeight * 0.2; // How \"wavy\" the edge is\n\n      while (x < renderWidth) {\n        const cp1x = x + segmentWidth / 3;\n        const cp1y = fadeTopHeight + (Math.random() * variance - variance / 2);\n        const cp2x = x + segmentWidth / 3 * 2;\n        const cp2y = fadeTopHeight + (Math.random() * variance - variance / 2);\n        const endX = x + segmentWidth;\n        const endY = fadeTopHeight;\n        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);\n        x += segmentWidth;\n      }\n      ctx.lineTo(renderWidth, 0);\n      ctx.closePath();\n      ctx.fill();\n    }\n\n    // Bottom fade\n    if (shouldFadeBottom) {\n      const startY = renderHeight - fadeBottomHeight;\n      const gradient = ctx.createLinearGradient(0, startY, 0, renderHeight);\n      gradient.addColorStop(0, withOpacity(backgroundColor, 0)); // 0% opacity\n      gradient.addColorStop(0.3, withOpacity(backgroundColor, 0.5)); // 50% opacity\n      gradient.addColorStop(1, backgroundColor);\n      ctx.fillStyle = gradient;\n      ctx.beginPath();\n\n      // Create a wavy, painterly top edge for the gradient\n      ctx.moveTo(0, renderHeight);\n      ctx.lineTo(renderWidth, renderHeight);\n\n      // Wavy top edge with bezier curves\n      let x = 0;\n      const segmentWidth = renderWidth / 8;\n      const variance = fadeBottomHeight * 0.2; // How \"wavy\" the edge is\n\n      while (x < renderWidth) {\n        const cp1x = renderWidth - (x + segmentWidth / 3);\n        const cp1y = startY + (Math.random() * variance - variance / 2);\n        const cp2x = renderWidth - (x + segmentWidth / 3 * 2);\n        const cp2y = startY + (Math.random() * variance - variance / 2);\n        const endX = renderWidth - (x + segmentWidth);\n        const endY = startY;\n        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);\n        x += segmentWidth;\n      }\n      ctx.lineTo(0, renderHeight);\n      ctx.closePath();\n      ctx.fill();\n    }\n\n    // For debugging: show the actual image area\n    /*\n    ctx.strokeStyle = \"rgba(255,0,0,0.5)\";\n    ctx.lineWidth = 2;\n    ctx.strokeRect(offsetX, offsetY, drawWidth, drawHeight);\n    */\n  }, [dimensions, parallaxFactor, position, backgroundColor, opacity, fadeSize, imageAspect]);\n\n  // Scroll event handler using requestAnimationFrame for performance\n  useEffect(() => {\n    const handleScroll = () => {\n      targetScrollY.current = window.scrollY;\n\n      // Only start animation if we're not already animating\n      if (!rafRef.current) {\n        rafRef.current = requestAnimationFrame(animateScroll);\n      }\n    };\n    window.addEventListener('scroll', handleScroll, {\n      passive: true\n    });\n\n    // Initialize animation\n    targetScrollY.current = window.scrollY;\n    currentScrollY.current = window.scrollY;\n\n    // Initial render\n    if (isImageLoaded) {\n      renderCanvas();\n    }\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n      if (rafRef.current) {\n        cancelAnimationFrame(rafRef.current);\n        rafRef.current = null;\n      }\n    };\n  }, [animateScroll, renderCanvas, isImageLoaded]);\n\n  // Re-render when image loads\n  useEffect(() => {\n    if (isImageLoaded) {\n      renderCanvas();\n    }\n  }, [isImageLoaded, renderCanvas]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'relative',\n      width: '100%',\n      height,\n      overflow: 'hidden',\n      zIndex,\n      backgroundColor\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        display: isImageLoaded ? 'block' : 'none'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 365,\n      columnNumber: 7\n    }, this), !isImageLoaded && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        backgroundColor\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 379,\n      columnNumber: 9\n    }, this), children && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: 'relative',\n        zIndex: 1,\n        width: '100%',\n        height: '100%'\n      },\n      children: children\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 393,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 354,\n    columnNumber: 5\n  }, this);\n};\n_s(SlidingBackground, \"PrEadI48aT22eluKayryhCkUqcs=\");\n_c = SlidingBackground;\nexport default SlidingBackground;\nvar _c;\n$RefreshReg$(_c, \"SlidingBackground\");","map":{"version":3,"names":["React","useRef","useEffect","useState","useCallback","jsxDEV","_jsxDEV","SlidingBackground","image","position","height","parallaxFactor","backgroundColor","zIndex","fadeSize","opacity","children","_s","containerRef","canvasRef","imageRef","rafRef","prevScrollY","targetScrollY","currentScrollY","dimensions","setDimensions","width","isImageLoaded","setIsImageLoaded","imageAspect","setImageAspect","calculateDimensions","current","rect","getBoundingClientRect","img","Image","crossOrigin","onload","onerror","err","console","error","src","handleResize","renderCanvas","window","addEventListener","removeEventListener","canvas","dpr","devicePixelRatio","style","ctx","getContext","scale","animateScroll","ease","delta","Math","abs","requestAnimationFrame","renderWidth","renderHeight","clearRect","parallaxOffset","canvasAspect","drawWidth","drawHeight","offsetX","offsetY","globalAlpha","drawImage","withOpacity","color","startsWith","r","g","b","length","parseInt","substring","replace","fadeTopHeight","floor","fadeBottomHeight","shouldFadeTop","shouldFadeBottom","gradient","createLinearGradient","addColorStop","fillStyle","beginPath","moveTo","lineTo","x","segmentWidth","variance","cp1x","cp1y","random","cp2x","cp2y","endX","endY","bezierCurveTo","closePath","fill","startY","handleScroll","scrollY","passive","cancelAnimationFrame","ref","overflow","top","left","display","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/effects/scrollingeffects/SlidingBackground.jsx"],"sourcesContent":["import React, { useRef, useEffect, useState, useCallback } from 'react';\n\n/**\n * PainterlyBackground Component\n * \n * A smooth, high-quality background component with painterly fade effects and \n * fluid parallax scrolling that properly handles high-resolution images.\n * \n * @param {Object} props - Component props\n * @param {string} props.image - URL of the background image\n * @param {string} [props.position='top'] - Position of the focused area ('top', 'middle', 'bottom')\n * @param {string|number} [props.height='33vh'] - Height of the component\n * @param {number} [props.parallaxFactor=0.4] - How much the image moves relative to scroll (lower = smoother)\n * @param {string} [props.backgroundColor='#000'] - Background color\n * @param {number} [props.zIndex=0] - z-index of the component\n * @param {number} [props.fadeSize=0.4] - Size of the fade effect (0-1)\n * @param {number} [props.opacity=1] - Overall opacity of the component\n * @param {React.ReactNode} [props.children] - Content to render on top of the background\n */\nconst SlidingBackground = ({\n  image,\n  position = 'top',\n  height = '33vh',\n  parallaxFactor = 0.4,\n  backgroundColor = '#000',\n  zIndex = 0,\n  fadeSize = 0.4,\n  opacity = 1,\n  children\n}) => {\n  // Refs\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const imageRef = useRef(null);\n  const rafRef = useRef(null);\n  const prevScrollY = useRef(0);\n  const targetScrollY = useRef(0);\n  const currentScrollY = useRef(0);\n  \n  // State\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n  const [isImageLoaded, setIsImageLoaded] = useState(false);\n  const [imageAspect, setImageAspect] = useState(0);\n  \n  // Calculate dimensions for the image and canvas\n  const calculateDimensions = useCallback(() => {\n    if (!containerRef.current) return;\n    \n    const rect = containerRef.current.getBoundingClientRect();\n    setDimensions({\n      width: rect.width,\n      height: rect.height\n    });\n  }, []);\n  \n  // Load high-quality image with proper handling\n  useEffect(() => {\n    const img = new Image();\n    img.crossOrigin = \"Anonymous\";\n    \n    img.onload = () => {\n      imageRef.current = img;\n      setImageAspect(img.width / img.height);\n      setIsImageLoaded(true);\n    };\n    \n    img.onerror = (err) => {\n      console.error(\"Failed to load image:\", err);\n    };\n    \n    img.src = image;\n    \n    return () => {\n      img.onload = null;\n      img.onerror = null;\n    };\n  }, [image]);\n  \n  // Set up canvas dimensions and handle resize\n  useEffect(() => {\n    calculateDimensions();\n    \n    const handleResize = () => {\n      calculateDimensions();\n      \n      // Immediately render after resize to prevent flickering\n      if (isImageLoaded) {\n        renderCanvas();\n      }\n    };\n    \n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, [calculateDimensions, isImageLoaded]);\n  \n  // Update canvas based on current dimensions\n  useEffect(() => {\n    if (canvasRef.current && dimensions.width && dimensions.height) {\n      const canvas = canvasRef.current;\n      const dpr = window.devicePixelRatio || 1;\n      \n      // Set display size\n      canvas.style.width = `${dimensions.width}px`;\n      canvas.style.height = `${dimensions.height}px`;\n      \n      // Set actual size with high DPR for retina displays\n      canvas.width = dimensions.width * dpr;\n      canvas.height = dimensions.height * dpr;\n      \n      // Scale all drawing operations for high DPR\n      const ctx = canvas.getContext('2d');\n      ctx.scale(dpr, dpr);\n    }\n  }, [dimensions]);\n  \n  // Smooth scroll animation using easing\n  const animateScroll = useCallback(() => {\n    // LERP (Linear Interpolation) for smooth transitions\n    const ease = 0.08; // Lower = smoother but slower\n    \n    // Calculate new position with easing\n    const delta = targetScrollY.current - currentScrollY.current;\n    currentScrollY.current += delta * ease;\n    \n    // Only render if changed enough to be visible\n    if (Math.abs(delta) > 0.1) {\n      renderCanvas();\n      rafRef.current = requestAnimationFrame(animateScroll);\n    } else {\n      // Snap to target when very close to avoid tiny movements\n      currentScrollY.current = targetScrollY.current;\n      renderCanvas();\n    }\n  }, []);\n  \n  // Render the canvas with painterly effects\n  const renderCanvas = useCallback(() => {\n    if (!canvasRef.current || !imageRef.current || !dimensions.width || !dimensions.height) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const dpr = window.devicePixelRatio || 1;\n    \n    // Calculate the rendering context size (accounting for DPR)\n    const renderWidth = dimensions.width;\n    const renderHeight = dimensions.height;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, renderWidth, renderHeight);\n    \n    // Calculate parallax offset based on current interpolated scroll position\n    const parallaxOffset = currentScrollY.current * parallaxFactor;\n    \n    // Calculate image dimensions to maintain aspect ratio\n    const canvasAspect = renderWidth / renderHeight;\n    let drawWidth, drawHeight, offsetX, offsetY;\n    \n    // Ensure image covers the entire canvas with some overflow for parallax\n    if (imageAspect > canvasAspect) {\n      // Image is wider than canvas (relative to height)\n      drawHeight = renderHeight * 1.1; // Add 10% to allow for parallax movement\n      drawWidth = drawHeight * imageAspect;\n      offsetX = (renderWidth - drawWidth) / 2;\n      offsetY = 0;\n    } else {\n      // Image is taller than canvas (relative to width)\n      drawWidth = renderWidth * 1.1; // Add 10% to allow for parallax movement\n      drawHeight = drawWidth / imageAspect;\n      offsetX = 0;\n      offsetY = (renderHeight - drawHeight) / 2;\n    }\n    \n    // Adjust based on position setting\n    if (position === 'top') {\n      offsetY = 0;\n    } else if (position === 'bottom') {\n      offsetY = renderHeight - drawHeight;\n    } else if (position === 'middle') {\n      offsetY = (renderHeight - drawHeight) / 2;\n    }\n    \n    // Apply parallax offset\n    offsetY += parallaxOffset;\n    \n    // Global opacity\n    ctx.globalAlpha = opacity;\n    \n    // Draw the image\n    ctx.drawImage(imageRef.current, offsetX, offsetY, drawWidth, drawHeight);\n    \n    // Helper function to convert color to rgba with opacity\n    const withOpacity = (color, opacity) => {\n      // Handle hex colors\n      if (color.startsWith('#')) {\n        // Convert hex to rgb\n        let r = 0, g = 0, b = 0;\n        \n        // Handle #RGB format\n        if (color.length === 4) {\n          r = parseInt(color[1] + color[1], 16);\n          g = parseInt(color[2] + color[2], 16);\n          b = parseInt(color[3] + color[3], 16);\n        } \n        // Handle #RRGGBB format\n        else if (color.length === 7) {\n          r = parseInt(color.substring(1, 3), 16);\n          g = parseInt(color.substring(3, 5), 16);\n          b = parseInt(color.substring(5, 7), 16);\n        }\n        \n        return `rgba(${r}, ${g}, ${b}, ${opacity})`;\n      }\n      \n      // Handle rgb/rgba colors\n      if (color.startsWith('rgb')) {\n        // If already rgba, replace the opacity\n        if (color.startsWith('rgba')) {\n          return color.replace(/rgba\\((.+?),\\s*[\\d.]+\\)/, `rgba($1, ${opacity})`);\n        }\n        // Convert rgb to rgba\n        return color.replace(/rgb\\((.+?)\\)/, `rgba($1, ${opacity})`);\n      }\n      \n      // Handle named colors by using a semi-transparent black as fallback\n      return `rgba(0, 0, 0, ${opacity})`;\n    };\n    \n    // Painterly fade effects\n    const fadeTopHeight = Math.floor(renderHeight * fadeSize);\n    const fadeBottomHeight = Math.floor(renderHeight * fadeSize);\n    const shouldFadeTop = position === 'bottom' || position === 'middle';\n    const shouldFadeBottom = position === 'top' || position === 'middle';\n    \n    // Top fade\n    if (shouldFadeTop) {\n      const gradient = ctx.createLinearGradient(0, 0, 0, fadeTopHeight);\n      gradient.addColorStop(0, backgroundColor);\n      gradient.addColorStop(0.7, withOpacity(backgroundColor, 0.5)); // 50% opacity\n      gradient.addColorStop(1, withOpacity(backgroundColor, 0)); // 0% opacity\n      \n      ctx.fillStyle = gradient;\n      ctx.beginPath();\n      \n      // Create a wavy, painterly bottom edge for the gradient\n      ctx.moveTo(0, 0);\n      ctx.lineTo(renderWidth, 0);\n      \n      // Wavy bottom edge with bezier curves\n      let x = 0;\n      const segmentWidth = renderWidth / 8;\n      const variance = fadeTopHeight * 0.2; // How \"wavy\" the edge is\n      \n      while (x < renderWidth) {\n        const cp1x = x + segmentWidth / 3;\n        const cp1y = fadeTopHeight + (Math.random() * variance - variance/2);\n        const cp2x = x + (segmentWidth / 3) * 2;\n        const cp2y = fadeTopHeight + (Math.random() * variance - variance/2);\n        const endX = x + segmentWidth;\n        const endY = fadeTopHeight;\n        \n        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);\n        x += segmentWidth;\n      }\n      \n      ctx.lineTo(renderWidth, 0);\n      ctx.closePath();\n      ctx.fill();\n    }\n    \n    // Bottom fade\n    if (shouldFadeBottom) {\n      const startY = renderHeight - fadeBottomHeight;\n      const gradient = ctx.createLinearGradient(0, startY, 0, renderHeight);\n      gradient.addColorStop(0, withOpacity(backgroundColor, 0)); // 0% opacity\n      gradient.addColorStop(0.3, withOpacity(backgroundColor, 0.5)); // 50% opacity\n      gradient.addColorStop(1, backgroundColor);\n      \n      ctx.fillStyle = gradient;\n      ctx.beginPath();\n      \n      // Create a wavy, painterly top edge for the gradient\n      ctx.moveTo(0, renderHeight);\n      ctx.lineTo(renderWidth, renderHeight);\n      \n      // Wavy top edge with bezier curves\n      let x = 0;\n      const segmentWidth = renderWidth / 8;\n      const variance = fadeBottomHeight * 0.2; // How \"wavy\" the edge is\n      \n      while (x < renderWidth) {\n        const cp1x = renderWidth - (x + segmentWidth / 3);\n        const cp1y = startY + (Math.random() * variance - variance/2);\n        const cp2x = renderWidth - (x + (segmentWidth / 3) * 2);\n        const cp2y = startY + (Math.random() * variance - variance/2);\n        const endX = renderWidth - (x + segmentWidth);\n        const endY = startY;\n        \n        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);\n        x += segmentWidth;\n      }\n      \n      ctx.lineTo(0, renderHeight);\n      ctx.closePath();\n      ctx.fill();\n    }\n    \n    // For debugging: show the actual image area\n    /*\n    ctx.strokeStyle = \"rgba(255,0,0,0.5)\";\n    ctx.lineWidth = 2;\n    ctx.strokeRect(offsetX, offsetY, drawWidth, drawHeight);\n    */\n  }, [dimensions, parallaxFactor, position, backgroundColor, opacity, fadeSize, imageAspect]);\n  \n  // Scroll event handler using requestAnimationFrame for performance\n  useEffect(() => {\n    const handleScroll = () => {\n      targetScrollY.current = window.scrollY;\n      \n      // Only start animation if we're not already animating\n      if (!rafRef.current) {\n        rafRef.current = requestAnimationFrame(animateScroll);\n      }\n    };\n    \n    window.addEventListener('scroll', handleScroll, { passive: true });\n    \n    // Initialize animation\n    targetScrollY.current = window.scrollY;\n    currentScrollY.current = window.scrollY;\n    \n    // Initial render\n    if (isImageLoaded) {\n      renderCanvas();\n    }\n    \n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n      if (rafRef.current) {\n        cancelAnimationFrame(rafRef.current);\n        rafRef.current = null;\n      }\n    };\n  }, [animateScroll, renderCanvas, isImageLoaded]);\n  \n  // Re-render when image loads\n  useEffect(() => {\n    if (isImageLoaded) {\n      renderCanvas();\n    }\n  }, [isImageLoaded, renderCanvas]);\n  \n  return (\n    <div\n      ref={containerRef}\n      style={{\n        position: 'relative',\n        width: '100%',\n        height,\n        overflow: 'hidden',\n        zIndex,\n        backgroundColor\n      }}\n    >\n      <canvas\n        ref={canvasRef}\n        style={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%',\n          display: isImageLoaded ? 'block' : 'none'\n        }}\n      />\n      \n      {/* Loading state */}\n      {!isImageLoaded && (\n        <div\n          style={{\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            width: '100%',\n            height: '100%',\n            backgroundColor\n          }}\n        />\n      )}\n      \n      {/* Content container */}\n      {children && (\n        <div\n          style={{\n            position: 'relative',\n            zIndex: 1,\n            width: '100%',\n            height: '100%'\n          }}\n        >\n          {children}\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default SlidingBackground;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}