{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/Background.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect, useCallback, useMemo } from 'react';\n\n/**\n * Background Component\n * \n * Creates an immersive infinite stellar background that generates new stars\n * as the user scrolls down the page, with realistic stellar rendering.\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Background = () => {\n  _s();\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const documentHeightRef = useRef(0);\n  const visibleAreaRef = useRef({\n    top: 0,\n    bottom: 0\n  });\n  const starMapRef = useRef(new Map());\n  const animationFrameRef = useRef(null);\n  const lastTimeRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n\n  // Component state\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0,\n    pixelRatio: 1\n  });\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n\n  // Configuration wrapped in useMemo to prevent unnecessary re-renders\n  const CONFIG = useMemo(() => ({\n    // Star parameters\n    starDensity: 0.00012,\n    // Increased star density\n    cellSize: 500,\n    // Size of star generation cells\n    bufferCells: 1,\n    // Buffer cells outside visible area\n    starSizeMin: 0.8,\n    starSizeMax: 2.5,\n    starOpacityMin: 0.15,\n    starOpacityMax: 0.85,\n    // Motion and animation\n    baseMovementSpeed: 0.00015,\n    // Very subtle movement\n    pulseFrequency: 0.00004,\n    // Slower pulsing\n    pulseIntensity: 0.25,\n    // Subtle pulse\n\n    // Parallax effect\n    parallaxIntensity: 0.04,\n    // Extremely subtle parallax\n\n    // Performance parameters\n    maxFPS: 30,\n    useGlow: true\n  }), []);\n\n  // Warm, golden color palette wrapped in useMemo\n  const COLORS = useMemo(() => ({\n    // Main star colors (warm golden tones)\n    stars: ['rgba(255, 243, 200, alpha)',\n    // Warm yellow\n    'rgba(255, 231, 164, alpha)',\n    // Golden\n    'rgba(255, 236, 179, alpha)',\n    // Pale gold\n    'rgba(252, 249, 231, alpha)',\n    // Off-white gold\n    'rgba(255, 225, 205, alpha)' // Warm white (slight orange)\n    ],\n    // Background gradient colors\n    background: {\n      topColor: 'rgb(8, 8, 12)',\n      bottomColor: 'rgb(15, 15, 20)'\n    }\n  }), []);\n\n  // Get color with opacity\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    return baseColor.replace(/alpha\\)$/, `${safeOpacity})`);\n  }, []);\n\n  // Get the current document height\n  const updateDocumentHeight = useCallback(() => {\n    const documentHeight = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);\n    documentHeightRef.current = documentHeight;\n\n    // Update container height to match document\n    if (containerRef.current) {\n      containerRef.current.style.height = `${documentHeight}px`;\n    }\n  }, []);\n\n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) return false;\n    const canvas = canvasRef.current;\n\n    // Get viewport dimensions\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const pixelRatio = window.devicePixelRatio || 1;\n\n    // Set canvas size accounting for pixel ratio\n    canvas.width = width * pixelRatio;\n    canvas.height = height * pixelRatio;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n\n    // Update dimensions state\n    setDimensions({\n      width,\n      height,\n      pixelRatio\n    });\n    return true;\n  }, []);\n\n  // Generate a deterministic random number based on input coordinates\n  const seededRandom = useCallback((x, y, seed = 1) => {\n    const dot = x * 12.9898 + y * 78.233 + seed;\n    return Math.sin(dot) * 43758.5453 % 1;\n  }, []);\n\n  // Generate stars for a specific cell\n  const generateStarsForCell = useCallback((cellX, cellY) => {\n    const cellKey = `${cellX},${cellY}`;\n\n    // Check if we already generated stars for this cell\n    if (starMapRef.current.has(cellKey)) {\n      return starMapRef.current.get(cellKey);\n    }\n    const stars = [];\n    const cellWidth = CONFIG.cellSize;\n    const cellHeight = CONFIG.cellSize;\n    const startX = cellX * cellWidth;\n    const startY = cellY * cellHeight;\n\n    // Calculate how many stars based on density\n    const starCount = Math.floor(cellWidth * cellHeight * CONFIG.starDensity);\n\n    // Create stars with deterministic positions based on cell coordinates\n    for (let i = 0; i < starCount; i++) {\n      // Use seeded random for deterministic star placement\n      const rx = seededRandom(cellX, i, 1);\n      const ry = seededRandom(cellY, i, 2);\n      const rz = seededRandom(cellX, cellY, i * 3);\n      const star = {};\n\n      // Position within cell\n      star.x = startX + rx * cellWidth;\n      star.y = startY + ry * cellHeight;\n      star.z = rz * 0.8 + 0.1; // Depth (0.1 to 0.9)\n\n      // Visual properties with seeded random\n      star.size = (seededRandom(cellX, i, 4) * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n      star.baseOpacity = seededRandom(cellX, i, 5) * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n      star.opacity = star.baseOpacity;\n\n      // Animation properties\n      star.pulsePhase = seededRandom(cellX, i, 6) * Math.PI * 2;\n      star.pulseSpeed = seededRandom(cellX, i, 7) * 0.002 + 0.001;\n\n      // Motion properties - very subtle\n      star.movementX = (seededRandom(cellX, i, 8) * 2 - 1) * CONFIG.baseMovementSpeed;\n      star.movementY = (seededRandom(cellX, i, 9) * 2 - 1) * CONFIG.baseMovementSpeed;\n      star.initialX = star.x;\n      star.initialY = star.y;\n\n      // Star shape properties - add variation for more realistic stars\n      star.rays = seededRandom(cellX, i, 10) > 0.7 ? Math.floor(seededRandom(cellX, i, 11) * 2) + 4 : 0;\n      star.rayLength = star.size * (seededRandom(cellX, i, 12) * 0.7 + 0.3);\n      star.rayIntensity = seededRandom(cellX, i, 13) * 0.4 + 0.3;\n\n      // Color variation\n      const colorIndex = Math.floor(seededRandom(cellX, i, 14) * COLORS.stars.length);\n      star.color = COLORS.stars[colorIndex];\n      stars.push(star);\n    }\n\n    // Store in map\n    starMapRef.current.set(cellKey, stars);\n    return stars;\n  }, [CONFIG, COLORS.stars, seededRandom]);\n\n  // Generate stars for the visible area and buffer\n  const generateStarsForVisibleArea = useCallback(() => {\n    if (!dimensions.width) return;\n    const {\n      top,\n      bottom\n    } = visibleAreaRef.current;\n\n    // Calculate which cells are visible\n    const startCellY = Math.floor(top / CONFIG.cellSize) - CONFIG.bufferCells;\n    const endCellY = Math.ceil(bottom / CONFIG.cellSize) + CONFIG.bufferCells;\n\n    // Width cells (always visible)\n    const startCellX = 0;\n    const endCellX = Math.ceil(dimensions.width / CONFIG.cellSize);\n\n    // Generate stars for all visible cells\n    for (let y = Math.max(0, startCellY); y <= endCellY; y++) {\n      for (let x = startCellX; x < endCellX; x++) {\n        generateStarsForCell(x, y);\n      }\n    }\n  }, [dimensions.width, CONFIG.cellSize, CONFIG.bufferCells, generateStarsForCell]);\n\n  // Get all visible stars\n  const getVisibleStars = useCallback(() => {\n    const visibleStars = [];\n    const buffer = dimensions.height; // Extra buffer to account for parallax\n\n    // Calculate which cells could be visible\n    const startCellY = Math.floor((visibleAreaRef.current.top - buffer) / CONFIG.cellSize);\n    const endCellY = Math.ceil((visibleAreaRef.current.bottom + buffer) / CONFIG.cellSize);\n    const startCellX = 0;\n    const endCellX = Math.ceil(dimensions.width / CONFIG.cellSize);\n\n    // Collect stars from all potentially visible cells\n    for (let y = Math.max(0, startCellY); y <= endCellY; y++) {\n      for (let x = startCellX; x < endCellX; x++) {\n        const cellKey = `${x},${y}`;\n        if (starMapRef.current.has(cellKey)) {\n          visibleStars.push(...starMapRef.current.get(cellKey));\n        }\n      }\n    }\n    return visibleStars;\n  }, [dimensions.height, dimensions.width, CONFIG.cellSize]);\n\n  // Update animation state\n  const updateAnimation = useCallback((deltaTime, timestamp) => {\n    // Global time factor for animations\n    const timeFactor = timestamp * 0.001;\n\n    // Parallax effect from scroll - extremely subtle\n    const parallaxOffset = scrollPositionRef.current * CONFIG.parallaxIntensity;\n\n    // Motion dampening for reduced motion preference\n    const motionFactor = prefersReducedMotion ? 0.1 : 1;\n\n    // Get all visible stars\n    const visibleStars = getVisibleStars();\n\n    // Update stars\n    for (let i = 0; i < visibleStars.length; i++) {\n      const star = visibleStars[i];\n\n      // Small positional oscillation around initial position\n      star.x = star.initialX + Math.sin(timeFactor * 0.2 + star.pulsePhase) * 0.5 * motionFactor;\n      star.y = star.initialY + Math.cos(timeFactor * 0.3 + star.pulsePhase * 1.3) * 0.5 * motionFactor;\n\n      // Apply parallax offset based on depth (z) - extremely subtle\n      const starParallax = parallaxOffset * (1 - star.z) * 0.5;\n      star.parallaxY = starParallax;\n\n      // Subtle pulsing effect - more natural by combining multiple sine waves\n      const pulseFactor = (Math.sin(timeFactor * star.pulseSpeed + star.pulsePhase) * 0.5 + Math.sin(timeFactor * star.pulseSpeed * 0.4 + star.pulsePhase * 1.3) * 0.3) * 0.15 + 0.85;\n      star.opacity = star.baseOpacity * pulseFactor;\n\n      // Vary ray intensity based on pulse\n      if (star.rays > 0) {\n        star.currentRayIntensity = star.rayIntensity * pulseFactor;\n      }\n    }\n  }, [CONFIG.parallaxIntensity, prefersReducedMotion, getVisibleStars]);\n\n  // Render a more realistic star with optional rays\n  const drawStar = useCallback((ctx, star, y) => {\n    // Skip stars that are far outside the visible area (accounting for parallax)\n    if (y < visibleAreaRef.current.top - 50 || y > visibleAreaRef.current.bottom + 50) {\n      return;\n    }\n\n    // Ensure we have positive values to prevent \"Negative radius\" errors\n    const glowRadius = Math.max(0.1, star.size * 2);\n    try {\n      // Draw outer glow for all stars\n      const gradient = ctx.createRadialGradient(star.x, y, 0, star.x, y, glowRadius);\n      gradient.addColorStop(0, getColor(star.color, star.opacity * 0.9));\n      gradient.addColorStop(0.5, getColor(star.color, star.opacity * 0.3));\n      gradient.addColorStop(1, getColor(star.color, 0));\n      ctx.beginPath();\n      ctx.fillStyle = gradient;\n      ctx.arc(star.x, y, glowRadius, 0, Math.PI * 2);\n      ctx.fill();\n\n      // Draw bright core\n      ctx.beginPath();\n      ctx.fillStyle = getColor(star.color, star.opacity);\n      ctx.arc(star.x, y, Math.max(0.1, star.size * 0.5), 0, Math.PI * 2);\n      ctx.fill();\n\n      // Draw rays for some stars\n      if (star.rays > 0 && star.opacity > 0.3) {\n        ctx.save();\n        ctx.translate(star.x, y);\n        ctx.rotate(Math.sin(Date.now() * 0.0001) * 0.05); // Very slight rotation\n\n        for (let i = 0; i < star.rays; i++) {\n          const angle = i / star.rays * Math.PI * 2;\n          const rayLength = Math.max(0.1, star.rayLength * (0.7 + Math.sin(Date.now() * 0.001 + i) * 0.3));\n          ctx.beginPath();\n          ctx.moveTo(0, 0);\n          ctx.lineTo(Math.cos(angle) * rayLength, Math.sin(angle) * rayLength);\n\n          // Create gradient for ray\n          const rayGradient = ctx.createLinearGradient(0, 0, Math.cos(angle) * rayLength, Math.sin(angle) * rayLength);\n          rayGradient.addColorStop(0, getColor(star.color, star.opacity * 0.9));\n          rayGradient.addColorStop(1, getColor(star.color, 0));\n          ctx.strokeStyle = rayGradient;\n          ctx.lineWidth = Math.max(0.1, star.size * 0.3);\n          ctx.stroke();\n        }\n        ctx.restore();\n      }\n    } catch (error) {\n      // Silently handle any canvas drawing errors\n      // This prevents errors from breaking the entire component\n    }\n  }, [getColor]);\n\n  // Render the scene\n  const renderScene = useCallback(() => {\n    if (!canvasRef.current) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Apply device pixel ratio scaling\n    ctx.setTransform(dimensions.pixelRatio, 0, 0, dimensions.pixelRatio, 0, 0);\n\n    // Clear canvas\n    ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n\n    // Draw background gradient\n    const gradient = ctx.createLinearGradient(0, 0, 0, dimensions.height);\n    gradient.addColorStop(0, COLORS.background.topColor);\n    gradient.addColorStop(1, COLORS.background.bottomColor);\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, dimensions.width, dimensions.height);\n\n    // Enable global composition for better glow effect\n    ctx.globalCompositeOperation = 'lighter';\n\n    // Get all visible stars\n    const visibleStars = getVisibleStars();\n\n    // Draw stars\n    for (const star of visibleStars) {\n      // Skip almost invisible stars\n      if (star.opacity < 0.02) continue;\n\n      // Calculate screen position based on scroll\n      // Adjust y position relative to canvas (which is fixed to the viewport)\n      const screenY = star.y - visibleAreaRef.current.top + (star.parallaxY || 0);\n\n      // Only render stars that are visible in the viewport plus a small buffer\n      if (screenY >= -50 && screenY <= dimensions.height + 50) {\n        // Draw star with enhanced rendering\n        drawStar(ctx, star, screenY);\n      }\n    }\n\n    // Reset global composition\n    ctx.globalCompositeOperation = 'source-over';\n  }, [dimensions, COLORS, getVisibleStars, drawStar]);\n\n  // Main animation loop\n  const animate = useCallback(timestamp => {\n    if (!isInitialized) {\n      animationFrameRef.current = requestAnimationFrame(animate);\n      return;\n    }\n\n    // Calculate delta time with cap to prevent large jumps\n    const deltaTime = lastTimeRef.current ? Math.min(timestamp - lastTimeRef.current, 33) : 16;\n    lastTimeRef.current = timestamp;\n\n    // Update animation state\n    updateAnimation(deltaTime, timestamp);\n\n    // Render scene\n    renderScene();\n\n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(animate);\n  }, [isInitialized, updateAnimation, renderScene]);\n\n  // Detect reduced motion preference\n  useEffect(() => {\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    const handleReducedMotionChange = e => {\n      setPrefersReducedMotion(e.matches);\n    };\n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n    };\n  }, []);\n\n  // Handle canvas setup and initialization\n  useEffect(() => {\n    // Initialize canvas\n    setupCanvas();\n\n    // Return cleanup function\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [setupCanvas]);\n\n  // Handle document updates and star generation\n  useEffect(() => {\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n\n      // Update visible area\n      const viewportHeight = window.innerHeight;\n      visibleAreaRef.current = {\n        top: window.scrollY,\n        bottom: window.scrollY + viewportHeight\n      };\n\n      // Generate stars for newly visible areas\n      generateStarsForVisibleArea();\n    };\n    const handleResize = () => {\n      // Update document height on resize\n      updateDocumentHeight();\n\n      // Update canvas dimensions\n      setupCanvas();\n\n      // Reset visible area\n      const viewportHeight = window.innerHeight;\n      visibleAreaRef.current = {\n        top: window.scrollY,\n        bottom: window.scrollY + viewportHeight\n      };\n\n      // Clear existing stars and regenerate\n      starMapRef.current.clear();\n      generateStarsForVisibleArea();\n    };\n    window.addEventListener('scroll', handleScroll, {\n      passive: true\n    });\n    window.addEventListener('resize', handleResize);\n\n    // Initial calls\n    updateDocumentHeight();\n    handleScroll();\n\n    // Set initialized after first render\n    setIsInitialized(true);\n\n    // Start animation\n    animationFrameRef.current = requestAnimationFrame(animate);\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n      window.removeEventListener('resize', handleResize);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [updateDocumentHeight, setupCanvas, generateStarsForVisibleArea, animate]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      // Will be updated to full document height\n      overflow: 'hidden',\n      zIndex: -1,\n      pointerEvents: 'none'\n    },\n    \"aria-hidden\": \"true\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'fixed',\n        // Canvas stays fixed but renders content based on scroll\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 509,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 495,\n    columnNumber: 5\n  }, this);\n};\n_s(Background, \"1ciWI3LLeU6EDW3xkEfGKYSpfa8=\");\n_c = Background;\nexport default Background;\nvar _c;\n$RefreshReg$(_c, \"Background\");","map":{"version":3,"names":["React","useRef","useState","useEffect","useCallback","useMemo","jsxDEV","_jsxDEV","Background","_s","containerRef","canvasRef","documentHeightRef","visibleAreaRef","top","bottom","starMapRef","Map","animationFrameRef","lastTimeRef","scrollPositionRef","dimensions","setDimensions","width","height","pixelRatio","isInitialized","setIsInitialized","prefersReducedMotion","setPrefersReducedMotion","CONFIG","starDensity","cellSize","bufferCells","starSizeMin","starSizeMax","starOpacityMin","starOpacityMax","baseMovementSpeed","pulseFrequency","pulseIntensity","parallaxIntensity","maxFPS","useGlow","COLORS","stars","background","topColor","bottomColor","getColor","baseColor","opacity","safeOpacity","Math","max","min","replace","updateDocumentHeight","documentHeight","document","body","scrollHeight","offsetHeight","documentElement","clientHeight","current","style","setupCanvas","canvas","window","innerWidth","innerHeight","devicePixelRatio","seededRandom","x","y","seed","dot","sin","generateStarsForCell","cellX","cellY","cellKey","has","get","cellWidth","cellHeight","startX","startY","starCount","floor","i","rx","ry","rz","star","z","size","baseOpacity","pulsePhase","PI","pulseSpeed","movementX","movementY","initialX","initialY","rays","rayLength","rayIntensity","colorIndex","length","color","push","set","generateStarsForVisibleArea","startCellY","endCellY","ceil","startCellX","endCellX","getVisibleStars","visibleStars","buffer","updateAnimation","deltaTime","timestamp","timeFactor","parallaxOffset","motionFactor","cos","starParallax","parallaxY","pulseFactor","currentRayIntensity","drawStar","ctx","glowRadius","gradient","createRadialGradient","addColorStop","beginPath","fillStyle","arc","fill","save","translate","rotate","Date","now","angle","moveTo","lineTo","rayGradient","createLinearGradient","strokeStyle","lineWidth","stroke","restore","error","renderScene","getContext","setTransform","clearRect","fillRect","globalCompositeOperation","screenY","animate","requestAnimationFrame","reducedMotionQuery","matchMedia","matches","handleReducedMotionChange","e","addEventListener","removeEventListener","cancelAnimationFrame","handleScroll","scrollY","viewportHeight","handleResize","clear","passive","ref","position","left","overflow","zIndex","pointerEvents","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/Background.jsx"],"sourcesContent":["import React, { useRef, useState, useEffect, useCallback, useMemo } from 'react';\n\n/**\n * Background Component\n * \n * Creates an immersive infinite stellar background that generates new stars\n * as the user scrolls down the page, with realistic stellar rendering.\n */\nconst Background = () => {\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const documentHeightRef = useRef(0);\n  const visibleAreaRef = useRef({ top: 0, bottom: 0 });\n  const starMapRef = useRef(new Map());\n  const animationFrameRef = useRef(null);\n  const lastTimeRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n  \n  // Component state\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0, pixelRatio: 1 });\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  \n  // Configuration wrapped in useMemo to prevent unnecessary re-renders\n  const CONFIG = useMemo(() => ({\n    // Star parameters\n    starDensity: 0.00012,   // Increased star density\n    cellSize: 500,          // Size of star generation cells\n    bufferCells: 1,         // Buffer cells outside visible area\n    starSizeMin: 0.8,\n    starSizeMax: 2.5,\n    starOpacityMin: 0.15,\n    starOpacityMax: 0.85,\n    \n    // Motion and animation\n    baseMovementSpeed: 0.00015,  // Very subtle movement\n    pulseFrequency: 0.00004,     // Slower pulsing\n    pulseIntensity: 0.25,        // Subtle pulse\n    \n    // Parallax effect\n    parallaxIntensity: 0.04,     // Extremely subtle parallax\n    \n    // Performance parameters\n    maxFPS: 30,\n    useGlow: true\n  }), []);\n  \n  // Warm, golden color palette wrapped in useMemo\n  const COLORS = useMemo(() => ({\n    // Main star colors (warm golden tones)\n    stars: [\n      'rgba(255, 243, 200, alpha)', // Warm yellow\n      'rgba(255, 231, 164, alpha)', // Golden\n      'rgba(255, 236, 179, alpha)', // Pale gold\n      'rgba(252, 249, 231, alpha)', // Off-white gold\n      'rgba(255, 225, 205, alpha)'  // Warm white (slight orange)\n    ],\n    \n    // Background gradient colors\n    background: {\n      topColor: 'rgb(8, 8, 12)',\n      bottomColor: 'rgb(15, 15, 20)'\n    }\n  }), []);\n  \n  // Get color with opacity\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    return baseColor.replace(/alpha\\)$/, `${safeOpacity})`);\n  }, []);\n  \n  // Get the current document height\n  const updateDocumentHeight = useCallback(() => {\n    const documentHeight = Math.max(\n      document.body.scrollHeight,\n      document.body.offsetHeight,\n      document.documentElement.clientHeight,\n      document.documentElement.scrollHeight,\n      document.documentElement.offsetHeight\n    );\n    documentHeightRef.current = documentHeight;\n    \n    // Update container height to match document\n    if (containerRef.current) {\n      containerRef.current.style.height = `${documentHeight}px`;\n    }\n  }, []);\n  \n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) return false;\n    \n    const canvas = canvasRef.current;\n    \n    // Get viewport dimensions\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const pixelRatio = window.devicePixelRatio || 1;\n    \n    // Set canvas size accounting for pixel ratio\n    canvas.width = width * pixelRatio;\n    canvas.height = height * pixelRatio;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n    \n    // Update dimensions state\n    setDimensions({\n      width,\n      height,\n      pixelRatio\n    });\n    \n    return true;\n  }, []);\n  \n  // Generate a deterministic random number based on input coordinates\n  const seededRandom = useCallback((x, y, seed = 1) => {\n    const dot = x * 12.9898 + y * 78.233 + seed;\n    return (Math.sin(dot) * 43758.5453) % 1;\n  }, []);\n  \n  // Generate stars for a specific cell\n  const generateStarsForCell = useCallback((cellX, cellY) => {\n    const cellKey = `${cellX},${cellY}`;\n    \n    // Check if we already generated stars for this cell\n    if (starMapRef.current.has(cellKey)) {\n      return starMapRef.current.get(cellKey);\n    }\n    \n    const stars = [];\n    const cellWidth = CONFIG.cellSize;\n    const cellHeight = CONFIG.cellSize;\n    const startX = cellX * cellWidth;\n    const startY = cellY * cellHeight;\n    \n    // Calculate how many stars based on density\n    const starCount = Math.floor(cellWidth * cellHeight * CONFIG.starDensity);\n    \n    // Create stars with deterministic positions based on cell coordinates\n    for (let i = 0; i < starCount; i++) {\n      // Use seeded random for deterministic star placement\n      const rx = seededRandom(cellX, i, 1);\n      const ry = seededRandom(cellY, i, 2);\n      const rz = seededRandom(cellX, cellY, i * 3);\n      \n      const star = {};\n      \n      // Position within cell\n      star.x = startX + rx * cellWidth;\n      star.y = startY + ry * cellHeight;\n      star.z = rz * 0.8 + 0.1; // Depth (0.1 to 0.9)\n      \n      // Visual properties with seeded random\n      star.size = (seededRandom(cellX, i, 4) * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n      star.baseOpacity = seededRandom(cellX, i, 5) * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n      star.opacity = star.baseOpacity;\n      \n      // Animation properties\n      star.pulsePhase = seededRandom(cellX, i, 6) * Math.PI * 2;\n      star.pulseSpeed = seededRandom(cellX, i, 7) * 0.002 + 0.001;\n      \n      // Motion properties - very subtle\n      star.movementX = (seededRandom(cellX, i, 8) * 2 - 1) * CONFIG.baseMovementSpeed;\n      star.movementY = (seededRandom(cellX, i, 9) * 2 - 1) * CONFIG.baseMovementSpeed;\n      star.initialX = star.x;\n      star.initialY = star.y;\n      \n      // Star shape properties - add variation for more realistic stars\n      star.rays = seededRandom(cellX, i, 10) > 0.7 ? Math.floor(seededRandom(cellX, i, 11) * 2) + 4 : 0;\n      star.rayLength = star.size * (seededRandom(cellX, i, 12) * 0.7 + 0.3);\n      star.rayIntensity = seededRandom(cellX, i, 13) * 0.4 + 0.3;\n      \n      // Color variation\n      const colorIndex = Math.floor(seededRandom(cellX, i, 14) * COLORS.stars.length);\n      star.color = COLORS.stars[colorIndex];\n      \n      stars.push(star);\n    }\n    \n    // Store in map\n    starMapRef.current.set(cellKey, stars);\n    \n    return stars;\n  }, [CONFIG, COLORS.stars, seededRandom]);\n  \n  // Generate stars for the visible area and buffer\n  const generateStarsForVisibleArea = useCallback(() => {\n    if (!dimensions.width) return;\n    \n    const { top, bottom } = visibleAreaRef.current;\n    \n    // Calculate which cells are visible\n    const startCellY = Math.floor(top / CONFIG.cellSize) - CONFIG.bufferCells;\n    const endCellY = Math.ceil(bottom / CONFIG.cellSize) + CONFIG.bufferCells;\n    \n    // Width cells (always visible)\n    const startCellX = 0;\n    const endCellX = Math.ceil(dimensions.width / CONFIG.cellSize);\n    \n    // Generate stars for all visible cells\n    for (let y = Math.max(0, startCellY); y <= endCellY; y++) {\n      for (let x = startCellX; x < endCellX; x++) {\n        generateStarsForCell(x, y);\n      }\n    }\n  }, [dimensions.width, CONFIG.cellSize, CONFIG.bufferCells, generateStarsForCell]);\n  \n  // Get all visible stars\n  const getVisibleStars = useCallback(() => {\n    const visibleStars = [];\n    const buffer = dimensions.height; // Extra buffer to account for parallax\n    \n    // Calculate which cells could be visible\n    const startCellY = Math.floor((visibleAreaRef.current.top - buffer) / CONFIG.cellSize);\n    const endCellY = Math.ceil((visibleAreaRef.current.bottom + buffer) / CONFIG.cellSize);\n    const startCellX = 0;\n    const endCellX = Math.ceil(dimensions.width / CONFIG.cellSize);\n    \n    // Collect stars from all potentially visible cells\n    for (let y = Math.max(0, startCellY); y <= endCellY; y++) {\n      for (let x = startCellX; x < endCellX; x++) {\n        const cellKey = `${x},${y}`;\n        if (starMapRef.current.has(cellKey)) {\n          visibleStars.push(...starMapRef.current.get(cellKey));\n        }\n      }\n    }\n    \n    return visibleStars;\n  }, [dimensions.height, dimensions.width, CONFIG.cellSize]);\n  \n  // Update animation state\n  const updateAnimation = useCallback((deltaTime, timestamp) => {\n    // Global time factor for animations\n    const timeFactor = timestamp * 0.001;\n    \n    // Parallax effect from scroll - extremely subtle\n    const parallaxOffset = scrollPositionRef.current * CONFIG.parallaxIntensity;\n    \n    // Motion dampening for reduced motion preference\n    const motionFactor = prefersReducedMotion ? 0.1 : 1;\n    \n    // Get all visible stars\n    const visibleStars = getVisibleStars();\n    \n    // Update stars\n    for (let i = 0; i < visibleStars.length; i++) {\n      const star = visibleStars[i];\n      \n      // Small positional oscillation around initial position\n      star.x = star.initialX + Math.sin(timeFactor * 0.2 + star.pulsePhase) * 0.5 * motionFactor;\n      star.y = star.initialY + Math.cos(timeFactor * 0.3 + star.pulsePhase * 1.3) * 0.5 * motionFactor;\n      \n      // Apply parallax offset based on depth (z) - extremely subtle\n      const starParallax = parallaxOffset * (1 - star.z) * 0.5;\n      star.parallaxY = starParallax;\n      \n      // Subtle pulsing effect - more natural by combining multiple sine waves\n      const pulseFactor = (\n        Math.sin(timeFactor * star.pulseSpeed + star.pulsePhase) * 0.5 + \n        Math.sin(timeFactor * star.pulseSpeed * 0.4 + star.pulsePhase * 1.3) * 0.3\n      ) * 0.15 + 0.85;\n      \n      star.opacity = star.baseOpacity * pulseFactor;\n      \n      // Vary ray intensity based on pulse\n      if (star.rays > 0) {\n        star.currentRayIntensity = star.rayIntensity * pulseFactor;\n      }\n    }\n  }, [CONFIG.parallaxIntensity, prefersReducedMotion, getVisibleStars]);\n  \n  // Render a more realistic star with optional rays\n  const drawStar = useCallback((ctx, star, y) => {\n    // Skip stars that are far outside the visible area (accounting for parallax)\n    if (y < visibleAreaRef.current.top - 50 || y > visibleAreaRef.current.bottom + 50) {\n      return;\n    }\n    \n    // Ensure we have positive values to prevent \"Negative radius\" errors\n    const glowRadius = Math.max(0.1, star.size * 2);\n    \n    try {\n      // Draw outer glow for all stars\n      const gradient = ctx.createRadialGradient(star.x, y, 0, star.x, y, glowRadius);\n      gradient.addColorStop(0, getColor(star.color, star.opacity * 0.9));\n      gradient.addColorStop(0.5, getColor(star.color, star.opacity * 0.3));\n      gradient.addColorStop(1, getColor(star.color, 0));\n      \n      ctx.beginPath();\n      ctx.fillStyle = gradient;\n      ctx.arc(star.x, y, glowRadius, 0, Math.PI * 2);\n      ctx.fill();\n      \n      // Draw bright core\n      ctx.beginPath();\n      ctx.fillStyle = getColor(star.color, star.opacity);\n      ctx.arc(star.x, y, Math.max(0.1, star.size * 0.5), 0, Math.PI * 2);\n      ctx.fill();\n      \n      // Draw rays for some stars\n      if (star.rays > 0 && star.opacity > 0.3) {\n        ctx.save();\n        ctx.translate(star.x, y);\n        ctx.rotate(Math.sin(Date.now() * 0.0001) * 0.05); // Very slight rotation\n        \n        for (let i = 0; i < star.rays; i++) {\n          const angle = (i / star.rays) * Math.PI * 2;\n          const rayLength = Math.max(0.1, star.rayLength * (0.7 + Math.sin(Date.now() * 0.001 + i) * 0.3));\n          \n          ctx.beginPath();\n          ctx.moveTo(0, 0);\n          ctx.lineTo(Math.cos(angle) * rayLength, Math.sin(angle) * rayLength);\n          \n          // Create gradient for ray\n          const rayGradient = ctx.createLinearGradient(\n            0, 0,\n            Math.cos(angle) * rayLength, Math.sin(angle) * rayLength\n          );\n          rayGradient.addColorStop(0, getColor(star.color, star.opacity * 0.9));\n          rayGradient.addColorStop(1, getColor(star.color, 0));\n          \n          ctx.strokeStyle = rayGradient;\n          ctx.lineWidth = Math.max(0.1, star.size * 0.3);\n          ctx.stroke();\n        }\n        \n        ctx.restore();\n      }\n    } catch (error) {\n      // Silently handle any canvas drawing errors\n      // This prevents errors from breaking the entire component\n    }\n  }, [getColor]);\n  \n  // Render the scene\n  const renderScene = useCallback(() => {\n    if (!canvasRef.current) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    \n    if (!ctx) return;\n    \n    // Apply device pixel ratio scaling\n    ctx.setTransform(dimensions.pixelRatio, 0, 0, dimensions.pixelRatio, 0, 0);\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n    \n    // Draw background gradient\n    const gradient = ctx.createLinearGradient(0, 0, 0, dimensions.height);\n    gradient.addColorStop(0, COLORS.background.topColor);\n    gradient.addColorStop(1, COLORS.background.bottomColor);\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, dimensions.width, dimensions.height);\n    \n    // Enable global composition for better glow effect\n    ctx.globalCompositeOperation = 'lighter';\n    \n    // Get all visible stars\n    const visibleStars = getVisibleStars();\n    \n    // Draw stars\n    for (const star of visibleStars) {\n      // Skip almost invisible stars\n      if (star.opacity < 0.02) continue;\n      \n      // Calculate screen position based on scroll\n      // Adjust y position relative to canvas (which is fixed to the viewport)\n      const screenY = star.y - visibleAreaRef.current.top + (star.parallaxY || 0);\n      \n      // Only render stars that are visible in the viewport plus a small buffer\n      if (screenY >= -50 && screenY <= dimensions.height + 50) {\n        // Draw star with enhanced rendering\n        drawStar(ctx, star, screenY);\n      }\n    }\n    \n    // Reset global composition\n    ctx.globalCompositeOperation = 'source-over';\n  }, [dimensions, COLORS, getVisibleStars, drawStar]);\n  \n  // Main animation loop\n  const animate = useCallback((timestamp) => {\n    if (!isInitialized) {\n      animationFrameRef.current = requestAnimationFrame(animate);\n      return;\n    }\n    \n    // Calculate delta time with cap to prevent large jumps\n    const deltaTime = lastTimeRef.current ? Math.min(timestamp - lastTimeRef.current, 33) : 16;\n    lastTimeRef.current = timestamp;\n    \n    // Update animation state\n    updateAnimation(deltaTime, timestamp);\n    \n    // Render scene\n    renderScene();\n    \n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(animate);\n  }, [isInitialized, updateAnimation, renderScene]);\n  \n  // Detect reduced motion preference\n  useEffect(() => {\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    \n    const handleReducedMotionChange = (e) => {\n      setPrefersReducedMotion(e.matches);\n    };\n    \n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n    \n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n    };\n  }, []);\n  \n  // Handle canvas setup and initialization\n  useEffect(() => {\n    // Initialize canvas\n    setupCanvas();\n    \n    // Return cleanup function\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [setupCanvas]);\n  \n  // Handle document updates and star generation\n  useEffect(() => {\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n      \n      // Update visible area\n      const viewportHeight = window.innerHeight;\n      visibleAreaRef.current = {\n        top: window.scrollY,\n        bottom: window.scrollY + viewportHeight\n      };\n      \n      // Generate stars for newly visible areas\n      generateStarsForVisibleArea();\n    };\n    \n    const handleResize = () => {\n      // Update document height on resize\n      updateDocumentHeight();\n      \n      // Update canvas dimensions\n      setupCanvas();\n      \n      // Reset visible area\n      const viewportHeight = window.innerHeight;\n      visibleAreaRef.current = {\n        top: window.scrollY,\n        bottom: window.scrollY + viewportHeight\n      };\n      \n      // Clear existing stars and regenerate\n      starMapRef.current.clear();\n      generateStarsForVisibleArea();\n    };\n    \n    window.addEventListener('scroll', handleScroll, { passive: true });\n    window.addEventListener('resize', handleResize);\n    \n    // Initial calls\n    updateDocumentHeight();\n    handleScroll();\n    \n    // Set initialized after first render\n    setIsInitialized(true);\n    \n    // Start animation\n    animationFrameRef.current = requestAnimationFrame(animate);\n    \n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n      window.removeEventListener('resize', handleResize);\n      \n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [updateDocumentHeight, setupCanvas, generateStarsForVisibleArea, animate]);\n  \n  return (\n    <div\n      ref={containerRef}\n      style={{\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',  // Will be updated to full document height\n        overflow: 'hidden',\n        zIndex: -1,\n        pointerEvents: 'none'\n      }}\n      aria-hidden=\"true\"\n    >\n      <canvas\n        ref={canvasRef}\n        style={{\n          position: 'fixed',  // Canvas stays fixed but renders content based on scroll\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%'\n        }}\n      />\n    </div>\n  );\n};\n\nexport default Background;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}