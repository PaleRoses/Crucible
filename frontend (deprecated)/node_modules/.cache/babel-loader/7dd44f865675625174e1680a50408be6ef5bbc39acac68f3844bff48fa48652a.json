{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/layout/Background.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useCallback, useMemo } from 'react';\n\n/**\n * Optimized Background Component with Parallax Effects\n * \n * Creates an immersive stellar background with realistic star particles\n * and scroll-based parallax effects while maintaining performance through canvas.\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Background = () => {\n  _s();\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const starsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimeRef = useRef(0);\n  const scrollYRef = useRef(0);\n  const lastScrollYRef = useRef(0);\n  const scrollVelocityRef = useRef(0);\n\n  // Use refs instead of state to prevent re-renders during initialization\n  const isInitializedRef = useRef(false);\n  const firstRenderCompleteRef = useRef(false);\n\n  // Store dimensions in a ref to avoid re-renders when they change\n  const dimensionsRef = useRef({\n    width: 0,\n    height: 0,\n    pixelRatio: 1\n  });\n\n  // Configuration - wrapped in useMemo to prevent recreation on each render\n  const CONFIG = useMemo(() => ({\n    // Reduced star count for better performance\n    starCount: 100,\n    starSizeMin: 0.8,\n    starSizeMax: 2.5,\n    starOpacityMin: 0.15,\n    starOpacityMax: 0.85,\n    // Motion parameters\n    baseMovementSpeed: 0.00008,\n    pulseFrequency: 0.00003,\n    // Parallax effect configuration\n    parallaxEnabled: true,\n    parallaxStrength: 0.2,\n    parallaxMaxDisplacement: 50,\n    parallaxLayerCount: 5,\n    // Spring physics for smooth animations\n    springStiffness: 0.08,\n    springDamping: 0.65,\n    // Performance parameters\n    maxFPS: 60,\n    // Session persistence\n    sessionKey: 'star_background_config'\n  }), []);\n\n  // Warm, golden color palette - wrapped in useMemo\n  const COLORS = useMemo(() => ({\n    // Simplified color palette\n    stars: ['rgba(255, 243, 200, alpha)',\n    // Warm yellow\n    'rgba(255, 231, 164, alpha)',\n    // Golden\n    'rgba(252, 249, 231, alpha)' // Off-white gold\n    ],\n    // Background gradient colors\n    background: {}\n  }), []);\n\n  // Pre-generated color values to avoid string replacements during animation\n  const colorCache = useMemo(() => {\n    const cache = {};\n    COLORS.stars.forEach(baseColor => {\n      cache[baseColor] = {};\n      for (let opacity = 0; opacity <= 10; opacity++) {\n        const value = opacity / 10;\n        cache[baseColor][value] = baseColor.replace(/alpha\\)$/, `${value})`);\n      }\n    });\n    return cache;\n  }, [COLORS.stars]);\n\n  // Get color with opacity from cache (faster than string replacement)\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    // Round to nearest 0.1 to use cached values\n    const roundedOpacity = Math.round(safeOpacity * 10) / 10;\n    return colorCache[baseColor][roundedOpacity] || baseColor.replace(/alpha\\)$/, `${safeOpacity})`);\n  }, [colorCache]);\n\n  // Load or generate session-persistent configuration\n  const getSessionConfiguration = useCallback(() => {\n    try {\n      // Try to load existing configuration from sessionStorage\n      const storedConfig = sessionStorage.getItem(CONFIG.sessionKey);\n      if (storedConfig) {\n        return JSON.parse(storedConfig);\n      }\n    } catch (error) {\n      console.warn('Could not load star configuration from session storage', error);\n    }\n\n    // Generate new configuration if none exists\n    const starSeeds = [];\n    for (let i = 0; i < CONFIG.starCount; i++) {\n      starSeeds.push({\n        xSeed: Math.random(),\n        ySeed: Math.random(),\n        zSeed: Math.random() * 0.8 + 0.1,\n        sizeSeed: Math.random(),\n        opacitySeed: Math.random(),\n        phaseSeed: Math.random() * Math.PI * 2,\n        speedSeed: Math.random() * 0.2 + 0.9,\n        pulseSpeedSeed: Math.random() * 0.002 + 0.001,\n        colorIndex: Math.floor(Math.random() * COLORS.stars.length),\n        // New properties for parallax effect\n        parallaxLayer: Math.floor(Math.random() * CONFIG.parallaxLayerCount),\n        springOffsetX: 0,\n        springOffsetY: 0,\n        targetOffsetX: 0,\n        targetOffsetY: 0,\n        // Direction factors for varied movement\n        directionX: Math.random() > 0.5 ? 1 : -1,\n        directionY: Math.random() > 0.5 ? 1 : -1\n      });\n    }\n\n    // Store new configuration in sessionStorage\n    const newConfig = {\n      starSeeds,\n      timestamp: Date.now()\n    };\n    try {\n      sessionStorage.setItem(CONFIG.sessionKey, JSON.stringify(newConfig));\n    } catch (error) {\n      console.warn('Could not save star configuration to session storage', error);\n    }\n    return newConfig;\n  }, [CONFIG.sessionKey, CONFIG.starCount, CONFIG.parallaxLayerCount, COLORS.stars.length]);\n\n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) return false;\n    const canvas = canvasRef.current;\n\n    // Get viewport dimensions\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const pixelRatio = window.devicePixelRatio || 1;\n\n    // Set canvas size accounting for pixel ratio\n    canvas.width = width * pixelRatio;\n    canvas.height = height * pixelRatio;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n\n    // Ensure canvas is visible with a background color\n    const ctx = canvas.getContext('2d', {\n      alpha: false\n    }); // Optimize for non-transparent canvas\n    if (ctx) {\n      ctx.fillStyle = 'rgb(15, 15, 20)';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n\n    // Update dimensions ref instead of state\n    dimensionsRef.current = {\n      width,\n      height,\n      pixelRatio\n    };\n    return true;\n  }, []);\n\n  // Initialize stars with session-persistent configuration\n  const initializeStars = useCallback(() => {\n    const {\n      width,\n      height\n    } = dimensionsRef.current;\n    if (!width || !height) return;\n\n    // Get or create session-persistent configuration\n    const sessionConfig = getSessionConfiguration();\n    const {\n      starSeeds\n    } = sessionConfig;\n\n    // Clear existing stars\n    starsRef.current = [];\n\n    // Create stars using the persistent seeds\n    for (let i = 0; i < starSeeds.length; i++) {\n      const seed = starSeeds[i];\n      const star = {};\n\n      // Position - use seeds but adapt to current screen dimensions\n      star.baseX = seed.xSeed * width;\n      star.baseY = seed.ySeed * height;\n      star.x = star.baseX;\n      star.y = star.baseY;\n      star.z = seed.zSeed; // Depth (0.1 to 0.9)\n\n      // Visual properties\n      star.size = (seed.sizeSeed * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n      star.baseOpacity = seed.opacitySeed * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n      star.opacity = star.baseOpacity;\n\n      // Animation properties\n      star.pulsePhase = seed.phaseSeed;\n      star.pulseSpeed = seed.pulseSpeedSeed;\n      star.movementSpeed = seed.speedSeed * CONFIG.baseMovementSpeed * (1.1 - star.z);\n\n      // Color variation\n      star.color = COLORS.stars[seed.colorIndex];\n\n      // New parallax properties\n      star.parallaxLayer = seed.parallaxLayer;\n      star.parallaxFactor = (star.parallaxLayer + 1) / CONFIG.parallaxLayerCount;\n      star.springOffsetX = 0;\n      star.springOffsetY = 0;\n      star.targetOffsetX = 0;\n      star.targetOffsetY = 0;\n      star.directionX = seed.directionX;\n      star.directionY = seed.directionY;\n\n      // Store in ref\n      starsRef.current.push(star);\n    }\n  }, [CONFIG, COLORS.stars, getSessionConfiguration]);\n\n  // Optimized star rendering\n  const drawStar = useCallback((ctx, star) => {\n    // Skip rendering almost invisible stars\n    if (star.opacity < 0.05) return;\n\n    // Get final position with parallax offsets\n    const x = star.x + star.springOffsetX;\n    const y = star.y + star.springOffsetY;\n\n    // Simplified star rendering without creating new gradients every frame\n    ctx.beginPath();\n    ctx.arc(x, y, star.size, 0, Math.PI * 2);\n    ctx.fillStyle = getColor(star.color, star.opacity);\n    ctx.fill();\n\n    // Simplified glow effect without expensive gradient creation\n    if (star.opacity > 0.3) {\n      ctx.beginPath();\n      ctx.arc(x, y, star.size * 1.8, 0, Math.PI * 2);\n      ctx.fillStyle = getColor(star.color, star.opacity * 0.4);\n      ctx.fill();\n    }\n  }, [getColor]);\n\n  // Render the scene - optimized for performance\n  const renderScene = useCallback(() => {\n    if (!canvasRef.current) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d', {\n      alpha: false\n    });\n    if (!ctx) return;\n    const {\n      width,\n      height,\n      pixelRatio\n    } = dimensionsRef.current;\n\n    // Clear canvas\n    ctx.fillStyle = COLORS.background.topColor;\n    ctx.fillRect(0, 0, width * pixelRatio, height * pixelRatio);\n\n    // Apply device pixel ratio scaling only once\n    ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n\n    // Enable global composition for better glow effect\n    ctx.globalCompositeOperation = 'lighter';\n\n    // Draw stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      drawStar(ctx, starsRef.current[i]);\n    }\n\n    // Reset global composition\n    ctx.globalCompositeOperation = 'source-over';\n  }, [COLORS.background.topColor, drawStar]);\n\n  // Apply spring physics to star offsets\n  const applySpringPhysics = useCallback((star, deltaTime) => {\n    // Spring physics constants\n    const stiffness = CONFIG.springStiffness;\n    const damping = CONFIG.springDamping;\n\n    // Calculate spring force for X axis\n    let springForceX = (star.targetOffsetX - star.springOffsetX) * stiffness;\n    let dampingForceX = -star.velocityX * damping;\n    star.accelerationX = springForceX + dampingForceX;\n    star.velocityX += star.accelerationX * deltaTime;\n    star.springOffsetX += star.velocityX * deltaTime;\n\n    // Calculate spring force for Y axis\n    let springForceY = (star.targetOffsetY - star.springOffsetY) * stiffness;\n    let dampingForceY = -star.velocityY * damping;\n    star.accelerationY = springForceY + dampingForceY;\n    star.velocityY += star.accelerationY * deltaTime;\n    star.springOffsetY += star.velocityY * deltaTime;\n  }, [CONFIG.springStiffness, CONFIG.springDamping]);\n\n  // Update animation state - optimized for performance\n  const updateAnimation = useCallback((deltaTime, timestamp) => {\n    const {\n      width,\n      height\n    } = dimensionsRef.current;\n\n    // Global time factor for animations\n    const timeFactor = timestamp * 0.001;\n\n    // Get current scroll position and calculate scroll velocity\n    const currentScrollY = window.scrollY;\n    const scrollDelta = currentScrollY - lastScrollYRef.current;\n\n    // Update scroll velocity with smoothing\n    scrollVelocityRef.current = scrollVelocityRef.current * 0.8 + scrollDelta * 0.2;\n\n    // Store current scroll position for next frame\n    lastScrollYRef.current = currentScrollY;\n    scrollYRef.current = currentScrollY;\n\n    // Maximum displacement based on config\n    const maxDisplacement = CONFIG.parallaxMaxDisplacement;\n\n    // Update stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n\n      // Initialize velocity and acceleration if not present\n      if (star.velocityX === undefined) {\n        star.velocityX = 0;\n        star.velocityY = 0;\n        star.accelerationX = 0;\n        star.accelerationY = 0;\n      }\n\n      // Basic movement based on time\n      star.x = star.baseX + Math.sin(timeFactor * 0.2 + star.pulsePhase) * 2 * star.directionX;\n      star.y = star.baseY + Math.cos(timeFactor * 0.3 + star.pulsePhase * 1.3) * 2 * star.directionY;\n\n      // Parallax effect based on scroll - each star moves differently based on its layer\n      if (CONFIG.parallaxEnabled) {\n        // Calculate target offset based on scroll position\n        // Stars in deeper layers (higher parallaxFactor) move more\n        const scrollInfluence = scrollYRef.current / height * maxDisplacement;\n        const layerFactor = star.parallaxFactor;\n\n        // Add velocity-based effects for a more dynamic feel\n        const velocityInfluence = scrollVelocityRef.current * 0.1 * layerFactor;\n\n        // Set target offsets - notice how deeper layers move more\n        star.targetOffsetX = Math.sin(timeFactor * 0.1 + star.pulsePhase) * velocityInfluence * star.directionX;\n        star.targetOffsetY = scrollInfluence * layerFactor + Math.cos(timeFactor * 0.15 + star.pulsePhase) * velocityInfluence * star.directionY;\n\n        // Apply spring physics for smooth transitions\n        applySpringPhysics(star, deltaTime);\n      }\n\n      // Wrap around screen edges\n      const effectiveX = star.x + star.springOffsetX;\n      const effectiveY = star.y + star.springOffsetY;\n      if (effectiveX < 0) star.baseX = width;\n      if (effectiveX > width) star.baseX = 0;\n      if (effectiveY < 0) star.baseY = height;\n      if (effectiveY > height) star.baseY = 0;\n\n      // Simplified pulsing effect\n      const pulseFactor = Math.sin(timeFactor * star.pulseSpeed + star.pulsePhase) * 0.15 + 0.85;\n      star.opacity = star.baseOpacity * pulseFactor;\n\n      // Subtle size variation based on parallax movement\n      const sizeVariation = 1 + (Math.abs(star.springOffsetX) + Math.abs(star.springOffsetY)) / (maxDisplacement * 10);\n      star.currentSize = star.size * sizeVariation;\n    }\n  }, [CONFIG.parallaxEnabled, CONFIG.parallaxMaxDisplacement, applySpringPhysics]);\n\n  // Define the animation loop function with FPS limiting\n  const animate = useCallback(function animationLoop(timestamp) {\n    if (!isInitializedRef.current) {\n      animationFrameRef.current = requestAnimationFrame(animationLoop);\n      return;\n    }\n\n    // Limit FPS\n    const minFrameTime = 1000 / CONFIG.maxFPS;\n    const elapsed = timestamp - (lastTimeRef.current || 0);\n    if (elapsed < minFrameTime) {\n      animationFrameRef.current = requestAnimationFrame(animationLoop);\n      return;\n    }\n\n    // Calculate delta time with cap to prevent large jumps\n    const deltaTime = lastTimeRef.current ? Math.min(elapsed, 50) : 16;\n    lastTimeRef.current = timestamp;\n\n    // Update animation state\n    updateAnimation(deltaTime, timestamp);\n\n    // Render scene\n    renderScene();\n\n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(animationLoop);\n  }, [CONFIG.maxFPS, updateAnimation, renderScene]);\n\n  // Track scroll position\n  useEffect(() => {\n    const handleScroll = () => {\n      scrollYRef.current = window.scrollY;\n    };\n    window.addEventListener('scroll', handleScroll, {\n      passive: true\n    });\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, []);\n\n  // Comprehensive initialization and resize handling\n  useEffect(() => {\n    // One-time initialization function\n    const initialize = () => {\n      if (setupCanvas()) {\n        // Create stars only after canvas is ready\n        initializeStars();\n        // Mark as initialized but don't trigger re-render\n        isInitializedRef.current = true;\n        // Start animation only after everything is ready\n        animationFrameRef.current = requestAnimationFrame(animate);\n      }\n    };\n\n    // Handle resize events\n    const handleResize = () => {\n      // Only re-initialize if already initialized\n      if (isInitializedRef.current) {\n        setupCanvas();\n        initializeStars();\n        // No need to change initialization state\n      }\n    };\n\n    // Throttle resize events\n    let resizeTimer;\n    const throttledResize = () => {\n      if (!resizeTimer) {\n        resizeTimer = setTimeout(() => {\n          resizeTimer = null;\n          handleResize();\n        }, 200); // 200ms throttle\n      }\n    };\n\n    // Add resize listener\n    window.addEventListener('resize', throttledResize);\n\n    // Run initialization after first render is complete\n    // This prevents the \"double load\" effect\n    requestAnimationFrame(() => {\n      firstRenderCompleteRef.current = true;\n      initialize();\n    });\n\n    // Cleanup\n    return () => {\n      window.removeEventListener('resize', throttledResize);\n      if (resizeTimer) clearTimeout(resizeTimer);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [setupCanvas, initializeStars, animate]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      width: '100vw',\n      height: '100vh',\n      overflow: 'hidden',\n      zIndex: -1,\n      pointerEvents: 'none'\n    },\n    \"aria-hidden\": \"true\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 486,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 472,\n    columnNumber: 5\n  }, this);\n};\n_s(Background, \"EDCEfdb+NW/Nc18uIGYCi3Hu0/U=\");\n_c = Background;\nexport default Background;\nvar _c;\n$RefreshReg$(_c, \"Background\");","map":{"version":3,"names":["React","useRef","useEffect","useCallback","useMemo","jsxDEV","_jsxDEV","Background","_s","containerRef","canvasRef","starsRef","animationFrameRef","lastTimeRef","scrollYRef","lastScrollYRef","scrollVelocityRef","isInitializedRef","firstRenderCompleteRef","dimensionsRef","width","height","pixelRatio","CONFIG","starCount","starSizeMin","starSizeMax","starOpacityMin","starOpacityMax","baseMovementSpeed","pulseFrequency","parallaxEnabled","parallaxStrength","parallaxMaxDisplacement","parallaxLayerCount","springStiffness","springDamping","maxFPS","sessionKey","COLORS","stars","background","colorCache","cache","forEach","baseColor","opacity","value","replace","getColor","safeOpacity","Math","max","min","roundedOpacity","round","getSessionConfiguration","storedConfig","sessionStorage","getItem","JSON","parse","error","console","warn","starSeeds","i","push","xSeed","random","ySeed","zSeed","sizeSeed","opacitySeed","phaseSeed","PI","speedSeed","pulseSpeedSeed","colorIndex","floor","length","parallaxLayer","springOffsetX","springOffsetY","targetOffsetX","targetOffsetY","directionX","directionY","newConfig","timestamp","Date","now","setItem","stringify","setupCanvas","current","canvas","window","innerWidth","innerHeight","devicePixelRatio","style","ctx","getContext","alpha","fillStyle","fillRect","initializeStars","sessionConfig","seed","star","baseX","baseY","x","y","z","size","baseOpacity","pulsePhase","pulseSpeed","movementSpeed","color","parallaxFactor","drawStar","beginPath","arc","fill","renderScene","topColor","setTransform","globalCompositeOperation","applySpringPhysics","deltaTime","stiffness","damping","springForceX","dampingForceX","velocityX","accelerationX","springForceY","dampingForceY","velocityY","accelerationY","updateAnimation","timeFactor","currentScrollY","scrollY","scrollDelta","maxDisplacement","undefined","sin","cos","scrollInfluence","layerFactor","velocityInfluence","effectiveX","effectiveY","pulseFactor","sizeVariation","abs","currentSize","animate","animationLoop","requestAnimationFrame","minFrameTime","elapsed","handleScroll","addEventListener","passive","removeEventListener","initialize","handleResize","resizeTimer","throttledResize","setTimeout","clearTimeout","cancelAnimationFrame","ref","position","top","left","overflow","zIndex","pointerEvents","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/layout/Background.jsx"],"sourcesContent":["import React, { useRef, useEffect, useCallback, useMemo } from 'react';\n\n/**\n * Optimized Background Component with Parallax Effects\n * \n * Creates an immersive stellar background with realistic star particles\n * and scroll-based parallax effects while maintaining performance through canvas.\n */\nconst Background = () => {\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const starsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimeRef = useRef(0);\n  const scrollYRef = useRef(0);\n  const lastScrollYRef = useRef(0);\n  const scrollVelocityRef = useRef(0);\n  \n  // Use refs instead of state to prevent re-renders during initialization\n  const isInitializedRef = useRef(false);\n  const firstRenderCompleteRef = useRef(false);\n  \n  // Store dimensions in a ref to avoid re-renders when they change\n  const dimensionsRef = useRef({ width: 0, height: 0, pixelRatio: 1 });\n  \n  // Configuration - wrapped in useMemo to prevent recreation on each render\n  const CONFIG = useMemo(() => ({\n    // Reduced star count for better performance\n    starCount: 100,\n    starSizeMin: 0.8,\n    starSizeMax: 2.5,\n    starOpacityMin: 0.15,\n    starOpacityMax: 0.85,\n    \n    // Motion parameters\n    baseMovementSpeed: 0.00008,\n    pulseFrequency: 0.00003,\n    \n    // Parallax effect configuration\n    parallaxEnabled: true,\n    parallaxStrength: 0.2,\n    parallaxMaxDisplacement: 50,\n    parallaxLayerCount: 5,\n    \n    // Spring physics for smooth animations\n    springStiffness: 0.08,\n    springDamping: 0.65,\n    \n    // Performance parameters\n    maxFPS: 60,\n    \n    // Session persistence\n    sessionKey: 'star_background_config'\n  }), []);\n  \n  // Warm, golden color palette - wrapped in useMemo\n  const COLORS = useMemo(() => ({\n    // Simplified color palette\n    stars: [\n      'rgba(255, 243, 200, alpha)', // Warm yellow\n      'rgba(255, 231, 164, alpha)', // Golden\n      'rgba(252, 249, 231, alpha)'  // Off-white gold\n    ],\n    \n    // Background gradient colors\n    background: {\n     \n    }\n  }), []);\n  \n  // Pre-generated color values to avoid string replacements during animation\n  const colorCache = useMemo(() => {\n    const cache = {};\n    COLORS.stars.forEach(baseColor => {\n      cache[baseColor] = {};\n      for (let opacity = 0; opacity <= 10; opacity++) {\n        const value = opacity / 10;\n        cache[baseColor][value] = baseColor.replace(/alpha\\)$/, `${value})`);\n      }\n    });\n    return cache;\n  }, [COLORS.stars]);\n  \n  // Get color with opacity from cache (faster than string replacement)\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    // Round to nearest 0.1 to use cached values\n    const roundedOpacity = Math.round(safeOpacity * 10) / 10;\n    return colorCache[baseColor][roundedOpacity] || baseColor.replace(/alpha\\)$/, `${safeOpacity})`);\n  }, [colorCache]);\n  \n  // Load or generate session-persistent configuration\n  const getSessionConfiguration = useCallback(() => {\n    try {\n      // Try to load existing configuration from sessionStorage\n      const storedConfig = sessionStorage.getItem(CONFIG.sessionKey);\n      \n      if (storedConfig) {\n        return JSON.parse(storedConfig);\n      }\n    } catch (error) {\n      console.warn('Could not load star configuration from session storage', error);\n    }\n    \n    // Generate new configuration if none exists\n    const starSeeds = [];\n    for (let i = 0; i < CONFIG.starCount; i++) {\n      starSeeds.push({\n        xSeed: Math.random(),\n        ySeed: Math.random(),\n        zSeed: Math.random() * 0.8 + 0.1,\n        sizeSeed: Math.random(),\n        opacitySeed: Math.random(),\n        phaseSeed: Math.random() * Math.PI * 2,\n        speedSeed: Math.random() * 0.2 + 0.9,\n        pulseSpeedSeed: Math.random() * 0.002 + 0.001,\n        colorIndex: Math.floor(Math.random() * COLORS.stars.length),\n        // New properties for parallax effect\n        parallaxLayer: Math.floor(Math.random() * CONFIG.parallaxLayerCount),\n        springOffsetX: 0,\n        springOffsetY: 0,\n        targetOffsetX: 0,\n        targetOffsetY: 0,\n        // Direction factors for varied movement\n        directionX: Math.random() > 0.5 ? 1 : -1,\n        directionY: Math.random() > 0.5 ? 1 : -1\n      });\n    }\n    \n    // Store new configuration in sessionStorage\n    const newConfig = { starSeeds, timestamp: Date.now() };\n    try {\n      sessionStorage.setItem(CONFIG.sessionKey, JSON.stringify(newConfig));\n    } catch (error) {\n      console.warn('Could not save star configuration to session storage', error);\n    }\n    \n    return newConfig;\n  }, [CONFIG.sessionKey, CONFIG.starCount, CONFIG.parallaxLayerCount, COLORS.stars.length]);\n  \n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) return false;\n    \n    const canvas = canvasRef.current;\n    \n    // Get viewport dimensions\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const pixelRatio = window.devicePixelRatio || 1;\n    \n    // Set canvas size accounting for pixel ratio\n    canvas.width = width * pixelRatio;\n    canvas.height = height * pixelRatio;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n    \n    // Ensure canvas is visible with a background color\n    const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for non-transparent canvas\n    if (ctx) {\n      ctx.fillStyle = 'rgb(15, 15, 20)';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    \n    // Update dimensions ref instead of state\n    dimensionsRef.current = { width, height, pixelRatio };\n    \n    return true;\n  }, []);\n  \n  // Initialize stars with session-persistent configuration\n  const initializeStars = useCallback(() => {\n    const { width, height } = dimensionsRef.current;\n    if (!width || !height) return;\n    \n    // Get or create session-persistent configuration\n    const sessionConfig = getSessionConfiguration();\n    const { starSeeds } = sessionConfig;\n    \n    // Clear existing stars\n    starsRef.current = [];\n    \n    // Create stars using the persistent seeds\n    for (let i = 0; i < starSeeds.length; i++) {\n      const seed = starSeeds[i];\n      const star = {};\n      \n      // Position - use seeds but adapt to current screen dimensions\n      star.baseX = seed.xSeed * width;\n      star.baseY = seed.ySeed * height;\n      star.x = star.baseX;\n      star.y = star.baseY;\n      star.z = seed.zSeed; // Depth (0.1 to 0.9)\n      \n      // Visual properties\n      star.size = (seed.sizeSeed * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n      star.baseOpacity = seed.opacitySeed * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n      star.opacity = star.baseOpacity;\n      \n      // Animation properties\n      star.pulsePhase = seed.phaseSeed;\n      star.pulseSpeed = seed.pulseSpeedSeed;\n      star.movementSpeed = seed.speedSeed * CONFIG.baseMovementSpeed * (1.1 - star.z);\n      \n      // Color variation\n      star.color = COLORS.stars[seed.colorIndex];\n      \n      // New parallax properties\n      star.parallaxLayer = seed.parallaxLayer;\n      star.parallaxFactor = (star.parallaxLayer + 1) / CONFIG.parallaxLayerCount;\n      star.springOffsetX = 0;\n      star.springOffsetY = 0;\n      star.targetOffsetX = 0;\n      star.targetOffsetY = 0;\n      star.directionX = seed.directionX;\n      star.directionY = seed.directionY;\n      \n      // Store in ref\n      starsRef.current.push(star);\n    }\n  }, [CONFIG, COLORS.stars, getSessionConfiguration]);\n  \n  // Optimized star rendering\n  const drawStar = useCallback((ctx, star) => {\n    // Skip rendering almost invisible stars\n    if (star.opacity < 0.05) return;\n    \n    // Get final position with parallax offsets\n    const x = star.x + star.springOffsetX;\n    const y = star.y + star.springOffsetY;\n\n    // Simplified star rendering without creating new gradients every frame\n    ctx.beginPath();\n    ctx.arc(x, y, star.size, 0, Math.PI * 2);\n    ctx.fillStyle = getColor(star.color, star.opacity);\n    ctx.fill();\n    \n    // Simplified glow effect without expensive gradient creation\n    if (star.opacity > 0.3) {\n      ctx.beginPath();\n      ctx.arc(x, y, star.size * 1.8, 0, Math.PI * 2);\n      ctx.fillStyle = getColor(star.color, star.opacity * 0.4);\n      ctx.fill();\n    }\n  }, [getColor]);\n  \n  // Render the scene - optimized for performance\n  const renderScene = useCallback(() => {\n    if (!canvasRef.current) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d', { alpha: false });\n    \n    if (!ctx) return;\n    \n    const { width, height, pixelRatio } = dimensionsRef.current;\n    \n    // Clear canvas\n    ctx.fillStyle = COLORS.background.topColor;\n    ctx.fillRect(0, 0, width * pixelRatio, height * pixelRatio);\n    \n    // Apply device pixel ratio scaling only once\n    ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    \n    // Enable global composition for better glow effect\n    ctx.globalCompositeOperation = 'lighter';\n    \n    // Draw stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      drawStar(ctx, starsRef.current[i]);\n    }\n    \n    // Reset global composition\n    ctx.globalCompositeOperation = 'source-over';\n  }, [COLORS.background.topColor, drawStar]);\n\n  // Apply spring physics to star offsets\n  const applySpringPhysics = useCallback((star, deltaTime) => {\n    // Spring physics constants\n    const stiffness = CONFIG.springStiffness; \n    const damping = CONFIG.springDamping;\n\n    // Calculate spring force for X axis\n    let springForceX = (star.targetOffsetX - star.springOffsetX) * stiffness;\n    let dampingForceX = -star.velocityX * damping;\n    star.accelerationX = springForceX + dampingForceX;\n    star.velocityX += star.accelerationX * deltaTime;\n    star.springOffsetX += star.velocityX * deltaTime;\n\n    // Calculate spring force for Y axis\n    let springForceY = (star.targetOffsetY - star.springOffsetY) * stiffness;\n    let dampingForceY = -star.velocityY * damping;\n    star.accelerationY = springForceY + dampingForceY;\n    star.velocityY += star.accelerationY * deltaTime;\n    star.springOffsetY += star.velocityY * deltaTime;\n  }, [CONFIG.springStiffness, CONFIG.springDamping]);\n  \n  // Update animation state - optimized for performance\n  const updateAnimation = useCallback((deltaTime, timestamp) => {\n    const { width, height } = dimensionsRef.current;\n    \n    // Global time factor for animations\n    const timeFactor = timestamp * 0.001;\n    \n    // Get current scroll position and calculate scroll velocity\n    const currentScrollY = window.scrollY;\n    const scrollDelta = currentScrollY - lastScrollYRef.current;\n    \n    // Update scroll velocity with smoothing\n    scrollVelocityRef.current = scrollVelocityRef.current * 0.8 + scrollDelta * 0.2;\n    \n    // Store current scroll position for next frame\n    lastScrollYRef.current = currentScrollY;\n    scrollYRef.current = currentScrollY;\n    \n    // Maximum displacement based on config\n    const maxDisplacement = CONFIG.parallaxMaxDisplacement;\n\n    // Update stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n      \n      // Initialize velocity and acceleration if not present\n      if (star.velocityX === undefined) {\n        star.velocityX = 0;\n        star.velocityY = 0;\n        star.accelerationX = 0;\n        star.accelerationY = 0;\n      }\n      \n      // Basic movement based on time\n      star.x = star.baseX + Math.sin(timeFactor * 0.2 + star.pulsePhase) * 2 * star.directionX;\n      star.y = star.baseY + Math.cos(timeFactor * 0.3 + star.pulsePhase * 1.3) * 2 * star.directionY;\n      \n      // Parallax effect based on scroll - each star moves differently based on its layer\n      if (CONFIG.parallaxEnabled) {\n        // Calculate target offset based on scroll position\n        // Stars in deeper layers (higher parallaxFactor) move more\n        const scrollInfluence = (scrollYRef.current / height) * maxDisplacement;\n        const layerFactor = star.parallaxFactor;\n        \n        // Add velocity-based effects for a more dynamic feel\n        const velocityInfluence = scrollVelocityRef.current * 0.1 * layerFactor;\n        \n        // Set target offsets - notice how deeper layers move more\n        star.targetOffsetX = Math.sin(timeFactor * 0.1 + star.pulsePhase) * velocityInfluence * star.directionX;\n        star.targetOffsetY = (scrollInfluence * layerFactor) + (Math.cos(timeFactor * 0.15 + star.pulsePhase) * velocityInfluence * star.directionY);\n        \n        // Apply spring physics for smooth transitions\n        applySpringPhysics(star, deltaTime);\n      }\n      \n      // Wrap around screen edges\n      const effectiveX = star.x + star.springOffsetX;\n      const effectiveY = star.y + star.springOffsetY;\n      \n      if (effectiveX < 0) star.baseX = width;\n      if (effectiveX > width) star.baseX = 0;\n      if (effectiveY < 0) star.baseY = height;\n      if (effectiveY > height) star.baseY = 0;\n      \n      // Simplified pulsing effect\n      const pulseFactor = Math.sin(timeFactor * star.pulseSpeed + star.pulsePhase) * 0.15 + 0.85;\n      star.opacity = star.baseOpacity * pulseFactor;\n      \n      // Subtle size variation based on parallax movement\n      const sizeVariation = 1 + (Math.abs(star.springOffsetX) + Math.abs(star.springOffsetY)) / (maxDisplacement * 10);\n      star.currentSize = star.size * sizeVariation;\n    }\n  }, [CONFIG.parallaxEnabled, CONFIG.parallaxMaxDisplacement, applySpringPhysics]);\n  \n  // Define the animation loop function with FPS limiting\n  const animate = useCallback(function animationLoop(timestamp) {\n    if (!isInitializedRef.current) {\n      animationFrameRef.current = requestAnimationFrame(animationLoop);\n      return;\n    }\n    \n    // Limit FPS\n    const minFrameTime = 1000 / CONFIG.maxFPS;\n    const elapsed = timestamp - (lastTimeRef.current || 0);\n    \n    if (elapsed < minFrameTime) {\n      animationFrameRef.current = requestAnimationFrame(animationLoop);\n      return;\n    }\n    \n    // Calculate delta time with cap to prevent large jumps\n    const deltaTime = lastTimeRef.current ? Math.min(elapsed, 50) : 16;\n    lastTimeRef.current = timestamp;\n    \n    // Update animation state\n    updateAnimation(deltaTime, timestamp);\n    \n    // Render scene\n    renderScene();\n    \n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(animationLoop);\n  }, [CONFIG.maxFPS, updateAnimation, renderScene]);\n  \n  // Track scroll position\n  useEffect(() => {\n    const handleScroll = () => {\n      scrollYRef.current = window.scrollY;\n    };\n    \n    window.addEventListener('scroll', handleScroll, { passive: true });\n    \n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, []);\n  \n  // Comprehensive initialization and resize handling\n  useEffect(() => {\n    // One-time initialization function\n    const initialize = () => {\n      if (setupCanvas()) {\n        // Create stars only after canvas is ready\n        initializeStars();\n        // Mark as initialized but don't trigger re-render\n        isInitializedRef.current = true;\n        // Start animation only after everything is ready\n        animationFrameRef.current = requestAnimationFrame(animate);\n      }\n    };\n    \n    // Handle resize events\n    const handleResize = () => {\n      // Only re-initialize if already initialized\n      if (isInitializedRef.current) {\n        setupCanvas();\n        initializeStars();\n        // No need to change initialization state\n      }\n    };\n    \n    // Throttle resize events\n    let resizeTimer;\n    const throttledResize = () => {\n      if (!resizeTimer) {\n        resizeTimer = setTimeout(() => {\n          resizeTimer = null;\n          handleResize();\n        }, 200); // 200ms throttle\n      }\n    };\n    \n    // Add resize listener\n    window.addEventListener('resize', throttledResize);\n    \n    // Run initialization after first render is complete\n    // This prevents the \"double load\" effect\n    requestAnimationFrame(() => {\n      firstRenderCompleteRef.current = true;\n      initialize();\n    });\n    \n    // Cleanup\n    return () => {\n      window.removeEventListener('resize', throttledResize);\n      if (resizeTimer) clearTimeout(resizeTimer);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [setupCanvas, initializeStars, animate]);\n  \n  return (\n    <div\n      ref={containerRef}\n      style={{\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        width: '100vw',\n        height: '100vh',\n        overflow: 'hidden',\n        zIndex: -1,\n        pointerEvents: 'none'\n      }}\n      aria-hidden=\"true\"\n    >\n      <canvas\n        ref={canvasRef}\n        style={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%'\n        }}\n      />\n    </div>\n  );\n};\n\nexport default Background;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}