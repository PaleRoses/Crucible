{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/effects/scrollingeffects/SlidingBackground.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\n\n/**\n * SlidingBackground Component\n * \n * A highly configurable background component with parallax and fade effects\n * that integrates seamlessly into existing page layouts.\n * \n * @param {Object} props - Component props\n * @param {string} props.image - URL of the background image\n * @param {string} [props.position='top'] - Position of the focused area ('top', 'middle', 'bottom')\n * @param {string|number} [props.height='100%'] - Height of the component\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of the parallax effect (0-1)\n * @param {number} [props.parallaxLimitPercent=30] - Maximum percentage of component height the image can move\n * @param {boolean} [props.clampParallax=true] - Whether to clamp parallax movement\n * @param {boolean} [props.enableParallax=true] - Enable/disable parallax effect\n * @param {number} [props.fadeSize=0.4] - Size of the fade effect (0-1, as a fraction of the component)\n * @param {string} [props.backgroundColor='#000'] - Background color for the fade effect\n * @param {number} [props.zIndex=0] - z-index of the component\n * @param {number} [props.blurAmount=0] - Amount of blur for the fade transition (px)\n * @param {number} [props.opacity=1] - Opacity of the background image\n * @param {string} [props.backgroundSize='cover'] - Background size property\n * @param {string} [props.backgroundPosition] - Background position (overrides position setting)\n * @param {string} [props.transitionEffect='gradient'] - Type of transition effect ('gradient', 'dissolve')\n * @param {boolean} [props.fitContainer=true] - Whether the background should fit its container\n * @param {number} [props.heightMultiplier=1.2] - How much larger the background image should be\n * @param {Object} [props.containerStyle={}] - Additional styles for the container\n * @param {boolean} [props.createContainer=true] - Whether to create a container div\n * @param {React.ReactNode} [props.children] - Content to render on top of the background\n * @param {string} [props.className=''] - Additional CSS classes for the container\n */\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst SlidingBackground = ({\n  image,\n  position = 'top',\n  height = '100%',\n  parallaxIntensity = 0.2,\n  parallaxLimitPercent = 30,\n  clampParallax = true,\n  enableParallax = true,\n  fadeSize = 0.4,\n  backgroundColor = '#000',\n  zIndex = 0,\n  blurAmount = 0,\n  opacity = 1,\n  backgroundSize = 'cover',\n  backgroundPosition,\n  transitionEffect = 'gradient',\n  fitContainer = true,\n  heightMultiplier = 1.2,\n  containerStyle = {},\n  createContainer = true,\n  children,\n  className = ''\n}) => {\n  _s();\n  const elementRef = useRef(null);\n  const canvasRef = useRef(null);\n  const [scrollPosition, setScrollPosition] = useState(0);\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0\n  });\n  const [imageLoaded, setImageLoaded] = useState(false);\n  const imageRef = useRef(null);\n  const animationFrameRef = useRef(null);\n\n  /**\n   * Renders the dissolve effect on the canvas\n   * Creates a smooth transition that completely fades into the background color\n   */\n  const renderDissolveEffect = useCallback(() => {\n    if (!canvasRef.current || !imageRef.current || !dimensions.width || !dimensions.height) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const img = imageRef.current;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Calculate parallax offset with clamping if enabled\n    let parallaxOffset = enableParallax ? scrollPosition * parallaxIntensity : 0;\n\n    // Clamp parallax movement if enabled\n    if (clampParallax && enableParallax) {\n      const maxOffset = canvas.height * parallaxLimitPercent / 100;\n      parallaxOffset = Math.max(Math.min(parallaxOffset, maxOffset), -maxOffset);\n    }\n\n    // Calculate image dimensions to maintain aspect ratio while covering the canvas\n    const imgAspect = img.width / img.height;\n    const canvasAspect = canvas.width / canvas.height;\n    let drawWidth, drawHeight, offsetX, offsetY;\n    if (fitContainer) {\n      // Apply heightMultiplier to make image larger than container if needed\n      if (imgAspect > canvasAspect) {\n        // Image is wider than canvas (relative to height)\n        drawHeight = canvas.height * heightMultiplier;\n        drawWidth = drawHeight * imgAspect;\n        offsetX = (canvas.width - drawWidth) / 2;\n        offsetY = (canvas.height - drawHeight) / 2;\n      } else {\n        // Image is taller than canvas (relative to width)\n        drawWidth = canvas.width * heightMultiplier;\n        drawHeight = drawWidth / imgAspect;\n        offsetX = (canvas.width - drawWidth) / 2;\n        offsetY = (canvas.height - drawHeight) / 2;\n      }\n    } else {\n      // Cover the canvas\n      if (imgAspect > canvasAspect) {\n        drawHeight = canvas.height;\n        drawWidth = drawHeight * imgAspect;\n        offsetX = (canvas.width - drawWidth) / 2;\n        offsetY = 0;\n      } else {\n        drawWidth = canvas.width;\n        drawHeight = drawWidth / imgAspect;\n        offsetX = 0;\n        offsetY = (canvas.height - drawHeight) / 2;\n      }\n    }\n\n    // Adjust based on position setting\n    if (position === 'top') {\n      offsetY = 0;\n    } else if (position === 'bottom') {\n      offsetY = canvas.height - drawHeight;\n    } else if (position === 'middle') {\n      offsetY = (canvas.height - drawHeight) / 2;\n    }\n\n    // Apply parallax\n    offsetY += parallaxOffset;\n\n    // Draw the image\n    ctx.globalAlpha = opacity;\n    ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);\n\n    // Apply blur if specified\n    if (blurAmount > 0) {\n      ctx.filter = `blur(${blurAmount}px)`;\n      ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);\n      ctx.filter = 'none';\n    }\n\n    // Extract RGB components from backgroundColor\n    let r = 0,\n      g = 0,\n      b = 0;\n    if (backgroundColor.startsWith('#')) {\n      // Handle hex color\n      const hex = backgroundColor.substring(1);\n      if (hex.length === 3) {\n        r = parseInt(hex[0] + hex[0], 16);\n        g = parseInt(hex[1] + hex[1], 16);\n        b = parseInt(hex[2] + hex[2], 16);\n      } else if (hex.length === 6) {\n        r = parseInt(hex.substring(0, 2), 16);\n        g = parseInt(hex.substring(2, 4), 16);\n        b = parseInt(hex.substring(4, 6), 16);\n      }\n    } else if (backgroundColor.startsWith('rgb')) {\n      // Handle rgb/rgba color\n      const match = backgroundColor.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)/i);\n      if (match) {\n        r = parseInt(match[1]);\n        g = parseInt(match[2]);\n        b = parseInt(match[3]);\n      }\n    }\n\n    // Determine which edges should fade based on position\n    const shouldFadeTop = position === 'bottom' || position === 'middle';\n    const shouldFadeBottom = position === 'top' || position === 'middle';\n\n    // Top fade effect\n    if (shouldFadeTop) {\n      const fadeHeight = Math.floor(canvas.height * fadeSize);\n      const imageData = ctx.getImageData(0, 0, canvas.width, fadeHeight);\n      const pixels = imageData.data;\n      for (let y = 0; y < fadeHeight; y++) {\n        // Calculate how much of the background color to show\n        // At y=0 (top edge), should be 100% background color\n        // At y=fadeHeight (bottom of gradient), should be 0% background color\n        const ratio = 1 - y / fadeHeight;\n        for (let x = 0; x < canvas.width; x++) {\n          const pixelIndex = (y * canvas.width + x) * 4;\n\n          // Progressive smooth fade with noise for more organic appearance\n          const noise = Math.random() * 0.15; // Small amount of noise\n          const fadeAmount = Math.min(1, Math.max(0, ratio + noise * (ratio < 0.2 ? 0 : -1)));\n          if (fadeAmount > 0.98) {\n            // Complete fade to background color at the edge\n            pixels[pixelIndex] = r;\n            pixels[pixelIndex + 1] = g;\n            pixels[pixelIndex + 2] = b;\n            pixels[pixelIndex + 3] = 255; // Fully opaque\n          } else if (fadeAmount > 0) {\n            // Blend between image and background color\n            const imgWeight = 1 - fadeAmount;\n            pixels[pixelIndex] = Math.round(pixels[pixelIndex] * imgWeight + r * fadeAmount);\n            pixels[pixelIndex + 1] = Math.round(pixels[pixelIndex + 1] * imgWeight + g * fadeAmount);\n            pixels[pixelIndex + 2] = Math.round(pixels[pixelIndex + 2] * imgWeight + b * fadeAmount);\n          }\n        }\n      }\n      ctx.putImageData(imageData, 0, 0);\n    }\n\n    // Bottom fade effect\n    if (shouldFadeBottom) {\n      const fadeHeight = Math.floor(canvas.height * fadeSize);\n      const startY = canvas.height - fadeHeight;\n      const imageData = ctx.getImageData(0, startY, canvas.width, fadeHeight);\n      const pixels = imageData.data;\n      for (let y = 0; y < fadeHeight; y++) {\n        // Calculate how much of the background color to show\n        // At y=fadeHeight-1 (bottom edge), should be 100% background color\n        // At y=0 (top of gradient), should be 0% background color\n        const ratio = y / fadeHeight;\n        for (let x = 0; x < canvas.width; x++) {\n          const pixelIndex = (y * canvas.width + x) * 4;\n\n          // Progressive smooth fade with noise for more organic appearance\n          const noise = Math.random() * 0.15; // Small amount of noise\n          const fadeAmount = Math.min(1, Math.max(0, ratio + noise * (ratio < 0.2 ? 0 : -1)));\n          if (fadeAmount > 0.98) {\n            // Complete fade to background color at the edge\n            pixels[pixelIndex] = r;\n            pixels[pixelIndex + 1] = g;\n            pixels[pixelIndex + 2] = b;\n            pixels[pixelIndex + 3] = 255; // Fully opaque\n          } else if (fadeAmount > 0) {\n            // Blend between image and background color\n            const imgWeight = 1 - fadeAmount;\n            pixels[pixelIndex] = Math.round(pixels[pixelIndex] * imgWeight + r * fadeAmount);\n            pixels[pixelIndex + 1] = Math.round(pixels[pixelIndex + 1] * imgWeight + g * fadeAmount);\n            pixels[pixelIndex + 2] = Math.round(pixels[pixelIndex + 2] * imgWeight + b * fadeAmount);\n          }\n        }\n      }\n      ctx.putImageData(imageData, 0, startY);\n    }\n  }, [scrollPosition, parallaxIntensity, parallaxLimitPercent, clampParallax, enableParallax, position, opacity, blurAmount, fadeSize, backgroundColor, dimensions.width, dimensions.height, fitContainer, heightMultiplier]);\n\n  // Set up scroll event listener\n  useEffect(() => {\n    // Only attach scroll listener if parallax is enabled\n    if (!enableParallax) {\n      setScrollPosition(0);\n      return;\n    }\n    const handleScroll = () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      animationFrameRef.current = requestAnimationFrame(() => {\n        setScrollPosition(window.scrollY);\n      });\n    };\n    window.addEventListener('scroll', handleScroll, {\n      passive: true\n    });\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [enableParallax]);\n\n  // Update canvas when scroll position changes (for parallax)\n  useEffect(() => {\n    if (imageLoaded && transitionEffect === 'dissolve') {\n      renderDissolveEffect();\n    }\n  }, [scrollPosition, imageLoaded, transitionEffect, renderDissolveEffect]);\n\n  // Handle image loading and canvas setup\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (elementRef.current) {\n        const rect = elementRef.current.getBoundingClientRect();\n        const newDimensions = {\n          width: rect.width,\n          height: rect.height\n        };\n        setDimensions(newDimensions);\n        if (canvasRef.current && transitionEffect === 'dissolve') {\n          canvasRef.current.width = newDimensions.width;\n          canvasRef.current.height = newDimensions.height;\n          if (imageLoaded) {\n            renderDissolveEffect();\n          }\n        }\n      }\n    };\n\n    // Load image if using canvas-based effects\n    if (transitionEffect === 'dissolve') {\n      const img = new Image();\n      img.crossOrigin = \"Anonymous\";\n      img.src = image;\n      img.onload = () => {\n        imageRef.current = img;\n        setImageLoaded(true);\n        updateDimensions();\n      };\n    }\n    updateDimensions();\n    window.addEventListener('resize', updateDimensions);\n    return () => {\n      window.removeEventListener('resize', updateDimensions);\n    };\n  }, [image, transitionEffect, renderDissolveEffect, imageLoaded]);\n\n  // Calculate parallax transformation\n  let parallaxOffset = enableParallax ? scrollPosition * parallaxIntensity : 0;\n\n  // Clamp parallax movement if enabled\n  if (clampParallax && dimensions.height && enableParallax) {\n    const maxOffset = dimensions.height * parallaxLimitPercent / 100;\n    parallaxOffset = Math.max(Math.min(parallaxOffset, maxOffset), -maxOffset);\n  }\n\n  // Determine background position based on position setting\n  let bgPosition = backgroundPosition;\n  if (!bgPosition) {\n    switch (position) {\n      case 'top':\n        bgPosition = 'center top';\n        break;\n      case 'bottom':\n        bgPosition = 'center bottom';\n        break;\n      case 'middle':\n      default:\n        bgPosition = 'center center';\n    }\n  }\n\n  // Determine which edges should fade based on position setting\n  const shouldFadeTop = position === 'bottom' || position === 'middle';\n  const shouldFadeBottom = position === 'top' || position === 'middle';\n\n  // Default container styles\n  const defaultContainerStyle = {\n    position: 'relative',\n    width: '100%',\n    height,\n    overflow: 'hidden',\n    zIndex\n  };\n\n  // Combine default and custom container styles\n  const mergedContainerStyle = {\n    ...defaultContainerStyle,\n    ...containerStyle\n  };\n\n  // Content for rendering\n  const backgroundContent = /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [transitionEffect === 'gradient' && /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: fitContainer ? `${heightMultiplier * 100}%` : '100%',\n          backgroundImage: `url(${image})`,\n          backgroundSize: fitContainer ? 'contain' : backgroundSize,\n          backgroundRepeat: 'no-repeat',\n          backgroundPosition: bgPosition,\n          transform: `translateY(${parallaxOffset}px)`,\n          transition: 'transform 0.1s ease-out',\n          opacity,\n          filter: blurAmount > 0 ? `blur(${blurAmount}px)` : 'none'\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 393,\n        columnNumber: 11\n      }, this), shouldFadeTop && /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: `${fadeSize * 100}%`,\n          background: `linear-gradient(to bottom, ${backgroundColor} 0%, rgba(0,0,0,0) 100%)`,\n          pointerEvents: 'none'\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 413,\n        columnNumber: 13\n      }, this), shouldFadeBottom && /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: 'absolute',\n          bottom: 0,\n          left: 0,\n          width: '100%',\n          height: `${fadeSize * 100}%`,\n          background: `linear-gradient(to top, ${backgroundColor} 0%, rgba(0,0,0,0) 100%)`,\n          pointerEvents: 'none'\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 428,\n        columnNumber: 13\n      }, this)]\n    }, void 0, true), transitionEffect === 'dissolve' && /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 445,\n      columnNumber: 9\n    }, this), children && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: 'relative',\n        zIndex: 1,\n        width: '100%',\n        height: '100%'\n      },\n      children: children\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 459,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true);\n\n  // Render with or without container based on createContainer prop\n  return createContainer ? /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: elementRef,\n    className: className,\n    style: mergedContainerStyle,\n    children: backgroundContent\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 475,\n    columnNumber: 5\n  }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: elementRef,\n    className: className,\n    style: {\n      position: 'relative'\n    },\n    children: backgroundContent\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 483,\n    columnNumber: 5\n  }, this);\n};\n_s(SlidingBackground, \"r/ydtB7w35TrwUflECmXX4hFUbE=\");\n_c = SlidingBackground;\nexport default SlidingBackground;\nvar _c;\n$RefreshReg$(_c, \"SlidingBackground\");","map":{"version":3,"names":["React","useRef","useEffect","useState","useCallback","jsxDEV","_jsxDEV","Fragment","_Fragment","SlidingBackground","image","position","height","parallaxIntensity","parallaxLimitPercent","clampParallax","enableParallax","fadeSize","backgroundColor","zIndex","blurAmount","opacity","backgroundSize","backgroundPosition","transitionEffect","fitContainer","heightMultiplier","containerStyle","createContainer","children","className","_s","elementRef","canvasRef","scrollPosition","setScrollPosition","dimensions","setDimensions","width","imageLoaded","setImageLoaded","imageRef","animationFrameRef","renderDissolveEffect","current","canvas","ctx","getContext","img","clearRect","parallaxOffset","maxOffset","Math","max","min","imgAspect","canvasAspect","drawWidth","drawHeight","offsetX","offsetY","globalAlpha","drawImage","filter","r","g","b","startsWith","hex","substring","length","parseInt","match","shouldFadeTop","shouldFadeBottom","fadeHeight","floor","imageData","getImageData","pixels","data","y","ratio","x","pixelIndex","noise","random","fadeAmount","imgWeight","round","putImageData","startY","handleScroll","cancelAnimationFrame","requestAnimationFrame","window","scrollY","addEventListener","passive","removeEventListener","updateDimensions","rect","getBoundingClientRect","newDimensions","Image","crossOrigin","src","onload","bgPosition","defaultContainerStyle","overflow","mergedContainerStyle","backgroundContent","style","top","left","backgroundImage","backgroundRepeat","transform","transition","fileName","_jsxFileName","lineNumber","columnNumber","background","pointerEvents","bottom","ref","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/effects/scrollingeffects/SlidingBackground.jsx"],"sourcesContent":["import React, { useRef, useEffect, useState, useCallback } from 'react';\n\n/**\n * SlidingBackground Component\n * \n * A highly configurable background component with parallax and fade effects\n * that integrates seamlessly into existing page layouts.\n * \n * @param {Object} props - Component props\n * @param {string} props.image - URL of the background image\n * @param {string} [props.position='top'] - Position of the focused area ('top', 'middle', 'bottom')\n * @param {string|number} [props.height='100%'] - Height of the component\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of the parallax effect (0-1)\n * @param {number} [props.parallaxLimitPercent=30] - Maximum percentage of component height the image can move\n * @param {boolean} [props.clampParallax=true] - Whether to clamp parallax movement\n * @param {boolean} [props.enableParallax=true] - Enable/disable parallax effect\n * @param {number} [props.fadeSize=0.4] - Size of the fade effect (0-1, as a fraction of the component)\n * @param {string} [props.backgroundColor='#000'] - Background color for the fade effect\n * @param {number} [props.zIndex=0] - z-index of the component\n * @param {number} [props.blurAmount=0] - Amount of blur for the fade transition (px)\n * @param {number} [props.opacity=1] - Opacity of the background image\n * @param {string} [props.backgroundSize='cover'] - Background size property\n * @param {string} [props.backgroundPosition] - Background position (overrides position setting)\n * @param {string} [props.transitionEffect='gradient'] - Type of transition effect ('gradient', 'dissolve')\n * @param {boolean} [props.fitContainer=true] - Whether the background should fit its container\n * @param {number} [props.heightMultiplier=1.2] - How much larger the background image should be\n * @param {Object} [props.containerStyle={}] - Additional styles for the container\n * @param {boolean} [props.createContainer=true] - Whether to create a container div\n * @param {React.ReactNode} [props.children] - Content to render on top of the background\n * @param {string} [props.className=''] - Additional CSS classes for the container\n */\nconst SlidingBackground = ({\n  image,\n  position = 'top',\n  height = '100%',\n  parallaxIntensity = 0.2,\n  parallaxLimitPercent = 30,\n  clampParallax = true,\n  enableParallax = true,\n  fadeSize = 0.4,\n  backgroundColor = '#000',\n  zIndex = 0,\n  blurAmount = 0,\n  opacity = 1,\n  backgroundSize = 'cover',\n  backgroundPosition,\n  transitionEffect = 'gradient',\n  fitContainer = true,\n  heightMultiplier = 1.2,\n  containerStyle = {},\n  createContainer = true,\n  children,\n  className = '',\n}) => {\n  const elementRef = useRef(null);\n  const canvasRef = useRef(null);\n  const [scrollPosition, setScrollPosition] = useState(0);\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n  const [imageLoaded, setImageLoaded] = useState(false);\n  const imageRef = useRef(null);\n  const animationFrameRef = useRef(null);\n  \n  /**\n   * Renders the dissolve effect on the canvas\n   * Creates a smooth transition that completely fades into the background color\n   */\n  const renderDissolveEffect = useCallback(() => {\n    if (!canvasRef.current || !imageRef.current || !dimensions.width || !dimensions.height) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const img = imageRef.current;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // Calculate parallax offset with clamping if enabled\n    let parallaxOffset = enableParallax ? scrollPosition * parallaxIntensity : 0;\n    \n    // Clamp parallax movement if enabled\n    if (clampParallax && enableParallax) {\n      const maxOffset = (canvas.height * parallaxLimitPercent) / 100;\n      parallaxOffset = Math.max(Math.min(parallaxOffset, maxOffset), -maxOffset);\n    }\n    \n    // Calculate image dimensions to maintain aspect ratio while covering the canvas\n    const imgAspect = img.width / img.height;\n    const canvasAspect = canvas.width / canvas.height;\n    \n    let drawWidth, drawHeight, offsetX, offsetY;\n    \n    if (fitContainer) {\n      // Apply heightMultiplier to make image larger than container if needed\n      if (imgAspect > canvasAspect) {\n        // Image is wider than canvas (relative to height)\n        drawHeight = canvas.height * heightMultiplier;\n        drawWidth = drawHeight * imgAspect;\n        offsetX = (canvas.width - drawWidth) / 2;\n        offsetY = (canvas.height - drawHeight) / 2;\n      } else {\n        // Image is taller than canvas (relative to width)\n        drawWidth = canvas.width * heightMultiplier;\n        drawHeight = drawWidth / imgAspect;\n        offsetX = (canvas.width - drawWidth) / 2;\n        offsetY = (canvas.height - drawHeight) / 2;\n      }\n    } else {\n      // Cover the canvas\n      if (imgAspect > canvasAspect) {\n        drawHeight = canvas.height;\n        drawWidth = drawHeight * imgAspect;\n        offsetX = (canvas.width - drawWidth) / 2;\n        offsetY = 0;\n      } else {\n        drawWidth = canvas.width;\n        drawHeight = drawWidth / imgAspect;\n        offsetX = 0;\n        offsetY = (canvas.height - drawHeight) / 2;\n      }\n    }\n    \n    // Adjust based on position setting\n    if (position === 'top') {\n      offsetY = 0;\n    } else if (position === 'bottom') {\n      offsetY = canvas.height - drawHeight;\n    } else if (position === 'middle') {\n      offsetY = (canvas.height - drawHeight) / 2;\n    }\n    \n    // Apply parallax\n    offsetY += parallaxOffset;\n    \n    // Draw the image\n    ctx.globalAlpha = opacity;\n    ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);\n    \n    // Apply blur if specified\n    if (blurAmount > 0) {\n      ctx.filter = `blur(${blurAmount}px)`;\n      ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);\n      ctx.filter = 'none';\n    }\n    \n    // Extract RGB components from backgroundColor\n    let r = 0, g = 0, b = 0;\n    if (backgroundColor.startsWith('#')) {\n      // Handle hex color\n      const hex = backgroundColor.substring(1);\n      if (hex.length === 3) {\n        r = parseInt(hex[0] + hex[0], 16);\n        g = parseInt(hex[1] + hex[1], 16);\n        b = parseInt(hex[2] + hex[2], 16);\n      } else if (hex.length === 6) {\n        r = parseInt(hex.substring(0, 2), 16);\n        g = parseInt(hex.substring(2, 4), 16);\n        b = parseInt(hex.substring(4, 6), 16);\n      }\n    } else if (backgroundColor.startsWith('rgb')) {\n      // Handle rgb/rgba color\n      const match = backgroundColor.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)/i);\n      if (match) {\n        r = parseInt(match[1]);\n        g = parseInt(match[2]);\n        b = parseInt(match[3]);\n      }\n    }\n    \n    // Determine which edges should fade based on position\n    const shouldFadeTop = position === 'bottom' || position === 'middle';\n    const shouldFadeBottom = position === 'top' || position === 'middle';\n    \n    // Top fade effect\n    if (shouldFadeTop) {\n      const fadeHeight = Math.floor(canvas.height * fadeSize);\n      const imageData = ctx.getImageData(0, 0, canvas.width, fadeHeight);\n      const pixels = imageData.data;\n      \n      for (let y = 0; y < fadeHeight; y++) {\n        // Calculate how much of the background color to show\n        // At y=0 (top edge), should be 100% background color\n        // At y=fadeHeight (bottom of gradient), should be 0% background color\n        const ratio = 1 - (y / fadeHeight);\n        \n        for (let x = 0; x < canvas.width; x++) {\n          const pixelIndex = (y * canvas.width + x) * 4;\n          \n          // Progressive smooth fade with noise for more organic appearance\n          const noise = Math.random() * 0.15; // Small amount of noise\n          const fadeAmount = Math.min(1, Math.max(0, ratio + noise * (ratio < 0.2 ? 0 : -1)));\n          \n          if (fadeAmount > 0.98) {\n            // Complete fade to background color at the edge\n            pixels[pixelIndex] = r;\n            pixels[pixelIndex + 1] = g;\n            pixels[pixelIndex + 2] = b;\n            pixels[pixelIndex + 3] = 255; // Fully opaque\n          } else if (fadeAmount > 0) {\n            // Blend between image and background color\n            const imgWeight = 1 - fadeAmount;\n            pixels[pixelIndex] = Math.round(pixels[pixelIndex] * imgWeight + r * fadeAmount);\n            pixels[pixelIndex + 1] = Math.round(pixels[pixelIndex + 1] * imgWeight + g * fadeAmount);\n            pixels[pixelIndex + 2] = Math.round(pixels[pixelIndex + 2] * imgWeight + b * fadeAmount);\n          }\n        }\n      }\n      \n      ctx.putImageData(imageData, 0, 0);\n    }\n    \n    // Bottom fade effect\n    if (shouldFadeBottom) {\n      const fadeHeight = Math.floor(canvas.height * fadeSize);\n      const startY = canvas.height - fadeHeight;\n      const imageData = ctx.getImageData(0, startY, canvas.width, fadeHeight);\n      const pixels = imageData.data;\n      \n      for (let y = 0; y < fadeHeight; y++) {\n        // Calculate how much of the background color to show\n        // At y=fadeHeight-1 (bottom edge), should be 100% background color\n        // At y=0 (top of gradient), should be 0% background color\n        const ratio = y / fadeHeight;\n        \n        for (let x = 0; x < canvas.width; x++) {\n          const pixelIndex = (y * canvas.width + x) * 4;\n          \n          // Progressive smooth fade with noise for more organic appearance\n          const noise = Math.random() * 0.15; // Small amount of noise\n          const fadeAmount = Math.min(1, Math.max(0, ratio + noise * (ratio < 0.2 ? 0 : -1)));\n          \n          if (fadeAmount > 0.98) {\n            // Complete fade to background color at the edge\n            pixels[pixelIndex] = r;\n            pixels[pixelIndex + 1] = g;\n            pixels[pixelIndex + 2] = b;\n            pixels[pixelIndex + 3] = 255; // Fully opaque\n          } else if (fadeAmount > 0) {\n            // Blend between image and background color\n            const imgWeight = 1 - fadeAmount;\n            pixels[pixelIndex] = Math.round(pixels[pixelIndex] * imgWeight + r * fadeAmount);\n            pixels[pixelIndex + 1] = Math.round(pixels[pixelIndex + 1] * imgWeight + g * fadeAmount);\n            pixels[pixelIndex + 2] = Math.round(pixels[pixelIndex + 2] * imgWeight + b * fadeAmount);\n          }\n        }\n      }\n      \n      ctx.putImageData(imageData, 0, startY);\n    }\n  }, [\n    scrollPosition,\n    parallaxIntensity,\n    parallaxLimitPercent,\n    clampParallax,\n    enableParallax,\n    position,\n    opacity,\n    blurAmount,\n    fadeSize,\n    backgroundColor,\n    dimensions.width,\n    dimensions.height,\n    fitContainer,\n    heightMultiplier\n  ]);\n  \n  // Set up scroll event listener\n  useEffect(() => {\n    // Only attach scroll listener if parallax is enabled\n    if (!enableParallax) {\n      setScrollPosition(0);\n      return;\n    }\n    \n    const handleScroll = () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      \n      animationFrameRef.current = requestAnimationFrame(() => {\n        setScrollPosition(window.scrollY);\n      });\n    };\n    \n    window.addEventListener('scroll', handleScroll, { passive: true });\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [enableParallax]);\n  \n  // Update canvas when scroll position changes (for parallax)\n  useEffect(() => {\n    if (imageLoaded && transitionEffect === 'dissolve') {\n      renderDissolveEffect();\n    }\n  }, [scrollPosition, imageLoaded, transitionEffect, renderDissolveEffect]);\n  \n  // Handle image loading and canvas setup\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (elementRef.current) {\n        const rect = elementRef.current.getBoundingClientRect();\n        const newDimensions = { \n          width: rect.width, \n          height: rect.height \n        };\n        \n        setDimensions(newDimensions);\n        \n        if (canvasRef.current && transitionEffect === 'dissolve') {\n          canvasRef.current.width = newDimensions.width;\n          canvasRef.current.height = newDimensions.height;\n          \n          if (imageLoaded) {\n            renderDissolveEffect();\n          }\n        }\n      }\n    };\n    \n    // Load image if using canvas-based effects\n    if (transitionEffect === 'dissolve') {\n      const img = new Image();\n      img.crossOrigin = \"Anonymous\";\n      img.src = image;\n      img.onload = () => {\n        imageRef.current = img;\n        setImageLoaded(true);\n        updateDimensions();\n      };\n    }\n    \n    updateDimensions();\n    window.addEventListener('resize', updateDimensions);\n    \n    return () => {\n      window.removeEventListener('resize', updateDimensions);\n    };\n  }, [image, transitionEffect, renderDissolveEffect, imageLoaded]);\n  \n  // Calculate parallax transformation\n  let parallaxOffset = enableParallax ? scrollPosition * parallaxIntensity : 0;\n  \n  // Clamp parallax movement if enabled\n  if (clampParallax && dimensions.height && enableParallax) {\n    const maxOffset = (dimensions.height * parallaxLimitPercent) / 100;\n    parallaxOffset = Math.max(Math.min(parallaxOffset, maxOffset), -maxOffset);\n  }\n  \n  // Determine background position based on position setting\n  let bgPosition = backgroundPosition;\n  if (!bgPosition) {\n    switch (position) {\n      case 'top':\n        bgPosition = 'center top';\n        break;\n      case 'bottom':\n        bgPosition = 'center bottom';\n        break;\n      case 'middle':\n      default:\n        bgPosition = 'center center';\n    }\n  }\n  \n  // Determine which edges should fade based on position setting\n  const shouldFadeTop = position === 'bottom' || position === 'middle';\n  const shouldFadeBottom = position === 'top' || position === 'middle';\n  \n  // Default container styles\n  const defaultContainerStyle = {\n    position: 'relative',\n    width: '100%',\n    height,\n    overflow: 'hidden',\n    zIndex,\n  };\n  \n  // Combine default and custom container styles\n  const mergedContainerStyle = {\n    ...defaultContainerStyle,\n    ...containerStyle\n  };\n  \n  // Content for rendering\n  const backgroundContent = (\n    <>\n      {/* CSS-based gradient transition */}\n      {transitionEffect === 'gradient' && (\n        <>\n          <div\n            style={{\n              position: 'absolute',\n              top: 0,\n              left: 0,\n              width: '100%',\n              height: fitContainer ? `${heightMultiplier * 100}%` : '100%',\n              backgroundImage: `url(${image})`,\n              backgroundSize: fitContainer ? 'contain' : backgroundSize,\n              backgroundRepeat: 'no-repeat',\n              backgroundPosition: bgPosition,\n              transform: `translateY(${parallaxOffset}px)`,\n              transition: 'transform 0.1s ease-out',\n              opacity,\n              filter: blurAmount > 0 ? `blur(${blurAmount}px)` : 'none'\n            }}\n          />\n          \n          {/* Top fade gradient */}\n          {shouldFadeTop && (\n            <div\n              style={{\n                position: 'absolute',\n                top: 0,\n                left: 0,\n                width: '100%',\n                height: `${fadeSize * 100}%`,\n                background: `linear-gradient(to bottom, ${backgroundColor} 0%, rgba(0,0,0,0) 100%)`,\n                pointerEvents: 'none'\n              }}\n            />\n          )}\n          \n          {/* Bottom fade gradient */}\n          {shouldFadeBottom && (\n            <div\n              style={{\n                position: 'absolute',\n                bottom: 0,\n                left: 0,\n                width: '100%',\n                height: `${fadeSize * 100}%`,\n                background: `linear-gradient(to top, ${backgroundColor} 0%, rgba(0,0,0,0) 100%)`,\n                pointerEvents: 'none'\n              }}\n            />\n          )}\n        </>\n      )}\n      \n      {/* Canvas-based dissolve transition */}\n      {transitionEffect === 'dissolve' && (\n        <canvas\n          ref={canvasRef}\n          style={{\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            width: '100%',\n            height: '100%'\n          }}\n        />\n      )}\n      \n      {/* Content container */}\n      {children && (\n        <div\n          style={{\n            position: 'relative',\n            zIndex: 1,\n            width: '100%',\n            height: '100%'\n          }}\n        >\n          {children}\n        </div>\n      )}\n    </>\n  );\n  \n  // Render with or without container based on createContainer prop\n  return createContainer ? (\n    <div\n      ref={elementRef}\n      className={className}\n      style={mergedContainerStyle}\n    >\n      {backgroundContent}\n    </div>\n  ) : (\n    <div ref={elementRef} className={className} style={{ position: 'relative' }}>\n      {backgroundContent}\n    </div>\n  );\n};\n\nexport default SlidingBackground;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}