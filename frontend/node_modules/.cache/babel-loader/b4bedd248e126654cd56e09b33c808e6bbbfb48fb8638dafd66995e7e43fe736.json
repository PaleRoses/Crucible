{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/CosmicNebula.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useCallback, useState, useMemo } from 'react';\n\n/**\n * CosmicNebula Component\n * \n * Creates slowly rotating colorful gas clouds with depth and particle effects\n * that create an otherworldly backdrop for your cosmic background.\n * \n * Features:\n * - Canvas-based gradient rendering for gas cloud effects\n * - Slow rotation with customizable speed and direction\n * - Multi-layered depth with parallax effects\n * - Optimized for performance with adaptive quality settings\n * - Smooth motion with spring-based transitions\n * \n * @param {Object} props - Component props\n * @param {string|number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=2] - Z-index for the container (lower than MeteorShower but higher than Background)\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.cloudCount=5] - Number of nebula clouds to render\n * @param {number} [props.rotationSpeed=0.02] - Base rotation speed of clouds\n * @param {number} [props.expansionFactor=1.5] - How much the clouds expand beyond screen size\n * @param {number} [props.blurFactor=20] - Amount of blur applied to clouds (px)\n * @param {boolean} [props.enableParallax=true] - Enable parallax effect on scroll\n * @param {number} [props.parallaxIntensity=0.07] - Intensity of parallax effect\n * @param {string[][]} [props.colorSchemes] - Color schemes for the nebula clouds\n * @param {boolean} [props.adaptiveQuality=true] - Enable adaptive quality based on device\n * @param {boolean} [props.respectReducedMotion=true] - Respect reduced motion preferences\n * @param {number} [props.maxFPS=30] - Target maximum frames per second (lower than other components)\n * @param {boolean} [props.enableOffscreenRendering=true] - Enable offscreen canvas when available\n * @param {number} [props.cloudOpacity=0.15] - Base opacity of nebula clouds\n * @param {boolean} [props.debug=false] - Enable debug visualization\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CosmicNebula = ({\n  height = '100vh',\n  zIndex = 2,\n  active = true,\n  cloudCount = 5,\n  rotationSpeed = 0.02,\n  expansionFactor = 1.5,\n  blurFactor = 20,\n  enableParallax = true,\n  parallaxIntensity = 0.07,\n  colorSchemes = [['rgba(63, 12, 77, alpha)', 'rgba(107, 23, 129, alpha)', 'rgba(240, 107, 207, alpha)'],\n  // Purple-pink\n  ['rgba(11, 35, 65, alpha)', 'rgba(35, 91, 170, alpha)', 'rgba(79, 142, 230, alpha)'],\n  // Deep blue\n  ['rgba(55, 15, 15, alpha)', 'rgba(116, 38, 38, alpha)', 'rgba(206, 66, 66, alpha)'],\n  // Dark red\n  ['rgba(11, 45, 39, alpha)', 'rgba(30, 96, 82, alpha)', 'rgba(59, 160, 137, alpha)'] // Teal\n  ],\n  adaptiveQuality = true,\n  respectReducedMotion = true,\n  maxFPS = 30,\n  enableOffscreenRendering = true,\n  cloudOpacity = 0.15,\n  debug = false\n}) => {\n  _s();\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const ctxRef = useRef(null);\n  const offscreenCanvasRef = useRef(null);\n  const cloudsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const fpsTimestampRef = useRef(0);\n  const frameCountRef = useRef(0);\n  const currentFpsRef = useRef(30);\n  const scrollPositionRef = useRef(0);\n  const resizeObserverRef = useRef(null);\n  const visibilityObserverRef = useRef(null);\n  const visibilityChangeTimeRef = useRef(0);\n  const qualityChangeTimerRef = useRef(null);\n  const lastQualityFactorRef = useRef(1);\n  const stableFrameCountRef = useRef(0);\n  const seedsRef = useRef({\n    baseRotation: Math.random() * Math.PI * 2,\n    noise: Math.random() * 1000\n  });\n\n  // Component state\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0,\n    pixelRatio: 1\n  });\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [isVisible, setIsVisible] = useState(false);\n  const [qualityFactor, setQualityFactor] = useState(1);\n  const [deviceCapabilities, setDeviceCapabilities] = useState({\n    memory: 4,\n    cores: 4,\n    batteryLevel: 1,\n    isMobile: false,\n    supportsOffscreenCanvas: false\n  });\n\n  // Precompute color variants to avoid string operations during animation\n  const colorCacheRef = useRef(new Map());\n\n  // Adaptive settings based on quality factor\n  const adaptedSettings = useMemo(() => {\n    if (!adaptiveQuality || qualityFactor === 1) {\n      return {\n        cloudCount,\n        blurFactor,\n        useHighQualityRendering: true,\n        expansionFactor\n      };\n    }\n\n    // Adjust quality-dependent parameters\n    return {\n      cloudCount: Math.max(3, Math.floor(cloudCount * qualityFactor)),\n      blurFactor: Math.max(5, Math.floor(blurFactor * qualityFactor)),\n      useHighQualityRendering: qualityFactor > 0.6,\n      expansionFactor: Math.max(1.2, expansionFactor * qualityFactor)\n    };\n  }, [adaptiveQuality, qualityFactor, cloudCount, blurFactor, expansionFactor]);\n\n  // Get cached color with opacity\n  const getCachedColor = useCallback((baseColor, opacity) => {\n    // Ensure opacity is always valid\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n\n    // Round opacity to reduce cache size while maintaining visual quality\n    const roundedOpacity = Math.round(safeOpacity * 100) / 100;\n    const key = `${baseColor}-${roundedOpacity}`;\n    if (!colorCacheRef.current.has(key)) {\n      const newColor = baseColor.replace(/alpha\\)$/, roundedOpacity + ')');\n      colorCacheRef.current.set(key, newColor);\n    }\n    return colorCacheRef.current.get(key);\n  }, []);\n\n  // Detect device capabilities and set up optimization strategies\n  const detectCapabilities = useCallback(() => {\n    // Device memory, hardware concurrency\n    const memory = navigator.deviceMemory || 4;\n    const cores = navigator.hardwareConcurrency || 4;\n    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n\n    // Check offscreen canvas support\n    const supportsOffscreenCanvas = typeof OffscreenCanvas !== 'undefined';\n\n    // Set device capabilities state\n    setDeviceCapabilities({\n      memory,\n      cores,\n      batteryLevel: 1,\n      isCharging: true,\n      isMobile,\n      supportsOffscreenCanvas\n    });\n\n    // Calculate quality factor based on capabilities\n    if (adaptiveQuality) {\n      // Base score from hardware\n      const performanceScore = memory * cores / (isMobile ? 2 : 1);\n\n      // Scale quality based on performance score\n      let quality = 1;\n      if (performanceScore > 16) {\n        quality = 1; // High-end devices\n      } else if (performanceScore > 8) {\n        quality = 0.8; // Mid-range devices\n      } else if (performanceScore > 4) {\n        quality = 0.6; // Low-end devices\n      } else {\n        quality = 0.4; // Very low-end devices\n      }\n      setQualityFactor(quality);\n      lastQualityFactorRef.current = quality;\n    }\n  }, [adaptiveQuality]);\n\n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current || !containerRef.current) return false;\n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    const rect = container.getBoundingClientRect();\n    const pixelRatio = window.devicePixelRatio || 1;\n\n    // Calculate dimensions\n    const displayWidth = Math.floor(rect.width);\n    const displayHeight = typeof height === 'string' && height.endsWith('vh') ? Math.floor(parseInt(height, 10) / 100 * window.innerHeight) : Math.floor(parseInt(height, 10) || window.innerHeight);\n\n    // Set canvas size accounting for pixel ratio\n    canvas.width = displayWidth * pixelRatio;\n    canvas.height = displayHeight * pixelRatio;\n    canvas.style.width = `${displayWidth}px`;\n    canvas.style.height = `${displayHeight}px`;\n\n    // 2D Canvas context\n    const ctx = canvas.getContext('2d', {\n      alpha: true,\n      desynchronized: true,\n      willReadFrequently: false\n    });\n    if (!ctx) return false;\n\n    // Scale context for high-DPI displays\n    ctx.scale(pixelRatio, pixelRatio);\n\n    // Configure context for high-quality rendering\n    if (adaptedSettings.useHighQualityRendering) {\n      ctx.imageSmoothingEnabled = true;\n      ctx.imageSmoothingQuality = 'high';\n    }\n    ctxRef.current = ctx;\n\n    // Initialize offscreen canvas if supported and enabled\n    if (enableOffscreenRendering && typeof OffscreenCanvas !== 'undefined' && deviceCapabilities.supportsOffscreenCanvas) {\n      try {\n        // Create offscreen canvas\n        const offscreen = new OffscreenCanvas(displayWidth * pixelRatio, displayHeight * pixelRatio);\n\n        // Get 2D context for offscreen canvas\n        const offscreenCtx = offscreen.getContext('2d');\n        if (offscreenCtx) {\n          offscreenCtx.scale(pixelRatio, pixelRatio);\n          offscreenCanvasRef.current = {\n            canvas: offscreen,\n            ctx: offscreenCtx\n          };\n        }\n      } catch (error) {\n        console.warn('Offscreen canvas initialization error:', error);\n      }\n    }\n    setDimensions({\n      width: displayWidth,\n      height: displayHeight,\n      pixelRatio\n    });\n    return true;\n  }, [height, enableOffscreenRendering, deviceCapabilities.supportsOffscreenCanvas, adaptedSettings.useHighQualityRendering]);\n\n  // Perlin noise function for organic cloud shapes\n  const noise = useCallback((x, y) => {\n    const seed = seedsRef.current.noise;\n\n    // Simple noise function with multiple octaves for organic shapes\n    const X = Math.floor(x) & 255;\n    const Y = Math.floor(y) & 255;\n    const xf = x - Math.floor(x);\n    const yf = y - Math.floor(y);\n    const topRight = (X + 1 + seed + (Y + 1) * 379) % 977 / 977;\n    const topLeft = (X + seed + (Y + 1) * 379) % 977 / 977;\n    const bottomRight = (X + 1 + seed + Y * 379) % 977 / 977;\n    const bottomLeft = (X + seed + Y * 379) % 977 / 977;\n\n    // Smoothing function\n    const sx = smoothStep(xf);\n    const sy = smoothStep(yf);\n\n    // Interpolate values to get final noise value\n    const nx0 = lerp(bottomLeft, bottomRight, sx);\n    const nx1 = lerp(topLeft, topRight, sx);\n    const n = lerp(nx0, nx1, sy);\n    return n;\n\n    // Helper functions\n    function smoothStep(t) {\n      return t * t * (3 - 2 * t);\n    }\n    function lerp(a, b, t) {\n      return a + t * (b - a);\n    }\n  }, []);\n\n  // Create fractal noise for more complex patterns\n  const fractalNoise = useCallback((x, y, octaves = 6, persistence = 0.5) => {\n    let total = 0;\n    let frequency = 1;\n    let amplitude = 1;\n    let maxValue = 0;\n    for (let i = 0; i < octaves; i++) {\n      total += noise(x * frequency, y * frequency) * amplitude;\n      maxValue += amplitude;\n      amplitude *= persistence;\n      frequency *= 2;\n    }\n    return total / maxValue;\n  }, [noise]);\n\n  // Create a new nebula cloud\n  const createCloud = useCallback(index => {\n    const {\n      width,\n      height\n    } = dimensions;\n    if (!width || !height) return null;\n\n    // Larger dimension for proper sizing\n    const maxDimension = Math.max(width, height);\n\n    // Select a color scheme\n    const colorScheme = colorSchemes[index % colorSchemes.length];\n\n    // Create cloud with random properties\n    const cloud = {\n      // Position relative to center of screen\n      x: (Math.random() * 0.8 - 0.4) * width,\n      y: (Math.random() * 0.8 - 0.4) * height,\n      // Size - vary based on quality settings\n      size: (0.5 + Math.random() * 0.8) * maxDimension * adaptedSettings.expansionFactor,\n      // Visual properties\n      opacity: (Math.random() * 0.3 + 0.7) * cloudOpacity,\n      // 70-100% of base opacity\n      colorScheme,\n      // Rotation properties\n      rotation: Math.random() * Math.PI * 2,\n      rotationSpeed: (Math.random() * 0.5 + 0.75) * rotationSpeed * (Math.random() > 0.5 ? 1 : -1),\n      // Parallax factor\n      parallaxFactor: 0.1 + Math.random() * 0.3 * parallaxIntensity,\n      // Layer for depth effect (0=furthest, 1=closest)\n      layer: Math.random(),\n      // Cloud shape properties\n      complexity: 1 + Math.random() * 4,\n      // Controls noise scale\n      turbulence: 0.8 + Math.random() * 1.2,\n      // Controls noise distortion\n\n      // Animation properties\n      pulsePhase: Math.random() * Math.PI * 2,\n      pulseSpeed: 0.0001 + Math.random() * 0.0002,\n      pulseAmount: 0.02 + Math.random() * 0.04\n    };\n    return cloud;\n  }, [dimensions, colorSchemes, adaptedSettings.expansionFactor, cloudOpacity, rotationSpeed, parallaxIntensity]);\n\n  // Initialize nebula clouds\n  const initializeClouds = useCallback(() => {\n    // Clear existing clouds\n    cloudsRef.current = [];\n\n    // Generate clouds based on density and sort by layer for proper depth rendering\n    for (let i = 0; i < adaptedSettings.cloudCount; i++) {\n      const cloud = createCloud(i);\n      if (cloud) {\n        cloudsRef.current.push(cloud);\n      }\n    }\n\n    // Sort clouds by layer (furthest to closest)\n    cloudsRef.current.sort((a, b) => a.layer - b.layer);\n  }, [adaptedSettings.cloudCount, createCloud]);\n\n  // Detect device capabilities and preferences on mount\n  useEffect(() => {\n    // Check for reduced motion preference\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    const handleReducedMotionChange = e => {\n      setPrefersReducedMotion(e.matches);\n    };\n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n\n    // Detect device capabilities\n    detectCapabilities();\n\n    // Setup visibility change detection to pause when tab is inactive\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        visibilityChangeTimeRef.current = performance.now();\n      } else {\n        // Adjust timing references after visibility changes\n        const timeDelta = performance.now() - visibilityChangeTimeRef.current;\n        lastTimestampRef.current += timeDelta;\n      }\n    };\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n\n    // Cleanup\n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  }, [detectCapabilities]);\n\n  // Setup canvas resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Create a ResizeObserver to detect container size changes\n    const resizeObserver = new ResizeObserver(entries => {\n      // Debounce resize operations\n      if (resizeObserverRef.current.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n      resizeObserverRef.current.timeout = setTimeout(() => {\n        requestAnimationFrame(() => {\n          if (setupCanvas()) {\n            setIsInitialized(true);\n          }\n        });\n      }, 100); // 100ms debounce\n    });\n\n    // Capture current reference to avoid closure issues in cleanup\n    const currentContainer = containerRef.current;\n\n    // Start observing the container\n    resizeObserver.observe(currentContainer);\n    resizeObserverRef.current = {\n      observer: resizeObserver\n    };\n\n    // Initial setup\n    setupCanvas();\n    setIsInitialized(true);\n    return () => {\n      if (resizeObserverRef.current.observer) {\n        resizeObserverRef.current.observer.disconnect();\n      }\n      if (resizeObserverRef.current.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n    };\n  }, [setupCanvas]);\n\n  // Setup intersection observer to only animate when visible\n  useEffect(() => {\n    if (!containerRef.current) return;\n    const observer = new IntersectionObserver(entries => {\n      const isIntersecting = entries[0].isIntersecting;\n\n      // Only change state if visibility actually changed\n      if (isIntersecting !== isVisible) {\n        setIsVisible(isIntersecting);\n        if (isIntersecting) {\n          // Reset timing references when becoming visible again\n          lastTimestampRef.current = 0;\n        }\n      }\n    }, {\n      threshold: 0.01,\n      rootMargin: '100px'\n    });\n\n    // Store current reference to avoid closure issues\n    const currentContainerRef = containerRef.current;\n    observer.observe(currentContainerRef);\n    visibilityObserverRef.current = observer;\n    return () => {\n      if (visibilityObserverRef.current) {\n        visibilityObserverRef.current.disconnect();\n      }\n    };\n  }, [isVisible]);\n\n  // Handle parallax effect on scroll if enabled\n  useEffect(() => {\n    if (!enableParallax) return;\n\n    // Use passive event listener for better performance\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    window.addEventListener('scroll', handleScroll, {\n      passive: true\n    });\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [enableParallax]);\n\n  // Initialize clouds once canvas is ready\n  useEffect(() => {\n    if (isInitialized && dimensions.width && dimensions.height) {\n      initializeClouds();\n    }\n  }, [isInitialized, dimensions, initializeClouds]);\n\n  // Render a single nebula cloud with gradients and noise\n  const renderCloud = useCallback((ctx, cloud, timestamp) => {\n    const {\n      width,\n      height\n    } = dimensions;\n    const scrollY = scrollPositionRef.current;\n\n    // Apply time-based animations\n    const timeFactor = timestamp * 0.001;\n\n    // Update rotation\n    cloud.rotation += cloud.rotationSpeed * 0.01;\n\n    // Apply parallax effect if enabled\n    let parallaxOffsetY = 0;\n    if (enableParallax) {\n      parallaxOffsetY = scrollY * cloud.parallaxFactor;\n    }\n\n    // Apply pulsing effect\n    const pulseFactor = 1 + Math.sin(timeFactor * cloud.pulseSpeed + cloud.pulsePhase) * cloud.pulseAmount;\n\n    // Calculate size with pulse effect\n    const size = cloud.size * pulseFactor;\n\n    // Calculate center position with parallax\n    const centerX = width / 2 + cloud.x;\n    const centerY = height / 2 + cloud.y - parallaxOffsetY;\n\n    // Save context state\n    ctx.save();\n\n    // Apply transformations\n    ctx.translate(centerX, centerY);\n    ctx.rotate(cloud.rotation);\n\n    // Create radial gradient for cloud\n    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size / 2);\n\n    // Apply colors from scheme with opacity\n    const opacity = cloud.opacity * (0.7 + cloud.layer * 0.3); // Layer affects opacity\n    gradient.addColorStop(0, getCachedColor(cloud.colorScheme[0], opacity));\n    gradient.addColorStop(0.4, getCachedColor(cloud.colorScheme[1], opacity * 0.8));\n    gradient.addColorStop(1, getCachedColor(cloud.colorScheme[2], 0));\n\n    // Apply filter for cloud-like blur\n    if (adaptedSettings.useHighQualityRendering) {\n      // Layer affects blur - further clouds are more blurry\n      const layerBlur = adaptedSettings.blurFactor * (1 - cloud.layer * 0.5);\n      ctx.filter = `blur(${layerBlur}px)`;\n    }\n\n    // Draw cloud using noise function for organic shapes\n    ctx.beginPath();\n\n    // Higher iteration count for higher quality\n    const steps = adaptedSettings.useHighQualityRendering ? 24 : 16;\n\n    // Draw distorted circle using noise\n    for (let i = 0; i < steps; i++) {\n      const angle = i / steps * Math.PI * 2;\n      const nextAngle = (i + 1) / steps * Math.PI * 2;\n\n      // Use noise to create organic edge\n      const noiseX = Math.cos(angle) * cloud.complexity;\n      const noiseY = Math.sin(angle) * cloud.complexity;\n\n      // Get distortion from noise\n      const distortion = fractalNoise(noiseX + timeFactor * 0.05, noiseY) * cloud.turbulence;\n\n      // Calculate radius with distortion\n      const radius = size / 2 * (0.6 + distortion * 0.4);\n\n      // Calculate coordinates\n      const x = Math.cos(angle) * radius;\n      const y = Math.sin(angle) * radius;\n\n      // Draw path\n      if (i === 0) {\n        ctx.moveTo(x, y);\n      } else {\n        // Use quadratic curve for smoother edge\n        const nextNoiseX = Math.cos(nextAngle) * cloud.complexity;\n        const nextNoiseY = Math.sin(nextAngle) * cloud.complexity;\n        const nextDistortion = fractalNoise(nextNoiseX + timeFactor * 0.05, nextNoiseY) * cloud.turbulence;\n        const nextRadius = size / 2 * (0.6 + nextDistortion * 0.4);\n        const nextX = Math.cos(nextAngle) * nextRadius;\n        const nextY = Math.sin(nextAngle) * nextRadius;\n\n        // Control point for quadratic curve\n        const cpX = (x + nextX) / 2 + (Math.random() * 20 - 10) * (adaptedSettings.useHighQualityRendering ? 1 : 0.5);\n        const cpY = (y + nextY) / 2 + (Math.random() * 20 - 10) * (adaptedSettings.useHighQualityRendering ? 1 : 0.5);\n        ctx.quadraticCurveTo(cpX, cpY, nextX, nextY);\n      }\n    }\n    ctx.closePath();\n\n    // Fill with gradient\n    ctx.fillStyle = gradient;\n    ctx.globalCompositeOperation = 'screen';\n    ctx.fill();\n\n    // Restore context state\n    ctx.restore();\n  }, [dimensions, enableParallax, getCachedColor, adaptedSettings, fractalNoise]);\n\n  // Render the nebula scene\n  const renderScene = useCallback(timestamp => {\n    if (!ctxRef.current) return;\n    const ctx = ctxRef.current;\n    const {\n      width,\n      height\n    } = dimensions;\n\n    // Clear canvas with transparent background\n    ctx.clearRect(0, 0, width, height);\n\n    // Render each cloud from back to front (they're already sorted by layer)\n    for (let i = 0; i < cloudsRef.current.length; i++) {\n      renderCloud(ctx, cloudsRef.current[i], timestamp);\n    }\n\n    // Draw debug info if enabled\n    if (debug) {\n      ctx.globalCompositeOperation = 'source-over';\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n      ctx.font = '12px monospace';\n      ctx.fillText(`FPS: ${currentFpsRef.current}`, 10, 20);\n      ctx.fillText(`Clouds: ${cloudsRef.current.length}`, 10, 40);\n      ctx.fillText(`Quality: ${qualityFactor.toFixed(2)}`, 10, 60);\n    }\n  }, [dimensions, renderCloud, debug, qualityFactor]);\n\n  // FPS limiter for consistent animation speed\n  const fpsLimiter = useCallback((timestamp, callback) => {\n    // Skip animation if hidden, inactive, or reduced motion\n    if (!isVisible || !active || respectReducedMotion && prefersReducedMotion || document.hidden) {\n      animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n      return;\n    }\n    const targetFrameTime = 1000 / maxFPS;\n    const elapsed = timestamp - lastTimestampRef.current;\n    if (elapsed >= targetFrameTime || lastTimestampRef.current === 0) {\n      // Update timestamp, limiting to avoid jumps after inactivity\n      lastTimestampRef.current = timestamp - elapsed % targetFrameTime;\n\n      // Run animation callback with timestamp\n      callback(timestamp);\n\n      // FPS tracking for debug and adaptive quality\n      frameCountRef.current++;\n      if (timestamp - fpsTimestampRef.current >= 1000) {\n        currentFpsRef.current = frameCountRef.current;\n        frameCountRef.current = 0;\n        fpsTimestampRef.current = timestamp;\n\n        // Log FPS in debug mode\n        if (debug) {\n          console.log(`CosmicNebula FPS: ${currentFpsRef.current}, Quality: ${qualityFactor.toFixed(2)}`);\n        }\n\n        // Dynamic quality adjustment based on performance with debouncing\n        if (adaptiveQuality) {\n          // Check if FPS is stable by counting consecutive frames within target range\n          if (currentFpsRef.current >= maxFPS * 0.95) {\n            stableFrameCountRef.current += 1;\n          } else if (currentFpsRef.current < maxFPS * 0.7) {\n            stableFrameCountRef.current = 0;\n          }\n\n          // Avoid frequent quality changes by using a timer\n          if (qualityChangeTimerRef.current) {\n            clearTimeout(qualityChangeTimerRef.current);\n          }\n          qualityChangeTimerRef.current = setTimeout(() => {\n            // Only change quality if FPS has been stable or is very low\n            if (currentFpsRef.current < maxFPS * 0.7) {\n              // If FPS is below 70% of target, reduce quality\n              setQualityFactor(prev => {\n                const newQuality = Math.max(0.4, prev * 0.9);\n                lastQualityFactorRef.current = newQuality;\n                return newQuality;\n              });\n            } else if (stableFrameCountRef.current >= 3 && qualityFactor < 1) {\n              // If FPS has been high for several frames, gradually increase quality\n              setQualityFactor(prev => {\n                const newQuality = Math.min(1, prev * 1.05);\n                lastQualityFactorRef.current = newQuality;\n                return newQuality;\n              });\n            }\n          }, 1000); // Wait longer before changing quality since nebula changes are more visible\n        }\n      }\n    }\n\n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n  }, [isVisible, active, respectReducedMotion, prefersReducedMotion, maxFPS, debug, adaptiveQuality, qualityFactor]);\n\n  // Main animation handler\n  const handleAnimation = useCallback(timestamp => {\n    // Skip if component is not ready\n    if (!canvasRef.current || !isInitialized) return;\n\n    // Render scene\n    renderScene(timestamp);\n  }, [isInitialized, renderScene]);\n\n  // Main animation loop\n  useEffect(() => {\n    if (!active || !isInitialized || !dimensions.width || !dimensions.height) {\n      return;\n    }\n\n    // Start animation with FPS limiter\n    fpsTimestampRef.current = performance.now();\n    frameCountRef.current = 0;\n    lastTimestampRef.current = 0;\n    animationFrameRef.current = requestAnimationFrame(timestamp => {\n      fpsLimiter(timestamp, handleAnimation);\n    });\n\n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      if (qualityChangeTimerRef.current) {\n        clearTimeout(qualityChangeTimerRef.current);\n      }\n    };\n  }, [active, isInitialized, dimensions, fpsLimiter, handleAnimation]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: height,\n      overflow: 'hidden',\n      pointerEvents: 'none',\n      zIndex: zIndex,\n      // Hardware acceleration\n      backfaceVisibility: 'hidden',\n      transform: 'translateZ(0)',\n      willChange: 'transform'\n    },\n    \"aria-hidden\": \"true\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        // Additional rendering optimizations\n        imageRendering: 'high-quality',\n        // Hardware acceleration\n        backfaceVisibility: 'hidden',\n        transform: 'translateZ(0)',\n        willChange: 'transform',\n        // Ensures proper subpixel rendering\n        filter: 'none'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 781,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 763,\n    columnNumber: 5\n  }, this);\n};\n_s(CosmicNebula, \"/iBt9kBnXyG7uMI8nJJrNvpSvHU=\");\n_c = CosmicNebula;\nexport default CosmicNebula;\nvar _c;\n$RefreshReg$(_c, \"CosmicNebula\");","map":{"version":3,"names":["React","useRef","useEffect","useCallback","useState","useMemo","jsxDEV","_jsxDEV","CosmicNebula","height","zIndex","active","cloudCount","rotationSpeed","expansionFactor","blurFactor","enableParallax","parallaxIntensity","colorSchemes","adaptiveQuality","respectReducedMotion","maxFPS","enableOffscreenRendering","cloudOpacity","debug","_s","containerRef","canvasRef","ctxRef","offscreenCanvasRef","cloudsRef","animationFrameRef","lastTimestampRef","fpsTimestampRef","frameCountRef","currentFpsRef","scrollPositionRef","resizeObserverRef","visibilityObserverRef","visibilityChangeTimeRef","qualityChangeTimerRef","lastQualityFactorRef","stableFrameCountRef","seedsRef","baseRotation","Math","random","PI","noise","dimensions","setDimensions","width","pixelRatio","isInitialized","setIsInitialized","prefersReducedMotion","setPrefersReducedMotion","isVisible","setIsVisible","qualityFactor","setQualityFactor","deviceCapabilities","setDeviceCapabilities","memory","cores","batteryLevel","isMobile","supportsOffscreenCanvas","colorCacheRef","Map","adaptedSettings","useHighQualityRendering","max","floor","getCachedColor","baseColor","opacity","safeOpacity","min","roundedOpacity","round","key","current","has","newColor","replace","set","get","detectCapabilities","navigator","deviceMemory","hardwareConcurrency","test","userAgent","OffscreenCanvas","isCharging","performanceScore","quality","setupCanvas","canvas","container","rect","getBoundingClientRect","window","devicePixelRatio","displayWidth","displayHeight","endsWith","parseInt","innerHeight","style","ctx","getContext","alpha","desynchronized","willReadFrequently","scale","imageSmoothingEnabled","imageSmoothingQuality","offscreen","offscreenCtx","error","console","warn","x","y","seed","X","Y","xf","yf","topRight","topLeft","bottomRight","bottomLeft","sx","smoothStep","sy","nx0","lerp","nx1","n","t","a","b","fractalNoise","octaves","persistence","total","frequency","amplitude","maxValue","i","createCloud","index","maxDimension","colorScheme","length","cloud","size","rotation","parallaxFactor","layer","complexity","turbulence","pulsePhase","pulseSpeed","pulseAmount","initializeClouds","push","sort","reducedMotionQuery","matchMedia","matches","handleReducedMotionChange","e","addEventListener","handleVisibilityChange","document","hidden","performance","now","timeDelta","removeEventListener","resizeObserver","ResizeObserver","entries","timeout","clearTimeout","setTimeout","requestAnimationFrame","currentContainer","observe","observer","disconnect","IntersectionObserver","isIntersecting","threshold","rootMargin","currentContainerRef","handleScroll","scrollY","passive","renderCloud","timestamp","timeFactor","parallaxOffsetY","pulseFactor","sin","centerX","centerY","save","translate","rotate","gradient","createRadialGradient","addColorStop","layerBlur","filter","beginPath","steps","angle","nextAngle","noiseX","cos","noiseY","distortion","radius","moveTo","nextNoiseX","nextNoiseY","nextDistortion","nextRadius","nextX","nextY","cpX","cpY","quadraticCurveTo","closePath","fillStyle","globalCompositeOperation","fill","restore","renderScene","clearRect","font","fillText","toFixed","fpsLimiter","callback","time","targetFrameTime","elapsed","log","prev","newQuality","handleAnimation","cancelAnimationFrame","ref","position","top","left","overflow","pointerEvents","backfaceVisibility","transform","willChange","children","imageRendering","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/CosmicNebula.jsx"],"sourcesContent":["import React, { useRef, useEffect, useCallback, useState, useMemo } from 'react';\n\n/**\n * CosmicNebula Component\n * \n * Creates slowly rotating colorful gas clouds with depth and particle effects\n * that create an otherworldly backdrop for your cosmic background.\n * \n * Features:\n * - Canvas-based gradient rendering for gas cloud effects\n * - Slow rotation with customizable speed and direction\n * - Multi-layered depth with parallax effects\n * - Optimized for performance with adaptive quality settings\n * - Smooth motion with spring-based transitions\n * \n * @param {Object} props - Component props\n * @param {string|number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=2] - Z-index for the container (lower than MeteorShower but higher than Background)\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.cloudCount=5] - Number of nebula clouds to render\n * @param {number} [props.rotationSpeed=0.02] - Base rotation speed of clouds\n * @param {number} [props.expansionFactor=1.5] - How much the clouds expand beyond screen size\n * @param {number} [props.blurFactor=20] - Amount of blur applied to clouds (px)\n * @param {boolean} [props.enableParallax=true] - Enable parallax effect on scroll\n * @param {number} [props.parallaxIntensity=0.07] - Intensity of parallax effect\n * @param {string[][]} [props.colorSchemes] - Color schemes for the nebula clouds\n * @param {boolean} [props.adaptiveQuality=true] - Enable adaptive quality based on device\n * @param {boolean} [props.respectReducedMotion=true] - Respect reduced motion preferences\n * @param {number} [props.maxFPS=30] - Target maximum frames per second (lower than other components)\n * @param {boolean} [props.enableOffscreenRendering=true] - Enable offscreen canvas when available\n * @param {number} [props.cloudOpacity=0.15] - Base opacity of nebula clouds\n * @param {boolean} [props.debug=false] - Enable debug visualization\n */\nconst CosmicNebula = ({\n  height = '100vh',\n  zIndex = 2,\n  active = true,\n  cloudCount = 5,\n  rotationSpeed = 0.02,\n  expansionFactor = 1.5,\n  blurFactor = 20,\n  enableParallax = true,\n  parallaxIntensity = 0.07,\n  colorSchemes = [\n    ['rgba(63, 12, 77, alpha)', 'rgba(107, 23, 129, alpha)', 'rgba(240, 107, 207, alpha)'], // Purple-pink\n    ['rgba(11, 35, 65, alpha)', 'rgba(35, 91, 170, alpha)', 'rgba(79, 142, 230, alpha)'],   // Deep blue\n    ['rgba(55, 15, 15, alpha)', 'rgba(116, 38, 38, alpha)', 'rgba(206, 66, 66, alpha)'],    // Dark red\n    ['rgba(11, 45, 39, alpha)', 'rgba(30, 96, 82, alpha)', 'rgba(59, 160, 137, alpha)']     // Teal\n  ],\n  adaptiveQuality = true,\n  respectReducedMotion = true,\n  maxFPS = 30,\n  enableOffscreenRendering = true,\n  cloudOpacity = 0.15,\n  debug = false\n}) => {\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const ctxRef = useRef(null);\n  const offscreenCanvasRef = useRef(null);\n  const cloudsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const fpsTimestampRef = useRef(0);\n  const frameCountRef = useRef(0);\n  const currentFpsRef = useRef(30);\n  const scrollPositionRef = useRef(0);\n  const resizeObserverRef = useRef(null);\n  const visibilityObserverRef = useRef(null);\n  const visibilityChangeTimeRef = useRef(0);\n  const qualityChangeTimerRef = useRef(null);\n  const lastQualityFactorRef = useRef(1);\n  const stableFrameCountRef = useRef(0);\n  const seedsRef = useRef({\n    baseRotation: Math.random() * Math.PI * 2,\n    noise: Math.random() * 1000\n  });\n  \n  // Component state\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0, pixelRatio: 1 });\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [isVisible, setIsVisible] = useState(false);\n  const [qualityFactor, setQualityFactor] = useState(1);\n  const [deviceCapabilities, setDeviceCapabilities] = useState({\n    memory: 4,\n    cores: 4,\n    batteryLevel: 1,\n    isMobile: false,\n    supportsOffscreenCanvas: false\n  });\n  \n  // Precompute color variants to avoid string operations during animation\n  const colorCacheRef = useRef(new Map());\n  \n  // Adaptive settings based on quality factor\n  const adaptedSettings = useMemo(() => {\n    if (!adaptiveQuality || qualityFactor === 1) {\n      return {\n        cloudCount,\n        blurFactor,\n        useHighQualityRendering: true,\n        expansionFactor\n      };\n    }\n    \n    // Adjust quality-dependent parameters\n    return {\n      cloudCount: Math.max(3, Math.floor(cloudCount * qualityFactor)),\n      blurFactor: Math.max(5, Math.floor(blurFactor * qualityFactor)),\n      useHighQualityRendering: qualityFactor > 0.6,\n      expansionFactor: Math.max(1.2, expansionFactor * qualityFactor)\n    };\n  }, [adaptiveQuality, qualityFactor, cloudCount, blurFactor, expansionFactor]);\n  \n  // Get cached color with opacity\n  const getCachedColor = useCallback((baseColor, opacity) => {\n    // Ensure opacity is always valid\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    \n    // Round opacity to reduce cache size while maintaining visual quality\n    const roundedOpacity = Math.round(safeOpacity * 100) / 100;\n    const key = `${baseColor}-${roundedOpacity}`;\n    \n    if (!colorCacheRef.current.has(key)) {\n      const newColor = baseColor.replace(/alpha\\)$/, roundedOpacity + ')');\n      colorCacheRef.current.set(key, newColor);\n    }\n    \n    return colorCacheRef.current.get(key);\n  }, []);\n  \n  // Detect device capabilities and set up optimization strategies\n  const detectCapabilities = useCallback(() => {\n    // Device memory, hardware concurrency\n    const memory = navigator.deviceMemory || 4;\n    const cores = navigator.hardwareConcurrency || 4;\n    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n    \n    // Check offscreen canvas support\n    const supportsOffscreenCanvas = typeof OffscreenCanvas !== 'undefined';\n    \n    // Set device capabilities state\n    setDeviceCapabilities({\n      memory,\n      cores,\n      batteryLevel: 1,\n      isCharging: true,\n      isMobile,\n      supportsOffscreenCanvas\n    });\n    \n    // Calculate quality factor based on capabilities\n    if (adaptiveQuality) {\n      // Base score from hardware\n      const performanceScore = (memory * cores) / (isMobile ? 2 : 1);\n      \n      // Scale quality based on performance score\n      let quality = 1;\n      \n      if (performanceScore > 16) {\n        quality = 1; // High-end devices\n      } else if (performanceScore > 8) {\n        quality = 0.8; // Mid-range devices\n      } else if (performanceScore > 4) {\n        quality = 0.6; // Low-end devices\n      } else {\n        quality = 0.4; // Very low-end devices\n      }\n      \n      setQualityFactor(quality);\n      lastQualityFactorRef.current = quality;\n    }\n  }, [adaptiveQuality]);\n  \n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current || !containerRef.current) return false;\n    \n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    const rect = container.getBoundingClientRect();\n    const pixelRatio = window.devicePixelRatio || 1;\n    \n    // Calculate dimensions\n    const displayWidth = Math.floor(rect.width);\n    const displayHeight = typeof height === 'string' && height.endsWith('vh') \n      ? Math.floor((parseInt(height, 10) / 100) * window.innerHeight)\n      : Math.floor(parseInt(height, 10) || window.innerHeight);\n    \n    // Set canvas size accounting for pixel ratio\n    canvas.width = displayWidth * pixelRatio;\n    canvas.height = displayHeight * pixelRatio;\n    canvas.style.width = `${displayWidth}px`;\n    canvas.style.height = `${displayHeight}px`;\n    \n    // 2D Canvas context\n    const ctx = canvas.getContext('2d', {\n      alpha: true,\n      desynchronized: true,\n      willReadFrequently: false\n    });\n    \n    if (!ctx) return false;\n    \n    // Scale context for high-DPI displays\n    ctx.scale(pixelRatio, pixelRatio);\n    \n    // Configure context for high-quality rendering\n    if (adaptedSettings.useHighQualityRendering) {\n      ctx.imageSmoothingEnabled = true;\n      ctx.imageSmoothingQuality = 'high';\n    }\n    \n    ctxRef.current = ctx;\n    \n    // Initialize offscreen canvas if supported and enabled\n    if (enableOffscreenRendering && typeof OffscreenCanvas !== 'undefined' &&\n        deviceCapabilities.supportsOffscreenCanvas) {\n      try {\n        // Create offscreen canvas\n        const offscreen = new OffscreenCanvas(\n          displayWidth * pixelRatio,\n          displayHeight * pixelRatio\n        );\n        \n        // Get 2D context for offscreen canvas\n        const offscreenCtx = offscreen.getContext('2d');\n        if (offscreenCtx) {\n          offscreenCtx.scale(pixelRatio, pixelRatio);\n          offscreenCanvasRef.current = {\n            canvas: offscreen,\n            ctx: offscreenCtx\n          };\n        }\n      } catch (error) {\n        console.warn('Offscreen canvas initialization error:', error);\n      }\n    }\n    \n    setDimensions({\n      width: displayWidth,\n      height: displayHeight,\n      pixelRatio\n    });\n    \n    return true;\n  }, [height, enableOffscreenRendering, deviceCapabilities.supportsOffscreenCanvas, adaptedSettings.useHighQualityRendering]);\n  \n  // Perlin noise function for organic cloud shapes\n  const noise = useCallback((x, y) => {\n    const seed = seedsRef.current.noise;\n    \n    // Simple noise function with multiple octaves for organic shapes\n    const X = Math.floor(x) & 255;\n    const Y = Math.floor(y) & 255;\n    \n    const xf = x - Math.floor(x);\n    const yf = y - Math.floor(y);\n    \n    const topRight = (X + 1 + seed + (Y + 1) * 379) % 977 / 977;\n    const topLeft = (X + seed + (Y + 1) * 379) % 977 / 977;\n    const bottomRight = (X + 1 + seed + Y * 379) % 977 / 977;\n    const bottomLeft = (X + seed + Y * 379) % 977 / 977;\n    \n    // Smoothing function\n    const sx = smoothStep(xf);\n    const sy = smoothStep(yf);\n    \n    // Interpolate values to get final noise value\n    const nx0 = lerp(bottomLeft, bottomRight, sx);\n    const nx1 = lerp(topLeft, topRight, sx);\n    const n = lerp(nx0, nx1, sy);\n    \n    return n;\n    \n    // Helper functions\n    function smoothStep(t) {\n      return t * t * (3 - 2 * t);\n    }\n    \n    function lerp(a, b, t) {\n      return a + t * (b - a);\n    }\n  }, []);\n  \n  // Create fractal noise for more complex patterns\n  const fractalNoise = useCallback((x, y, octaves = 6, persistence = 0.5) => {\n    let total = 0;\n    let frequency = 1;\n    let amplitude = 1;\n    let maxValue = 0;\n    \n    for (let i = 0; i < octaves; i++) {\n      total += noise(x * frequency, y * frequency) * amplitude;\n      \n      maxValue += amplitude;\n      amplitude *= persistence;\n      frequency *= 2;\n    }\n    \n    return total / maxValue;\n  }, [noise]);\n  \n  // Create a new nebula cloud\n  const createCloud = useCallback((index) => {\n    const { width, height } = dimensions;\n    if (!width || !height) return null;\n    \n    // Larger dimension for proper sizing\n    const maxDimension = Math.max(width, height);\n    \n    // Select a color scheme\n    const colorScheme = colorSchemes[index % colorSchemes.length];\n    \n    // Create cloud with random properties\n    const cloud = {\n      // Position relative to center of screen\n      x: (Math.random() * 0.8 - 0.4) * width,\n      y: (Math.random() * 0.8 - 0.4) * height,\n      \n      // Size - vary based on quality settings\n      size: (0.5 + Math.random() * 0.8) * maxDimension * adaptedSettings.expansionFactor,\n      \n      // Visual properties\n      opacity: (Math.random() * 0.3 + 0.7) * cloudOpacity, // 70-100% of base opacity\n      colorScheme,\n      \n      // Rotation properties\n      rotation: Math.random() * Math.PI * 2,\n      rotationSpeed: (Math.random() * 0.5 + 0.75) * rotationSpeed * (Math.random() > 0.5 ? 1 : -1),\n      \n      // Parallax factor\n      parallaxFactor: 0.1 + Math.random() * 0.3 * parallaxIntensity,\n      \n      // Layer for depth effect (0=furthest, 1=closest)\n      layer: Math.random(),\n      \n      // Cloud shape properties\n      complexity: 1 + Math.random() * 4, // Controls noise scale\n      turbulence: 0.8 + Math.random() * 1.2, // Controls noise distortion\n      \n      // Animation properties\n      pulsePhase: Math.random() * Math.PI * 2,\n      pulseSpeed: 0.0001 + Math.random() * 0.0002,\n      pulseAmount: 0.02 + Math.random() * 0.04\n    };\n    \n    return cloud;\n  }, [dimensions, colorSchemes, adaptedSettings.expansionFactor, cloudOpacity, rotationSpeed, parallaxIntensity]);\n  \n  // Initialize nebula clouds\n  const initializeClouds = useCallback(() => {\n    // Clear existing clouds\n    cloudsRef.current = [];\n    \n    // Generate clouds based on density and sort by layer for proper depth rendering\n    for (let i = 0; i < adaptedSettings.cloudCount; i++) {\n      const cloud = createCloud(i);\n      if (cloud) {\n        cloudsRef.current.push(cloud);\n      }\n    }\n    \n    // Sort clouds by layer (furthest to closest)\n    cloudsRef.current.sort((a, b) => a.layer - b.layer);\n  }, [adaptedSettings.cloudCount, createCloud]);\n  \n  // Detect device capabilities and preferences on mount\n  useEffect(() => {\n    // Check for reduced motion preference\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    \n    const handleReducedMotionChange = (e) => {\n      setPrefersReducedMotion(e.matches);\n    };\n    \n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n    \n    // Detect device capabilities\n    detectCapabilities();\n    \n    // Setup visibility change detection to pause when tab is inactive\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        visibilityChangeTimeRef.current = performance.now();\n      } else {\n        // Adjust timing references after visibility changes\n        const timeDelta = performance.now() - visibilityChangeTimeRef.current;\n        lastTimestampRef.current += timeDelta;\n      }\n    };\n    \n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    \n    // Cleanup\n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  }, [detectCapabilities]);\n  \n  // Setup canvas resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n    \n    // Create a ResizeObserver to detect container size changes\n    const resizeObserver = new ResizeObserver(entries => {\n      // Debounce resize operations\n      if (resizeObserverRef.current.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n      \n      resizeObserverRef.current.timeout = setTimeout(() => {\n        requestAnimationFrame(() => {\n          if (setupCanvas()) {\n            setIsInitialized(true);\n          }\n        });\n      }, 100); // 100ms debounce\n    });\n    \n    // Capture current reference to avoid closure issues in cleanup\n    const currentContainer = containerRef.current;\n    \n    // Start observing the container\n    resizeObserver.observe(currentContainer);\n    resizeObserverRef.current = { observer: resizeObserver };\n    \n    // Initial setup\n    setupCanvas();\n    setIsInitialized(true);\n    \n    return () => {\n      if (resizeObserverRef.current.observer) {\n        resizeObserverRef.current.observer.disconnect();\n      }\n      if (resizeObserverRef.current.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n    };\n  }, [setupCanvas]);\n  \n  // Setup intersection observer to only animate when visible\n  useEffect(() => {\n    if (!containerRef.current) return;\n    \n    const observer = new IntersectionObserver(\n      entries => {\n        const isIntersecting = entries[0].isIntersecting;\n        \n        // Only change state if visibility actually changed\n        if (isIntersecting !== isVisible) {\n          setIsVisible(isIntersecting);\n          \n          if (isIntersecting) {\n            // Reset timing references when becoming visible again\n            lastTimestampRef.current = 0;\n          }\n        }\n      },\n      {\n        threshold: 0.01,\n        rootMargin: '100px'\n      }\n    );\n    \n    // Store current reference to avoid closure issues\n    const currentContainerRef = containerRef.current;\n    observer.observe(currentContainerRef);\n    visibilityObserverRef.current = observer;\n    \n    return () => {\n      if (visibilityObserverRef.current) {\n        visibilityObserverRef.current.disconnect();\n      }\n    };\n  }, [isVisible]);\n  \n  // Handle parallax effect on scroll if enabled\n  useEffect(() => {\n    if (!enableParallax) return;\n    \n    // Use passive event listener for better performance\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    \n    window.addEventListener('scroll', handleScroll, { passive: true });\n    \n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [enableParallax]);\n  \n  // Initialize clouds once canvas is ready\n  useEffect(() => {\n    if (isInitialized && dimensions.width && dimensions.height) {\n      initializeClouds();\n    }\n  }, [isInitialized, dimensions, initializeClouds]);\n  \n  // Render a single nebula cloud with gradients and noise\n  const renderCloud = useCallback((ctx, cloud, timestamp) => {\n    const { width, height } = dimensions;\n    const scrollY = scrollPositionRef.current;\n    \n    // Apply time-based animations\n    const timeFactor = timestamp * 0.001;\n    \n    // Update rotation\n    cloud.rotation += cloud.rotationSpeed * 0.01;\n    \n    // Apply parallax effect if enabled\n    let parallaxOffsetY = 0;\n    if (enableParallax) {\n      parallaxOffsetY = scrollY * cloud.parallaxFactor;\n    }\n    \n    // Apply pulsing effect\n    const pulseFactor = 1 + Math.sin(timeFactor * cloud.pulseSpeed + cloud.pulsePhase) * cloud.pulseAmount;\n    \n    // Calculate size with pulse effect\n    const size = cloud.size * pulseFactor;\n    \n    // Calculate center position with parallax\n    const centerX = width / 2 + cloud.x;\n    const centerY = height / 2 + cloud.y - parallaxOffsetY;\n    \n    // Save context state\n    ctx.save();\n    \n    // Apply transformations\n    ctx.translate(centerX, centerY);\n    ctx.rotate(cloud.rotation);\n    \n    // Create radial gradient for cloud\n    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size / 2);\n    \n    // Apply colors from scheme with opacity\n    const opacity = cloud.opacity * (0.7 + (cloud.layer * 0.3)); // Layer affects opacity\n    gradient.addColorStop(0, getCachedColor(cloud.colorScheme[0], opacity));\n    gradient.addColorStop(0.4, getCachedColor(cloud.colorScheme[1], opacity * 0.8));\n    gradient.addColorStop(1, getCachedColor(cloud.colorScheme[2], 0));\n    \n    // Apply filter for cloud-like blur\n    if (adaptedSettings.useHighQualityRendering) {\n      // Layer affects blur - further clouds are more blurry\n      const layerBlur = adaptedSettings.blurFactor * (1 - cloud.layer * 0.5);\n      ctx.filter = `blur(${layerBlur}px)`;\n    }\n    \n    // Draw cloud using noise function for organic shapes\n    ctx.beginPath();\n    \n    // Higher iteration count for higher quality\n    const steps = adaptedSettings.useHighQualityRendering ? 24 : 16;\n    \n    // Draw distorted circle using noise\n    for (let i = 0; i < steps; i++) {\n      const angle = (i / steps) * Math.PI * 2;\n      const nextAngle = ((i + 1) / steps) * Math.PI * 2;\n      \n      // Use noise to create organic edge\n      const noiseX = Math.cos(angle) * cloud.complexity;\n      const noiseY = Math.sin(angle) * cloud.complexity;\n      \n      // Get distortion from noise\n      const distortion = fractalNoise(noiseX + timeFactor * 0.05, noiseY) * cloud.turbulence;\n      \n      // Calculate radius with distortion\n      const radius = (size / 2) * (0.6 + distortion * 0.4);\n      \n      // Calculate coordinates\n      const x = Math.cos(angle) * radius;\n      const y = Math.sin(angle) * radius;\n      \n      // Draw path\n      if (i === 0) {\n        ctx.moveTo(x, y);\n      } else {\n        // Use quadratic curve for smoother edge\n        const nextNoiseX = Math.cos(nextAngle) * cloud.complexity;\n        const nextNoiseY = Math.sin(nextAngle) * cloud.complexity;\n        const nextDistortion = fractalNoise(nextNoiseX + timeFactor * 0.05, nextNoiseY) * cloud.turbulence;\n        const nextRadius = (size / 2) * (0.6 + nextDistortion * 0.4);\n        \n        const nextX = Math.cos(nextAngle) * nextRadius;\n        const nextY = Math.sin(nextAngle) * nextRadius;\n        \n        // Control point for quadratic curve\n        const cpX = (x + nextX) / 2 + (Math.random() * 20 - 10) * (adaptedSettings.useHighQualityRendering ? 1 : 0.5);\n        const cpY = (y + nextY) / 2 + (Math.random() * 20 - 10) * (adaptedSettings.useHighQualityRendering ? 1 : 0.5);\n        \n        ctx.quadraticCurveTo(cpX, cpY, nextX, nextY);\n      }\n    }\n    \n    ctx.closePath();\n    \n    // Fill with gradient\n    ctx.fillStyle = gradient;\n    ctx.globalCompositeOperation = 'screen';\n    ctx.fill();\n    \n    // Restore context state\n    ctx.restore();\n  }, [dimensions, enableParallax, getCachedColor, adaptedSettings, fractalNoise]);\n  \n  // Render the nebula scene\n  const renderScene = useCallback((timestamp) => {\n    if (!ctxRef.current) return;\n    \n    const ctx = ctxRef.current;\n    const { width, height } = dimensions;\n    \n    // Clear canvas with transparent background\n    ctx.clearRect(0, 0, width, height);\n    \n    // Render each cloud from back to front (they're already sorted by layer)\n    for (let i = 0; i < cloudsRef.current.length; i++) {\n      renderCloud(ctx, cloudsRef.current[i], timestamp);\n    }\n    \n    // Draw debug info if enabled\n    if (debug) {\n      ctx.globalCompositeOperation = 'source-over';\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n      ctx.font = '12px monospace';\n      ctx.fillText(`FPS: ${currentFpsRef.current}`, 10, 20);\n      ctx.fillText(`Clouds: ${cloudsRef.current.length}`, 10, 40);\n      ctx.fillText(`Quality: ${qualityFactor.toFixed(2)}`, 10, 60);\n    }\n  }, [dimensions, renderCloud, debug, qualityFactor]);\n  \n  // FPS limiter for consistent animation speed\n  const fpsLimiter = useCallback((timestamp, callback) => {\n    // Skip animation if hidden, inactive, or reduced motion\n    if (!isVisible || !active || (respectReducedMotion && prefersReducedMotion) || document.hidden) {\n      animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n      return;\n    }\n    \n    const targetFrameTime = 1000 / maxFPS;\n    const elapsed = timestamp - lastTimestampRef.current;\n    \n    if (elapsed >= targetFrameTime || lastTimestampRef.current === 0) {\n      // Update timestamp, limiting to avoid jumps after inactivity\n      lastTimestampRef.current = timestamp - (elapsed % targetFrameTime);\n      \n      // Run animation callback with timestamp\n      callback(timestamp);\n      \n      // FPS tracking for debug and adaptive quality\n      frameCountRef.current++;\n      if (timestamp - fpsTimestampRef.current >= 1000) {\n        currentFpsRef.current = frameCountRef.current;\n        frameCountRef.current = 0;\n        fpsTimestampRef.current = timestamp;\n        \n        // Log FPS in debug mode\n        if (debug) {\n          console.log(`CosmicNebula FPS: ${currentFpsRef.current}, Quality: ${qualityFactor.toFixed(2)}`);\n        }\n        \n        // Dynamic quality adjustment based on performance with debouncing\n        if (adaptiveQuality) {\n          // Check if FPS is stable by counting consecutive frames within target range\n          if (currentFpsRef.current >= maxFPS * 0.95) {\n            stableFrameCountRef.current += 1;\n          } else if (currentFpsRef.current < maxFPS * 0.7) {\n            stableFrameCountRef.current = 0;\n          }\n          \n          // Avoid frequent quality changes by using a timer\n          if (qualityChangeTimerRef.current) {\n            clearTimeout(qualityChangeTimerRef.current);\n          }\n          \n          qualityChangeTimerRef.current = setTimeout(() => {\n            // Only change quality if FPS has been stable or is very low\n            if (currentFpsRef.current < maxFPS * 0.7) {\n              // If FPS is below 70% of target, reduce quality\n              setQualityFactor(prev => {\n                const newQuality = Math.max(0.4, prev * 0.9);\n                lastQualityFactorRef.current = newQuality;\n                return newQuality;\n              });\n            } else if (stableFrameCountRef.current >= 3 && qualityFactor < 1) {\n              // If FPS has been high for several frames, gradually increase quality\n              setQualityFactor(prev => {\n                const newQuality = Math.min(1, prev * 1.05);\n                lastQualityFactorRef.current = newQuality;\n                return newQuality;\n              });\n            }\n          }, 1000); // Wait longer before changing quality since nebula changes are more visible\n        }\n      }\n    }\n    \n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n  }, [\n    isVisible,\n    active,\n    respectReducedMotion,\n    prefersReducedMotion,\n    maxFPS,\n    debug,\n    adaptiveQuality,\n    qualityFactor\n  ]);\n  \n  // Main animation handler\n  const handleAnimation = useCallback((timestamp) => {\n    // Skip if component is not ready\n    if (!canvasRef.current || !isInitialized) return;\n    \n    // Render scene\n    renderScene(timestamp);\n  }, [\n    isInitialized,\n    renderScene\n  ]);\n  \n  // Main animation loop\n  useEffect(() => {\n    if (!active || !isInitialized || !dimensions.width || !dimensions.height) {\n      return;\n    }\n    \n    // Start animation with FPS limiter\n    fpsTimestampRef.current = performance.now();\n    frameCountRef.current = 0;\n    lastTimestampRef.current = 0;\n    \n    animationFrameRef.current = requestAnimationFrame(timestamp => {\n      fpsLimiter(timestamp, handleAnimation);\n    });\n    \n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      \n      if (qualityChangeTimerRef.current) {\n        clearTimeout(qualityChangeTimerRef.current);\n      }\n    };\n  }, [\n    active,\n    isInitialized,\n    dimensions,\n    fpsLimiter,\n    handleAnimation\n  ]);\n  \n  return (\n    <div \n      ref={containerRef}\n      style={{ \n        position: 'absolute',\n        top: 0, \n        left: 0, \n        width: '100%', \n        height: height,\n        overflow: 'hidden', \n        pointerEvents: 'none', \n        zIndex: zIndex,\n        // Hardware acceleration\n        backfaceVisibility: 'hidden',\n        transform: 'translateZ(0)',\n        willChange: 'transform'\n      }}\n      aria-hidden=\"true\"\n    >\n      <canvas \n        ref={canvasRef} \n        style={{ \n          position: 'absolute', \n          top: 0, \n          left: 0, \n          width: '100%', \n          height: '100%',\n          // Additional rendering optimizations\n          imageRendering: 'high-quality',\n          // Hardware acceleration\n          backfaceVisibility: 'hidden',\n          transform: 'translateZ(0)',\n          willChange: 'transform',\n          // Ensures proper subpixel rendering\n          filter: 'none'\n        }} \n      />\n    </div>\n  );\n};\n\nexport default CosmicNebula;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}