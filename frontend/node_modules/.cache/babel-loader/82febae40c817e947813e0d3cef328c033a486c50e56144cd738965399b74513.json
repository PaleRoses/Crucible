{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/MeteorShower.jsx\",\n  _s3 = $RefreshSig$();\nimport React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';\n\n/**\n * MeteorShower Component - Enterprise Performance Optimized Version\n * \n * Creates a highly performant animated meteor shower effect where meteors\n * arc across the sky with comet-like trails and fade away naturally.\n * \n * Features:\n * - Advanced performance optimizations with WebGL acceleration option\n * - Adaptive quality scaling based on device capabilities\n * - Memory and battery-efficient rendering pipeline\n * - Accessibility compliance with reduced motion support\n * - Supports hardware acceleration and high-DPI displays\n * - Enhanced burst effects with realistic particle physics\n * \n * @param {Object} props - Component props\n * @param {string|number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=5] - Z-index for the container\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.meteorDensity=15] - Number of meteors to maintain on screen\n * @param {number} [props.meteorMinSize=1] - Minimum size of meteors\n * @param {number} [props.meteorMaxSize=3] - Maximum size of meteors\n * @param {number} [props.meteorSpeed=0.08] - Base speed of meteors\n * @param {number} [props.trailLength=180] - Length of meteor trails\n * @param {number} [props.trailSegments=20] - Number of segments in each trail\n * @param {string} [props.coreColor='rgba(255, 255, 255, 1)'] - Core color for meteors\n * @param {string} [props.glowColor='rgba(255, 253, 227, 0.9)'] - Glow color for meteors\n * @param {string} [props.trailColor='rgba(191, 173, 127, 0.8)'] - Trail color for meteors\n * @param {boolean} [props.enableParallax=false] - Enable parallax effect on scroll\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of parallax effect\n * @param {boolean} [props.staggered=true] - Enable staggered meteor appearance\n * @param {number} [props.minStaggerDelay=200] - Minimum delay between meteor spawns (ms)\n * @param {number} [props.maxStaggerDelay=2000] - Maximum delay between meteor spawns (ms)\n * @param {number} [props.journeyCompletion=0.9] - When meteors complete their journey (0-1)\n * @param {string} [props.mode='arc'] - Animation mode: 'arc', 'linear', or 'topArc'\n * @param {string} [props.direction='both'] - Direction: 'left', 'right', 'both', or 'top'\n * @param {number} [props.baseAngle=30] - Base angle for linear meteors (degrees)\n * @param {number} [props.angleVariation=15] - Random variation to apply to the base angle\n * @param {number} [props.arcIntensity=0.5] - Controls the curve intensity for 'topArc' mode\n * @param {number} [props.arcVariation=0.2] - Random variation for arc intensity\n * @param {boolean} [props.debug=false] - Enable debug visualization\n * @param {boolean} [props.adaptiveQuality=true] - Enable adaptive quality based on device\n * @param {boolean} [props.respectReducedMotion=true] - Respect reduced motion preferences\n * @param {number} [props.maxFPS=60] - Target maximum frames per second\n * @param {boolean} [props.useWebGL=false] - Use WebGL rendering for better performance\n * @param {boolean} [props.enableBursts=true] - Enable meteor burst effects\n * @param {boolean} [props.enableBattery=true] - Enable battery-saving optimizations\n * @param {string} [props.renderingMode='auto'] - Rendering mode: 'auto', '2d', or 'webgl'\n * @param {boolean} [props.enableOffscreenRendering=true] - Enable offscreen canvas when available\n * @param {number} [props.burstParticleCount=12] - Number of particles in each burst\n * @param {number} [props.burstParticleSize=2] - Size of burst particles\n * @param {number} [props.burstProbability=0.4] - Probability of meteor having a burst (0-1)\n * @param {string} [props.burstColorVariation='0.2'] - Amount of color variation in burst particles\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MeteorShower = ({\n  height = '100vh',\n  zIndex = 5,\n  active = true,\n  meteorDensity = 15,\n  meteorMinSize = 1,\n  meteorMaxSize = 3,\n  meteorSpeed = 0.08,\n  trailLength = 180,\n  trailSegments = 20,\n  coreColor = 'rgba(255, 255, 255, 1)',\n  glowColor = 'rgba(255, 245, 158, 0.9)',\n  trailColor = 'rgba(207, 181, 59, 0.8)',\n  enableParallax = false,\n  parallaxIntensity = 0.2,\n  staggered = true,\n  minStaggerDelay = 200,\n  maxStaggerDelay = 2000,\n  journeyCompletion = 0.9,\n  mode = 'arc',\n  direction = 'both',\n  baseAngle = 30,\n  angleVariation = 15,\n  arcIntensity = 0.5,\n  arcVariation = 0.2,\n  debug = false,\n  adaptiveQuality = true,\n  respectReducedMotion = true,\n  maxFPS = 60,\n  useWebGL = false,\n  enableBursts = true,\n  // Enabled by default now\n  enableBattery = true,\n  renderingMode = 'auto',\n  enableOffscreenRendering = true,\n  burstParticleCount = 12,\n  burstParticleSize = 2,\n  burstProbability = 0.4,\n  burstColorVariation = 0.2\n}) => {\n  _s3();\n  var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const ctxRef = useRef(null);\n  const webGLRef = useRef(null);\n  const offscreenCanvasRef = useRef(null);\n  const workerRef = useRef(null);\n  const meteorsRef = useRef([]);\n  const burstsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const fpsTimestampRef = useRef(0);\n  const frameCountRef = useRef(0);\n  const currentFpsRef = useRef(60);\n  const nextSpawnTimeRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n  const resizeObserverRef = useRef(null);\n  const visibilityObserverRef = useRef(null);\n  const batteryRef = useRef(null);\n  const visibilityChangeTimeRef = useRef(0);\n  const lastBurstCountRef = useRef(0);\n  const qualityChangeTimerRef = useRef(null);\n  const lastQualityFactorRef = useRef(1);\n  const stableFrameCountRef = useRef(0);\n\n  // Component state\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0,\n    pixelRatio: 1\n  });\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [isVisible, setIsVisible] = useState(false);\n  const [qualityFactor, setQualityFactor] = useState(1);\n  const [actualRenderingMode, setActualRenderingMode] = useState('2d');\n  const [deviceCapabilities, setDeviceCapabilities] = useState({\n    memory: 4,\n    cores: 4,\n    batteryLevel: 1,\n    isMobile: false,\n    supportsWebGL: false,\n    supportsOffscreenCanvas: false\n  });\n\n  // Pre-allocate objects to avoid garbage collection during animation\n  const pointCache = useRef({\n    current: {\n      x: 0,\n      y: 0\n    },\n    segment: {\n      x: 0,\n      y: 0\n    }\n  }).current;\n\n  // Precompute color variants to avoid string operations during animation\n  const colorCacheRef = useRef(new Map());\n\n  // WebGL shader programs and buffers\n  const webGLProgramsRef = useRef({\n    meteor: null,\n    trail: null,\n    burst: null\n  });\n\n  // Object pools for efficient memory usage\n  const objectPoolsRef = useRef({\n    meteors: [],\n    bursts: [],\n    vectors: []\n  });\n\n  // Fix 1: Limit trail segments to a reasonable number to prevent performance issues\n  const safeTrailSegments = useMemo(() => {\n    // If trail segments are extremely high, cap them based on device capability\n    const maxSegments = Math.min(deviceCapabilities.isMobile ? 40 : 80, trailSegments);\n    return maxSegments;\n  }, [trailSegments, deviceCapabilities.isMobile]);\n\n  // Detects device capabilities and sets up optimization strategies\n  const detectCapabilities = useCallback(() => {\n    // Device memory, hardware concurrency, and battery\n    const memory = navigator.deviceMemory || 4;\n    const cores = navigator.hardwareConcurrency || 4;\n    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n\n    // Check WebGL support\n    let supportsWebGL = false;\n    try {\n      const canvas = document.createElement('canvas');\n      supportsWebGL = !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));\n    } catch (e) {\n      supportsWebGL = false;\n    }\n\n    // Check offscreen canvas support\n    const supportsOffscreenCanvas = typeof OffscreenCanvas !== 'undefined';\n\n    // Get battery info if available\n    if (navigator.getBattery && enableBattery) {\n      navigator.getBattery().then(battery => {\n        batteryRef.current = battery;\n        const updateBattery = () => {\n          setDeviceCapabilities(prev => ({\n            ...prev,\n            batteryLevel: battery.level,\n            isCharging: battery.charging\n          }));\n\n          // Reduce quality if on battery and below 30%\n          if (!battery.charging && battery.level < 0.3 && adaptiveQuality) {\n            setQualityFactor(prev => Math.min(prev, 0.6));\n          }\n        };\n\n        // Add battery event listeners\n        battery.addEventListener('levelchange', updateBattery);\n        battery.addEventListener('chargingchange', updateBattery);\n\n        // Initial update\n        updateBattery();\n      }).catch(() => {\n        // Fallback if battery API is not available or fails\n        setDeviceCapabilities(prev => ({\n          ...prev,\n          batteryLevel: 1,\n          isCharging: true\n        }));\n      });\n    }\n\n    // Determine initial rendering mode\n    let initialRenderingMode = '2d';\n    if (renderingMode === 'auto') {\n      if (useWebGL && supportsWebGL) {\n        initialRenderingMode = 'webgl';\n      } else {\n        initialRenderingMode = '2d';\n      }\n    } else {\n      initialRenderingMode = renderingMode === 'webgl' && supportsWebGL ? 'webgl' : '2d';\n    }\n    setActualRenderingMode(initialRenderingMode);\n\n    // Set device capabilities state\n    setDeviceCapabilities({\n      memory,\n      cores,\n      batteryLevel: 1,\n      isCharging: true,\n      isMobile,\n      supportsWebGL,\n      supportsOffscreenCanvas\n    });\n\n    // Calculate quality factor based on capabilities\n    if (adaptiveQuality) {\n      // Base score from hardware\n      const performanceScore = memory * cores / (isMobile ? 2 : 1);\n\n      // Scale quality based on performance score\n      let quality = 1;\n      if (performanceScore > 16) {\n        quality = 1; // High-end devices\n      } else if (performanceScore > 8) {\n        quality = 0.8; // Mid-range devices\n      } else if (performanceScore > 4) {\n        quality = 0.6; // Low-end devices\n      } else {\n        quality = 0.4; // Very low-end devices\n      }\n      setQualityFactor(quality);\n      lastQualityFactorRef.current = quality;\n    }\n  }, [useWebGL, renderingMode, adaptiveQuality, enableBattery]);\n\n  // Get cached color with opacity\n  const getCachedColor = useCallback((baseColor, opacity) => {\n    // Fix 2: Ensure opacity is always valid to prevent rendering glitches\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n\n    // Round opacity to reduce cache size while maintaining visual quality\n    const roundedOpacity = Math.round(safeOpacity * 100) / 100;\n    const key = `${baseColor}-${roundedOpacity}`;\n    if (!colorCacheRef.current.has(key)) {\n      const newColor = baseColor.replace(/[\\d.]+\\)$/, roundedOpacity + ')');\n      colorCacheRef.current.set(key, newColor);\n    }\n    return colorCacheRef.current.get(key);\n  }, []);\n\n  // Adaptive settings based on quality factor\n  const adaptedSettings = useMemo(() => {\n    if (!adaptiveQuality || qualityFactor === 1) {\n      return {\n        meteorDensity,\n        trailSegments: safeTrailSegments,\n        burstParticleCount,\n        useShadow: true,\n        useGlow: true,\n        useHighQualityRendering: true\n      };\n    }\n\n    // Fix 3: Smoother quality adjustments to prevent visual jarring\n    // Adjust quality-dependent parameters\n    return {\n      meteorDensity: Math.max(3, Math.floor(meteorDensity * qualityFactor)),\n      trailSegments: Math.max(5, Math.floor(safeTrailSegments * qualityFactor)),\n      burstParticleCount: Math.max(4, Math.floor(burstParticleCount * qualityFactor)),\n      useShadow: qualityFactor > 0.5,\n      useGlow: qualityFactor > 0.3,\n      useHighQualityRendering: qualityFactor > 0.7\n    };\n  }, [adaptiveQuality, qualityFactor, meteorDensity, safeTrailSegments, burstParticleCount]);\n\n  // Detect device capabilities and preferences on mount\n  useEffect(() => {\n    // Check for reduced motion preference\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    const handleReducedMotionChange = e => {\n      setPrefersReducedMotion(e.matches);\n    };\n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n\n    // Detect device capabilities\n    detectCapabilities();\n\n    // Setup visibility change detection to pause when tab is inactive\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        visibilityChangeTimeRef.current = performance.now();\n      } else {\n        // Adjust timing references after visibility changes\n        const timeDelta = performance.now() - visibilityChangeTimeRef.current;\n        lastTimestampRef.current += timeDelta;\n        nextSpawnTimeRef.current += timeDelta;\n      }\n    };\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n\n    // Capture current worker ref to avoid closure issues\n    const currentWorker = workerRef.current;\n\n    // Cleanup\n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n\n      // Clean up worker if active\n      if (currentWorker) {\n        currentWorker.terminate();\n      }\n    };\n  }, [detectCapabilities]);\n\n  // Initialize WebGL context and shaders if using WebGL\n  const initWebGL = useCallback(() => {\n    if (!canvasRef.current || actualRenderingMode !== 'webgl') return false;\n    try {\n      // Get WebGL context\n      const gl = canvasRef.current.getContext('webgl', {\n        alpha: true,\n        antialias: true,\n        premultipliedAlpha: false,\n        depth: false,\n        // Fix 4: Add WebGL context attributes for better stability\n        powerPreference: 'high-performance',\n        failIfMajorPerformanceCaveat: false\n      });\n      if (!gl) return false;\n      webGLRef.current = gl;\n\n      // Create shader programs, vertex buffers, etc.\n      // This is a simplified placeholder - a real implementation would include\n      // proper shaders, attribute locations, and uniform setup\n\n      // Enable blending for transparency\n      gl.enable(gl.BLEND);\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n      // Set clear color to fully transparent\n      gl.clearColor(0.0, 0.0, 0.0, 0.0);\n\n      // Get current dimensions for viewport\n      const canvasWidth = canvasRef.current.width;\n      const canvasHeight = canvasRef.current.height;\n\n      // Set viewport\n      gl.viewport(0, 0, canvasWidth, canvasHeight);\n\n      // Simple vertex shader for meteor particles\n      const vertexShaderSource = `\n        attribute vec2 aPosition;\n        attribute float aSize;\n        attribute vec4 aColor;\n        \n        varying vec4 vColor;\n        \n        uniform vec2 uResolution;\n        \n        void main() {\n          // Convert to clip space\n          vec2 position = (aPosition / uResolution) * 2.0 - 1.0;\n          position.y = -position.y;\n          \n          gl_Position = vec4(position, 0, 1);\n          gl_PointSize = aSize;\n          vColor = aColor;\n        }\n      `;\n\n      // Simple fragment shader for meteor particles\n      const fragmentShaderSource = `\n        precision mediump float;\n        varying vec4 vColor;\n        \n        void main() {\n          // Calculate distance from center for circular point\n          float distance = length(gl_PointCoord - vec2(0.5, 0.5));\n          if (distance > 0.5) {\n            discard; // Outside circle\n          }\n          \n          // Softer edges\n          float alpha = smoothstep(0.5, 0.4, distance) * vColor.a;\n          gl_FragColor = vec4(vColor.rgb, alpha);\n        }\n      `;\n\n      // Compile shader program\n      const createShader = (gl, type, source) => {\n        const shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n\n        // Check for compilation errors\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n          console.error('Shader compilation error:', gl.getShaderInfoLog(shader));\n          gl.deleteShader(shader);\n          return null;\n        }\n        return shader;\n      };\n      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n      if (!vertexShader || !fragmentShader) {\n        return false;\n      }\n      const program = gl.createProgram();\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n\n      // Check for linking errors\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        console.error('Program linking error:', gl.getProgramInfoLog(program));\n        gl.deleteProgram(program);\n        return false;\n      }\n\n      // Store the program\n      webGLProgramsRef.current.meteor = {\n        program,\n        attributes: {\n          position: gl.getAttribLocation(program, 'aPosition'),\n          size: gl.getAttribLocation(program, 'aSize'),\n          color: gl.getAttribLocation(program, 'aColor')\n        },\n        uniforms: {\n          resolution: gl.getUniformLocation(program, 'uResolution')\n        }\n      };\n\n      // Now create shader program for burst particles\n      // This can be similar to the meteor program but with different parameters\n\n      // Simple vertex shader for burst particles\n      const burstVertexShaderSource = `\n        attribute vec2 aPosition;\n        attribute float aSize;\n        attribute vec4 aColor;\n        \n        varying vec4 vColor;\n        \n        uniform vec2 uResolution;\n        \n        void main() {\n          // Convert to clip space\n          vec2 position = (aPosition / uResolution) * 2.0 - 1.0;\n          position.y = -position.y;\n          \n          gl_Position = vec4(position, 0, 1);\n          gl_PointSize = aSize;\n          vColor = aColor;\n        }\n      `;\n\n      // Simple fragment shader for burst particles with softer edges\n      const burstFragmentShaderSource = `\n        precision mediump float;\n        varying vec4 vColor;\n        \n        void main() {\n          // Calculate distance from center for circular point\n          float distance = length(gl_PointCoord - vec2(0.5, 0.5));\n          if (distance > 0.5) {\n            discard; // Outside circle\n          }\n          \n          // Very soft edges for burst particles\n          float alpha = smoothstep(0.5, 0.2, distance) * vColor.a;\n          gl_FragColor = vec4(vColor.rgb, alpha);\n        }\n      `;\n      const burstVertexShader = createShader(gl, gl.VERTEX_SHADER, burstVertexShaderSource);\n      const burstFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, burstFragmentShaderSource);\n      if (!burstVertexShader || !burstFragmentShader) {\n        return false;\n      }\n      const burstProgram = gl.createProgram();\n      gl.attachShader(burstProgram, burstVertexShader);\n      gl.attachShader(burstProgram, burstFragmentShader);\n      gl.linkProgram(burstProgram);\n\n      // Check for linking errors\n      if (!gl.getProgramParameter(burstProgram, gl.LINK_STATUS)) {\n        console.error('Burst program linking error:', gl.getProgramInfoLog(burstProgram));\n        gl.deleteProgram(burstProgram);\n      } else {\n        // Store the burst program\n        webGLProgramsRef.current.burst = {\n          program: burstProgram,\n          attributes: {\n            position: gl.getAttribLocation(burstProgram, 'aPosition'),\n            size: gl.getAttribLocation(burstProgram, 'aSize'),\n            color: gl.getAttribLocation(burstProgram, 'aColor')\n          },\n          uniforms: {\n            resolution: gl.getUniformLocation(burstProgram, 'uResolution')\n          }\n        };\n      }\n      return true;\n    } catch (error) {\n      console.error('WebGL initialization error:', error);\n      setActualRenderingMode('2d');\n      return false;\n    }\n  }, [actualRenderingMode]);\n\n  // Calculate path parameters for a meteor based on selected mode\n  const calculateMeteorPath = useCallback((width, height) => {\n    if (mode === 'arc') {\n      // Arc path logic with optimized parameters\n      const startX = Math.random() * width * 1.5 - width * 0.25;\n      const startY = Math.random() * -100 - 50;\n      const curveDirection = Math.random() > 0.5 ? 1 : -1;\n      const curveIntensity = Math.random() * 0.4 + 0.2;\n      const endX = startX + curveDirection * width * curveIntensity;\n      const endY = height * journeyCompletion;\n      const controlX = (startX + endX) / 2 + curveDirection * width * curveIntensity;\n      const controlY = (startY + endY) * 0.5;\n      return {\n        pathType: 'arc',\n        start: {\n          x: startX,\n          y: startY\n        },\n        control: {\n          x: controlX,\n          y: controlY\n        },\n        end: {\n          x: endX,\n          y: endY\n        }\n      };\n    } else if (mode === 'topArc') {\n      // New topArc path logic - meteors starting at top and curving downward\n      // Distribute starting positions across the top of the screen\n      const position = Math.random();\n      let startX;\n\n      // Better distribution to prevent clustering\n      if (position < 0.3) {\n        // left side\n        startX = Math.random() * (width * 0.3);\n      } else if (position < 0.7) {\n        // middle\n        startX = width * 0.3 + Math.random() * (width * 0.4);\n      } else {\n        // right side\n        startX = width * 0.7 + Math.random() * (width * 0.3);\n      }\n\n      // Start above the screen\n      const startY = Math.random() * -100 - 20;\n\n      // End position will be toward bottom of screen\n      const endY = height * journeyCompletion;\n\n      // Calculate end X with a tendency to curve toward center\n      // This creates an elegant \"shower\" effect where meteors fan outward\n      const centerPull = Math.random() * 0.4 + 0.3; // How much they curve toward center\n      const endX = width * 0.5 + (startX - width * 0.5) * (1 - centerPull);\n\n      // Calculate curve intensity with variation\n      const intensity = arcIntensity + (Math.random() * 2 - 1) * arcVariation;\n\n      // Create control point for the bezier curve\n      // Control X affects the horizontal curve - subtle offset to create natural arcs\n      const curveDirection = startX < width * 0.5 ? 1 : -1;\n      const controlX = startX + curveDirection * width * intensity * 0.2;\n\n      // Control Y affects the vertical arc - lower values create more pronounced arcs\n      // This puts the control point somewhere in the first third of the journey\n      const controlY = startY + (endY - startY) * (0.2 + Math.random() * 0.2);\n      return {\n        pathType: 'arc',\n        // Reuse arc rendering\n        start: {\n          x: startX,\n          y: startY\n        },\n        control: {\n          x: controlX,\n          y: controlY\n        },\n        end: {\n          x: endX,\n          y: endY\n        }\n      };\n    } else if (mode === 'linear') {\n      // Linear path logic with enhanced direction control\n      let meteorDirection = direction;\n      if (direction === 'both') {\n        meteorDirection = Math.random() > 0.5 ? 'left' : 'right';\n      }\n      let angle;\n      if (direction === 'top') {\n        // Fix 5: More consistent angle calculation for top direction\n        angle = (30 + (Math.random() * 2 - 1) * 5) * Math.PI / 180;\n      } else {\n        angle = (baseAngle + (Math.random() * 2 - 1) * angleVariation) * Math.PI / 180;\n      }\n      let startX;\n      if (meteorDirection === 'left') {\n        startX = Math.random() * (width * 0.3) - width * 0.1;\n      } else if (meteorDirection === 'right') {\n        startX = width - Math.random() * (width * 0.3) + width * 0.1;\n      } else if (direction === 'top') {\n        const position = Math.random();\n        // Fix 6: Better distribution to prevent clustering\n        if (position < 0.5) {\n          startX = Math.random() * (width * 0.35);\n        } else if (position < 0.85) {\n          startX = width * 0.35 + Math.random() * (width * 0.35);\n        } else {\n          startX = width * 0.7 + Math.random() * (width * 0.3);\n        }\n      }\n      const startY = Math.random() * -100 - 50;\n      const distanceToTravel = height * journeyCompletion / Math.cos(angle);\n      let endX, endY;\n      if (meteorDirection === 'left' || direction === 'top') {\n        endX = startX + distanceToTravel * Math.sin(angle);\n        endY = startY + distanceToTravel * Math.cos(angle);\n      } else {\n        endX = startX - distanceToTravel * Math.sin(angle);\n        endY = startY + distanceToTravel * Math.cos(angle);\n      }\n      return {\n        pathType: 'linear',\n        start: {\n          x: startX,\n          y: startY\n        },\n        end: {\n          x: endX,\n          y: endY\n        },\n        direction: meteorDirection\n      };\n    }\n  }, [mode, direction, baseAngle, angleVariation, journeyCompletion, arcIntensity, arcVariation]);\n\n  // Get point along path with highly optimized calculations\n  const getPathPoint = useCallback((t, path, outPoint = {\n    x: 0,\n    y: 0\n  }) => {\n    // Fix 7: Ensure t is always within valid range\n    const safeT = Math.max(0, Math.min(1, t));\n    if (path.pathType === 'arc') {\n      // Optimized quadratic bezier calculation using pre-computed terms\n      const invT = 1 - safeT;\n      const invTSquared = invT * invT;\n      const tSquared = safeT * safeT;\n      const term1 = invTSquared;\n      const term2 = 2 * invT * safeT;\n      const term3 = tSquared;\n      outPoint.x = term1 * path.start.x + term2 * path.control.x + term3 * path.end.x;\n      outPoint.y = term1 * path.start.y + term2 * path.control.y + term3 * path.end.y;\n    } else {\n      // Linear interpolation with minimal operations\n      outPoint.x = path.start.x + (path.end.x - path.start.x) * safeT;\n      outPoint.y = path.start.y + (path.end.y - path.start.y) * safeT;\n    }\n    return outPoint;\n  }, []);\n\n  // Calculate velocity at a point on the path (for trail orientation)\n  const getPathVelocity = useCallback((t, path, outVelocity = {\n    x: 0,\n    y: 0\n  }) => {\n    // Fix 8: Ensure t is always within valid range\n    const safeT = Math.max(0, Math.min(1, t));\n    if (path.pathType === 'arc') {\n      // Derivative of quadratic bezier\n      const term1 = 2 * (1 - safeT);\n      const term2 = 2 * safeT;\n      outVelocity.x = term1 * (path.control.x - path.start.x) + term2 * (path.end.x - path.control.x);\n      outVelocity.y = term1 * (path.control.y - path.start.y) + term2 * (path.end.y - path.control.y);\n    } else {\n      // Constant velocity for linear paths\n      outVelocity.x = path.end.x - path.start.x;\n      outVelocity.y = path.end.y - path.start.y;\n\n      // Normalize\n      const length = Math.sqrt(outVelocity.x * outVelocity.x + outVelocity.y * outVelocity.y);\n      if (length > 0) {\n        outVelocity.x /= length;\n        outVelocity.y /= length;\n      }\n    }\n    return outVelocity;\n  }, []);\n\n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current || !containerRef.current) return false;\n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    const rect = container.getBoundingClientRect();\n    const pixelRatio = window.devicePixelRatio || 1;\n\n    // Fix 9: Ensure canvas dimensions are valid integers to prevent rendering issues\n    // Calculate dimensions\n    const displayWidth = Math.floor(rect.width);\n    const displayHeight = typeof height === 'string' && height.endsWith('vh') ? Math.floor(parseInt(height, 10) / 100 * window.innerHeight) : Math.floor(parseInt(height, 10) || window.innerHeight);\n\n    // Set canvas size accounting for pixel ratio\n    canvas.width = displayWidth * pixelRatio;\n    canvas.height = displayHeight * pixelRatio;\n    canvas.style.width = `${displayWidth}px`;\n    canvas.style.height = `${displayHeight}px`;\n\n    // Get appropriate rendering context\n    if (actualRenderingMode === 'webgl') {\n      initWebGL();\n    } else {\n      // 2D Canvas context\n      const ctx = canvas.getContext('2d', {\n        alpha: true,\n        desynchronized: true,\n        willReadFrequently: false\n      });\n      if (!ctx) return false;\n\n      // Scale context for high-DPI displays\n      ctx.scale(pixelRatio, pixelRatio);\n\n      // Configure context for high-quality rendering\n      if (adaptedSettings.useHighQualityRendering) {\n        ctx.imageSmoothingEnabled = true;\n        ctx.imageSmoothingQuality = 'high';\n      }\n      ctxRef.current = ctx;\n    }\n\n    // Initialize offscreen canvas if supported and enabled\n    if (enableOffscreenRendering && typeof OffscreenCanvas !== 'undefined' && deviceCapabilities.supportsOffscreenCanvas) {\n      try {\n        // Create offscreen canvas\n        const offscreen = new OffscreenCanvas(displayWidth * pixelRatio, displayHeight * pixelRatio);\n\n        // Get 2D context for offscreen canvas\n        const offscreenCtx = offscreen.getContext('2d');\n        if (offscreenCtx) {\n          offscreenCtx.scale(pixelRatio, pixelRatio);\n          offscreenCanvasRef.current = {\n            canvas: offscreen,\n            ctx: offscreenCtx\n          };\n        }\n      } catch (error) {\n        console.warn('Offscreen canvas initialization error:', error);\n      }\n    }\n    setDimensions({\n      width: displayWidth,\n      height: displayHeight,\n      pixelRatio\n    });\n    return true;\n  }, [height, actualRenderingMode, initWebGL, enableOffscreenRendering, deviceCapabilities.supportsOffscreenCanvas, adaptedSettings.useHighQualityRendering]);\n\n  // Setup canvas resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Create a ResizeObserver to detect container size changes\n    const resizeObserver = new ResizeObserver(entries => {\n      // Debounce resize operations\n      if (resizeObserverRef.current.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n      resizeObserverRef.current.timeout = setTimeout(() => {\n        requestAnimationFrame(() => {\n          if (setupCanvas()) {\n            setIsInitialized(true);\n          }\n        });\n      }, 100); // 100ms debounce\n    });\n\n    // Capture current reference to avoid closure issues in cleanup\n    const currentContainer = containerRef.current;\n\n    // Start observing the container\n    resizeObserver.observe(currentContainer);\n    resizeObserverRef.current = {\n      observer: resizeObserver\n    };\n\n    // Initial setup\n    setupCanvas();\n    setIsInitialized(true);\n    return () => {\n      if (resizeObserverRef.current.observer) {\n        resizeObserverRef.current.observer.disconnect();\n      }\n      if (resizeObserverRef.current.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n    };\n  }, [setupCanvas]);\n\n  // Setup intersection observer to only animate when visible\n  useEffect(() => {\n    if (!containerRef.current) return;\n    const observer = new IntersectionObserver(entries => {\n      const isIntersecting = entries[0].isIntersecting;\n\n      // Only change state if visibility actually changed\n      if (isIntersecting !== isVisible) {\n        setIsVisible(isIntersecting);\n        if (isIntersecting) {\n          // Reset timing references when becoming visible again\n          lastTimestampRef.current = 0;\n          nextSpawnTimeRef.current = performance.now();\n        }\n      }\n    }, {\n      threshold: 0.01,\n      rootMargin: '100px'\n    });\n\n    // Store current reference to avoid closure issues\n    const currentContainerRef = containerRef.current;\n    observer.observe(currentContainerRef);\n    visibilityObserverRef.current = observer;\n    return () => {\n      if (visibilityObserverRef.current) {\n        visibilityObserverRef.current.disconnect();\n      }\n    };\n  }, [isVisible]);\n\n  // Handle parallax effect on scroll if enabled\n  useEffect(() => {\n    if (!enableParallax) return;\n\n    // Use passive event listener for better performance\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    window.addEventListener('scroll', handleScroll, {\n      passive: true\n    });\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [enableParallax]);\n\n  // Get a meteor from the object pool or create a new one\n  const getMeteor = useCallback(() => {\n    // Try to get from pool first\n    const pool = objectPoolsRef.current.meteors;\n    let meteor;\n    if (pool.length > 0) {\n      meteor = pool.pop();\n      // Reset meteor properties\n      meteor.progress = 0;\n      meteor.active = true;\n    } else {\n      // Create new if pool is empty\n      meteor = {\n        progress: 0,\n        active: true,\n        positions: Array(adaptedSettings.trailSegments)\n      };\n\n      // Pre-allocate position objects\n      for (let i = 0; i < adaptedSettings.trailSegments; i++) {\n        meteor.positions[i] = {\n          x: 0,\n          y: 0\n        };\n      }\n    }\n    return meteor;\n  }, [adaptedSettings.trailSegments]);\n\n  // Initialize a meteor with all required properties\n  const initializeMeteor = useCallback(() => {\n    const {\n      width,\n      height\n    } = dimensions;\n    if (!width || !height) return null;\n\n    // Get meteor from pool\n    const meteor = getMeteor();\n\n    // Calculate path based on mode\n    const path = calculateMeteorPath(width, height);\n\n    // Set path and initial position\n    meteor.path = path;\n\n    // Fix 10: Ensure all positions are initialized properly to prevent flickering\n    const initialPoint = {\n      x: path.start.x,\n      y: path.start.y\n    };\n    for (let i = 0; i < meteor.positions.length; i++) {\n      if (!meteor.positions[i]) {\n        meteor.positions[i] = {\n          x: initialPoint.x,\n          y: initialPoint.y\n        };\n      } else {\n        meteor.positions[i].x = initialPoint.x;\n        meteor.positions[i].y = initialPoint.y;\n      }\n    }\n\n    // Set meteor properties\n    meteor.size = Math.random() * (meteorMaxSize - meteorMinSize) + meteorMinSize;\n    meteor.speed = meteorSpeed * (Math.random() * 0.5 + 0.75);\n    meteor.opacity = Math.random() * 0.3 + 0.7;\n    meteor.fadeThreshold = 0.7 + Math.random() * 0.2;\n    meteor.pulsePhase = Math.random() * Math.PI * 2;\n    meteor.pulseSpeed = Math.random() * 0.01 + 0.005;\n\n    // Add burst properties if enabled\n    if (enableBursts && Math.random() < burstProbability) {\n      meteor.hasBurst = true;\n\n      // Vary the burst threshold - occasionally have early bursts for variety\n      const earlyBurst = Math.random() < 0.15; // 15% chance for early burst\n      meteor.burstThreshold = earlyBurst ? 0.3 + Math.random() * 0.4 // Early burst range (0.3-0.7)\n      : 0.85 + Math.random() * 0.13; // Normal late burst range (0.85-0.98)\n\n      meteor.burstTriggered = false;\n\n      // Adjust burst size based on when it occurs\n      meteor.burstSize = earlyBurst ? meteor.size * (3 + Math.random() * 4) // Larger for early bursts\n      : meteor.size * (2 + Math.random() * 2); // More controlled for end bursts\n\n      // Adjust particle count based on when it occurs\n      meteor.burstParticles = Math.floor(adaptedSettings.burstParticleCount * (earlyBurst ? 1.2 : 0.8) * (\n      // More particles for early bursts\n      0.8 + Math.random() * 0.4));\n\n      // Use custom gold-centric colors for dark fantasy aesthetic\n      // No need to use createColorVariant here since we're using specific themed colors\n      meteor.burstColors = ['rgba(255, 215, 0, 1)',\n      // Gold\n      'rgba(218, 165, 32, 1)',\n      // Goldenrod\n      'rgba(212, 175, 55, 1)',\n      // Metallic gold\n      'rgba(207, 181, 59, 1)',\n      // Old gold\n      earlyBurst ? 'rgba(255, 255, 220, 1)' : 'rgba(192, 192, 192, 1)' // Bright for early, silver for late\n      ];\n    } else {\n      meteor.hasBurst = false;\n    }\n    return meteor;\n  }, [dimensions, calculateMeteorPath, meteorMinSize, meteorMaxSize, meteorSpeed, enableBursts, burstProbability, adaptedSettings.burstParticleCount, getMeteor]);\n\n  // Get a burst particle from the object pool or create a new one\n  const getBurstParticle = useCallback(() => {\n    const pool = objectPoolsRef.current.bursts;\n    if (pool.length > 0) {\n      const burst = pool.pop();\n      // Reset properties\n      burst.life = 1.0;\n      return burst;\n    }\n\n    // Create new if pool is empty\n    return {};\n  }, []);\n\n  // Create a burst effect at a specified position\n  const createBurst = useCallback((x, y, size, colors, particleCount, velocityInfluence = {\n    x: 0,\n    y: 0\n  }) => {\n    // Skip if bursts are not enabled\n    if (!enableBursts) return;\n\n    // Fix 11: Limit bursts to prevent overloading and causing flickering\n    // Limit the number of active burst particles to avoid performance issues\n    const maxBurstParticles = adaptedSettings.useHighQualityRendering ? 300 : 150;\n\n    // If we're already close to the limit, reduce the number of particles\n    let actualParticleCount = particleCount;\n    if (burstsRef.current.length > maxBurstParticles - particleCount) {\n      actualParticleCount = Math.max(4, Math.floor(particleCount * 0.5));\n    }\n\n    // Skip burst creation completely if we're already over the limit\n    if (burstsRef.current.length > maxBurstParticles) {\n      // Remove older bursts to make room\n      const toRemove = Math.min(20, burstsRef.current.length - maxBurstParticles + actualParticleCount);\n      for (let i = 0; i < toRemove; i++) {\n        const oldBurst = burstsRef.current.shift();\n        if (oldBurst) {\n          objectPoolsRef.current.bursts.push(oldBurst);\n        }\n      }\n    }\n\n    // Track burst counts for debug\n    lastBurstCountRef.current = actualParticleCount;\n\n    // Create fragments that look like pieces of the meteor breaking apart\n    for (let i = 0; i < actualParticleCount; i++) {\n      // Create directional burst effect following the meteor's trajectory\n      const baseAngle = Math.atan2(velocityInfluence.y, velocityInfluence.x);\n\n      // Calculate particle direction - within a forward-facing cone\n      const angleSpread = 1.2; // Narrower spread for more focused effect\n      const angleVariance = Math.random() * angleSpread - angleSpread / 2;\n      const angle = baseAngle + angleVariance;\n\n      // Speed - slower for a more elegant effect\n      const speedVariance = Math.random() * 0.4 + 0.7;\n      const baseSpeed = 0.4 + Math.random() * 0.8; // Slower overall\n      const speed = baseSpeed * speedVariance;\n\n      // Calculate velocity components\n      const vx = Math.cos(angle) * speed + velocityInfluence.x * 0.4;\n      const vy = Math.sin(angle) * speed + velocityInfluence.y * 0.4;\n\n      // Create fragments of different sizes\n      const sizeVariance = 0.2 + Math.random() * 0.8;\n      const particleSize = size * sizeVariance * burstParticleSize * 0.6;\n\n      // Use meteor's colors for the fragments\n      const colorIndex = Math.random() < 0.7 ? 0 : 1; // 70% core color, 30% glow color\n      const color = colorIndex === 0 ? coreColor : glowColor;\n\n      // Create the burst particle\n      const burst = getBurstParticle();\n\n      // Set properties\n      burst.x = x;\n      burst.y = y;\n      burst.vx = vx;\n      burst.vy = vy;\n      burst.size = particleSize;\n      burst.life = 1.0;\n      burst.decay = 0.006 + Math.random() * 0.01; // Slower decay\n      burst.color = color;\n      burst.trailLength = 2 + Math.random() * 6; // Length of trail behind fragment\n\n      // More elegantly diminishing velocity\n      burst.damping = 0.95 + Math.random() * 0.03;\n\n      // Add to active bursts\n      burstsRef.current.push(burst);\n    }\n  }, [enableBursts, adaptedSettings.useHighQualityRendering, getBurstParticle, burstParticleSize, coreColor, glowColor]);\n\n  // Render burst particles with WebGL\n  const renderBurstsWebGL = _s(useCallback(_s((gl, deltaTime) => {\n    _s();\n    if (!enableBursts || burstsRef.current.length === 0 || !webGLProgramsRef.current.burst) return;\n    const burstProgram = webGLProgramsRef.current.burst;\n\n    // Use burst shader program\n    gl.useProgram(burstProgram.program);\n\n    // Set resolution uniform\n    gl.uniform2f(burstProgram.uniforms.resolution, canvasRef.current.width, canvasRef.current.height);\n\n    // Create float32 arrays to hold position, size, and color data\n    // 2 floats per position (x, y)\n    const positions = new Float32Array(burstsRef.current.length * 2);\n    // 1 float per size\n    const sizes = new Float32Array(burstsRef.current.length);\n    // 4 floats per color (r, g, b, a)\n    const colors = new Float32Array(burstsRef.current.length * 4);\n\n    // Process each burst particle and update its data\n    for (let i = 0; i < burstsRef.current.length; i++) {\n      const burst = burstsRef.current[i];\n\n      // Update position\n      burst.x += burst.vx * (deltaTime / 16);\n      burst.y += burst.vy * (deltaTime / 16);\n\n      // Apply gravity if present\n      if (burst.gravity) {\n        burst.vy += burst.gravity * (deltaTime / 16);\n      }\n\n      // Apply damping to velocity\n      burst.vx *= burst.damping;\n      burst.vy *= burst.damping;\n\n      // Update rotation\n      if (burst.rotationSpeed) {\n        burst.rotation += burst.rotationSpeed * (deltaTime / 16);\n      }\n\n      // Reduce life\n      burst.life -= burst.decay * (deltaTime / 16);\n\n      // Map burst data to arrays\n      const posIndex = i * 2;\n      positions[posIndex] = burst.x;\n      positions[posIndex + 1] = burst.y;\n      sizes[i] = burst.size * Math.pow(burst.life, 0.7) * dimensions.pixelRatio;\n\n      // Parse color components from rgba string\n      // Fix 12: Safer color handling for WebGL\n      const colorIndex = i * 4;\n      colors[colorIndex] = 1.0; // r\n      colors[colorIndex + 1] = 0.9; // g\n      colors[colorIndex + 2] = 0.7; // b\n      colors[colorIndex + 3] = Math.max(0, Math.min(1, burst.life * 0.7)); // a - clamped for safety\n    }\n\n    // Create and bind position buffer\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(burstProgram.attributes.position);\n    gl.vertexAttribPointer(burstProgram.attributes.position, 2, gl.FLOAT, false, 0, 0);\n\n    // Create and bind size buffer\n    const sizeBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, sizes, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(burstProgram.attributes.size);\n    gl.vertexAttribPointer(burstProgram.attributes.size, 1, gl.FLOAT, false, 0, 0);\n\n    // Create and bind color buffer\n    const colorBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(burstProgram.attributes.color);\n    gl.vertexAttribPointer(burstProgram.attributes.color, 4, gl.FLOAT, false, 0, 0);\n\n    // Draw points\n    gl.drawArrays(gl.POINTS, 0, burstsRef.current.length);\n\n    // Clean up\n    gl.disableVertexAttribArray(burstProgram.attributes.position);\n    gl.disableVertexAttribArray(burstProgram.attributes.size);\n    gl.disableVertexAttribArray(burstProgram.attributes.color);\n    gl.deleteBuffer(positionBuffer);\n    gl.deleteBuffer(sizeBuffer);\n    gl.deleteBuffer(colorBuffer);\n\n    // Filter out dead particles\n    let j = 0;\n    for (let i = 0; i < burstsRef.current.length; i++) {\n      const burst = burstsRef.current[i];\n      if (burst.life > 0) {\n        // Keep alive particles, compact array\n        if (i !== j) {\n          burstsRef.current[j] = burst;\n        }\n        j++;\n      } else {\n        // Return to object pool\n        objectPoolsRef.current.bursts.push(burst);\n      }\n    }\n\n    // Truncate array to remove dead particles\n    if (j < burstsRef.current.length) {\n      burstsRef.current.length = j;\n    }\n  }, \"ZdQBZ3rq7bWAAMQq6hlVCmYF0jM=\", false, function () {\n    return [gl.useProgram];\n  }), [enableBursts, dimensions.pixelRatio]), \"ZdQBZ3rq7bWAAMQq6hlVCmYF0jM=\", true);\n\n  // Render burst particles with Canvas 2D\n  const renderBursts2D = useCallback((ctx, deltaTime) => {\n    if (!enableBursts || burstsRef.current.length === 0) return;\n\n    // Fix 13: Use a more efficient approach to avoid array splicing during rendering\n    // Process and render each burst particle\n    let j = 0;\n    for (let i = 0; i < burstsRef.current.length; i++) {\n      const burst = burstsRef.current[i];\n\n      // Update position\n      burst.x += burst.vx * (deltaTime / 16);\n      burst.y += burst.vy * (deltaTime / 16);\n\n      // Apply damping to velocity\n      burst.vx *= burst.damping;\n      burst.vy *= burst.damping;\n\n      // Reduce life\n      burst.life -= burst.decay * (deltaTime / 16);\n\n      // Keep alive particles\n      if (burst.life > 0) {\n        // Draw particle\n        ctx.save();\n\n        // Get velocity direction for trail orientation\n        const angle = Math.atan2(burst.vy, burst.vx);\n        if (adaptedSettings.useHighQualityRendering) {\n          // Draw trail behind fragment\n          const trailLength = (burst.trailLength || 4) * burst.life;\n          const fragmentSize = burst.size * burst.life;\n\n          // Create trail gradient\n          const trailGradient = ctx.createLinearGradient(burst.x, burst.y, burst.x - Math.cos(angle) * trailLength, burst.y - Math.sin(angle) * trailLength);\n\n          // Get the base color with varying opacity\n          trailGradient.addColorStop(0, getCachedColor(burst.color, burst.life * 0.8));\n          trailGradient.addColorStop(0.5, getCachedColor(burst.color, burst.life * 0.4));\n          trailGradient.addColorStop(1, getCachedColor(burst.color, 0));\n\n          // Draw trail\n          ctx.beginPath();\n          ctx.moveTo(burst.x, burst.y);\n          ctx.lineTo(burst.x - Math.cos(angle) * trailLength, burst.y - Math.sin(angle) * trailLength);\n          ctx.lineWidth = fragmentSize * 0.8;\n          ctx.lineCap = 'round';\n          ctx.strokeStyle = trailGradient;\n          ctx.stroke();\n\n          // Draw fragment\n          if (adaptedSettings.useGlow) {\n            ctx.shadowColor = burst.color;\n            ctx.shadowBlur = fragmentSize * 2;\n          }\n          ctx.beginPath();\n          ctx.arc(burst.x, burst.y, fragmentSize * 0.5, 0, Math.PI * 2);\n          ctx.fillStyle = getCachedColor(burst.color, burst.life);\n          ctx.fill();\n        } else {\n          // Simplified rendering for lower performance devices\n          const trailLength = (burst.trailLength || 3) * burst.life;\n          const fragmentSize = burst.size * burst.life;\n\n          // Draw simple tapered line\n          ctx.beginPath();\n          ctx.moveTo(burst.x, burst.y);\n          ctx.lineTo(burst.x - Math.cos(angle) * trailLength, burst.y - Math.sin(angle) * trailLength);\n          ctx.lineWidth = fragmentSize * 0.7;\n          ctx.lineCap = 'round';\n          ctx.strokeStyle = getCachedColor(burst.color, burst.life * 0.6);\n          ctx.stroke();\n        }\n        ctx.restore();\n\n        // Compact alive particles\n        if (i !== j) {\n          burstsRef.current[j] = burst;\n        }\n        j++;\n      } else {\n        // Return to object pool\n        objectPoolsRef.current.bursts.push(burst);\n      }\n    }\n\n    // Truncate array to remove dead particles\n    if (j < burstsRef.current.length) {\n      burstsRef.current.length = j;\n    }\n  }, [enableBursts, adaptedSettings.useHighQualityRendering, adaptedSettings.useGlow, getCachedColor]);\n\n  // 2D Canvas rendering method for meteors\n  const renderMeteors2D = useCallback((ctx, parallaxOffset, timestamp) => {\n    // Process and render each meteor\n    meteorsRef.current.forEach(meteor => {\n      // Fix 14: Ensure position array is valid to prevent flickering\n      if (!meteor.positions || !meteor.positions[0]) return;\n\n      // Calculate opacity based on progress\n      let currentOpacity = meteor.opacity;\n      if (meteor.progress > meteor.fadeThreshold) {\n        const fadeProgress = (meteor.progress - meteor.fadeThreshold) / (1 - meteor.fadeThreshold);\n        currentOpacity = meteor.opacity * (1 - fadeProgress);\n      }\n\n      // Apply pulse effect\n      const timeFactor = timestamp * 0.001;\n      const pulseEffect = Math.sin(timeFactor * meteor.pulseSpeed + meteor.pulsePhase) * 0.2 + 0.8;\n\n      // Parallax offset adjustment\n      const adjustY = enableParallax ? parallaxOffset * (meteor.size / meteorMaxSize) : 0;\n\n      // Check if we should create a burst effect\n      if (meteor.hasBurst && !meteor.burstTriggered && meteor.progress >= meteor.burstThreshold) {\n        meteor.burstTriggered = true;\n        const burstPosition = meteor.positions[0];\n\n        // Get velocity at burst point for influence on particles\n        const velocityPoint = {\n          x: 0,\n          y: 0\n        };\n        getPathVelocity(meteor.progress, meteor.path, velocityPoint);\n\n        // Scale velocity for better visual effect\n        velocityPoint.x *= 0.8;\n        velocityPoint.y *= 0.8;\n\n        // Create burst with velocity influence\n        createBurst(burstPosition.x, burstPosition.y + adjustY, meteor.burstSize, meteor.burstColors, meteor.burstParticles, velocityPoint);\n\n        // Start fading process after burst\n        meteor.burstFadeStartTime = timestamp;\n        meteor.fadeAfterBurst = true;\n        meteor.initialOpacity = meteor.opacity; // Store original opacity for smooth fade\n      }\n\n      // Apply fading effect after burst\n      if (meteor.fadeAfterBurst) {\n        // Calculate fade progress over 600ms (adjust for desired fade duration)\n        const fadeDuration = 600;\n        const fadeProgress = Math.min(1, (timestamp - meteor.burstFadeStartTime) / fadeDuration);\n\n        // Apply eased fade out\n        const fadeEase = 1 - fadeProgress * fadeProgress; // Quadratic ease out\n        currentOpacity *= fadeEase;\n\n        // If almost completely faded, mark for removal\n        if (fadeProgress >= 0.95) {\n          meteor.terminateAfterBurst = true;\n        }\n      }\n\n      // Optimized rendering approach\n      if (adaptedSettings.useHighQualityRendering) {\n        // High-quality rendering with shadows\n        // Set shadow for glow effect if enabled\n        if (adaptedSettings.useGlow) {\n          ctx.shadowColor = glowColor;\n          ctx.shadowBlur = meteor.size * 3 * pulseEffect;\n        }\n\n        // Draw trail segments\n        ctx.lineCap = 'round';\n        for (let i = meteor.positions.length - 2; i >= 0; i--) {\n          const pos1 = meteor.positions[i];\n          const pos2 = meteor.positions[i + 1];\n          if (!pos1 || !pos2) continue;\n\n          // Calculate segment opacity (decreases along the trail)\n          const segmentOpacity = currentOpacity * (1 - i / meteor.positions.length) * pulseEffect;\n\n          // Skip if nearly invisible\n          if (segmentOpacity < 0.02) continue;\n\n          // Calculate segment width (decreases along the trail)\n          const segmentWidth = meteor.size * (1 - i / meteor.positions.length * 0.7);\n\n          // Draw line segment\n          ctx.beginPath();\n          ctx.moveTo(pos1.x, pos1.y + adjustY);\n          ctx.lineTo(pos2.x, pos2.y + adjustY);\n\n          // Set line style\n          ctx.lineWidth = segmentWidth;\n          ctx.strokeStyle = getCachedColor(trailColor, segmentOpacity);\n          ctx.stroke();\n        }\n\n        // Draw meteor head\n        if (meteor.positions[0]) {\n          const headPos = meteor.positions[0];\n\n          // Set shadow for head\n          if (adaptedSettings.useShadow) {\n            ctx.shadowColor = glowColor;\n            ctx.shadowBlur = meteor.size * 5 * pulseEffect;\n          }\n\n          // Draw outer glow\n          ctx.beginPath();\n          ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 1.5, 0, Math.PI * 2);\n          ctx.fillStyle = getCachedColor(glowColor, currentOpacity * 0.7 * pulseEffect);\n          ctx.fill();\n\n          // Draw inner core\n          ctx.beginPath();\n          ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 0.7, 0, Math.PI * 2);\n          ctx.fillStyle = getCachedColor(coreColor, currentOpacity * pulseEffect);\n          ctx.fill();\n        }\n      } else {\n        // Performance-optimized rendering for lower-end devices\n        // Draw simplified trail\n        ctx.beginPath();\n        const headPos = meteor.positions[0];\n        if (!headPos) return;\n        ctx.moveTo(headPos.x, headPos.y + adjustY);\n        for (let i = 1; i < meteor.positions.length; i += 2) {\n          const pos = meteor.positions[i];\n          if (!pos) continue;\n          ctx.lineTo(pos.x, pos.y + adjustY);\n        }\n\n        // Gradient trail\n        const gradient = ctx.createLinearGradient(headPos.x, headPos.y + adjustY, meteor.positions[meteor.positions.length - 1].x, meteor.positions[meteor.positions.length - 1].y + adjustY);\n        gradient.addColorStop(0, getCachedColor(coreColor, currentOpacity * pulseEffect));\n        gradient.addColorStop(0.3, getCachedColor(glowColor, currentOpacity * 0.7 * pulseEffect));\n        gradient.addColorStop(1, getCachedColor(trailColor, 0));\n        ctx.strokeStyle = gradient;\n        ctx.lineWidth = meteor.size;\n        ctx.lineCap = 'round';\n        ctx.stroke();\n\n        // Simple head\n        ctx.beginPath();\n        ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 0.7, 0, Math.PI * 2);\n        ctx.fillStyle = getCachedColor(coreColor, currentOpacity * pulseEffect);\n        ctx.fill();\n      }\n    });\n  }, [adaptedSettings.useHighQualityRendering, adaptedSettings.useGlow, adaptedSettings.useShadow, enableParallax, meteorMaxSize, glowColor, trailColor, coreColor, getCachedColor, createBurst, getPathVelocity]);\n\n  // WebGL rendering method\n  const renderMeteorsWebGL = _s2(useCallback(_s2((gl, timestamp) => {\n    _s2();\n    // This is a simplified placeholder for WebGL rendering\n    // A full implementation would use the shaders and buffers set up earlier\n\n    if (!gl || !webGLProgramsRef.current.meteor) return;\n\n    // Clear canvas\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    // Use meteor shader program\n    const meteorProgram = webGLProgramsRef.current.meteor;\n    gl.useProgram(meteorProgram.program);\n\n    // Set uniforms\n    gl.uniform2f(meteorProgram.uniforms.resolution, canvasRef.current.width, canvasRef.current.height);\n\n    // This is where we would bind vertex buffers and render particles\n    // For a real implementation, you would:\n    // 1. Update vertex buffer with current meteor positions\n    // 2. Set attributes for position, size, color\n    // 3. Draw using gl.POINTS or other appropriate primitives\n\n    // Check for burst triggers in WebGL mode too\n    meteorsRef.current.forEach(meteor => {\n      if (meteor.hasBurst && !meteor.burstTriggered && meteor.progress >= meteor.burstThreshold) {\n        meteor.burstTriggered = true;\n        const burstPosition = meteor.positions[0];\n\n        // Get velocity at burst point for influence on particles\n        const velocityPoint = {\n          x: 0,\n          y: 0\n        };\n        getPathVelocity(meteor.progress, meteor.path, velocityPoint);\n\n        // Create burst with velocity influence\n        // This will add particles to be rendered by renderBurstsWebGL\n        createBurst(burstPosition.x, burstPosition.y, meteor.burstSize, meteor.burstColors, meteor.burstParticles, velocityPoint);\n      }\n    });\n  }, \"ZdQBZ3rq7bWAAMQq6hlVCmYF0jM=\", false, function () {\n    return [gl.useProgram];\n  }), [createBurst, getPathVelocity]), \"ZdQBZ3rq7bWAAMQq6hlVCmYF0jM=\", true);\n\n  // Update meteor positions\n  const updateMeteors = useCallback(deltaTime => {\n    // Fix 15: More stable progress calculation to prevent position jumps\n    // Apply a maximum delta time to prevent large jumps after tab switching or lag spikes\n    const cappedDeltaTime = Math.min(deltaTime, 50);\n\n    // Process meteors without destructuring unused width/height\n    for (let i = meteorsRef.current.length - 1; i >= 0; i--) {\n      const meteor = meteorsRef.current[i];\n\n      // Update progress based on speed and delta time\n      meteor.progress += meteor.speed * (cappedDeltaTime / 1000);\n\n      // Check if meteor has completed its path or has fully faded after burst\n      if (meteor.progress >= 1 || meteor.terminateAfterBurst && meteor.burstTriggered) {\n        // Return to object pool\n        meteor.active = false;\n        meteor.terminateAfterBurst = false; // Reset for reuse\n        meteor.burstTriggered = false; // Reset for reuse\n        meteor.fadeAfterBurst = false; // Reset fade state\n        meteor.burstFadeStartTime = 0; // Reset fade timing\n        objectPoolsRef.current.meteors.push(meteor);\n        meteorsRef.current.splice(i, 1);\n        continue;\n      }\n\n      // Calculate current position along the path\n      const currentPos = getPathPoint(Math.min(1, meteor.progress), meteor.path, pointCache.current);\n\n      // Fix 16: More stable position history update to prevent flickering\n      // Update position history (for trail) using optimized array management\n      // First, check if the position array exists and has enough elements\n      if (!meteor.positions || meteor.positions.length < 2) continue;\n\n      // Shift positions array one by one to maintain proper history\n      for (let j = meteor.positions.length - 1; j > 0; j--) {\n        const current = meteor.positions[j];\n        const prev = meteor.positions[j - 1];\n        if (!current || !prev) continue;\n        current.x = prev.x;\n        current.y = prev.y;\n      }\n\n      // Update head position\n      meteor.positions[0].x = currentPos.x;\n      meteor.positions[0].y = currentPos.y;\n    }\n\n    // Spawn new meteors if needed\n    const now = performance.now();\n    const spawnNeeded = meteorsRef.current.length < adaptedSettings.meteorDensity;\n    const canSpawnNow = !staggered || now >= nextSpawnTimeRef.current;\n    if (spawnNeeded && canSpawnNow) {\n      const newMeteor = initializeMeteor();\n      if (newMeteor) {\n        meteorsRef.current.push(newMeteor);\n\n        // Set next spawn time if staggering is enabled\n        if (staggered) {\n          const delay = Math.random() * (maxStaggerDelay - minStaggerDelay) + minStaggerDelay;\n          nextSpawnTimeRef.current = now + delay;\n        }\n      }\n    }\n    // Dependencies for updateMeteors\n  }, [adaptedSettings.meteorDensity, staggered, minStaggerDelay, maxStaggerDelay, initializeMeteor, getPathPoint, pointCache]);\n\n  // FPS limiter for consistent animation speed\n  const fpsLimiter = useCallback((timestamp, callback) => {\n    // Skip animation if hidden, inactive, or reduced motion\n    if (!isVisible || !active || respectReducedMotion && prefersReducedMotion || document.hidden) {\n      animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n      return;\n    }\n    const targetFrameTime = 1000 / maxFPS;\n    const elapsed = timestamp - lastTimestampRef.current;\n    if (elapsed >= targetFrameTime || lastTimestampRef.current === 0) {\n      // Calculate correct delta\n      const delta = lastTimestampRef.current === 0 ? 16 : elapsed;\n\n      // Update timestamp, limiting delta to avoid jumps after inactivity\n      lastTimestampRef.current = timestamp - elapsed % targetFrameTime;\n\n      // Run animation callback with capped delta time\n      callback(Math.min(delta, 50));\n\n      // FPS tracking for debug and adaptive quality\n      frameCountRef.current++;\n      if (timestamp - fpsTimestampRef.current >= 1000) {\n        currentFpsRef.current = frameCountRef.current;\n        frameCountRef.current = 0;\n        fpsTimestampRef.current = timestamp;\n\n        // Log FPS in debug mode\n        if (debug) {\n          console.log(`MeteorShower FPS: ${currentFpsRef.current}, Quality: ${qualityFactor.toFixed(2)}`);\n        }\n\n        // Fix 17: More stable quality adjustment to prevent flickering during quality changes\n        // Dynamic quality adjustment based on performance with debouncing\n        if (adaptiveQuality) {\n          // Check if FPS is stable by counting consecutive frames within target range\n          if (currentFpsRef.current >= maxFPS * 0.95) {\n            stableFrameCountRef.current += 1;\n          } else if (currentFpsRef.current < maxFPS * 0.7) {\n            stableFrameCountRef.current = 0;\n          }\n\n          // Avoid frequent quality changes by using a timer\n          if (qualityChangeTimerRef.current) {\n            clearTimeout(qualityChangeTimerRef.current);\n          }\n          qualityChangeTimerRef.current = setTimeout(() => {\n            // Only change quality if FPS has been stable or is very low\n            if (currentFpsRef.current < maxFPS * 0.7) {\n              // If FPS is below 70% of target, reduce quality\n              setQualityFactor(prev => {\n                const newQuality = Math.max(0.4, prev * 0.9);\n                lastQualityFactorRef.current = newQuality;\n                return newQuality;\n              });\n            } else if (stableFrameCountRef.current >= 3 && qualityFactor < 1) {\n              // If FPS has been high for several frames, gradually increase quality\n              setQualityFactor(prev => {\n                const newQuality = Math.min(1, prev * 1.05);\n                lastQualityFactorRef.current = newQuality;\n                return newQuality;\n              });\n            }\n          }, 500); // Wait 500ms before changing quality to avoid rapid oscillation\n        }\n      }\n    }\n\n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n  }, [isVisible, active, respectReducedMotion, prefersReducedMotion, maxFPS, debug, adaptiveQuality, qualityFactor]);\n\n  // Main animation handler\n  const handleAnimation = useCallback(deltaTime => {\n    // Skip if component is not ready\n    if (!canvasRef.current || !isInitialized) return;\n    const now = performance.now();\n\n    // Calculate parallax offset if enabled\n    let parallaxOffset = 0;\n    if (enableParallax) {\n      parallaxOffset = scrollPositionRef.current * parallaxIntensity;\n    }\n\n    // Update meteor positions\n    updateMeteors(deltaTime);\n\n    // Render based on selected mode\n    if (actualRenderingMode === 'webgl' && webGLRef.current) {\n      // WebGL rendering path\n      renderMeteorsWebGL(webGLRef.current, now);\n\n      // Render burst particles with WebGL\n      if (enableBursts) {\n        renderBurstsWebGL(webGLRef.current, deltaTime);\n      }\n    } else {\n      // Canvas 2D rendering path\n      const ctx = ctxRef.current;\n      if (!ctx) return;\n\n      // Fix 18: More reliable canvas clearing to prevent flickering artifacts\n      // Clear canvas with optimized clear method\n      ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n\n      // Render meteors\n      renderMeteors2D(ctx, parallaxOffset, now);\n\n      // Render burst particles\n      if (enableBursts) {\n        renderBursts2D(ctx, deltaTime);\n      }\n\n      // Debug visualization\n      if (debug) {\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n        ctx.font = '12px monospace';\n        ctx.fillText(`FPS: ${currentFpsRef.current}`, 10, 20);\n        ctx.fillText(`Meteors: ${meteorsRef.current.length}/${adaptedSettings.meteorDensity}`, 10, 40);\n        ctx.fillText(`Quality: ${qualityFactor.toFixed(2)}`, 10, 60);\n        ctx.fillText(`Rendering: ${actualRenderingMode}`, 10, 80);\n        if (enableBursts) {\n          ctx.fillText(`Bursts: ${burstsRef.current.length}`, 10, 100);\n          ctx.fillText(`Last Burst: ${lastBurstCountRef.current}`, 10, 120);\n        }\n      }\n    }\n  }, [isInitialized, dimensions, adaptedSettings.meteorDensity, enableParallax, parallaxIntensity, actualRenderingMode, debug, updateMeteors, renderMeteors2D, renderMeteorsWebGL, enableBursts, renderBursts2D, renderBurstsWebGL, qualityFactor]);\n\n  // Main animation loop\n  useEffect(() => {\n    if (!active || !isInitialized || !dimensions.width || !dimensions.height) {\n      return;\n    }\n\n    // Start animation with FPS limiter\n    fpsTimestampRef.current = performance.now();\n    frameCountRef.current = 0;\n    lastTimestampRef.current = 0;\n    animationFrameRef.current = requestAnimationFrame(timestamp => {\n      fpsLimiter(timestamp, handleAnimation);\n    });\n\n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n\n      // Fix 19: Clear quality adjustment timer on unmount\n      if (qualityChangeTimerRef.current) {\n        clearTimeout(qualityChangeTimerRef.current);\n      }\n    };\n  }, [active, isInitialized, dimensions, fpsLimiter, handleAnimation]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: height,\n      overflow: 'hidden',\n      pointerEvents: 'none',\n      zIndex: zIndex,\n      // Hardware acceleration\n      backfaceVisibility: 'hidden',\n      transform: 'translateZ(0)',\n      willChange: 'transform'\n    },\n    \"aria-hidden\": \"true\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        // Additional rendering optimizations\n        imageRendering: 'high-quality',\n        // Hardware acceleration\n        backfaceVisibility: 'hidden',\n        transform: 'translateZ(0)',\n        willChange: 'transform',\n        // Ensures proper subpixel rendering\n        filter: 'none'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1859,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1841,\n    columnNumber: 5\n  }, this);\n};\n\n/**\n * GoldenMeteorShower Component\n * \n * A preset version of the MeteorShower with a golden/amber color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_s3(MeteorShower, \"/RboUarsRyZiAunaGcLrKdCW7rM=\");\n_c = MeteorShower;\nexport const GoldenMeteorShower = props => {\n  const goldenPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 245, 158, 0.9)',\n    trailColor: 'rgba(207, 181, 59, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 200,\n    maxStaggerDelay: 2000,\n    enableBursts: true,\n    burstProbability: 0.4,\n    burstParticleSize: 1.8,\n    burstParticleCount: 14\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...goldenPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1908,\n    columnNumber: 10\n  }, this);\n};\n\n/**\n * CelestialMeteorShower Component\n * \n * A preset version of the MeteorShower with a bluish-purple color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c2 = GoldenMeteorShower;\nexport const CelestialMeteorShower = props => {\n  const celestialPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(220, 225, 255, 0.9)',\n    trailColor: 'rgba(150, 160, 255, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 300,\n    maxStaggerDelay: 1800,\n    enableBursts: true,\n    burstProbability: 0.35\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...celestialPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1936,\n    columnNumber: 10\n  }, this);\n};\n\n/**\n * RubyMeteorShower Component\n * \n * A preset version of the MeteorShower with a red color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c3 = CelestialMeteorShower;\nexport const RubyMeteorShower = props => {\n  const rubyPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 200, 200, 0.9)',\n    trailColor: 'rgba(220, 100, 100, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 350,\n    maxStaggerDelay: 2200,\n    enableBursts: true,\n    burstProbability: 0.45\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...rubyPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1964,\n    columnNumber: 10\n  }, this);\n};\n\n/**\n * TopMeteorShower Component\n * \n * A preset version of the MeteorShower with meteors falling from the top of the screen\n * at a consistent 30-degree angle, distributed with emphasis on left and center areas.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c4 = RubyMeteorShower;\nexport const TopMeteorShower = props => {\n  const topPreset = {\n    mode: 'linear',\n    direction: 'top',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.12,\n    trailLength: 200,\n    trailSegments: 25,\n    journeyCompletion: 0.95,\n    staggered: true,\n    minStaggerDelay: 100,\n    maxStaggerDelay: 1000,\n    enableBursts: true,\n    burstProbability: 0.5,\n    burstParticleCount: 15\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...topPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1993,\n    columnNumber: 10\n  }, this);\n};\n\n/**\n * TopArcMeteorShower Component\n * \n * A new preset that combines the top-down trajectory with curved arc paths.\n * Meteors start from the top of the screen and curve downward with elegant arcs.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c5 = TopMeteorShower;\nexport const TopArcMeteorShower = props => {\n  const topArcPreset = {\n    mode: 'topArc',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.10,\n    trailLength: 200,\n    trailSegments: 25,\n    arcIntensity: 0.5,\n    arcVariation: 0.2,\n    journeyCompletion: 0.95,\n    staggered: true,\n    minStaggerDelay: 150,\n    maxStaggerDelay: 1200,\n    enableBursts: true,\n    burstProbability: 0.4,\n    burstParticleCount: 12\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...topArcPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 2023,\n    columnNumber: 10\n  }, this);\n};\n_c6 = TopArcMeteorShower;\nexport default MeteorShower;\nvar _c, _c2, _c3, _c4, _c5, _c6;\n$RefreshReg$(_c, \"MeteorShower\");\n$RefreshReg$(_c2, \"GoldenMeteorShower\");\n$RefreshReg$(_c3, \"CelestialMeteorShower\");\n$RefreshReg$(_c4, \"RubyMeteorShower\");\n$RefreshReg$(_c5, \"TopMeteorShower\");\n$RefreshReg$(_c6, \"TopArcMeteorShower\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useCallback","useMemo","jsxDEV","_jsxDEV","MeteorShower","height","zIndex","active","meteorDensity","meteorMinSize","meteorMaxSize","meteorSpeed","trailLength","trailSegments","coreColor","glowColor","trailColor","enableParallax","parallaxIntensity","staggered","minStaggerDelay","maxStaggerDelay","journeyCompletion","mode","direction","baseAngle","angleVariation","arcIntensity","arcVariation","debug","adaptiveQuality","respectReducedMotion","maxFPS","useWebGL","enableBursts","enableBattery","renderingMode","enableOffscreenRendering","burstParticleCount","burstParticleSize","burstProbability","burstColorVariation","_s3","_s","$RefreshSig$","_s2","containerRef","canvasRef","ctxRef","webGLRef","offscreenCanvasRef","workerRef","meteorsRef","burstsRef","animationFrameRef","lastTimestampRef","fpsTimestampRef","frameCountRef","currentFpsRef","nextSpawnTimeRef","scrollPositionRef","resizeObserverRef","visibilityObserverRef","batteryRef","visibilityChangeTimeRef","lastBurstCountRef","qualityChangeTimerRef","lastQualityFactorRef","stableFrameCountRef","dimensions","setDimensions","width","pixelRatio","isInitialized","setIsInitialized","prefersReducedMotion","setPrefersReducedMotion","isVisible","setIsVisible","qualityFactor","setQualityFactor","actualRenderingMode","setActualRenderingMode","deviceCapabilities","setDeviceCapabilities","memory","cores","batteryLevel","isMobile","supportsWebGL","supportsOffscreenCanvas","pointCache","current","x","y","segment","colorCacheRef","Map","webGLProgramsRef","meteor","trail","burst","objectPoolsRef","meteors","bursts","vectors","safeTrailSegments","maxSegments","Math","min","detectCapabilities","navigator","deviceMemory","hardwareConcurrency","test","userAgent","canvas","document","createElement","window","WebGLRenderingContext","getContext","e","OffscreenCanvas","getBattery","then","battery","updateBattery","prev","level","isCharging","charging","addEventListener","catch","initialRenderingMode","performanceScore","quality","getCachedColor","baseColor","opacity","safeOpacity","max","roundedOpacity","round","key","has","newColor","replace","set","get","adaptedSettings","useShadow","useGlow","useHighQualityRendering","floor","reducedMotionQuery","matchMedia","matches","handleReducedMotionChange","handleVisibilityChange","hidden","performance","now","timeDelta","currentWorker","removeEventListener","terminate","initWebGL","gl","alpha","antialias","premultipliedAlpha","depth","powerPreference","failIfMajorPerformanceCaveat","enable","BLEND","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","clearColor","canvasWidth","canvasHeight","viewport","vertexShaderSource","fragmentShaderSource","createShader","type","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","error","getShaderInfoLog","deleteShader","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","program","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","attributes","position","getAttribLocation","size","color","uniforms","resolution","getUniformLocation","burstVertexShaderSource","burstFragmentShaderSource","burstVertexShader","burstFragmentShader","burstProgram","calculateMeteorPath","startX","random","startY","curveDirection","curveIntensity","endX","endY","controlX","controlY","pathType","start","control","end","centerPull","intensity","meteorDirection","angle","PI","distanceToTravel","cos","sin","getPathPoint","t","path","outPoint","safeT","invT","invTSquared","tSquared","term1","term2","term3","getPathVelocity","outVelocity","length","sqrt","setupCanvas","container","rect","getBoundingClientRect","devicePixelRatio","displayWidth","displayHeight","endsWith","parseInt","innerHeight","style","ctx","desynchronized","willReadFrequently","scale","imageSmoothingEnabled","imageSmoothingQuality","offscreen","offscreenCtx","warn","resizeObserver","ResizeObserver","entries","timeout","clearTimeout","setTimeout","requestAnimationFrame","currentContainer","observe","observer","disconnect","IntersectionObserver","isIntersecting","threshold","rootMargin","currentContainerRef","handleScroll","scrollY","passive","getMeteor","pool","pop","progress","positions","Array","i","initializeMeteor","initialPoint","speed","fadeThreshold","pulsePhase","pulseSpeed","hasBurst","earlyBurst","burstThreshold","burstTriggered","burstSize","burstParticles","burstColors","getBurstParticle","life","createBurst","colors","particleCount","velocityInfluence","maxBurstParticles","actualParticleCount","toRemove","oldBurst","shift","push","atan2","angleSpread","angleVariance","speedVariance","baseSpeed","vx","vy","sizeVariance","particleSize","colorIndex","decay","damping","renderBurstsWebGL","deltaTime","useProgram","uniform2f","Float32Array","sizes","gravity","rotationSpeed","rotation","posIndex","pow","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","enableVertexAttribArray","vertexAttribPointer","FLOAT","sizeBuffer","colorBuffer","drawArrays","POINTS","disableVertexAttribArray","deleteBuffer","j","renderBursts2D","save","fragmentSize","trailGradient","createLinearGradient","addColorStop","beginPath","moveTo","lineTo","lineWidth","lineCap","strokeStyle","stroke","shadowColor","shadowBlur","arc","fillStyle","fill","restore","renderMeteors2D","parallaxOffset","timestamp","forEach","currentOpacity","fadeProgress","timeFactor","pulseEffect","adjustY","burstPosition","velocityPoint","burstFadeStartTime","fadeAfterBurst","initialOpacity","fadeDuration","fadeEase","terminateAfterBurst","pos1","pos2","segmentOpacity","segmentWidth","headPos","pos","gradient","renderMeteorsWebGL","clear","COLOR_BUFFER_BIT","meteorProgram","updateMeteors","cappedDeltaTime","splice","currentPos","spawnNeeded","canSpawnNow","newMeteor","delay","fpsLimiter","callback","time","targetFrameTime","elapsed","delta","log","toFixed","newQuality","handleAnimation","clearRect","font","fillText","cancelAnimationFrame","ref","top","left","overflow","pointerEvents","backfaceVisibility","transform","willChange","children","imageRendering","filter","fileName","_jsxFileName","lineNumber","columnNumber","_c","GoldenMeteorShower","props","goldenPreset","_c2","CelestialMeteorShower","celestialPreset","_c3","RubyMeteorShower","rubyPreset","_c4","TopMeteorShower","topPreset","_c5","TopArcMeteorShower","topArcPreset","_c6","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/MeteorShower.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';\n\n/**\n * MeteorShower Component - Enterprise Performance Optimized Version\n * \n * Creates a highly performant animated meteor shower effect where meteors\n * arc across the sky with comet-like trails and fade away naturally.\n * \n * Features:\n * - Advanced performance optimizations with WebGL acceleration option\n * - Adaptive quality scaling based on device capabilities\n * - Memory and battery-efficient rendering pipeline\n * - Accessibility compliance with reduced motion support\n * - Supports hardware acceleration and high-DPI displays\n * - Enhanced burst effects with realistic particle physics\n * \n * @param {Object} props - Component props\n * @param {string|number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=5] - Z-index for the container\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.meteorDensity=15] - Number of meteors to maintain on screen\n * @param {number} [props.meteorMinSize=1] - Minimum size of meteors\n * @param {number} [props.meteorMaxSize=3] - Maximum size of meteors\n * @param {number} [props.meteorSpeed=0.08] - Base speed of meteors\n * @param {number} [props.trailLength=180] - Length of meteor trails\n * @param {number} [props.trailSegments=20] - Number of segments in each trail\n * @param {string} [props.coreColor='rgba(255, 255, 255, 1)'] - Core color for meteors\n * @param {string} [props.glowColor='rgba(255, 253, 227, 0.9)'] - Glow color for meteors\n * @param {string} [props.trailColor='rgba(191, 173, 127, 0.8)'] - Trail color for meteors\n * @param {boolean} [props.enableParallax=false] - Enable parallax effect on scroll\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of parallax effect\n * @param {boolean} [props.staggered=true] - Enable staggered meteor appearance\n * @param {number} [props.minStaggerDelay=200] - Minimum delay between meteor spawns (ms)\n * @param {number} [props.maxStaggerDelay=2000] - Maximum delay between meteor spawns (ms)\n * @param {number} [props.journeyCompletion=0.9] - When meteors complete their journey (0-1)\n * @param {string} [props.mode='arc'] - Animation mode: 'arc', 'linear', or 'topArc'\n * @param {string} [props.direction='both'] - Direction: 'left', 'right', 'both', or 'top'\n * @param {number} [props.baseAngle=30] - Base angle for linear meteors (degrees)\n * @param {number} [props.angleVariation=15] - Random variation to apply to the base angle\n * @param {number} [props.arcIntensity=0.5] - Controls the curve intensity for 'topArc' mode\n * @param {number} [props.arcVariation=0.2] - Random variation for arc intensity\n * @param {boolean} [props.debug=false] - Enable debug visualization\n * @param {boolean} [props.adaptiveQuality=true] - Enable adaptive quality based on device\n * @param {boolean} [props.respectReducedMotion=true] - Respect reduced motion preferences\n * @param {number} [props.maxFPS=60] - Target maximum frames per second\n * @param {boolean} [props.useWebGL=false] - Use WebGL rendering for better performance\n * @param {boolean} [props.enableBursts=true] - Enable meteor burst effects\n * @param {boolean} [props.enableBattery=true] - Enable battery-saving optimizations\n * @param {string} [props.renderingMode='auto'] - Rendering mode: 'auto', '2d', or 'webgl'\n * @param {boolean} [props.enableOffscreenRendering=true] - Enable offscreen canvas when available\n * @param {number} [props.burstParticleCount=12] - Number of particles in each burst\n * @param {number} [props.burstParticleSize=2] - Size of burst particles\n * @param {number} [props.burstProbability=0.4] - Probability of meteor having a burst (0-1)\n * @param {string} [props.burstColorVariation='0.2'] - Amount of color variation in burst particles\n */\nconst MeteorShower = ({\n  height = '100vh',\n  zIndex = 5,\n  active = true,\n  meteorDensity = 15,\n  meteorMinSize = 1,\n  meteorMaxSize = 3,\n  meteorSpeed = 0.08,\n  trailLength = 180,\n  trailSegments = 20,\n  coreColor = 'rgba(255, 255, 255, 1)',\n  glowColor = 'rgba(255, 245, 158, 0.9)',\n  trailColor = 'rgba(207, 181, 59, 0.8)',\n  enableParallax = false,\n  parallaxIntensity = 0.2,\n  staggered = true,\n  minStaggerDelay = 200,\n  maxStaggerDelay = 2000,\n  journeyCompletion = 0.9,\n  mode = 'arc',\n  direction = 'both',\n  baseAngle = 30,\n  angleVariation = 15,\n  arcIntensity = 0.5,\n  arcVariation = 0.2,\n  debug = false,\n  adaptiveQuality = true,\n  respectReducedMotion = true,\n  maxFPS = 60,\n  useWebGL = false,\n  enableBursts = true, // Enabled by default now\n  enableBattery = true,\n  renderingMode = 'auto',\n  enableOffscreenRendering = true,\n  burstParticleCount = 12,\n  burstParticleSize = 2,\n  burstProbability = 0.4,\n  burstColorVariation = 0.2\n}) => {\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const ctxRef = useRef(null);\n  const webGLRef = useRef(null);\n  const offscreenCanvasRef = useRef(null);\n  const workerRef = useRef(null);\n  const meteorsRef = useRef([]);\n  const burstsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const fpsTimestampRef = useRef(0);\n  const frameCountRef = useRef(0);\n  const currentFpsRef = useRef(60);\n  const nextSpawnTimeRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n  const resizeObserverRef = useRef(null);\n  const visibilityObserverRef = useRef(null);\n  const batteryRef = useRef(null);\n  const visibilityChangeTimeRef = useRef(0);\n  const lastBurstCountRef = useRef(0);\n  const qualityChangeTimerRef = useRef(null);\n  const lastQualityFactorRef = useRef(1);\n  const stableFrameCountRef = useRef(0);\n  \n  // Component state\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0, pixelRatio: 1 });\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [isVisible, setIsVisible] = useState(false);\n  const [qualityFactor, setQualityFactor] = useState(1);\n  const [actualRenderingMode, setActualRenderingMode] = useState('2d');\n  const [deviceCapabilities, setDeviceCapabilities] = useState({\n    memory: 4,\n    cores: 4,\n    batteryLevel: 1,\n    isMobile: false,\n    supportsWebGL: false,\n    supportsOffscreenCanvas: false\n  });\n  \n  // Pre-allocate objects to avoid garbage collection during animation\n  const pointCache = useRef({\n    current: { x: 0, y: 0 },\n    segment: { x: 0, y: 0 }\n  }).current;\n  \n  // Precompute color variants to avoid string operations during animation\n  const colorCacheRef = useRef(new Map());\n  \n  // WebGL shader programs and buffers\n  const webGLProgramsRef = useRef({\n    meteor: null,\n    trail: null,\n    burst: null\n  });\n  \n  // Object pools for efficient memory usage\n  const objectPoolsRef = useRef({\n    meteors: [],\n    bursts: [],\n    vectors: []\n  });\n  \n  // Fix 1: Limit trail segments to a reasonable number to prevent performance issues\n  const safeTrailSegments = useMemo(() => {\n    // If trail segments are extremely high, cap them based on device capability\n    const maxSegments = Math.min(\n      deviceCapabilities.isMobile ? 40 : 80, \n      trailSegments\n    );\n    \n    return maxSegments;\n  }, [trailSegments, deviceCapabilities.isMobile]);\n  \n  // Detects device capabilities and sets up optimization strategies\n  const detectCapabilities = useCallback(() => {\n    // Device memory, hardware concurrency, and battery\n    const memory = navigator.deviceMemory || 4;\n    const cores = navigator.hardwareConcurrency || 4;\n    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n    \n    // Check WebGL support\n    let supportsWebGL = false;\n    try {\n      const canvas = document.createElement('canvas');\n      supportsWebGL = !!(window.WebGLRenderingContext && \n        (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));\n    } catch (e) {\n      supportsWebGL = false;\n    }\n    \n    // Check offscreen canvas support\n    const supportsOffscreenCanvas = typeof OffscreenCanvas !== 'undefined';\n    \n    // Get battery info if available\n    if (navigator.getBattery && enableBattery) {\n      navigator.getBattery().then(battery => {\n        batteryRef.current = battery;\n        \n        const updateBattery = () => {\n          setDeviceCapabilities(prev => ({\n            ...prev,\n            batteryLevel: battery.level,\n            isCharging: battery.charging\n          }));\n          \n          // Reduce quality if on battery and below 30%\n          if (!battery.charging && battery.level < 0.3 && adaptiveQuality) {\n            setQualityFactor(prev => Math.min(prev, 0.6));\n          }\n        };\n        \n        // Add battery event listeners\n        battery.addEventListener('levelchange', updateBattery);\n        battery.addEventListener('chargingchange', updateBattery);\n        \n        // Initial update\n        updateBattery();\n      }).catch(() => {\n        // Fallback if battery API is not available or fails\n        setDeviceCapabilities(prev => ({\n          ...prev,\n          batteryLevel: 1,\n          isCharging: true\n        }));\n      });\n    }\n    \n    // Determine initial rendering mode\n    let initialRenderingMode = '2d';\n    if (renderingMode === 'auto') {\n      if (useWebGL && supportsWebGL) {\n        initialRenderingMode = 'webgl';\n      } else {\n        initialRenderingMode = '2d';\n      }\n    } else {\n      initialRenderingMode = renderingMode === 'webgl' && supportsWebGL ? 'webgl' : '2d';\n    }\n    \n    setActualRenderingMode(initialRenderingMode);\n    \n    // Set device capabilities state\n    setDeviceCapabilities({\n      memory,\n      cores,\n      batteryLevel: 1,\n      isCharging: true,\n      isMobile,\n      supportsWebGL,\n      supportsOffscreenCanvas\n    });\n    \n    // Calculate quality factor based on capabilities\n    if (adaptiveQuality) {\n      // Base score from hardware\n      const performanceScore = (memory * cores) / (isMobile ? 2 : 1);\n      \n      // Scale quality based on performance score\n      let quality = 1;\n      \n      if (performanceScore > 16) {\n        quality = 1; // High-end devices\n      } else if (performanceScore > 8) {\n        quality = 0.8; // Mid-range devices\n      } else if (performanceScore > 4) {\n        quality = 0.6; // Low-end devices\n      } else {\n        quality = 0.4; // Very low-end devices\n      }\n      \n      setQualityFactor(quality);\n      lastQualityFactorRef.current = quality;\n    }\n  }, [useWebGL, renderingMode, adaptiveQuality, enableBattery]);\n  \n  // Get cached color with opacity\n  const getCachedColor = useCallback((baseColor, opacity) => {\n    // Fix 2: Ensure opacity is always valid to prevent rendering glitches\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    \n    // Round opacity to reduce cache size while maintaining visual quality\n    const roundedOpacity = Math.round(safeOpacity * 100) / 100;\n    const key = `${baseColor}-${roundedOpacity}`;\n    \n    if (!colorCacheRef.current.has(key)) {\n      const newColor = baseColor.replace(/[\\d.]+\\)$/, roundedOpacity + ')');\n      colorCacheRef.current.set(key, newColor);\n    }\n    \n    return colorCacheRef.current.get(key);\n  }, []);\n  \n  // Adaptive settings based on quality factor\n  const adaptedSettings = useMemo(() => {\n    if (!adaptiveQuality || qualityFactor === 1) {\n      return {\n        meteorDensity,\n        trailSegments: safeTrailSegments,\n        burstParticleCount,\n        useShadow: true,\n        useGlow: true,\n        useHighQualityRendering: true\n      };\n    }\n    \n    // Fix 3: Smoother quality adjustments to prevent visual jarring\n    // Adjust quality-dependent parameters\n    return {\n      meteorDensity: Math.max(3, Math.floor(meteorDensity * qualityFactor)),\n      trailSegments: Math.max(5, Math.floor(safeTrailSegments * qualityFactor)),\n      burstParticleCount: Math.max(4, Math.floor(burstParticleCount * qualityFactor)),\n      useShadow: qualityFactor > 0.5,\n      useGlow: qualityFactor > 0.3,\n      useHighQualityRendering: qualityFactor > 0.7\n    };\n  }, [adaptiveQuality, qualityFactor, meteorDensity, safeTrailSegments, burstParticleCount]);\n  \n  // Detect device capabilities and preferences on mount\n  useEffect(() => {\n    // Check for reduced motion preference\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    \n    const handleReducedMotionChange = (e) => {\n      setPrefersReducedMotion(e.matches);\n    };\n    \n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n    \n    // Detect device capabilities\n    detectCapabilities();\n    \n    // Setup visibility change detection to pause when tab is inactive\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        visibilityChangeTimeRef.current = performance.now();\n      } else {\n        // Adjust timing references after visibility changes\n        const timeDelta = performance.now() - visibilityChangeTimeRef.current;\n        lastTimestampRef.current += timeDelta;\n        nextSpawnTimeRef.current += timeDelta;\n      }\n    };\n    \n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    \n    // Capture current worker ref to avoid closure issues\n    const currentWorker = workerRef.current;\n    \n    // Cleanup\n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n      \n      // Clean up worker if active\n      if (currentWorker) {\n        currentWorker.terminate();\n      }\n    };\n  }, [detectCapabilities]);\n  \n  // Initialize WebGL context and shaders if using WebGL\n  const initWebGL = useCallback(() => {\n    if (!canvasRef.current || actualRenderingMode !== 'webgl') return false;\n    \n    try {\n      // Get WebGL context\n      const gl = canvasRef.current.getContext('webgl', {\n        alpha: true,\n        antialias: true,\n        premultipliedAlpha: false,\n        depth: false,\n        // Fix 4: Add WebGL context attributes for better stability\n        powerPreference: 'high-performance',\n        failIfMajorPerformanceCaveat: false\n      });\n      \n      if (!gl) return false;\n      \n      webGLRef.current = gl;\n      \n      // Create shader programs, vertex buffers, etc.\n      // This is a simplified placeholder - a real implementation would include\n      // proper shaders, attribute locations, and uniform setup\n      \n      // Enable blending for transparency\n      gl.enable(gl.BLEND);\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n      \n      // Set clear color to fully transparent\n      gl.clearColor(0.0, 0.0, 0.0, 0.0);\n      \n      // Get current dimensions for viewport\n      const canvasWidth = canvasRef.current.width;\n      const canvasHeight = canvasRef.current.height;\n      \n      // Set viewport\n      gl.viewport(0, 0, canvasWidth, canvasHeight);\n      \n      // Simple vertex shader for meteor particles\n      const vertexShaderSource = `\n        attribute vec2 aPosition;\n        attribute float aSize;\n        attribute vec4 aColor;\n        \n        varying vec4 vColor;\n        \n        uniform vec2 uResolution;\n        \n        void main() {\n          // Convert to clip space\n          vec2 position = (aPosition / uResolution) * 2.0 - 1.0;\n          position.y = -position.y;\n          \n          gl_Position = vec4(position, 0, 1);\n          gl_PointSize = aSize;\n          vColor = aColor;\n        }\n      `;\n      \n      // Simple fragment shader for meteor particles\n      const fragmentShaderSource = `\n        precision mediump float;\n        varying vec4 vColor;\n        \n        void main() {\n          // Calculate distance from center for circular point\n          float distance = length(gl_PointCoord - vec2(0.5, 0.5));\n          if (distance > 0.5) {\n            discard; // Outside circle\n          }\n          \n          // Softer edges\n          float alpha = smoothstep(0.5, 0.4, distance) * vColor.a;\n          gl_FragColor = vec4(vColor.rgb, alpha);\n        }\n      `;\n      \n      // Compile shader program\n      const createShader = (gl, type, source) => {\n        const shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        \n        // Check for compilation errors\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n          console.error('Shader compilation error:', gl.getShaderInfoLog(shader));\n          gl.deleteShader(shader);\n          return null;\n        }\n        \n        return shader;\n      };\n      \n      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n      \n      if (!vertexShader || !fragmentShader) {\n        return false;\n      }\n      \n      const program = gl.createProgram();\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n      \n      // Check for linking errors\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        console.error('Program linking error:', gl.getProgramInfoLog(program));\n        gl.deleteProgram(program);\n        return false;\n      }\n      \n      // Store the program\n      webGLProgramsRef.current.meteor = {\n        program,\n        attributes: {\n          position: gl.getAttribLocation(program, 'aPosition'),\n          size: gl.getAttribLocation(program, 'aSize'),\n          color: gl.getAttribLocation(program, 'aColor')\n        },\n        uniforms: {\n          resolution: gl.getUniformLocation(program, 'uResolution')\n        }\n      };\n      \n      // Now create shader program for burst particles\n      // This can be similar to the meteor program but with different parameters\n      \n      // Simple vertex shader for burst particles\n      const burstVertexShaderSource = `\n        attribute vec2 aPosition;\n        attribute float aSize;\n        attribute vec4 aColor;\n        \n        varying vec4 vColor;\n        \n        uniform vec2 uResolution;\n        \n        void main() {\n          // Convert to clip space\n          vec2 position = (aPosition / uResolution) * 2.0 - 1.0;\n          position.y = -position.y;\n          \n          gl_Position = vec4(position, 0, 1);\n          gl_PointSize = aSize;\n          vColor = aColor;\n        }\n      `;\n      \n      // Simple fragment shader for burst particles with softer edges\n      const burstFragmentShaderSource = `\n        precision mediump float;\n        varying vec4 vColor;\n        \n        void main() {\n          // Calculate distance from center for circular point\n          float distance = length(gl_PointCoord - vec2(0.5, 0.5));\n          if (distance > 0.5) {\n            discard; // Outside circle\n          }\n          \n          // Very soft edges for burst particles\n          float alpha = smoothstep(0.5, 0.2, distance) * vColor.a;\n          gl_FragColor = vec4(vColor.rgb, alpha);\n        }\n      `;\n      \n      const burstVertexShader = createShader(gl, gl.VERTEX_SHADER, burstVertexShaderSource);\n      const burstFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, burstFragmentShaderSource);\n      \n      if (!burstVertexShader || !burstFragmentShader) {\n        return false;\n      }\n      \n      const burstProgram = gl.createProgram();\n      gl.attachShader(burstProgram, burstVertexShader);\n      gl.attachShader(burstProgram, burstFragmentShader);\n      gl.linkProgram(burstProgram);\n      \n      // Check for linking errors\n      if (!gl.getProgramParameter(burstProgram, gl.LINK_STATUS)) {\n        console.error('Burst program linking error:', gl.getProgramInfoLog(burstProgram));\n        gl.deleteProgram(burstProgram);\n      } else {\n        // Store the burst program\n        webGLProgramsRef.current.burst = {\n          program: burstProgram,\n          attributes: {\n            position: gl.getAttribLocation(burstProgram, 'aPosition'),\n            size: gl.getAttribLocation(burstProgram, 'aSize'),\n            color: gl.getAttribLocation(burstProgram, 'aColor')\n          },\n          uniforms: {\n            resolution: gl.getUniformLocation(burstProgram, 'uResolution')\n          }\n        };\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('WebGL initialization error:', error);\n      setActualRenderingMode('2d');\n      return false;\n    }\n  }, [actualRenderingMode]);\n  \n  // Calculate path parameters for a meteor based on selected mode\n  const calculateMeteorPath = useCallback((width, height) => {\n    if (mode === 'arc') {\n      // Arc path logic with optimized parameters\n      const startX = Math.random() * width * 1.5 - width * 0.25;\n      const startY = Math.random() * -100 - 50;\n      \n      const curveDirection = Math.random() > 0.5 ? 1 : -1;\n      const curveIntensity = Math.random() * 0.4 + 0.2;\n      \n      const endX = startX + (curveDirection * width * curveIntensity);\n      const endY = height * journeyCompletion;\n      \n      const controlX = (startX + endX) / 2 + (curveDirection * width * curveIntensity);\n      const controlY = (startY + endY) * 0.5;\n      \n      return {\n        pathType: 'arc',\n        start: { x: startX, y: startY },\n        control: { x: controlX, y: controlY },\n        end: { x: endX, y: endY }\n      };\n    } else if (mode === 'topArc') {\n      // New topArc path logic - meteors starting at top and curving downward\n      // Distribute starting positions across the top of the screen\n      const position = Math.random();\n      let startX;\n      \n      // Better distribution to prevent clustering\n      if (position < 0.3) { // left side\n        startX = Math.random() * (width * 0.3);\n      } else if (position < 0.7) { // middle\n        startX = width * 0.3 + Math.random() * (width * 0.4);\n      } else { // right side\n        startX = width * 0.7 + Math.random() * (width * 0.3);\n      }\n      \n      // Start above the screen\n      const startY = Math.random() * -100 - 20;\n      \n      // End position will be toward bottom of screen\n      const endY = height * journeyCompletion;\n      \n      // Calculate end X with a tendency to curve toward center\n      // This creates an elegant \"shower\" effect where meteors fan outward\n      const centerPull = Math.random() * 0.4 + 0.3; // How much they curve toward center\n      const endX = width * 0.5 + (startX - width * 0.5) * (1 - centerPull);\n      \n      // Calculate curve intensity with variation\n      const intensity = arcIntensity + (Math.random() * 2 - 1) * arcVariation;\n      \n      // Create control point for the bezier curve\n      // Control X affects the horizontal curve - subtle offset to create natural arcs\n      const curveDirection = startX < width * 0.5 ? 1 : -1;\n      const controlX = startX + curveDirection * width * intensity * 0.2;\n      \n      // Control Y affects the vertical arc - lower values create more pronounced arcs\n      // This puts the control point somewhere in the first third of the journey\n      const controlY = startY + (endY - startY) * (0.2 + Math.random() * 0.2);\n      \n      return {\n        pathType: 'arc', // Reuse arc rendering\n        start: { x: startX, y: startY },\n        control: { x: controlX, y: controlY },\n        end: { x: endX, y: endY }\n      };\n    } else if (mode === 'linear') {\n      // Linear path logic with enhanced direction control\n      let meteorDirection = direction;\n      if (direction === 'both') {\n        meteorDirection = Math.random() > 0.5 ? 'left' : 'right';\n      }\n      \n      let angle;\n      if (direction === 'top') {\n        // Fix 5: More consistent angle calculation for top direction\n        angle = ((30 + (Math.random() * 2 - 1) * 5) * Math.PI) / 180;\n      } else {\n        angle = ((baseAngle + (Math.random() * 2 - 1) * angleVariation) * Math.PI) / 180;\n      }\n      \n      let startX;\n      if (meteorDirection === 'left') {\n        startX = Math.random() * (width * 0.3) - (width * 0.1);\n      } else if (meteorDirection === 'right') {\n        startX = width - Math.random() * (width * 0.3) + (width * 0.1);\n      } else if (direction === 'top') {\n        const position = Math.random();\n        // Fix 6: Better distribution to prevent clustering\n        if (position < 0.5) {\n          startX = Math.random() * (width * 0.35);\n        } else if (position < 0.85) {\n          startX = width * 0.35 + Math.random() * (width * 0.35);\n        } else {\n          startX = width * 0.7 + Math.random() * (width * 0.3);\n        }\n      }\n      \n      const startY = Math.random() * -100 - 50;\n      const distanceToTravel = (height * journeyCompletion) / Math.cos(angle);\n      \n      let endX, endY;\n      if (meteorDirection === 'left' || direction === 'top') {\n        endX = startX + distanceToTravel * Math.sin(angle);\n        endY = startY + distanceToTravel * Math.cos(angle);\n      } else {\n        endX = startX - distanceToTravel * Math.sin(angle);\n        endY = startY + distanceToTravel * Math.cos(angle);\n      }\n      \n      return {\n        pathType: 'linear',\n        start: { x: startX, y: startY },\n        end: { x: endX, y: endY },\n        direction: meteorDirection\n      };\n    }\n  }, [mode, direction, baseAngle, angleVariation, journeyCompletion, arcIntensity, arcVariation]);\n  \n  // Get point along path with highly optimized calculations\n  const getPathPoint = useCallback((t, path, outPoint = { x: 0, y: 0 }) => {\n    // Fix 7: Ensure t is always within valid range\n    const safeT = Math.max(0, Math.min(1, t));\n    \n    if (path.pathType === 'arc') {\n      // Optimized quadratic bezier calculation using pre-computed terms\n      const invT = 1 - safeT;\n      const invTSquared = invT * invT;\n      const tSquared = safeT * safeT;\n      const term1 = invTSquared;\n      const term2 = 2 * invT * safeT;\n      const term3 = tSquared;\n      \n      outPoint.x = term1 * path.start.x + term2 * path.control.x + term3 * path.end.x;\n      outPoint.y = term1 * path.start.y + term2 * path.control.y + term3 * path.end.y;\n    } else {\n      // Linear interpolation with minimal operations\n      outPoint.x = path.start.x + (path.end.x - path.start.x) * safeT;\n      outPoint.y = path.start.y + (path.end.y - path.start.y) * safeT;\n    }\n    \n    return outPoint;\n  }, []);\n  \n  // Calculate velocity at a point on the path (for trail orientation)\n  const getPathVelocity = useCallback((t, path, outVelocity = { x: 0, y: 0 }) => {\n    // Fix 8: Ensure t is always within valid range\n    const safeT = Math.max(0, Math.min(1, t));\n    \n    if (path.pathType === 'arc') {\n      // Derivative of quadratic bezier\n      const term1 = 2 * (1 - safeT);\n      const term2 = 2 * safeT;\n      \n      outVelocity.x = term1 * (path.control.x - path.start.x) + term2 * (path.end.x - path.control.x);\n      outVelocity.y = term1 * (path.control.y - path.start.y) + term2 * (path.end.y - path.control.y);\n    } else {\n      // Constant velocity for linear paths\n      outVelocity.x = path.end.x - path.start.x;\n      outVelocity.y = path.end.y - path.start.y;\n      \n      // Normalize\n      const length = Math.sqrt(outVelocity.x * outVelocity.x + outVelocity.y * outVelocity.y);\n      if (length > 0) {\n        outVelocity.x /= length;\n        outVelocity.y /= length;\n      }\n    }\n    \n    return outVelocity;\n  }, []);\n  \n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current || !containerRef.current) return false;\n    \n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    const rect = container.getBoundingClientRect();\n    const pixelRatio = window.devicePixelRatio || 1;\n    \n    // Fix 9: Ensure canvas dimensions are valid integers to prevent rendering issues\n    // Calculate dimensions\n    const displayWidth = Math.floor(rect.width);\n    const displayHeight = typeof height === 'string' && height.endsWith('vh') \n      ? Math.floor((parseInt(height, 10) / 100) * window.innerHeight)\n      : Math.floor(parseInt(height, 10) || window.innerHeight);\n    \n    // Set canvas size accounting for pixel ratio\n    canvas.width = displayWidth * pixelRatio;\n    canvas.height = displayHeight * pixelRatio;\n    canvas.style.width = `${displayWidth}px`;\n    canvas.style.height = `${displayHeight}px`;\n    \n    // Get appropriate rendering context\n    if (actualRenderingMode === 'webgl') {\n      initWebGL();\n    } else {\n      // 2D Canvas context\n      const ctx = canvas.getContext('2d', {\n        alpha: true,\n        desynchronized: true,\n        willReadFrequently: false\n      });\n      \n      if (!ctx) return false;\n      \n      // Scale context for high-DPI displays\n      ctx.scale(pixelRatio, pixelRatio);\n      \n      // Configure context for high-quality rendering\n      if (adaptedSettings.useHighQualityRendering) {\n        ctx.imageSmoothingEnabled = true;\n        ctx.imageSmoothingQuality = 'high';\n      }\n      \n      ctxRef.current = ctx;\n    }\n    \n    // Initialize offscreen canvas if supported and enabled\n    if (enableOffscreenRendering && typeof OffscreenCanvas !== 'undefined' &&\n        deviceCapabilities.supportsOffscreenCanvas) {\n      try {\n        // Create offscreen canvas\n        const offscreen = new OffscreenCanvas(\n          displayWidth * pixelRatio,\n          displayHeight * pixelRatio\n        );\n        \n        // Get 2D context for offscreen canvas\n        const offscreenCtx = offscreen.getContext('2d');\n        if (offscreenCtx) {\n          offscreenCtx.scale(pixelRatio, pixelRatio);\n          offscreenCanvasRef.current = {\n            canvas: offscreen,\n            ctx: offscreenCtx\n          };\n        }\n      } catch (error) {\n        console.warn('Offscreen canvas initialization error:', error);\n      }\n    }\n    \n    setDimensions({\n      width: displayWidth,\n      height: displayHeight,\n      pixelRatio\n    });\n    \n    return true;\n  }, [height, actualRenderingMode, initWebGL, enableOffscreenRendering, deviceCapabilities.supportsOffscreenCanvas, adaptedSettings.useHighQualityRendering]);\n  \n  // Setup canvas resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n    \n    // Create a ResizeObserver to detect container size changes\n    const resizeObserver = new ResizeObserver(entries => {\n      // Debounce resize operations\n      if (resizeObserverRef.current.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n      \n      resizeObserverRef.current.timeout = setTimeout(() => {\n        requestAnimationFrame(() => {\n          if (setupCanvas()) {\n            setIsInitialized(true);\n          }\n        });\n      }, 100); // 100ms debounce\n    });\n    \n    // Capture current reference to avoid closure issues in cleanup\n    const currentContainer = containerRef.current;\n    \n    // Start observing the container\n    resizeObserver.observe(currentContainer);\n    resizeObserverRef.current = { observer: resizeObserver };\n    \n    // Initial setup\n    setupCanvas();\n    setIsInitialized(true);\n    \n    return () => {\n      if (resizeObserverRef.current.observer) {\n        resizeObserverRef.current.observer.disconnect();\n      }\n      if (resizeObserverRef.current.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n    };\n  }, [setupCanvas]);\n  \n  // Setup intersection observer to only animate when visible\n  useEffect(() => {\n    if (!containerRef.current) return;\n    \n    const observer = new IntersectionObserver(\n      entries => {\n        const isIntersecting = entries[0].isIntersecting;\n        \n        // Only change state if visibility actually changed\n        if (isIntersecting !== isVisible) {\n          setIsVisible(isIntersecting);\n          \n          if (isIntersecting) {\n            // Reset timing references when becoming visible again\n            lastTimestampRef.current = 0;\n            nextSpawnTimeRef.current = performance.now();\n          }\n        }\n      },\n      {\n        threshold: 0.01,\n        rootMargin: '100px'\n      }\n    );\n    \n    // Store current reference to avoid closure issues\n    const currentContainerRef = containerRef.current;\n    observer.observe(currentContainerRef);\n    visibilityObserverRef.current = observer;\n    \n    return () => {\n      if (visibilityObserverRef.current) {\n        visibilityObserverRef.current.disconnect();\n      }\n    };\n  }, [isVisible]);\n  \n  // Handle parallax effect on scroll if enabled\n  useEffect(() => {\n    if (!enableParallax) return;\n    \n    // Use passive event listener for better performance\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    \n    window.addEventListener('scroll', handleScroll, { passive: true });\n    \n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [enableParallax]);\n  \n  // Get a meteor from the object pool or create a new one\n  const getMeteor = useCallback(() => {\n    // Try to get from pool first\n    const pool = objectPoolsRef.current.meteors;\n    let meteor;\n    \n    if (pool.length > 0) {\n      meteor = pool.pop();\n      // Reset meteor properties\n      meteor.progress = 0;\n      meteor.active = true;\n    } else {\n      // Create new if pool is empty\n      meteor = {\n        progress: 0,\n        active: true,\n        positions: Array(adaptedSettings.trailSegments)\n      };\n      \n      // Pre-allocate position objects\n      for (let i = 0; i < adaptedSettings.trailSegments; i++) {\n        meteor.positions[i] = { x: 0, y: 0 };\n      }\n    }\n    \n    return meteor;\n  }, [adaptedSettings.trailSegments]);\n  \n  // Initialize a meteor with all required properties\n  const initializeMeteor = useCallback(() => {\n    const { width, height } = dimensions;\n    \n    if (!width || !height) return null;\n    \n    // Get meteor from pool\n    const meteor = getMeteor();\n    \n    // Calculate path based on mode\n    const path = calculateMeteorPath(width, height);\n    \n    // Set path and initial position\n    meteor.path = path;\n    \n    // Fix 10: Ensure all positions are initialized properly to prevent flickering\n    const initialPoint = { x: path.start.x, y: path.start.y };\n    for (let i = 0; i < meteor.positions.length; i++) {\n      if (!meteor.positions[i]) {\n        meteor.positions[i] = { x: initialPoint.x, y: initialPoint.y };\n      } else {\n        meteor.positions[i].x = initialPoint.x;\n        meteor.positions[i].y = initialPoint.y;\n      }\n    }\n    \n    // Set meteor properties\n    meteor.size = Math.random() * (meteorMaxSize - meteorMinSize) + meteorMinSize;\n    meteor.speed = meteorSpeed * (Math.random() * 0.5 + 0.75);\n    meteor.opacity = Math.random() * 0.3 + 0.7;\n    meteor.fadeThreshold = 0.7 + Math.random() * 0.2;\n    meteor.pulsePhase = Math.random() * Math.PI * 2;\n    meteor.pulseSpeed = Math.random() * 0.01 + 0.005;\n    \n    // Add burst properties if enabled\n    if (enableBursts && Math.random() < burstProbability) {\n      meteor.hasBurst = true;\n      \n      // Vary the burst threshold - occasionally have early bursts for variety\n      const earlyBurst = Math.random() < 0.15; // 15% chance for early burst\n      meteor.burstThreshold = earlyBurst \n        ? 0.3 + Math.random() * 0.4 // Early burst range (0.3-0.7)\n        : 0.85 + Math.random() * 0.13; // Normal late burst range (0.85-0.98)\n      \n      meteor.burstTriggered = false;\n      \n      // Adjust burst size based on when it occurs\n      meteor.burstSize = earlyBurst\n        ? meteor.size * (3 + Math.random() * 4) // Larger for early bursts\n        : meteor.size * (2 + Math.random() * 2); // More controlled for end bursts\n      \n      // Adjust particle count based on when it occurs\n      meteor.burstParticles = Math.floor(\n        adaptedSettings.burstParticleCount * \n        (earlyBurst ? 1.2 : 0.8) * // More particles for early bursts\n        (0.8 + Math.random() * 0.4)\n      );\n      \n      // Use custom gold-centric colors for dark fantasy aesthetic\n      // No need to use createColorVariant here since we're using specific themed colors\n      meteor.burstColors = [\n        'rgba(255, 215, 0, 1)', // Gold\n        'rgba(218, 165, 32, 1)', // Goldenrod\n        'rgba(212, 175, 55, 1)', // Metallic gold\n        'rgba(207, 181, 59, 1)', // Old gold\n        earlyBurst ? 'rgba(255, 255, 220, 1)' : 'rgba(192, 192, 192, 1)' // Bright for early, silver for late\n      ];\n    } else {\n      meteor.hasBurst = false;\n    }\n    \n    return meteor;\n  }, [\n    dimensions,\n    calculateMeteorPath,\n    meteorMinSize,\n    meteorMaxSize,\n    meteorSpeed,\n    enableBursts,\n    burstProbability,\n    adaptedSettings.burstParticleCount,\n    getMeteor\n  ]);\n  \n  // Get a burst particle from the object pool or create a new one\n  const getBurstParticle = useCallback(() => {\n    const pool = objectPoolsRef.current.bursts;\n    \n    if (pool.length > 0) {\n      const burst = pool.pop();\n      // Reset properties\n      burst.life = 1.0;\n      return burst;\n    }\n    \n    // Create new if pool is empty\n    return {};\n  }, []);\n  \n  // Create a burst effect at a specified position\n  const createBurst = useCallback((x, y, size, colors, particleCount, velocityInfluence = { x: 0, y: 0 }) => {\n    // Skip if bursts are not enabled\n    if (!enableBursts) return;\n    \n    // Fix 11: Limit bursts to prevent overloading and causing flickering\n    // Limit the number of active burst particles to avoid performance issues\n    const maxBurstParticles = adaptedSettings.useHighQualityRendering ? 300 : 150;\n    \n    // If we're already close to the limit, reduce the number of particles\n    let actualParticleCount = particleCount;\n    if (burstsRef.current.length > maxBurstParticles - particleCount) {\n      actualParticleCount = Math.max(4, Math.floor(particleCount * 0.5));\n    }\n    \n    // Skip burst creation completely if we're already over the limit\n    if (burstsRef.current.length > maxBurstParticles) {\n      // Remove older bursts to make room\n      const toRemove = Math.min(20, burstsRef.current.length - maxBurstParticles + actualParticleCount);\n      for (let i = 0; i < toRemove; i++) {\n        const oldBurst = burstsRef.current.shift();\n        if (oldBurst) {\n          objectPoolsRef.current.bursts.push(oldBurst);\n        }\n      }\n    }\n    \n    // Track burst counts for debug\n    lastBurstCountRef.current = actualParticleCount;\n    \n    // Create fragments that look like pieces of the meteor breaking apart\n    for (let i = 0; i < actualParticleCount; i++) {\n      // Create directional burst effect following the meteor's trajectory\n      const baseAngle = Math.atan2(velocityInfluence.y, velocityInfluence.x);\n      \n      // Calculate particle direction - within a forward-facing cone\n      const angleSpread = 1.2; // Narrower spread for more focused effect\n      const angleVariance = (Math.random() * angleSpread - angleSpread/2);\n      const angle = baseAngle + angleVariance;\n      \n      // Speed - slower for a more elegant effect\n      const speedVariance = Math.random() * 0.4 + 0.7;\n      const baseSpeed = 0.4 + Math.random() * 0.8; // Slower overall\n      const speed = baseSpeed * speedVariance;\n      \n      // Calculate velocity components\n      const vx = Math.cos(angle) * speed + velocityInfluence.x * 0.4;\n      const vy = Math.sin(angle) * speed + velocityInfluence.y * 0.4;\n      \n      // Create fragments of different sizes\n      const sizeVariance = 0.2 + Math.random() * 0.8;\n      const particleSize = size * sizeVariance * burstParticleSize * 0.6;\n      \n      // Use meteor's colors for the fragments\n      const colorIndex = Math.random() < 0.7 ? 0 : 1; // 70% core color, 30% glow color\n      const color = colorIndex === 0 ? coreColor : glowColor;\n      \n      // Create the burst particle\n      const burst = getBurstParticle();\n      \n      // Set properties\n      burst.x = x;\n      burst.y = y;\n      burst.vx = vx;\n      burst.vy = vy;\n      burst.size = particleSize;\n      burst.life = 1.0;\n      burst.decay = 0.006 + Math.random() * 0.01; // Slower decay\n      burst.color = color;\n      burst.trailLength = 2 + Math.random() * 6; // Length of trail behind fragment\n      \n      // More elegantly diminishing velocity\n      burst.damping = 0.95 + Math.random() * 0.03;\n      \n      // Add to active bursts\n      burstsRef.current.push(burst);\n    }\n  }, [enableBursts, adaptedSettings.useHighQualityRendering, getBurstParticle, burstParticleSize, coreColor, glowColor]);\n  \n  // Render burst particles with WebGL\n  const renderBurstsWebGL = useCallback((gl, deltaTime) => {\n    if (!enableBursts || burstsRef.current.length === 0 || !webGLProgramsRef.current.burst) return;\n    \n    const burstProgram = webGLProgramsRef.current.burst;\n    \n    // Use burst shader program\n    gl.useProgram(burstProgram.program);\n    \n    // Set resolution uniform\n    gl.uniform2f(\n      burstProgram.uniforms.resolution,\n      canvasRef.current.width,\n      canvasRef.current.height\n    );\n    \n    // Create float32 arrays to hold position, size, and color data\n    // 2 floats per position (x, y)\n    const positions = new Float32Array(burstsRef.current.length * 2);\n    // 1 float per size\n    const sizes = new Float32Array(burstsRef.current.length);\n    // 4 floats per color (r, g, b, a)\n    const colors = new Float32Array(burstsRef.current.length * 4);\n    \n    // Process each burst particle and update its data\n    for (let i = 0; i < burstsRef.current.length; i++) {\n      const burst = burstsRef.current[i];\n      \n      // Update position\n      burst.x += burst.vx * (deltaTime / 16);\n      burst.y += burst.vy * (deltaTime / 16);\n      \n      // Apply gravity if present\n      if (burst.gravity) {\n        burst.vy += burst.gravity * (deltaTime / 16);\n      }\n      \n      // Apply damping to velocity\n      burst.vx *= burst.damping;\n      burst.vy *= burst.damping;\n      \n      // Update rotation\n      if (burst.rotationSpeed) {\n        burst.rotation += burst.rotationSpeed * (deltaTime / 16);\n      }\n      \n      // Reduce life\n      burst.life -= burst.decay * (deltaTime / 16);\n      \n      // Map burst data to arrays\n      const posIndex = i * 2;\n      positions[posIndex] = burst.x;\n      positions[posIndex + 1] = burst.y;\n      \n      sizes[i] = burst.size * Math.pow(burst.life, 0.7) * dimensions.pixelRatio;\n      \n      // Parse color components from rgba string\n      // Fix 12: Safer color handling for WebGL\n      const colorIndex = i * 4;\n      colors[colorIndex] = 1.0;     // r\n      colors[colorIndex + 1] = 0.9; // g\n      colors[colorIndex + 2] = 0.7; // b\n      colors[colorIndex + 3] = Math.max(0, Math.min(1, burst.life * 0.7)); // a - clamped for safety\n    }\n    \n    // Create and bind position buffer\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(burstProgram.attributes.position);\n    gl.vertexAttribPointer(burstProgram.attributes.position, 2, gl.FLOAT, false, 0, 0);\n    \n    // Create and bind size buffer\n    const sizeBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, sizes, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(burstProgram.attributes.size);\n    gl.vertexAttribPointer(burstProgram.attributes.size, 1, gl.FLOAT, false, 0, 0);\n    \n    // Create and bind color buffer\n    const colorBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(burstProgram.attributes.color);\n    gl.vertexAttribPointer(burstProgram.attributes.color, 4, gl.FLOAT, false, 0, 0);\n    \n    // Draw points\n    gl.drawArrays(gl.POINTS, 0, burstsRef.current.length);\n    \n    // Clean up\n    gl.disableVertexAttribArray(burstProgram.attributes.position);\n    gl.disableVertexAttribArray(burstProgram.attributes.size);\n    gl.disableVertexAttribArray(burstProgram.attributes.color);\n    gl.deleteBuffer(positionBuffer);\n    gl.deleteBuffer(sizeBuffer);\n    gl.deleteBuffer(colorBuffer);\n    \n    // Filter out dead particles\n    let j = 0;\n    for (let i = 0; i < burstsRef.current.length; i++) {\n      const burst = burstsRef.current[i];\n      if (burst.life > 0) {\n        // Keep alive particles, compact array\n        if (i !== j) {\n          burstsRef.current[j] = burst;\n        }\n        j++;\n      } else {\n        // Return to object pool\n        objectPoolsRef.current.bursts.push(burst);\n      }\n    }\n    \n    // Truncate array to remove dead particles\n    if (j < burstsRef.current.length) {\n      burstsRef.current.length = j;\n    }\n  }, [enableBursts, dimensions.pixelRatio]);\n  \n  // Render burst particles with Canvas 2D\n  const renderBursts2D = useCallback((ctx, deltaTime) => {\n    if (!enableBursts || burstsRef.current.length === 0) return;\n    \n    // Fix 13: Use a more efficient approach to avoid array splicing during rendering\n    // Process and render each burst particle\n    let j = 0;\n    for (let i = 0; i < burstsRef.current.length; i++) {\n      const burst = burstsRef.current[i];\n      \n      // Update position\n      burst.x += burst.vx * (deltaTime / 16);\n      burst.y += burst.vy * (deltaTime / 16);\n      \n      // Apply damping to velocity\n      burst.vx *= burst.damping;\n      burst.vy *= burst.damping;\n      \n      // Reduce life\n      burst.life -= burst.decay * (deltaTime / 16);\n      \n      // Keep alive particles\n      if (burst.life > 0) {\n        // Draw particle\n        ctx.save();\n        \n        // Get velocity direction for trail orientation\n        const angle = Math.atan2(burst.vy, burst.vx);\n        \n        if (adaptedSettings.useHighQualityRendering) {\n          // Draw trail behind fragment\n          const trailLength = (burst.trailLength || 4) * burst.life;\n          const fragmentSize = burst.size * burst.life;\n          \n          // Create trail gradient\n          const trailGradient = ctx.createLinearGradient(\n            burst.x, \n            burst.y,\n            burst.x - Math.cos(angle) * trailLength,\n            burst.y - Math.sin(angle) * trailLength\n          );\n          \n          // Get the base color with varying opacity\n          trailGradient.addColorStop(0, getCachedColor(burst.color, burst.life * 0.8));\n          trailGradient.addColorStop(0.5, getCachedColor(burst.color, burst.life * 0.4));\n          trailGradient.addColorStop(1, getCachedColor(burst.color, 0));\n          \n          // Draw trail\n          ctx.beginPath();\n          ctx.moveTo(burst.x, burst.y);\n          ctx.lineTo(\n            burst.x - Math.cos(angle) * trailLength,\n            burst.y - Math.sin(angle) * trailLength\n          );\n          ctx.lineWidth = fragmentSize * 0.8;\n          ctx.lineCap = 'round';\n          ctx.strokeStyle = trailGradient;\n          ctx.stroke();\n          \n          // Draw fragment\n          if (adaptedSettings.useGlow) {\n            ctx.shadowColor = burst.color;\n            ctx.shadowBlur = fragmentSize * 2;\n          }\n          \n          ctx.beginPath();\n          ctx.arc(burst.x, burst.y, fragmentSize * 0.5, 0, Math.PI * 2);\n          ctx.fillStyle = getCachedColor(burst.color, burst.life);\n          ctx.fill();\n        } else {\n          // Simplified rendering for lower performance devices\n          const trailLength = (burst.trailLength || 3) * burst.life;\n          const fragmentSize = burst.size * burst.life;\n          \n          // Draw simple tapered line\n          ctx.beginPath();\n          ctx.moveTo(burst.x, burst.y);\n          ctx.lineTo(\n            burst.x - Math.cos(angle) * trailLength,\n            burst.y - Math.sin(angle) * trailLength\n          );\n          ctx.lineWidth = fragmentSize * 0.7;\n          ctx.lineCap = 'round';\n          ctx.strokeStyle = getCachedColor(burst.color, burst.life * 0.6);\n          ctx.stroke();\n        }\n        \n        ctx.restore();\n        \n        // Compact alive particles\n        if (i !== j) {\n          burstsRef.current[j] = burst;\n        }\n        j++;\n      } else {\n        // Return to object pool\n        objectPoolsRef.current.bursts.push(burst);\n      }\n    }\n    \n    // Truncate array to remove dead particles\n    if (j < burstsRef.current.length) {\n      burstsRef.current.length = j;\n    }\n  }, [enableBursts, adaptedSettings.useHighQualityRendering, adaptedSettings.useGlow, getCachedColor]);\n  \n  // 2D Canvas rendering method for meteors\n  const renderMeteors2D = useCallback((ctx, parallaxOffset, timestamp) => {\n    // Process and render each meteor\n    meteorsRef.current.forEach(meteor => {\n      // Fix 14: Ensure position array is valid to prevent flickering\n      if (!meteor.positions || !meteor.positions[0]) return;\n      \n      // Calculate opacity based on progress\n      let currentOpacity = meteor.opacity;\n      if (meteor.progress > meteor.fadeThreshold) {\n        const fadeProgress = (meteor.progress - meteor.fadeThreshold) / (1 - meteor.fadeThreshold);\n        currentOpacity = meteor.opacity * (1 - fadeProgress);\n      }\n      \n      // Apply pulse effect\n      const timeFactor = timestamp * 0.001;\n      const pulseEffect = Math.sin(timeFactor * meteor.pulseSpeed + meteor.pulsePhase) * 0.2 + 0.8;\n      \n      // Parallax offset adjustment\n      const adjustY = enableParallax ? parallaxOffset * (meteor.size / meteorMaxSize) : 0;\n      \n      // Check if we should create a burst effect\n      if (meteor.hasBurst && !meteor.burstTriggered && meteor.progress >= meteor.burstThreshold) {\n        meteor.burstTriggered = true;\n        const burstPosition = meteor.positions[0];\n        \n        // Get velocity at burst point for influence on particles\n        const velocityPoint = { x: 0, y: 0 };\n        getPathVelocity(meteor.progress, meteor.path, velocityPoint);\n        \n        // Scale velocity for better visual effect\n        velocityPoint.x *= 0.8;\n        velocityPoint.y *= 0.8;\n        \n        // Create burst with velocity influence\n        createBurst(\n          burstPosition.x,\n          burstPosition.y + adjustY,\n          meteor.burstSize,\n          meteor.burstColors,\n          meteor.burstParticles,\n          velocityPoint\n        );\n        \n        // Start fading process after burst\n        meteor.burstFadeStartTime = timestamp;\n        meteor.fadeAfterBurst = true;\n        meteor.initialOpacity = meteor.opacity; // Store original opacity for smooth fade\n      }\n      \n      // Apply fading effect after burst\n      if (meteor.fadeAfterBurst) {\n        // Calculate fade progress over 600ms (adjust for desired fade duration)\n        const fadeDuration = 600; \n        const fadeProgress = Math.min(1, (timestamp - meteor.burstFadeStartTime) / fadeDuration);\n        \n        // Apply eased fade out\n        const fadeEase = 1 - fadeProgress * fadeProgress; // Quadratic ease out\n        currentOpacity *= fadeEase;\n        \n        // If almost completely faded, mark for removal\n        if (fadeProgress >= 0.95) {\n          meteor.terminateAfterBurst = true;\n        }\n      }\n      \n      // Optimized rendering approach\n      if (adaptedSettings.useHighQualityRendering) {\n        // High-quality rendering with shadows\n        // Set shadow for glow effect if enabled\n        if (adaptedSettings.useGlow) {\n          ctx.shadowColor = glowColor;\n          ctx.shadowBlur = meteor.size * 3 * pulseEffect;\n        }\n        \n        // Draw trail segments\n        ctx.lineCap = 'round';\n        \n        for (let i = meteor.positions.length - 2; i >= 0; i--) {\n          const pos1 = meteor.positions[i];\n          const pos2 = meteor.positions[i + 1];\n          \n          if (!pos1 || !pos2) continue;\n          \n          // Calculate segment opacity (decreases along the trail)\n          const segmentOpacity = currentOpacity * (1 - i / meteor.positions.length) * pulseEffect;\n          \n          // Skip if nearly invisible\n          if (segmentOpacity < 0.02) continue;\n          \n          // Calculate segment width (decreases along the trail)\n          const segmentWidth = meteor.size * (1 - i / meteor.positions.length * 0.7);\n          \n          // Draw line segment\n          ctx.beginPath();\n          ctx.moveTo(pos1.x, pos1.y + adjustY);\n          ctx.lineTo(pos2.x, pos2.y + adjustY);\n          \n          // Set line style\n          ctx.lineWidth = segmentWidth;\n          ctx.strokeStyle = getCachedColor(trailColor, segmentOpacity);\n          ctx.stroke();\n        }\n        \n        // Draw meteor head\n        if (meteor.positions[0]) {\n          const headPos = meteor.positions[0];\n          \n          // Set shadow for head\n          if (adaptedSettings.useShadow) {\n            ctx.shadowColor = glowColor;\n            ctx.shadowBlur = meteor.size * 5 * pulseEffect;\n          }\n          \n          // Draw outer glow\n          ctx.beginPath();\n          ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 1.5, 0, Math.PI * 2);\n          ctx.fillStyle = getCachedColor(glowColor, currentOpacity * 0.7 * pulseEffect);\n          ctx.fill();\n          \n          // Draw inner core\n          ctx.beginPath();\n          ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 0.7, 0, Math.PI * 2);\n          ctx.fillStyle = getCachedColor(coreColor, currentOpacity * pulseEffect);\n          ctx.fill();\n        }\n      } else {\n        // Performance-optimized rendering for lower-end devices\n        // Draw simplified trail\n        ctx.beginPath();\n        const headPos = meteor.positions[0];\n        if (!headPos) return;\n        \n        ctx.moveTo(headPos.x, headPos.y + adjustY);\n        \n        for (let i = 1; i < meteor.positions.length; i += 2) {\n          const pos = meteor.positions[i];\n          if (!pos) continue;\n          ctx.lineTo(pos.x, pos.y + adjustY);\n        }\n        \n        // Gradient trail\n        const gradient = ctx.createLinearGradient(\n          headPos.x, headPos.y + adjustY,\n          meteor.positions[meteor.positions.length - 1].x,\n          meteor.positions[meteor.positions.length - 1].y + adjustY\n        );\n        \n        gradient.addColorStop(0, getCachedColor(coreColor, currentOpacity * pulseEffect));\n        gradient.addColorStop(0.3, getCachedColor(glowColor, currentOpacity * 0.7 * pulseEffect));\n        gradient.addColorStop(1, getCachedColor(trailColor, 0));\n        \n        ctx.strokeStyle = gradient;\n        ctx.lineWidth = meteor.size;\n        ctx.lineCap = 'round';\n        ctx.stroke();\n        \n        // Simple head\n        ctx.beginPath();\n        ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 0.7, 0, Math.PI * 2);\n        ctx.fillStyle = getCachedColor(coreColor, currentOpacity * pulseEffect);\n        ctx.fill();\n      }\n    });\n  }, [\n    adaptedSettings.useHighQualityRendering,\n    adaptedSettings.useGlow,\n    adaptedSettings.useShadow,\n    enableParallax,\n    meteorMaxSize,\n    glowColor,\n    trailColor,\n    coreColor,\n    getCachedColor,\n    createBurst,\n    getPathVelocity\n  ]);\n  \n  // WebGL rendering method\n  const renderMeteorsWebGL = useCallback((gl, timestamp) => {\n    // This is a simplified placeholder for WebGL rendering\n    // A full implementation would use the shaders and buffers set up earlier\n    \n    if (!gl || !webGLProgramsRef.current.meteor) return;\n    \n    // Clear canvas\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    \n    // Use meteor shader program\n    const meteorProgram = webGLProgramsRef.current.meteor;\n    gl.useProgram(meteorProgram.program);\n    \n    // Set uniforms\n    gl.uniform2f(\n      meteorProgram.uniforms.resolution,\n      canvasRef.current.width,\n      canvasRef.current.height\n    );\n    \n    // This is where we would bind vertex buffers and render particles\n    // For a real implementation, you would:\n    // 1. Update vertex buffer with current meteor positions\n    // 2. Set attributes for position, size, color\n    // 3. Draw using gl.POINTS or other appropriate primitives\n    \n    // Check for burst triggers in WebGL mode too\n    meteorsRef.current.forEach(meteor => {\n      if (meteor.hasBurst && !meteor.burstTriggered && meteor.progress >= meteor.burstThreshold) {\n        meteor.burstTriggered = true;\n        const burstPosition = meteor.positions[0];\n        \n        // Get velocity at burst point for influence on particles\n        const velocityPoint = { x: 0, y: 0 };\n        getPathVelocity(meteor.progress, meteor.path, velocityPoint);\n        \n        // Create burst with velocity influence\n        // This will add particles to be rendered by renderBurstsWebGL\n        createBurst(\n          burstPosition.x,\n          burstPosition.y,\n          meteor.burstSize,\n          meteor.burstColors,\n          meteor.burstParticles,\n          velocityPoint\n        );\n      }\n    });\n    \n  }, [createBurst, getPathVelocity]);\n  \n  // Update meteor positions\n  const updateMeteors = useCallback((deltaTime) => {\n    // Fix 15: More stable progress calculation to prevent position jumps\n    // Apply a maximum delta time to prevent large jumps after tab switching or lag spikes\n    const cappedDeltaTime = Math.min(deltaTime, 50);\n    \n    // Process meteors without destructuring unused width/height\n    for (let i = meteorsRef.current.length - 1; i >= 0; i--) {\n      const meteor = meteorsRef.current[i];\n      \n      // Update progress based on speed and delta time\n      meteor.progress += meteor.speed * (cappedDeltaTime / 1000);\n      \n      // Check if meteor has completed its path or has fully faded after burst\n      if (meteor.progress >= 1 || (meteor.terminateAfterBurst && meteor.burstTriggered)) {\n        // Return to object pool\n        meteor.active = false;\n        meteor.terminateAfterBurst = false; // Reset for reuse\n        meteor.burstTriggered = false; // Reset for reuse\n        meteor.fadeAfterBurst = false; // Reset fade state\n        meteor.burstFadeStartTime = 0; // Reset fade timing\n        objectPoolsRef.current.meteors.push(meteor);\n        meteorsRef.current.splice(i, 1);\n        continue;\n      }\n      \n      // Calculate current position along the path\n      const currentPos = getPathPoint(Math.min(1, meteor.progress), meteor.path, pointCache.current);\n      \n      // Fix 16: More stable position history update to prevent flickering\n      // Update position history (for trail) using optimized array management\n      // First, check if the position array exists and has enough elements\n      if (!meteor.positions || meteor.positions.length < 2) continue;\n      \n      // Shift positions array one by one to maintain proper history\n      for (let j = meteor.positions.length - 1; j > 0; j--) {\n        const current = meteor.positions[j];\n        const prev = meteor.positions[j - 1];\n        \n        if (!current || !prev) continue;\n        \n        current.x = prev.x;\n        current.y = prev.y;\n      }\n      \n      // Update head position\n      meteor.positions[0].x = currentPos.x;\n      meteor.positions[0].y = currentPos.y;\n    }\n    \n    // Spawn new meteors if needed\n    const now = performance.now();\n    const spawnNeeded = meteorsRef.current.length < adaptedSettings.meteorDensity;\n    const canSpawnNow = !staggered || now >= nextSpawnTimeRef.current;\n    \n    if (spawnNeeded && canSpawnNow) {\n      const newMeteor = initializeMeteor();\n      if (newMeteor) {\n        meteorsRef.current.push(newMeteor);\n        \n        // Set next spawn time if staggering is enabled\n        if (staggered) {\n          const delay = Math.random() * (maxStaggerDelay - minStaggerDelay) + minStaggerDelay;\n          nextSpawnTimeRef.current = now + delay;\n        }\n      }\n    }\n  // Dependencies for updateMeteors\n  }, [\n    adaptedSettings.meteorDensity,\n    staggered,\n    minStaggerDelay,\n    maxStaggerDelay,\n    initializeMeteor,\n    getPathPoint,\n    pointCache\n  ]);\n  \n  // FPS limiter for consistent animation speed\n  const fpsLimiter = useCallback((timestamp, callback) => {\n    // Skip animation if hidden, inactive, or reduced motion\n    if (!isVisible || !active || (respectReducedMotion && prefersReducedMotion) || document.hidden) {\n      animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n      return;\n    }\n    \n    const targetFrameTime = 1000 / maxFPS;\n    const elapsed = timestamp - lastTimestampRef.current;\n    \n    if (elapsed >= targetFrameTime || lastTimestampRef.current === 0) {\n      // Calculate correct delta\n      const delta = lastTimestampRef.current === 0 ? 16 : elapsed;\n      \n      // Update timestamp, limiting delta to avoid jumps after inactivity\n      lastTimestampRef.current = timestamp - (elapsed % targetFrameTime);\n      \n      // Run animation callback with capped delta time\n      callback(Math.min(delta, 50));\n      \n      // FPS tracking for debug and adaptive quality\n      frameCountRef.current++;\n      if (timestamp - fpsTimestampRef.current >= 1000) {\n        currentFpsRef.current = frameCountRef.current;\n        frameCountRef.current = 0;\n        fpsTimestampRef.current = timestamp;\n        \n        // Log FPS in debug mode\n        if (debug) {\n          console.log(`MeteorShower FPS: ${currentFpsRef.current}, Quality: ${qualityFactor.toFixed(2)}`);\n        }\n        \n        // Fix 17: More stable quality adjustment to prevent flickering during quality changes\n        // Dynamic quality adjustment based on performance with debouncing\n        if (adaptiveQuality) {\n          // Check if FPS is stable by counting consecutive frames within target range\n          if (currentFpsRef.current >= maxFPS * 0.95) {\n            stableFrameCountRef.current += 1;\n          } else if (currentFpsRef.current < maxFPS * 0.7) {\n            stableFrameCountRef.current = 0;\n          }\n          \n          // Avoid frequent quality changes by using a timer\n          if (qualityChangeTimerRef.current) {\n            clearTimeout(qualityChangeTimerRef.current);\n          }\n          \n          qualityChangeTimerRef.current = setTimeout(() => {\n            // Only change quality if FPS has been stable or is very low\n            if (currentFpsRef.current < maxFPS * 0.7) {\n              // If FPS is below 70% of target, reduce quality\n              setQualityFactor(prev => {\n                const newQuality = Math.max(0.4, prev * 0.9);\n                lastQualityFactorRef.current = newQuality;\n                return newQuality;\n              });\n            } else if (stableFrameCountRef.current >= 3 && qualityFactor < 1) {\n              // If FPS has been high for several frames, gradually increase quality\n              setQualityFactor(prev => {\n                const newQuality = Math.min(1, prev * 1.05);\n                lastQualityFactorRef.current = newQuality;\n                return newQuality;\n              });\n            }\n          }, 500); // Wait 500ms before changing quality to avoid rapid oscillation\n        }\n      }\n    }\n    \n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n  }, [\n    isVisible,\n    active,\n    respectReducedMotion,\n    prefersReducedMotion,\n    maxFPS,\n    debug,\n    adaptiveQuality,\n    qualityFactor\n  ]);\n  \n  // Main animation handler\n  const handleAnimation = useCallback((deltaTime) => {\n    // Skip if component is not ready\n    if (!canvasRef.current || !isInitialized) return;\n    \n    const now = performance.now();\n    \n    // Calculate parallax offset if enabled\n    let parallaxOffset = 0;\n    if (enableParallax) {\n      parallaxOffset = scrollPositionRef.current * parallaxIntensity;\n    }\n    \n    // Update meteor positions\n    updateMeteors(deltaTime);\n    \n    // Render based on selected mode\n    if (actualRenderingMode === 'webgl' && webGLRef.current) {\n      // WebGL rendering path\n      renderMeteorsWebGL(webGLRef.current, now);\n      \n      // Render burst particles with WebGL\n      if (enableBursts) {\n        renderBurstsWebGL(webGLRef.current, deltaTime);\n      }\n    } else {\n      // Canvas 2D rendering path\n      const ctx = ctxRef.current;\n      if (!ctx) return;\n      \n      // Fix 18: More reliable canvas clearing to prevent flickering artifacts\n      // Clear canvas with optimized clear method\n      ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n      \n      // Render meteors\n      renderMeteors2D(ctx, parallaxOffset, now);\n      \n      // Render burst particles\n      if (enableBursts) {\n        renderBursts2D(ctx, deltaTime);\n      }\n      \n      // Debug visualization\n      if (debug) {\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n        ctx.font = '12px monospace';\n        ctx.fillText(`FPS: ${currentFpsRef.current}`, 10, 20);\n        ctx.fillText(`Meteors: ${meteorsRef.current.length}/${adaptedSettings.meteorDensity}`, 10, 40);\n        ctx.fillText(`Quality: ${qualityFactor.toFixed(2)}`, 10, 60);\n        ctx.fillText(`Rendering: ${actualRenderingMode}`, 10, 80);\n        \n        if (enableBursts) {\n          ctx.fillText(`Bursts: ${burstsRef.current.length}`, 10, 100);\n          ctx.fillText(`Last Burst: ${lastBurstCountRef.current}`, 10, 120);\n        }\n      }\n    }\n  }, [\n    isInitialized,\n    dimensions,\n    adaptedSettings.meteorDensity,\n    enableParallax,\n    parallaxIntensity,\n    actualRenderingMode,\n    debug,\n    updateMeteors,\n    renderMeteors2D,\n    renderMeteorsWebGL,\n    enableBursts,\n    renderBursts2D,\n    renderBurstsWebGL,\n    qualityFactor\n  ]);\n  \n  // Main animation loop\n  useEffect(() => {\n    if (!active || !isInitialized || !dimensions.width || !dimensions.height) {\n      return;\n    }\n    \n    // Start animation with FPS limiter\n    fpsTimestampRef.current = performance.now();\n    frameCountRef.current = 0;\n    lastTimestampRef.current = 0;\n    \n    animationFrameRef.current = requestAnimationFrame(timestamp => {\n      fpsLimiter(timestamp, handleAnimation);\n    });\n    \n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      \n      // Fix 19: Clear quality adjustment timer on unmount\n      if (qualityChangeTimerRef.current) {\n        clearTimeout(qualityChangeTimerRef.current);\n      }\n    };\n  }, [\n    active,\n    isInitialized,\n    dimensions,\n    fpsLimiter,\n    handleAnimation\n  ]);\n  \n  return (\n    <div \n      ref={containerRef}\n      style={{ \n        position: 'absolute',\n        top: 0, \n        left: 0, \n        width: '100%', \n        height: height,\n        overflow: 'hidden', \n        pointerEvents: 'none', \n        zIndex: zIndex,\n        // Hardware acceleration\n        backfaceVisibility: 'hidden',\n        transform: 'translateZ(0)',\n        willChange: 'transform'\n      }}\n      aria-hidden=\"true\"\n    >\n      <canvas \n        ref={canvasRef} \n        style={{ \n          position: 'absolute', \n          top: 0, \n          left: 0, \n          width: '100%', \n          height: '100%',\n          // Additional rendering optimizations\n          imageRendering: 'high-quality',\n          // Hardware acceleration\n          backfaceVisibility: 'hidden',\n          transform: 'translateZ(0)',\n          willChange: 'transform',\n          // Ensures proper subpixel rendering\n          filter: 'none'\n        }} \n      />\n    </div>\n  );\n};\n\n/**\n * GoldenMeteorShower Component\n * \n * A preset version of the MeteorShower with a golden/amber color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const GoldenMeteorShower = (props) => {\n  const goldenPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 245, 158, 0.9)',\n    trailColor: 'rgba(207, 181, 59, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 200,\n    maxStaggerDelay: 2000,\n    enableBursts: true,\n    burstProbability: 0.4,\n    burstParticleSize: 1.8,\n    burstParticleCount: 14\n  };\n  \n  return <MeteorShower {...goldenPreset} {...props} />;\n};\n\n/**\n * CelestialMeteorShower Component\n * \n * A preset version of the MeteorShower with a bluish-purple color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const CelestialMeteorShower = (props) => {\n  const celestialPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(220, 225, 255, 0.9)',\n    trailColor: 'rgba(150, 160, 255, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 300,\n    maxStaggerDelay: 1800,\n    enableBursts: true,\n    burstProbability: 0.35\n  };\n  \n  return <MeteorShower {...celestialPreset} {...props} />;\n};\n\n/**\n * RubyMeteorShower Component\n * \n * A preset version of the MeteorShower with a red color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const RubyMeteorShower = (props) => {\n  const rubyPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 200, 200, 0.9)',\n    trailColor: 'rgba(220, 100, 100, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 350,\n    maxStaggerDelay: 2200,\n    enableBursts: true,\n    burstProbability: 0.45\n  };\n  \n  return <MeteorShower {...rubyPreset} {...props} />;\n};\n\n/**\n * TopMeteorShower Component\n * \n * A preset version of the MeteorShower with meteors falling from the top of the screen\n * at a consistent 30-degree angle, distributed with emphasis on left and center areas.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const TopMeteorShower = (props) => {\n  const topPreset = {\n    mode: 'linear',\n    direction: 'top',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.12,\n    trailLength: 200,\n    trailSegments: 25,\n    journeyCompletion: 0.95,\n    staggered: true,\n    minStaggerDelay: 100,\n    maxStaggerDelay: 1000,\n    enableBursts: true,\n    burstProbability: 0.5,\n    burstParticleCount: 15\n  };\n  \n  return <MeteorShower {...topPreset} {...props} />;\n};\n\n/**\n * TopArcMeteorShower Component\n * \n * A new preset that combines the top-down trajectory with curved arc paths.\n * Meteors start from the top of the screen and curve downward with elegant arcs.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const TopArcMeteorShower = (props) => {\n  const topArcPreset = {\n    mode: 'topArc',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.10,\n    trailLength: 200,\n    trailSegments: 25,\n    arcIntensity: 0.5,\n    arcVariation: 0.2,\n    journeyCompletion: 0.95,\n    staggered: true,\n    minStaggerDelay: 150,\n    maxStaggerDelay: 1200,\n    enableBursts: true,\n    burstProbability: 0.4,\n    burstParticleCount: 12\n  };\n  \n  return <MeteorShower {...topArcPreset} {...props} />;\n};\n\nexport default MeteorShower;"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,SAAS,EAAEC,MAAM,EAAEC,WAAW,EAAEC,OAAO,QAAQ,OAAO;;AAEhF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApDA,SAAAC,MAAA,IAAAC,OAAA;AAqDA,MAAMC,YAAY,GAAGA,CAAC;EACpBC,MAAM,GAAG,OAAO;EAChBC,MAAM,GAAG,CAAC;EACVC,MAAM,GAAG,IAAI;EACbC,aAAa,GAAG,EAAE;EAClBC,aAAa,GAAG,CAAC;EACjBC,aAAa,GAAG,CAAC;EACjBC,WAAW,GAAG,IAAI;EAClBC,WAAW,GAAG,GAAG;EACjBC,aAAa,GAAG,EAAE;EAClBC,SAAS,GAAG,wBAAwB;EACpCC,SAAS,GAAG,0BAA0B;EACtCC,UAAU,GAAG,yBAAyB;EACtCC,cAAc,GAAG,KAAK;EACtBC,iBAAiB,GAAG,GAAG;EACvBC,SAAS,GAAG,IAAI;EAChBC,eAAe,GAAG,GAAG;EACrBC,eAAe,GAAG,IAAI;EACtBC,iBAAiB,GAAG,GAAG;EACvBC,IAAI,GAAG,KAAK;EACZC,SAAS,GAAG,MAAM;EAClBC,SAAS,GAAG,EAAE;EACdC,cAAc,GAAG,EAAE;EACnBC,YAAY,GAAG,GAAG;EAClBC,YAAY,GAAG,GAAG;EAClBC,KAAK,GAAG,KAAK;EACbC,eAAe,GAAG,IAAI;EACtBC,oBAAoB,GAAG,IAAI;EAC3BC,MAAM,GAAG,EAAE;EACXC,QAAQ,GAAG,KAAK;EAChBC,YAAY,GAAG,IAAI;EAAE;EACrBC,aAAa,GAAG,IAAI;EACpBC,aAAa,GAAG,MAAM;EACtBC,wBAAwB,GAAG,IAAI;EAC/BC,kBAAkB,GAAG,EAAE;EACvBC,iBAAiB,GAAG,CAAC;EACrBC,gBAAgB,GAAG,GAAG;EACtBC,mBAAmB,GAAG;AACxB,CAAC,KAAK;EAAAC,GAAA;EAAA,IAAAC,EAAA,GAAAC,YAAA;IAAAC,GAAA,GAAAD,YAAA;EACJ;EACA,MAAME,YAAY,GAAG/C,MAAM,CAAC,IAAI,CAAC;EACjC,MAAMgD,SAAS,GAAGhD,MAAM,CAAC,IAAI,CAAC;EAC9B,MAAMiD,MAAM,GAAGjD,MAAM,CAAC,IAAI,CAAC;EAC3B,MAAMkD,QAAQ,GAAGlD,MAAM,CAAC,IAAI,CAAC;EAC7B,MAAMmD,kBAAkB,GAAGnD,MAAM,CAAC,IAAI,CAAC;EACvC,MAAMoD,SAAS,GAAGpD,MAAM,CAAC,IAAI,CAAC;EAC9B,MAAMqD,UAAU,GAAGrD,MAAM,CAAC,EAAE,CAAC;EAC7B,MAAMsD,SAAS,GAAGtD,MAAM,CAAC,EAAE,CAAC;EAC5B,MAAMuD,iBAAiB,GAAGvD,MAAM,CAAC,IAAI,CAAC;EACtC,MAAMwD,gBAAgB,GAAGxD,MAAM,CAAC,CAAC,CAAC;EAClC,MAAMyD,eAAe,GAAGzD,MAAM,CAAC,CAAC,CAAC;EACjC,MAAM0D,aAAa,GAAG1D,MAAM,CAAC,CAAC,CAAC;EAC/B,MAAM2D,aAAa,GAAG3D,MAAM,CAAC,EAAE,CAAC;EAChC,MAAM4D,gBAAgB,GAAG5D,MAAM,CAAC,CAAC,CAAC;EAClC,MAAM6D,iBAAiB,GAAG7D,MAAM,CAAC,CAAC,CAAC;EACnC,MAAM8D,iBAAiB,GAAG9D,MAAM,CAAC,IAAI,CAAC;EACtC,MAAM+D,qBAAqB,GAAG/D,MAAM,CAAC,IAAI,CAAC;EAC1C,MAAMgE,UAAU,GAAGhE,MAAM,CAAC,IAAI,CAAC;EAC/B,MAAMiE,uBAAuB,GAAGjE,MAAM,CAAC,CAAC,CAAC;EACzC,MAAMkE,iBAAiB,GAAGlE,MAAM,CAAC,CAAC,CAAC;EACnC,MAAMmE,qBAAqB,GAAGnE,MAAM,CAAC,IAAI,CAAC;EAC1C,MAAMoE,oBAAoB,GAAGpE,MAAM,CAAC,CAAC,CAAC;EACtC,MAAMqE,mBAAmB,GAAGrE,MAAM,CAAC,CAAC,CAAC;;EAErC;EACA,MAAM,CAACsE,UAAU,EAAEC,aAAa,CAAC,GAAGzE,QAAQ,CAAC;IAAE0E,KAAK,EAAE,CAAC;IAAElE,MAAM,EAAE,CAAC;IAAEmE,UAAU,EAAE;EAAE,CAAC,CAAC;EACpF,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAG7E,QAAQ,CAAC,KAAK,CAAC;EACzD,MAAM,CAAC8E,oBAAoB,EAAEC,uBAAuB,CAAC,GAAG/E,QAAQ,CAAC,KAAK,CAAC;EACvE,MAAM,CAACgF,SAAS,EAAEC,YAAY,CAAC,GAAGjF,QAAQ,CAAC,KAAK,CAAC;EACjD,MAAM,CAACkF,aAAa,EAAEC,gBAAgB,CAAC,GAAGnF,QAAQ,CAAC,CAAC,CAAC;EACrD,MAAM,CAACoF,mBAAmB,EAAEC,sBAAsB,CAAC,GAAGrF,QAAQ,CAAC,IAAI,CAAC;EACpE,MAAM,CAACsF,kBAAkB,EAAEC,qBAAqB,CAAC,GAAGvF,QAAQ,CAAC;IAC3DwF,MAAM,EAAE,CAAC;IACTC,KAAK,EAAE,CAAC;IACRC,YAAY,EAAE,CAAC;IACfC,QAAQ,EAAE,KAAK;IACfC,aAAa,EAAE,KAAK;IACpBC,uBAAuB,EAAE;EAC3B,CAAC,CAAC;;EAEF;EACA,MAAMC,UAAU,GAAG5F,MAAM,CAAC;IACxB6F,OAAO,EAAE;MAAEC,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE;IAAE,CAAC;IACvBC,OAAO,EAAE;MAAEF,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE;IAAE;EACxB,CAAC,CAAC,CAACF,OAAO;;EAEV;EACA,MAAMI,aAAa,GAAGjG,MAAM,CAAC,IAAIkG,GAAG,CAAC,CAAC,CAAC;;EAEvC;EACA,MAAMC,gBAAgB,GAAGnG,MAAM,CAAC;IAC9BoG,MAAM,EAAE,IAAI;IACZC,KAAK,EAAE,IAAI;IACXC,KAAK,EAAE;EACT,CAAC,CAAC;;EAEF;EACA,MAAMC,cAAc,GAAGvG,MAAM,CAAC;IAC5BwG,OAAO,EAAE,EAAE;IACXC,MAAM,EAAE,EAAE;IACVC,OAAO,EAAE;EACX,CAAC,CAAC;;EAEF;EACA,MAAMC,iBAAiB,GAAGzG,OAAO,CAAC,MAAM;IACtC;IACA,MAAM0G,WAAW,GAAGC,IAAI,CAACC,GAAG,CAC1B1B,kBAAkB,CAACK,QAAQ,GAAG,EAAE,GAAG,EAAE,EACrC3E,aACF,CAAC;IAED,OAAO8F,WAAW;EACpB,CAAC,EAAE,CAAC9F,aAAa,EAAEsE,kBAAkB,CAACK,QAAQ,CAAC,CAAC;;EAEhD;EACA,MAAMsB,kBAAkB,GAAG9G,WAAW,CAAC,MAAM;IAC3C;IACA,MAAMqF,MAAM,GAAG0B,SAAS,CAACC,YAAY,IAAI,CAAC;IAC1C,MAAM1B,KAAK,GAAGyB,SAAS,CAACE,mBAAmB,IAAI,CAAC;IAChD,MAAMzB,QAAQ,GAAG,gEAAgE,CAAC0B,IAAI,CAACH,SAAS,CAACI,SAAS,CAAC;;IAE3G;IACA,IAAI1B,aAAa,GAAG,KAAK;IACzB,IAAI;MACF,MAAM2B,MAAM,GAAGC,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;MAC/C7B,aAAa,GAAG,CAAC,EAAE8B,MAAM,CAACC,qBAAqB,KAC5CJ,MAAM,CAACK,UAAU,CAAC,OAAO,CAAC,IAAIL,MAAM,CAACK,UAAU,CAAC,oBAAoB,CAAC,CAAC,CAAC;IAC5E,CAAC,CAAC,OAAOC,CAAC,EAAE;MACVjC,aAAa,GAAG,KAAK;IACvB;;IAEA;IACA,MAAMC,uBAAuB,GAAG,OAAOiC,eAAe,KAAK,WAAW;;IAEtE;IACA,IAAIZ,SAAS,CAACa,UAAU,IAAIzF,aAAa,EAAE;MACzC4E,SAAS,CAACa,UAAU,CAAC,CAAC,CAACC,IAAI,CAACC,OAAO,IAAI;QACrC/D,UAAU,CAAC6B,OAAO,GAAGkC,OAAO;QAE5B,MAAMC,aAAa,GAAGA,CAAA,KAAM;UAC1B3C,qBAAqB,CAAC4C,IAAI,KAAK;YAC7B,GAAGA,IAAI;YACPzC,YAAY,EAAEuC,OAAO,CAACG,KAAK;YAC3BC,UAAU,EAAEJ,OAAO,CAACK;UACtB,CAAC,CAAC,CAAC;;UAEH;UACA,IAAI,CAACL,OAAO,CAACK,QAAQ,IAAIL,OAAO,CAACG,KAAK,GAAG,GAAG,IAAInG,eAAe,EAAE;YAC/DkD,gBAAgB,CAACgD,IAAI,IAAIpB,IAAI,CAACC,GAAG,CAACmB,IAAI,EAAE,GAAG,CAAC,CAAC;UAC/C;QACF,CAAC;;QAED;QACAF,OAAO,CAACM,gBAAgB,CAAC,aAAa,EAAEL,aAAa,CAAC;QACtDD,OAAO,CAACM,gBAAgB,CAAC,gBAAgB,EAAEL,aAAa,CAAC;;QAEzD;QACAA,aAAa,CAAC,CAAC;MACjB,CAAC,CAAC,CAACM,KAAK,CAAC,MAAM;QACb;QACAjD,qBAAqB,CAAC4C,IAAI,KAAK;UAC7B,GAAGA,IAAI;UACPzC,YAAY,EAAE,CAAC;UACf2C,UAAU,EAAE;QACd,CAAC,CAAC,CAAC;MACL,CAAC,CAAC;IACJ;;IAEA;IACA,IAAII,oBAAoB,GAAG,IAAI;IAC/B,IAAIlG,aAAa,KAAK,MAAM,EAAE;MAC5B,IAAIH,QAAQ,IAAIwD,aAAa,EAAE;QAC7B6C,oBAAoB,GAAG,OAAO;MAChC,CAAC,MAAM;QACLA,oBAAoB,GAAG,IAAI;MAC7B;IACF,CAAC,MAAM;MACLA,oBAAoB,GAAGlG,aAAa,KAAK,OAAO,IAAIqD,aAAa,GAAG,OAAO,GAAG,IAAI;IACpF;IAEAP,sBAAsB,CAACoD,oBAAoB,CAAC;;IAE5C;IACAlD,qBAAqB,CAAC;MACpBC,MAAM;MACNC,KAAK;MACLC,YAAY,EAAE,CAAC;MACf2C,UAAU,EAAE,IAAI;MAChB1C,QAAQ;MACRC,aAAa;MACbC;IACF,CAAC,CAAC;;IAEF;IACA,IAAI5D,eAAe,EAAE;MACnB;MACA,MAAMyG,gBAAgB,GAAIlD,MAAM,GAAGC,KAAK,IAAKE,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC;;MAE9D;MACA,IAAIgD,OAAO,GAAG,CAAC;MAEf,IAAID,gBAAgB,GAAG,EAAE,EAAE;QACzBC,OAAO,GAAG,CAAC,CAAC,CAAC;MACf,CAAC,MAAM,IAAID,gBAAgB,GAAG,CAAC,EAAE;QAC/BC,OAAO,GAAG,GAAG,CAAC,CAAC;MACjB,CAAC,MAAM,IAAID,gBAAgB,GAAG,CAAC,EAAE;QAC/BC,OAAO,GAAG,GAAG,CAAC,CAAC;MACjB,CAAC,MAAM;QACLA,OAAO,GAAG,GAAG,CAAC,CAAC;MACjB;MAEAxD,gBAAgB,CAACwD,OAAO,CAAC;MACzBrE,oBAAoB,CAACyB,OAAO,GAAG4C,OAAO;IACxC;EACF,CAAC,EAAE,CAACvG,QAAQ,EAAEG,aAAa,EAAEN,eAAe,EAAEK,aAAa,CAAC,CAAC;;EAE7D;EACA,MAAMsG,cAAc,GAAGzI,WAAW,CAAC,CAAC0I,SAAS,EAAEC,OAAO,KAAK;IACzD;IACA,MAAMC,WAAW,GAAGhC,IAAI,CAACiC,GAAG,CAAC,CAAC,EAAEjC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE8B,OAAO,IAAI,CAAC,CAAC,CAAC;;IAE1D;IACA,MAAMG,cAAc,GAAGlC,IAAI,CAACmC,KAAK,CAACH,WAAW,GAAG,GAAG,CAAC,GAAG,GAAG;IAC1D,MAAMI,GAAG,GAAG,GAAGN,SAAS,IAAII,cAAc,EAAE;IAE5C,IAAI,CAAC9C,aAAa,CAACJ,OAAO,CAACqD,GAAG,CAACD,GAAG,CAAC,EAAE;MACnC,MAAME,QAAQ,GAAGR,SAAS,CAACS,OAAO,CAAC,WAAW,EAAEL,cAAc,GAAG,GAAG,CAAC;MACrE9C,aAAa,CAACJ,OAAO,CAACwD,GAAG,CAACJ,GAAG,EAAEE,QAAQ,CAAC;IAC1C;IAEA,OAAOlD,aAAa,CAACJ,OAAO,CAACyD,GAAG,CAACL,GAAG,CAAC;EACvC,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAMM,eAAe,GAAGrJ,OAAO,CAAC,MAAM;IACpC,IAAI,CAAC6B,eAAe,IAAIiD,aAAa,KAAK,CAAC,EAAE;MAC3C,OAAO;QACLvE,aAAa;QACbK,aAAa,EAAE6F,iBAAiB;QAChCpE,kBAAkB;QAClBiH,SAAS,EAAE,IAAI;QACfC,OAAO,EAAE,IAAI;QACbC,uBAAuB,EAAE;MAC3B,CAAC;IACH;;IAEA;IACA;IACA,OAAO;MACLjJ,aAAa,EAAEoG,IAAI,CAACiC,GAAG,CAAC,CAAC,EAAEjC,IAAI,CAAC8C,KAAK,CAAClJ,aAAa,GAAGuE,aAAa,CAAC,CAAC;MACrElE,aAAa,EAAE+F,IAAI,CAACiC,GAAG,CAAC,CAAC,EAAEjC,IAAI,CAAC8C,KAAK,CAAChD,iBAAiB,GAAG3B,aAAa,CAAC,CAAC;MACzEzC,kBAAkB,EAAEsE,IAAI,CAACiC,GAAG,CAAC,CAAC,EAAEjC,IAAI,CAAC8C,KAAK,CAACpH,kBAAkB,GAAGyC,aAAa,CAAC,CAAC;MAC/EwE,SAAS,EAAExE,aAAa,GAAG,GAAG;MAC9ByE,OAAO,EAAEzE,aAAa,GAAG,GAAG;MAC5B0E,uBAAuB,EAAE1E,aAAa,GAAG;IAC3C,CAAC;EACH,CAAC,EAAE,CAACjD,eAAe,EAAEiD,aAAa,EAAEvE,aAAa,EAAEkG,iBAAiB,EAAEpE,kBAAkB,CAAC,CAAC;;EAE1F;EACAxC,SAAS,CAAC,MAAM;IACd;IACA,MAAM6J,kBAAkB,GAAGpC,MAAM,CAACqC,UAAU,CAAC,kCAAkC,CAAC;IAChFhF,uBAAuB,CAAC+E,kBAAkB,CAACE,OAAO,CAAC;IAEnD,MAAMC,yBAAyB,GAAIpC,CAAC,IAAK;MACvC9C,uBAAuB,CAAC8C,CAAC,CAACmC,OAAO,CAAC;IACpC,CAAC;IAEDF,kBAAkB,CAACvB,gBAAgB,CAAC,QAAQ,EAAE0B,yBAAyB,CAAC;;IAExE;IACAhD,kBAAkB,CAAC,CAAC;;IAEpB;IACA,MAAMiD,sBAAsB,GAAGA,CAAA,KAAM;MACnC,IAAI1C,QAAQ,CAAC2C,MAAM,EAAE;QACnBhG,uBAAuB,CAAC4B,OAAO,GAAGqE,WAAW,CAACC,GAAG,CAAC,CAAC;MACrD,CAAC,MAAM;QACL;QACA,MAAMC,SAAS,GAAGF,WAAW,CAACC,GAAG,CAAC,CAAC,GAAGlG,uBAAuB,CAAC4B,OAAO;QACrErC,gBAAgB,CAACqC,OAAO,IAAIuE,SAAS;QACrCxG,gBAAgB,CAACiC,OAAO,IAAIuE,SAAS;MACvC;IACF,CAAC;IAED9C,QAAQ,CAACe,gBAAgB,CAAC,kBAAkB,EAAE2B,sBAAsB,CAAC;;IAErE;IACA,MAAMK,aAAa,GAAGjH,SAAS,CAACyC,OAAO;;IAEvC;IACA,OAAO,MAAM;MACX+D,kBAAkB,CAACU,mBAAmB,CAAC,QAAQ,EAAEP,yBAAyB,CAAC;MAC3EzC,QAAQ,CAACgD,mBAAmB,CAAC,kBAAkB,EAAEN,sBAAsB,CAAC;;MAExE;MACA,IAAIK,aAAa,EAAE;QACjBA,aAAa,CAACE,SAAS,CAAC,CAAC;MAC3B;IACF,CAAC;EACH,CAAC,EAAE,CAACxD,kBAAkB,CAAC,CAAC;;EAExB;EACA,MAAMyD,SAAS,GAAGvK,WAAW,CAAC,MAAM;IAClC,IAAI,CAAC+C,SAAS,CAAC6C,OAAO,IAAIX,mBAAmB,KAAK,OAAO,EAAE,OAAO,KAAK;IAEvE,IAAI;MACF;MACA,MAAMuF,EAAE,GAAGzH,SAAS,CAAC6C,OAAO,CAAC6B,UAAU,CAAC,OAAO,EAAE;QAC/CgD,KAAK,EAAE,IAAI;QACXC,SAAS,EAAE,IAAI;QACfC,kBAAkB,EAAE,KAAK;QACzBC,KAAK,EAAE,KAAK;QACZ;QACAC,eAAe,EAAE,kBAAkB;QACnCC,4BAA4B,EAAE;MAChC,CAAC,CAAC;MAEF,IAAI,CAACN,EAAE,EAAE,OAAO,KAAK;MAErBvH,QAAQ,CAAC2C,OAAO,GAAG4E,EAAE;;MAErB;MACA;MACA;;MAEA;MACAA,EAAE,CAACO,MAAM,CAACP,EAAE,CAACQ,KAAK,CAAC;MACnBR,EAAE,CAACS,SAAS,CAACT,EAAE,CAACU,SAAS,EAAEV,EAAE,CAACW,mBAAmB,CAAC;;MAElD;MACAX,EAAE,CAACY,UAAU,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;;MAEjC;MACA,MAAMC,WAAW,GAAGtI,SAAS,CAAC6C,OAAO,CAACrB,KAAK;MAC3C,MAAM+G,YAAY,GAAGvI,SAAS,CAAC6C,OAAO,CAACvF,MAAM;;MAE7C;MACAmK,EAAE,CAACe,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEF,WAAW,EAAEC,YAAY,CAAC;;MAE5C;MACA,MAAME,kBAAkB,GAAG;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;MAED;MACA,MAAMC,oBAAoB,GAAG;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;MAED;MACA,MAAMC,YAAY,GAAGA,CAAClB,EAAE,EAAEmB,IAAI,EAAEC,MAAM,KAAK;QACzC,MAAMC,MAAM,GAAGrB,EAAE,CAACkB,YAAY,CAACC,IAAI,CAAC;QACpCnB,EAAE,CAACsB,YAAY,CAACD,MAAM,EAAED,MAAM,CAAC;QAC/BpB,EAAE,CAACuB,aAAa,CAACF,MAAM,CAAC;;QAExB;QACA,IAAI,CAACrB,EAAE,CAACwB,kBAAkB,CAACH,MAAM,EAAErB,EAAE,CAACyB,cAAc,CAAC,EAAE;UACrDC,OAAO,CAACC,KAAK,CAAC,2BAA2B,EAAE3B,EAAE,CAAC4B,gBAAgB,CAACP,MAAM,CAAC,CAAC;UACvErB,EAAE,CAAC6B,YAAY,CAACR,MAAM,CAAC;UACvB,OAAO,IAAI;QACb;QAEA,OAAOA,MAAM;MACf,CAAC;MAED,MAAMS,YAAY,GAAGZ,YAAY,CAAClB,EAAE,EAAEA,EAAE,CAAC+B,aAAa,EAAEf,kBAAkB,CAAC;MAC3E,MAAMgB,cAAc,GAAGd,YAAY,CAAClB,EAAE,EAAEA,EAAE,CAACiC,eAAe,EAAEhB,oBAAoB,CAAC;MAEjF,IAAI,CAACa,YAAY,IAAI,CAACE,cAAc,EAAE;QACpC,OAAO,KAAK;MACd;MAEA,MAAME,OAAO,GAAGlC,EAAE,CAACmC,aAAa,CAAC,CAAC;MAClCnC,EAAE,CAACoC,YAAY,CAACF,OAAO,EAAEJ,YAAY,CAAC;MACtC9B,EAAE,CAACoC,YAAY,CAACF,OAAO,EAAEF,cAAc,CAAC;MACxChC,EAAE,CAACqC,WAAW,CAACH,OAAO,CAAC;;MAEvB;MACA,IAAI,CAAClC,EAAE,CAACsC,mBAAmB,CAACJ,OAAO,EAAElC,EAAE,CAACuC,WAAW,CAAC,EAAE;QACpDb,OAAO,CAACC,KAAK,CAAC,wBAAwB,EAAE3B,EAAE,CAACwC,iBAAiB,CAACN,OAAO,CAAC,CAAC;QACtElC,EAAE,CAACyC,aAAa,CAACP,OAAO,CAAC;QACzB,OAAO,KAAK;MACd;;MAEA;MACAxG,gBAAgB,CAACN,OAAO,CAACO,MAAM,GAAG;QAChCuG,OAAO;QACPQ,UAAU,EAAE;UACVC,QAAQ,EAAE3C,EAAE,CAAC4C,iBAAiB,CAACV,OAAO,EAAE,WAAW,CAAC;UACpDW,IAAI,EAAE7C,EAAE,CAAC4C,iBAAiB,CAACV,OAAO,EAAE,OAAO,CAAC;UAC5CY,KAAK,EAAE9C,EAAE,CAAC4C,iBAAiB,CAACV,OAAO,EAAE,QAAQ;QAC/C,CAAC;QACDa,QAAQ,EAAE;UACRC,UAAU,EAAEhD,EAAE,CAACiD,kBAAkB,CAACf,OAAO,EAAE,aAAa;QAC1D;MACF,CAAC;;MAED;MACA;;MAEA;MACA,MAAMgB,uBAAuB,GAAG;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;MAED;MACA,MAAMC,yBAAyB,GAAG;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;MAED,MAAMC,iBAAiB,GAAGlC,YAAY,CAAClB,EAAE,EAAEA,EAAE,CAAC+B,aAAa,EAAEmB,uBAAuB,CAAC;MACrF,MAAMG,mBAAmB,GAAGnC,YAAY,CAAClB,EAAE,EAAEA,EAAE,CAACiC,eAAe,EAAEkB,yBAAyB,CAAC;MAE3F,IAAI,CAACC,iBAAiB,IAAI,CAACC,mBAAmB,EAAE;QAC9C,OAAO,KAAK;MACd;MAEA,MAAMC,YAAY,GAAGtD,EAAE,CAACmC,aAAa,CAAC,CAAC;MACvCnC,EAAE,CAACoC,YAAY,CAACkB,YAAY,EAAEF,iBAAiB,CAAC;MAChDpD,EAAE,CAACoC,YAAY,CAACkB,YAAY,EAAED,mBAAmB,CAAC;MAClDrD,EAAE,CAACqC,WAAW,CAACiB,YAAY,CAAC;;MAE5B;MACA,IAAI,CAACtD,EAAE,CAACsC,mBAAmB,CAACgB,YAAY,EAAEtD,EAAE,CAACuC,WAAW,CAAC,EAAE;QACzDb,OAAO,CAACC,KAAK,CAAC,8BAA8B,EAAE3B,EAAE,CAACwC,iBAAiB,CAACc,YAAY,CAAC,CAAC;QACjFtD,EAAE,CAACyC,aAAa,CAACa,YAAY,CAAC;MAChC,CAAC,MAAM;QACL;QACA5H,gBAAgB,CAACN,OAAO,CAACS,KAAK,GAAG;UAC/BqG,OAAO,EAAEoB,YAAY;UACrBZ,UAAU,EAAE;YACVC,QAAQ,EAAE3C,EAAE,CAAC4C,iBAAiB,CAACU,YAAY,EAAE,WAAW,CAAC;YACzDT,IAAI,EAAE7C,EAAE,CAAC4C,iBAAiB,CAACU,YAAY,EAAE,OAAO,CAAC;YACjDR,KAAK,EAAE9C,EAAE,CAAC4C,iBAAiB,CAACU,YAAY,EAAE,QAAQ;UACpD,CAAC;UACDP,QAAQ,EAAE;YACRC,UAAU,EAAEhD,EAAE,CAACiD,kBAAkB,CAACK,YAAY,EAAE,aAAa;UAC/D;QACF,CAAC;MACH;MAEA,OAAO,IAAI;IACb,CAAC,CAAC,OAAO3B,KAAK,EAAE;MACdD,OAAO,CAACC,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;MACnDjH,sBAAsB,CAAC,IAAI,CAAC;MAC5B,OAAO,KAAK;IACd;EACF,CAAC,EAAE,CAACD,mBAAmB,CAAC,CAAC;;EAEzB;EACA,MAAM8I,mBAAmB,GAAG/N,WAAW,CAAC,CAACuE,KAAK,EAAElE,MAAM,KAAK;IACzD,IAAIkB,IAAI,KAAK,KAAK,EAAE;MAClB;MACA,MAAMyM,MAAM,GAAGpH,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG1J,KAAK,GAAG,GAAG,GAAGA,KAAK,GAAG,IAAI;MACzD,MAAM2J,MAAM,GAAGtH,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,EAAE;MAExC,MAAME,cAAc,GAAGvH,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;MACnD,MAAMG,cAAc,GAAGxH,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,GAAG;MAEhD,MAAMI,IAAI,GAAGL,MAAM,GAAIG,cAAc,GAAG5J,KAAK,GAAG6J,cAAe;MAC/D,MAAME,IAAI,GAAGjO,MAAM,GAAGiB,iBAAiB;MAEvC,MAAMiN,QAAQ,GAAG,CAACP,MAAM,GAAGK,IAAI,IAAI,CAAC,GAAIF,cAAc,GAAG5J,KAAK,GAAG6J,cAAe;MAChF,MAAMI,QAAQ,GAAG,CAACN,MAAM,GAAGI,IAAI,IAAI,GAAG;MAEtC,OAAO;QACLG,QAAQ,EAAE,KAAK;QACfC,KAAK,EAAE;UAAE7I,CAAC,EAAEmI,MAAM;UAAElI,CAAC,EAAEoI;QAAO,CAAC;QAC/BS,OAAO,EAAE;UAAE9I,CAAC,EAAE0I,QAAQ;UAAEzI,CAAC,EAAE0I;QAAS,CAAC;QACrCI,GAAG,EAAE;UAAE/I,CAAC,EAAEwI,IAAI;UAAEvI,CAAC,EAAEwI;QAAK;MAC1B,CAAC;IACH,CAAC,MAAM,IAAI/M,IAAI,KAAK,QAAQ,EAAE;MAC5B;MACA;MACA,MAAM4L,QAAQ,GAAGvG,IAAI,CAACqH,MAAM,CAAC,CAAC;MAC9B,IAAID,MAAM;;MAEV;MACA,IAAIb,QAAQ,GAAG,GAAG,EAAE;QAAE;QACpBa,MAAM,GAAGpH,IAAI,CAACqH,MAAM,CAAC,CAAC,IAAI1J,KAAK,GAAG,GAAG,CAAC;MACxC,CAAC,MAAM,IAAI4I,QAAQ,GAAG,GAAG,EAAE;QAAE;QAC3Ba,MAAM,GAAGzJ,KAAK,GAAG,GAAG,GAAGqC,IAAI,CAACqH,MAAM,CAAC,CAAC,IAAI1J,KAAK,GAAG,GAAG,CAAC;MACtD,CAAC,MAAM;QAAE;QACPyJ,MAAM,GAAGzJ,KAAK,GAAG,GAAG,GAAGqC,IAAI,CAACqH,MAAM,CAAC,CAAC,IAAI1J,KAAK,GAAG,GAAG,CAAC;MACtD;;MAEA;MACA,MAAM2J,MAAM,GAAGtH,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,EAAE;;MAExC;MACA,MAAMK,IAAI,GAAGjO,MAAM,GAAGiB,iBAAiB;;MAEvC;MACA;MACA,MAAMuN,UAAU,GAAGjI,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC;MAC9C,MAAMI,IAAI,GAAG9J,KAAK,GAAG,GAAG,GAAG,CAACyJ,MAAM,GAAGzJ,KAAK,GAAG,GAAG,KAAK,CAAC,GAAGsK,UAAU,CAAC;;MAEpE;MACA,MAAMC,SAAS,GAAGnN,YAAY,GAAG,CAACiF,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,IAAIrM,YAAY;;MAEvE;MACA;MACA,MAAMuM,cAAc,GAAGH,MAAM,GAAGzJ,KAAK,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;MACpD,MAAMgK,QAAQ,GAAGP,MAAM,GAAGG,cAAc,GAAG5J,KAAK,GAAGuK,SAAS,GAAG,GAAG;;MAElE;MACA;MACA,MAAMN,QAAQ,GAAGN,MAAM,GAAG,CAACI,IAAI,GAAGJ,MAAM,KAAK,GAAG,GAAGtH,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC;MAEvE,OAAO;QACLQ,QAAQ,EAAE,KAAK;QAAE;QACjBC,KAAK,EAAE;UAAE7I,CAAC,EAAEmI,MAAM;UAAElI,CAAC,EAAEoI;QAAO,CAAC;QAC/BS,OAAO,EAAE;UAAE9I,CAAC,EAAE0I,QAAQ;UAAEzI,CAAC,EAAE0I;QAAS,CAAC;QACrCI,GAAG,EAAE;UAAE/I,CAAC,EAAEwI,IAAI;UAAEvI,CAAC,EAAEwI;QAAK;MAC1B,CAAC;IACH,CAAC,MAAM,IAAI/M,IAAI,KAAK,QAAQ,EAAE;MAC5B;MACA,IAAIwN,eAAe,GAAGvN,SAAS;MAC/B,IAAIA,SAAS,KAAK,MAAM,EAAE;QACxBuN,eAAe,GAAGnI,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,MAAM,GAAG,OAAO;MAC1D;MAEA,IAAIe,KAAK;MACT,IAAIxN,SAAS,KAAK,KAAK,EAAE;QACvB;QACAwN,KAAK,GAAI,CAAC,EAAE,GAAG,CAACpI,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,IAAIrH,IAAI,CAACqI,EAAE,GAAI,GAAG;MAC9D,CAAC,MAAM;QACLD,KAAK,GAAI,CAACvN,SAAS,GAAG,CAACmF,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,IAAIvM,cAAc,IAAIkF,IAAI,CAACqI,EAAE,GAAI,GAAG;MAClF;MAEA,IAAIjB,MAAM;MACV,IAAIe,eAAe,KAAK,MAAM,EAAE;QAC9Bf,MAAM,GAAGpH,IAAI,CAACqH,MAAM,CAAC,CAAC,IAAI1J,KAAK,GAAG,GAAG,CAAC,GAAIA,KAAK,GAAG,GAAI;MACxD,CAAC,MAAM,IAAIwK,eAAe,KAAK,OAAO,EAAE;QACtCf,MAAM,GAAGzJ,KAAK,GAAGqC,IAAI,CAACqH,MAAM,CAAC,CAAC,IAAI1J,KAAK,GAAG,GAAG,CAAC,GAAIA,KAAK,GAAG,GAAI;MAChE,CAAC,MAAM,IAAI/C,SAAS,KAAK,KAAK,EAAE;QAC9B,MAAM2L,QAAQ,GAAGvG,IAAI,CAACqH,MAAM,CAAC,CAAC;QAC9B;QACA,IAAId,QAAQ,GAAG,GAAG,EAAE;UAClBa,MAAM,GAAGpH,IAAI,CAACqH,MAAM,CAAC,CAAC,IAAI1J,KAAK,GAAG,IAAI,CAAC;QACzC,CAAC,MAAM,IAAI4I,QAAQ,GAAG,IAAI,EAAE;UAC1Ba,MAAM,GAAGzJ,KAAK,GAAG,IAAI,GAAGqC,IAAI,CAACqH,MAAM,CAAC,CAAC,IAAI1J,KAAK,GAAG,IAAI,CAAC;QACxD,CAAC,MAAM;UACLyJ,MAAM,GAAGzJ,KAAK,GAAG,GAAG,GAAGqC,IAAI,CAACqH,MAAM,CAAC,CAAC,IAAI1J,KAAK,GAAG,GAAG,CAAC;QACtD;MACF;MAEA,MAAM2J,MAAM,GAAGtH,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,EAAE;MACxC,MAAMiB,gBAAgB,GAAI7O,MAAM,GAAGiB,iBAAiB,GAAIsF,IAAI,CAACuI,GAAG,CAACH,KAAK,CAAC;MAEvE,IAAIX,IAAI,EAAEC,IAAI;MACd,IAAIS,eAAe,KAAK,MAAM,IAAIvN,SAAS,KAAK,KAAK,EAAE;QACrD6M,IAAI,GAAGL,MAAM,GAAGkB,gBAAgB,GAAGtI,IAAI,CAACwI,GAAG,CAACJ,KAAK,CAAC;QAClDV,IAAI,GAAGJ,MAAM,GAAGgB,gBAAgB,GAAGtI,IAAI,CAACuI,GAAG,CAACH,KAAK,CAAC;MACpD,CAAC,MAAM;QACLX,IAAI,GAAGL,MAAM,GAAGkB,gBAAgB,GAAGtI,IAAI,CAACwI,GAAG,CAACJ,KAAK,CAAC;QAClDV,IAAI,GAAGJ,MAAM,GAAGgB,gBAAgB,GAAGtI,IAAI,CAACuI,GAAG,CAACH,KAAK,CAAC;MACpD;MAEA,OAAO;QACLP,QAAQ,EAAE,QAAQ;QAClBC,KAAK,EAAE;UAAE7I,CAAC,EAAEmI,MAAM;UAAElI,CAAC,EAAEoI;QAAO,CAAC;QAC/BU,GAAG,EAAE;UAAE/I,CAAC,EAAEwI,IAAI;UAAEvI,CAAC,EAAEwI;QAAK,CAAC;QACzB9M,SAAS,EAAEuN;MACb,CAAC;IACH;EACF,CAAC,EAAE,CAACxN,IAAI,EAAEC,SAAS,EAAEC,SAAS,EAAEC,cAAc,EAAEJ,iBAAiB,EAAEK,YAAY,EAAEC,YAAY,CAAC,CAAC;;EAE/F;EACA,MAAMyN,YAAY,GAAGrP,WAAW,CAAC,CAACsP,CAAC,EAAEC,IAAI,EAAEC,QAAQ,GAAG;IAAE3J,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAE,CAAC,KAAK;IACvE;IACA,MAAM2J,KAAK,GAAG7I,IAAI,CAACiC,GAAG,CAAC,CAAC,EAAEjC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEyI,CAAC,CAAC,CAAC;IAEzC,IAAIC,IAAI,CAACd,QAAQ,KAAK,KAAK,EAAE;MAC3B;MACA,MAAMiB,IAAI,GAAG,CAAC,GAAGD,KAAK;MACtB,MAAME,WAAW,GAAGD,IAAI,GAAGA,IAAI;MAC/B,MAAME,QAAQ,GAAGH,KAAK,GAAGA,KAAK;MAC9B,MAAMI,KAAK,GAAGF,WAAW;MACzB,MAAMG,KAAK,GAAG,CAAC,GAAGJ,IAAI,GAAGD,KAAK;MAC9B,MAAMM,KAAK,GAAGH,QAAQ;MAEtBJ,QAAQ,CAAC3J,CAAC,GAAGgK,KAAK,GAAGN,IAAI,CAACb,KAAK,CAAC7I,CAAC,GAAGiK,KAAK,GAAGP,IAAI,CAACZ,OAAO,CAAC9I,CAAC,GAAGkK,KAAK,GAAGR,IAAI,CAACX,GAAG,CAAC/I,CAAC;MAC/E2J,QAAQ,CAAC1J,CAAC,GAAG+J,KAAK,GAAGN,IAAI,CAACb,KAAK,CAAC5I,CAAC,GAAGgK,KAAK,GAAGP,IAAI,CAACZ,OAAO,CAAC7I,CAAC,GAAGiK,KAAK,GAAGR,IAAI,CAACX,GAAG,CAAC9I,CAAC;IACjF,CAAC,MAAM;MACL;MACA0J,QAAQ,CAAC3J,CAAC,GAAG0J,IAAI,CAACb,KAAK,CAAC7I,CAAC,GAAG,CAAC0J,IAAI,CAACX,GAAG,CAAC/I,CAAC,GAAG0J,IAAI,CAACb,KAAK,CAAC7I,CAAC,IAAI4J,KAAK;MAC/DD,QAAQ,CAAC1J,CAAC,GAAGyJ,IAAI,CAACb,KAAK,CAAC5I,CAAC,GAAG,CAACyJ,IAAI,CAACX,GAAG,CAAC9I,CAAC,GAAGyJ,IAAI,CAACb,KAAK,CAAC5I,CAAC,IAAI2J,KAAK;IACjE;IAEA,OAAOD,QAAQ;EACjB,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAMQ,eAAe,GAAGhQ,WAAW,CAAC,CAACsP,CAAC,EAAEC,IAAI,EAAEU,WAAW,GAAG;IAAEpK,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAE,CAAC,KAAK;IAC7E;IACA,MAAM2J,KAAK,GAAG7I,IAAI,CAACiC,GAAG,CAAC,CAAC,EAAEjC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEyI,CAAC,CAAC,CAAC;IAEzC,IAAIC,IAAI,CAACd,QAAQ,KAAK,KAAK,EAAE;MAC3B;MACA,MAAMoB,KAAK,GAAG,CAAC,IAAI,CAAC,GAAGJ,KAAK,CAAC;MAC7B,MAAMK,KAAK,GAAG,CAAC,GAAGL,KAAK;MAEvBQ,WAAW,CAACpK,CAAC,GAAGgK,KAAK,IAAIN,IAAI,CAACZ,OAAO,CAAC9I,CAAC,GAAG0J,IAAI,CAACb,KAAK,CAAC7I,CAAC,CAAC,GAAGiK,KAAK,IAAIP,IAAI,CAACX,GAAG,CAAC/I,CAAC,GAAG0J,IAAI,CAACZ,OAAO,CAAC9I,CAAC,CAAC;MAC/FoK,WAAW,CAACnK,CAAC,GAAG+J,KAAK,IAAIN,IAAI,CAACZ,OAAO,CAAC7I,CAAC,GAAGyJ,IAAI,CAACb,KAAK,CAAC5I,CAAC,CAAC,GAAGgK,KAAK,IAAIP,IAAI,CAACX,GAAG,CAAC9I,CAAC,GAAGyJ,IAAI,CAACZ,OAAO,CAAC7I,CAAC,CAAC;IACjG,CAAC,MAAM;MACL;MACAmK,WAAW,CAACpK,CAAC,GAAG0J,IAAI,CAACX,GAAG,CAAC/I,CAAC,GAAG0J,IAAI,CAACb,KAAK,CAAC7I,CAAC;MACzCoK,WAAW,CAACnK,CAAC,GAAGyJ,IAAI,CAACX,GAAG,CAAC9I,CAAC,GAAGyJ,IAAI,CAACb,KAAK,CAAC5I,CAAC;;MAEzC;MACA,MAAMoK,MAAM,GAAGtJ,IAAI,CAACuJ,IAAI,CAACF,WAAW,CAACpK,CAAC,GAAGoK,WAAW,CAACpK,CAAC,GAAGoK,WAAW,CAACnK,CAAC,GAAGmK,WAAW,CAACnK,CAAC,CAAC;MACvF,IAAIoK,MAAM,GAAG,CAAC,EAAE;QACdD,WAAW,CAACpK,CAAC,IAAIqK,MAAM;QACvBD,WAAW,CAACnK,CAAC,IAAIoK,MAAM;MACzB;IACF;IAEA,OAAOD,WAAW;EACpB,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAMG,WAAW,GAAGpQ,WAAW,CAAC,MAAM;IACpC,IAAI,CAAC+C,SAAS,CAAC6C,OAAO,IAAI,CAAC9C,YAAY,CAAC8C,OAAO,EAAE,OAAO,KAAK;IAE7D,MAAMwB,MAAM,GAAGrE,SAAS,CAAC6C,OAAO;IAChC,MAAMyK,SAAS,GAAGvN,YAAY,CAAC8C,OAAO;IACtC,MAAM0K,IAAI,GAAGD,SAAS,CAACE,qBAAqB,CAAC,CAAC;IAC9C,MAAM/L,UAAU,GAAG+C,MAAM,CAACiJ,gBAAgB,IAAI,CAAC;;IAE/C;IACA;IACA,MAAMC,YAAY,GAAG7J,IAAI,CAAC8C,KAAK,CAAC4G,IAAI,CAAC/L,KAAK,CAAC;IAC3C,MAAMmM,aAAa,GAAG,OAAOrQ,MAAM,KAAK,QAAQ,IAAIA,MAAM,CAACsQ,QAAQ,CAAC,IAAI,CAAC,GACrE/J,IAAI,CAAC8C,KAAK,CAAEkH,QAAQ,CAACvQ,MAAM,EAAE,EAAE,CAAC,GAAG,GAAG,GAAIkH,MAAM,CAACsJ,WAAW,CAAC,GAC7DjK,IAAI,CAAC8C,KAAK,CAACkH,QAAQ,CAACvQ,MAAM,EAAE,EAAE,CAAC,IAAIkH,MAAM,CAACsJ,WAAW,CAAC;;IAE1D;IACAzJ,MAAM,CAAC7C,KAAK,GAAGkM,YAAY,GAAGjM,UAAU;IACxC4C,MAAM,CAAC/G,MAAM,GAAGqQ,aAAa,GAAGlM,UAAU;IAC1C4C,MAAM,CAAC0J,KAAK,CAACvM,KAAK,GAAG,GAAGkM,YAAY,IAAI;IACxCrJ,MAAM,CAAC0J,KAAK,CAACzQ,MAAM,GAAG,GAAGqQ,aAAa,IAAI;;IAE1C;IACA,IAAIzL,mBAAmB,KAAK,OAAO,EAAE;MACnCsF,SAAS,CAAC,CAAC;IACb,CAAC,MAAM;MACL;MACA,MAAMwG,GAAG,GAAG3J,MAAM,CAACK,UAAU,CAAC,IAAI,EAAE;QAClCgD,KAAK,EAAE,IAAI;QACXuG,cAAc,EAAE,IAAI;QACpBC,kBAAkB,EAAE;MACtB,CAAC,CAAC;MAEF,IAAI,CAACF,GAAG,EAAE,OAAO,KAAK;;MAEtB;MACAA,GAAG,CAACG,KAAK,CAAC1M,UAAU,EAAEA,UAAU,CAAC;;MAEjC;MACA,IAAI8E,eAAe,CAACG,uBAAuB,EAAE;QAC3CsH,GAAG,CAACI,qBAAqB,GAAG,IAAI;QAChCJ,GAAG,CAACK,qBAAqB,GAAG,MAAM;MACpC;MAEApO,MAAM,CAAC4C,OAAO,GAAGmL,GAAG;IACtB;;IAEA;IACA,IAAI1O,wBAAwB,IAAI,OAAOsF,eAAe,KAAK,WAAW,IAClExC,kBAAkB,CAACO,uBAAuB,EAAE;MAC9C,IAAI;QACF;QACA,MAAM2L,SAAS,GAAG,IAAI1J,eAAe,CACnC8I,YAAY,GAAGjM,UAAU,EACzBkM,aAAa,GAAGlM,UAClB,CAAC;;QAED;QACA,MAAM8M,YAAY,GAAGD,SAAS,CAAC5J,UAAU,CAAC,IAAI,CAAC;QAC/C,IAAI6J,YAAY,EAAE;UAChBA,YAAY,CAACJ,KAAK,CAAC1M,UAAU,EAAEA,UAAU,CAAC;UAC1CtB,kBAAkB,CAAC0C,OAAO,GAAG;YAC3BwB,MAAM,EAAEiK,SAAS;YACjBN,GAAG,EAAEO;UACP,CAAC;QACH;MACF,CAAC,CAAC,OAAOnF,KAAK,EAAE;QACdD,OAAO,CAACqF,IAAI,CAAC,wCAAwC,EAAEpF,KAAK,CAAC;MAC/D;IACF;IAEA7H,aAAa,CAAC;MACZC,KAAK,EAAEkM,YAAY;MACnBpQ,MAAM,EAAEqQ,aAAa;MACrBlM;IACF,CAAC,CAAC;IAEF,OAAO,IAAI;EACb,CAAC,EAAE,CAACnE,MAAM,EAAE4E,mBAAmB,EAAEsF,SAAS,EAAElI,wBAAwB,EAAE8C,kBAAkB,CAACO,uBAAuB,EAAE4D,eAAe,CAACG,uBAAuB,CAAC,CAAC;;EAE3J;EACA3J,SAAS,CAAC,MAAM;IACd,IAAI,CAACgD,YAAY,CAAC8C,OAAO,EAAE;;IAE3B;IACA,MAAM4L,cAAc,GAAG,IAAIC,cAAc,CAACC,OAAO,IAAI;MACnD;MACA,IAAI7N,iBAAiB,CAAC+B,OAAO,CAAC+L,OAAO,EAAE;QACrCC,YAAY,CAAC/N,iBAAiB,CAAC+B,OAAO,CAAC+L,OAAO,CAAC;MACjD;MAEA9N,iBAAiB,CAAC+B,OAAO,CAAC+L,OAAO,GAAGE,UAAU,CAAC,MAAM;QACnDC,qBAAqB,CAAC,MAAM;UAC1B,IAAI1B,WAAW,CAAC,CAAC,EAAE;YACjB1L,gBAAgB,CAAC,IAAI,CAAC;UACxB;QACF,CAAC,CAAC;MACJ,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;IACX,CAAC,CAAC;;IAEF;IACA,MAAMqN,gBAAgB,GAAGjP,YAAY,CAAC8C,OAAO;;IAE7C;IACA4L,cAAc,CAACQ,OAAO,CAACD,gBAAgB,CAAC;IACxClO,iBAAiB,CAAC+B,OAAO,GAAG;MAAEqM,QAAQ,EAAET;IAAe,CAAC;;IAExD;IACApB,WAAW,CAAC,CAAC;IACb1L,gBAAgB,CAAC,IAAI,CAAC;IAEtB,OAAO,MAAM;MACX,IAAIb,iBAAiB,CAAC+B,OAAO,CAACqM,QAAQ,EAAE;QACtCpO,iBAAiB,CAAC+B,OAAO,CAACqM,QAAQ,CAACC,UAAU,CAAC,CAAC;MACjD;MACA,IAAIrO,iBAAiB,CAAC+B,OAAO,CAAC+L,OAAO,EAAE;QACrCC,YAAY,CAAC/N,iBAAiB,CAAC+B,OAAO,CAAC+L,OAAO,CAAC;MACjD;IACF,CAAC;EACH,CAAC,EAAE,CAACvB,WAAW,CAAC,CAAC;;EAEjB;EACAtQ,SAAS,CAAC,MAAM;IACd,IAAI,CAACgD,YAAY,CAAC8C,OAAO,EAAE;IAE3B,MAAMqM,QAAQ,GAAG,IAAIE,oBAAoB,CACvCT,OAAO,IAAI;MACT,MAAMU,cAAc,GAAGV,OAAO,CAAC,CAAC,CAAC,CAACU,cAAc;;MAEhD;MACA,IAAIA,cAAc,KAAKvN,SAAS,EAAE;QAChCC,YAAY,CAACsN,cAAc,CAAC;QAE5B,IAAIA,cAAc,EAAE;UAClB;UACA7O,gBAAgB,CAACqC,OAAO,GAAG,CAAC;UAC5BjC,gBAAgB,CAACiC,OAAO,GAAGqE,WAAW,CAACC,GAAG,CAAC,CAAC;QAC9C;MACF;IACF,CAAC,EACD;MACEmI,SAAS,EAAE,IAAI;MACfC,UAAU,EAAE;IACd,CACF,CAAC;;IAED;IACA,MAAMC,mBAAmB,GAAGzP,YAAY,CAAC8C,OAAO;IAChDqM,QAAQ,CAACD,OAAO,CAACO,mBAAmB,CAAC;IACrCzO,qBAAqB,CAAC8B,OAAO,GAAGqM,QAAQ;IAExC,OAAO,MAAM;MACX,IAAInO,qBAAqB,CAAC8B,OAAO,EAAE;QACjC9B,qBAAqB,CAAC8B,OAAO,CAACsM,UAAU,CAAC,CAAC;MAC5C;IACF,CAAC;EACH,CAAC,EAAE,CAACrN,SAAS,CAAC,CAAC;;EAEf;EACA/E,SAAS,CAAC,MAAM;IACd,IAAI,CAACmB,cAAc,EAAE;;IAErB;IACA,MAAMuR,YAAY,GAAGA,CAAA,KAAM;MACzB5O,iBAAiB,CAACgC,OAAO,GAAG2B,MAAM,CAACkL,OAAO;IAC5C,CAAC;IAEDlL,MAAM,CAACa,gBAAgB,CAAC,QAAQ,EAAEoK,YAAY,EAAE;MAAEE,OAAO,EAAE;IAAK,CAAC,CAAC;IAElE,OAAO,MAAM;MACXnL,MAAM,CAAC8C,mBAAmB,CAAC,QAAQ,EAAEmI,YAAY,CAAC;IACpD,CAAC;EACH,CAAC,EAAE,CAACvR,cAAc,CAAC,CAAC;;EAEpB;EACA,MAAM0R,SAAS,GAAG3S,WAAW,CAAC,MAAM;IAClC;IACA,MAAM4S,IAAI,GAAGtM,cAAc,CAACV,OAAO,CAACW,OAAO;IAC3C,IAAIJ,MAAM;IAEV,IAAIyM,IAAI,CAAC1C,MAAM,GAAG,CAAC,EAAE;MACnB/J,MAAM,GAAGyM,IAAI,CAACC,GAAG,CAAC,CAAC;MACnB;MACA1M,MAAM,CAAC2M,QAAQ,GAAG,CAAC;MACnB3M,MAAM,CAAC5F,MAAM,GAAG,IAAI;IACtB,CAAC,MAAM;MACL;MACA4F,MAAM,GAAG;QACP2M,QAAQ,EAAE,CAAC;QACXvS,MAAM,EAAE,IAAI;QACZwS,SAAS,EAAEC,KAAK,CAAC1J,eAAe,CAACzI,aAAa;MAChD,CAAC;;MAED;MACA,KAAK,IAAIoS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG3J,eAAe,CAACzI,aAAa,EAAEoS,CAAC,EAAE,EAAE;QACtD9M,MAAM,CAAC4M,SAAS,CAACE,CAAC,CAAC,GAAG;UAAEpN,CAAC,EAAE,CAAC;UAAEC,CAAC,EAAE;QAAE,CAAC;MACtC;IACF;IAEA,OAAOK,MAAM;EACf,CAAC,EAAE,CAACmD,eAAe,CAACzI,aAAa,CAAC,CAAC;;EAEnC;EACA,MAAMqS,gBAAgB,GAAGlT,WAAW,CAAC,MAAM;IACzC,MAAM;MAAEuE,KAAK;MAAElE;IAAO,CAAC,GAAGgE,UAAU;IAEpC,IAAI,CAACE,KAAK,IAAI,CAAClE,MAAM,EAAE,OAAO,IAAI;;IAElC;IACA,MAAM8F,MAAM,GAAGwM,SAAS,CAAC,CAAC;;IAE1B;IACA,MAAMpD,IAAI,GAAGxB,mBAAmB,CAACxJ,KAAK,EAAElE,MAAM,CAAC;;IAE/C;IACA8F,MAAM,CAACoJ,IAAI,GAAGA,IAAI;;IAElB;IACA,MAAM4D,YAAY,GAAG;MAAEtN,CAAC,EAAE0J,IAAI,CAACb,KAAK,CAAC7I,CAAC;MAAEC,CAAC,EAAEyJ,IAAI,CAACb,KAAK,CAAC5I;IAAE,CAAC;IACzD,KAAK,IAAImN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG9M,MAAM,CAAC4M,SAAS,CAAC7C,MAAM,EAAE+C,CAAC,EAAE,EAAE;MAChD,IAAI,CAAC9M,MAAM,CAAC4M,SAAS,CAACE,CAAC,CAAC,EAAE;QACxB9M,MAAM,CAAC4M,SAAS,CAACE,CAAC,CAAC,GAAG;UAAEpN,CAAC,EAAEsN,YAAY,CAACtN,CAAC;UAAEC,CAAC,EAAEqN,YAAY,CAACrN;QAAE,CAAC;MAChE,CAAC,MAAM;QACLK,MAAM,CAAC4M,SAAS,CAACE,CAAC,CAAC,CAACpN,CAAC,GAAGsN,YAAY,CAACtN,CAAC;QACtCM,MAAM,CAAC4M,SAAS,CAACE,CAAC,CAAC,CAACnN,CAAC,GAAGqN,YAAY,CAACrN,CAAC;MACxC;IACF;;IAEA;IACAK,MAAM,CAACkH,IAAI,GAAGzG,IAAI,CAACqH,MAAM,CAAC,CAAC,IAAIvN,aAAa,GAAGD,aAAa,CAAC,GAAGA,aAAa;IAC7E0F,MAAM,CAACiN,KAAK,GAAGzS,WAAW,IAAIiG,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,IAAI,CAAC;IACzD9H,MAAM,CAACwC,OAAO,GAAG/B,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,GAAG;IAC1C9H,MAAM,CAACkN,aAAa,GAAG,GAAG,GAAGzM,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,GAAG;IAChD9H,MAAM,CAACmN,UAAU,GAAG1M,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAGrH,IAAI,CAACqI,EAAE,GAAG,CAAC;IAC/C9I,MAAM,CAACoN,UAAU,GAAG3M,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,IAAI,GAAG,KAAK;;IAEhD;IACA,IAAI/L,YAAY,IAAI0E,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAGzL,gBAAgB,EAAE;MACpD2D,MAAM,CAACqN,QAAQ,GAAG,IAAI;;MAEtB;MACA,MAAMC,UAAU,GAAG7M,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;MACzC9H,MAAM,CAACuN,cAAc,GAAGD,UAAU,GAC9B,GAAG,GAAG7M,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC;MAAA,EAC1B,IAAI,GAAGrH,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;;MAEjC9H,MAAM,CAACwN,cAAc,GAAG,KAAK;;MAE7B;MACAxN,MAAM,CAACyN,SAAS,GAAGH,UAAU,GACzBtN,MAAM,CAACkH,IAAI,IAAI,CAAC,GAAGzG,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;MAAA,EACtC9H,MAAM,CAACkH,IAAI,IAAI,CAAC,GAAGzG,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;MAE3C;MACA9H,MAAM,CAAC0N,cAAc,GAAGjN,IAAI,CAAC8C,KAAK,CAChCJ,eAAe,CAAChH,kBAAkB,IACjCmR,UAAU,GAAG,GAAG,GAAG,GAAG,CAAC;MAAG;MAC1B,GAAG,GAAG7M,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,GAAG,CAC5B,CAAC;;MAED;MACA;MACA9H,MAAM,CAAC2N,WAAW,GAAG,CACnB,sBAAsB;MAAE;MACxB,uBAAuB;MAAE;MACzB,uBAAuB;MAAE;MACzB,uBAAuB;MAAE;MACzBL,UAAU,GAAG,wBAAwB,GAAG,wBAAwB,CAAC;MAAA,CAClE;IACH,CAAC,MAAM;MACLtN,MAAM,CAACqN,QAAQ,GAAG,KAAK;IACzB;IAEA,OAAOrN,MAAM;EACf,CAAC,EAAE,CACD9B,UAAU,EACV0J,mBAAmB,EACnBtN,aAAa,EACbC,aAAa,EACbC,WAAW,EACXuB,YAAY,EACZM,gBAAgB,EAChB8G,eAAe,CAAChH,kBAAkB,EAClCqQ,SAAS,CACV,CAAC;;EAEF;EACA,MAAMoB,gBAAgB,GAAG/T,WAAW,CAAC,MAAM;IACzC,MAAM4S,IAAI,GAAGtM,cAAc,CAACV,OAAO,CAACY,MAAM;IAE1C,IAAIoM,IAAI,CAAC1C,MAAM,GAAG,CAAC,EAAE;MACnB,MAAM7J,KAAK,GAAGuM,IAAI,CAACC,GAAG,CAAC,CAAC;MACxB;MACAxM,KAAK,CAAC2N,IAAI,GAAG,GAAG;MAChB,OAAO3N,KAAK;IACd;;IAEA;IACA,OAAO,CAAC,CAAC;EACX,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAM4N,WAAW,GAAGjU,WAAW,CAAC,CAAC6F,CAAC,EAAEC,CAAC,EAAEuH,IAAI,EAAE6G,MAAM,EAAEC,aAAa,EAAEC,iBAAiB,GAAG;IAAEvO,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAE,CAAC,KAAK;IACzG;IACA,IAAI,CAAC5D,YAAY,EAAE;;IAEnB;IACA;IACA,MAAMmS,iBAAiB,GAAG/K,eAAe,CAACG,uBAAuB,GAAG,GAAG,GAAG,GAAG;;IAE7E;IACA,IAAI6K,mBAAmB,GAAGH,aAAa;IACvC,IAAI9Q,SAAS,CAACuC,OAAO,CAACsK,MAAM,GAAGmE,iBAAiB,GAAGF,aAAa,EAAE;MAChEG,mBAAmB,GAAG1N,IAAI,CAACiC,GAAG,CAAC,CAAC,EAAEjC,IAAI,CAAC8C,KAAK,CAACyK,aAAa,GAAG,GAAG,CAAC,CAAC;IACpE;;IAEA;IACA,IAAI9Q,SAAS,CAACuC,OAAO,CAACsK,MAAM,GAAGmE,iBAAiB,EAAE;MAChD;MACA,MAAME,QAAQ,GAAG3N,IAAI,CAACC,GAAG,CAAC,EAAE,EAAExD,SAAS,CAACuC,OAAO,CAACsK,MAAM,GAAGmE,iBAAiB,GAAGC,mBAAmB,CAAC;MACjG,KAAK,IAAIrB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsB,QAAQ,EAAEtB,CAAC,EAAE,EAAE;QACjC,MAAMuB,QAAQ,GAAGnR,SAAS,CAACuC,OAAO,CAAC6O,KAAK,CAAC,CAAC;QAC1C,IAAID,QAAQ,EAAE;UACZlO,cAAc,CAACV,OAAO,CAACY,MAAM,CAACkO,IAAI,CAACF,QAAQ,CAAC;QAC9C;MACF;IACF;;IAEA;IACAvQ,iBAAiB,CAAC2B,OAAO,GAAG0O,mBAAmB;;IAE/C;IACA,KAAK,IAAIrB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqB,mBAAmB,EAAErB,CAAC,EAAE,EAAE;MAC5C;MACA,MAAMxR,SAAS,GAAGmF,IAAI,CAAC+N,KAAK,CAACP,iBAAiB,CAACtO,CAAC,EAAEsO,iBAAiB,CAACvO,CAAC,CAAC;;MAEtE;MACA,MAAM+O,WAAW,GAAG,GAAG,CAAC,CAAC;MACzB,MAAMC,aAAa,GAAIjO,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG2G,WAAW,GAAGA,WAAW,GAAC,CAAE;MACnE,MAAM5F,KAAK,GAAGvN,SAAS,GAAGoT,aAAa;;MAEvC;MACA,MAAMC,aAAa,GAAGlO,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,GAAG;MAC/C,MAAM8G,SAAS,GAAG,GAAG,GAAGnO,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;MAC7C,MAAMmF,KAAK,GAAG2B,SAAS,GAAGD,aAAa;;MAEvC;MACA,MAAME,EAAE,GAAGpO,IAAI,CAACuI,GAAG,CAACH,KAAK,CAAC,GAAGoE,KAAK,GAAGgB,iBAAiB,CAACvO,CAAC,GAAG,GAAG;MAC9D,MAAMoP,EAAE,GAAGrO,IAAI,CAACwI,GAAG,CAACJ,KAAK,CAAC,GAAGoE,KAAK,GAAGgB,iBAAiB,CAACtO,CAAC,GAAG,GAAG;;MAE9D;MACA,MAAMoP,YAAY,GAAG,GAAG,GAAGtO,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,GAAG;MAC9C,MAAMkH,YAAY,GAAG9H,IAAI,GAAG6H,YAAY,GAAG3S,iBAAiB,GAAG,GAAG;;MAElE;MACA,MAAM6S,UAAU,GAAGxO,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;MAChD,MAAMX,KAAK,GAAG8H,UAAU,KAAK,CAAC,GAAGtU,SAAS,GAAGC,SAAS;;MAEtD;MACA,MAAMsF,KAAK,GAAG0N,gBAAgB,CAAC,CAAC;;MAEhC;MACA1N,KAAK,CAACR,CAAC,GAAGA,CAAC;MACXQ,KAAK,CAACP,CAAC,GAAGA,CAAC;MACXO,KAAK,CAAC2O,EAAE,GAAGA,EAAE;MACb3O,KAAK,CAAC4O,EAAE,GAAGA,EAAE;MACb5O,KAAK,CAACgH,IAAI,GAAG8H,YAAY;MACzB9O,KAAK,CAAC2N,IAAI,GAAG,GAAG;MAChB3N,KAAK,CAACgP,KAAK,GAAG,KAAK,GAAGzO,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;MAC5C5H,KAAK,CAACiH,KAAK,GAAGA,KAAK;MACnBjH,KAAK,CAACzF,WAAW,GAAG,CAAC,GAAGgG,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;;MAE3C;MACA5H,KAAK,CAACiP,OAAO,GAAG,IAAI,GAAG1O,IAAI,CAACqH,MAAM,CAAC,CAAC,GAAG,IAAI;;MAE3C;MACA5K,SAAS,CAACuC,OAAO,CAAC8O,IAAI,CAACrO,KAAK,CAAC;IAC/B;EACF,CAAC,EAAE,CAACnE,YAAY,EAAEoH,eAAe,CAACG,uBAAuB,EAAEsK,gBAAgB,EAAExR,iBAAiB,EAAEzB,SAAS,EAAEC,SAAS,CAAC,CAAC;;EAEtH;EACA,MAAMwU,iBAAiB,GAAA5S,EAAA,CAAG3C,WAAW,CAAA2C,EAAA,CAAC,CAAC6H,EAAE,EAAEgL,SAAS,KAAK;IAAA7S,EAAA;IACvD,IAAI,CAACT,YAAY,IAAImB,SAAS,CAACuC,OAAO,CAACsK,MAAM,KAAK,CAAC,IAAI,CAAChK,gBAAgB,CAACN,OAAO,CAACS,KAAK,EAAE;IAExF,MAAMyH,YAAY,GAAG5H,gBAAgB,CAACN,OAAO,CAACS,KAAK;;IAEnD;IACAmE,EAAE,CAACiL,UAAU,CAAC3H,YAAY,CAACpB,OAAO,CAAC;;IAEnC;IACAlC,EAAE,CAACkL,SAAS,CACV5H,YAAY,CAACP,QAAQ,CAACC,UAAU,EAChCzK,SAAS,CAAC6C,OAAO,CAACrB,KAAK,EACvBxB,SAAS,CAAC6C,OAAO,CAACvF,MACpB,CAAC;;IAED;IACA;IACA,MAAM0S,SAAS,GAAG,IAAI4C,YAAY,CAACtS,SAAS,CAACuC,OAAO,CAACsK,MAAM,GAAG,CAAC,CAAC;IAChE;IACA,MAAM0F,KAAK,GAAG,IAAID,YAAY,CAACtS,SAAS,CAACuC,OAAO,CAACsK,MAAM,CAAC;IACxD;IACA,MAAMgE,MAAM,GAAG,IAAIyB,YAAY,CAACtS,SAAS,CAACuC,OAAO,CAACsK,MAAM,GAAG,CAAC,CAAC;;IAE7D;IACA,KAAK,IAAI+C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5P,SAAS,CAACuC,OAAO,CAACsK,MAAM,EAAE+C,CAAC,EAAE,EAAE;MACjD,MAAM5M,KAAK,GAAGhD,SAAS,CAACuC,OAAO,CAACqN,CAAC,CAAC;;MAElC;MACA5M,KAAK,CAACR,CAAC,IAAIQ,KAAK,CAAC2O,EAAE,IAAIQ,SAAS,GAAG,EAAE,CAAC;MACtCnP,KAAK,CAACP,CAAC,IAAIO,KAAK,CAAC4O,EAAE,IAAIO,SAAS,GAAG,EAAE,CAAC;;MAEtC;MACA,IAAInP,KAAK,CAACwP,OAAO,EAAE;QACjBxP,KAAK,CAAC4O,EAAE,IAAI5O,KAAK,CAACwP,OAAO,IAAIL,SAAS,GAAG,EAAE,CAAC;MAC9C;;MAEA;MACAnP,KAAK,CAAC2O,EAAE,IAAI3O,KAAK,CAACiP,OAAO;MACzBjP,KAAK,CAAC4O,EAAE,IAAI5O,KAAK,CAACiP,OAAO;;MAEzB;MACA,IAAIjP,KAAK,CAACyP,aAAa,EAAE;QACvBzP,KAAK,CAAC0P,QAAQ,IAAI1P,KAAK,CAACyP,aAAa,IAAIN,SAAS,GAAG,EAAE,CAAC;MAC1D;;MAEA;MACAnP,KAAK,CAAC2N,IAAI,IAAI3N,KAAK,CAACgP,KAAK,IAAIG,SAAS,GAAG,EAAE,CAAC;;MAE5C;MACA,MAAMQ,QAAQ,GAAG/C,CAAC,GAAG,CAAC;MACtBF,SAAS,CAACiD,QAAQ,CAAC,GAAG3P,KAAK,CAACR,CAAC;MAC7BkN,SAAS,CAACiD,QAAQ,GAAG,CAAC,CAAC,GAAG3P,KAAK,CAACP,CAAC;MAEjC8P,KAAK,CAAC3C,CAAC,CAAC,GAAG5M,KAAK,CAACgH,IAAI,GAAGzG,IAAI,CAACqP,GAAG,CAAC5P,KAAK,CAAC2N,IAAI,EAAE,GAAG,CAAC,GAAG3P,UAAU,CAACG,UAAU;;MAEzE;MACA;MACA,MAAM4Q,UAAU,GAAGnC,CAAC,GAAG,CAAC;MACxBiB,MAAM,CAACkB,UAAU,CAAC,GAAG,GAAG,CAAC,CAAK;MAC9BlB,MAAM,CAACkB,UAAU,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;MAC9BlB,MAAM,CAACkB,UAAU,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;MAC9BlB,MAAM,CAACkB,UAAU,GAAG,CAAC,CAAC,GAAGxO,IAAI,CAACiC,GAAG,CAAC,CAAC,EAAEjC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAER,KAAK,CAAC2N,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;IACvE;;IAEA;IACA,MAAMkC,cAAc,GAAG1L,EAAE,CAAC2L,YAAY,CAAC,CAAC;IACxC3L,EAAE,CAAC4L,UAAU,CAAC5L,EAAE,CAAC6L,YAAY,EAAEH,cAAc,CAAC;IAC9C1L,EAAE,CAAC8L,UAAU,CAAC9L,EAAE,CAAC6L,YAAY,EAAEtD,SAAS,EAAEvI,EAAE,CAAC+L,WAAW,CAAC;IACzD/L,EAAE,CAACgM,uBAAuB,CAAC1I,YAAY,CAACZ,UAAU,CAACC,QAAQ,CAAC;IAC5D3C,EAAE,CAACiM,mBAAmB,CAAC3I,YAAY,CAACZ,UAAU,CAACC,QAAQ,EAAE,CAAC,EAAE3C,EAAE,CAACkM,KAAK,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;;IAElF;IACA,MAAMC,UAAU,GAAGnM,EAAE,CAAC2L,YAAY,CAAC,CAAC;IACpC3L,EAAE,CAAC4L,UAAU,CAAC5L,EAAE,CAAC6L,YAAY,EAAEM,UAAU,CAAC;IAC1CnM,EAAE,CAAC8L,UAAU,CAAC9L,EAAE,CAAC6L,YAAY,EAAET,KAAK,EAAEpL,EAAE,CAAC+L,WAAW,CAAC;IACrD/L,EAAE,CAACgM,uBAAuB,CAAC1I,YAAY,CAACZ,UAAU,CAACG,IAAI,CAAC;IACxD7C,EAAE,CAACiM,mBAAmB,CAAC3I,YAAY,CAACZ,UAAU,CAACG,IAAI,EAAE,CAAC,EAAE7C,EAAE,CAACkM,KAAK,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;;IAE9E;IACA,MAAME,WAAW,GAAGpM,EAAE,CAAC2L,YAAY,CAAC,CAAC;IACrC3L,EAAE,CAAC4L,UAAU,CAAC5L,EAAE,CAAC6L,YAAY,EAAEO,WAAW,CAAC;IAC3CpM,EAAE,CAAC8L,UAAU,CAAC9L,EAAE,CAAC6L,YAAY,EAAEnC,MAAM,EAAE1J,EAAE,CAAC+L,WAAW,CAAC;IACtD/L,EAAE,CAACgM,uBAAuB,CAAC1I,YAAY,CAACZ,UAAU,CAACI,KAAK,CAAC;IACzD9C,EAAE,CAACiM,mBAAmB,CAAC3I,YAAY,CAACZ,UAAU,CAACI,KAAK,EAAE,CAAC,EAAE9C,EAAE,CAACkM,KAAK,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;;IAE/E;IACAlM,EAAE,CAACqM,UAAU,CAACrM,EAAE,CAACsM,MAAM,EAAE,CAAC,EAAEzT,SAAS,CAACuC,OAAO,CAACsK,MAAM,CAAC;;IAErD;IACA1F,EAAE,CAACuM,wBAAwB,CAACjJ,YAAY,CAACZ,UAAU,CAACC,QAAQ,CAAC;IAC7D3C,EAAE,CAACuM,wBAAwB,CAACjJ,YAAY,CAACZ,UAAU,CAACG,IAAI,CAAC;IACzD7C,EAAE,CAACuM,wBAAwB,CAACjJ,YAAY,CAACZ,UAAU,CAACI,KAAK,CAAC;IAC1D9C,EAAE,CAACwM,YAAY,CAACd,cAAc,CAAC;IAC/B1L,EAAE,CAACwM,YAAY,CAACL,UAAU,CAAC;IAC3BnM,EAAE,CAACwM,YAAY,CAACJ,WAAW,CAAC;;IAE5B;IACA,IAAIK,CAAC,GAAG,CAAC;IACT,KAAK,IAAIhE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5P,SAAS,CAACuC,OAAO,CAACsK,MAAM,EAAE+C,CAAC,EAAE,EAAE;MACjD,MAAM5M,KAAK,GAAGhD,SAAS,CAACuC,OAAO,CAACqN,CAAC,CAAC;MAClC,IAAI5M,KAAK,CAAC2N,IAAI,GAAG,CAAC,EAAE;QAClB;QACA,IAAIf,CAAC,KAAKgE,CAAC,EAAE;UACX5T,SAAS,CAACuC,OAAO,CAACqR,CAAC,CAAC,GAAG5Q,KAAK;QAC9B;QACA4Q,CAAC,EAAE;MACL,CAAC,MAAM;QACL;QACA3Q,cAAc,CAACV,OAAO,CAACY,MAAM,CAACkO,IAAI,CAACrO,KAAK,CAAC;MAC3C;IACF;;IAEA;IACA,IAAI4Q,CAAC,GAAG5T,SAAS,CAACuC,OAAO,CAACsK,MAAM,EAAE;MAChC7M,SAAS,CAACuC,OAAO,CAACsK,MAAM,GAAG+G,CAAC;IAC9B;EACF,CAAC;IAAA,QA9GCzM,EAAE,CAACiL,UAAU;EAAA,IA8GZ,CAACvT,YAAY,EAAEmC,UAAU,CAACG,UAAU,CAAC,CAAC;;EAEzC;EACA,MAAM0S,cAAc,GAAGlX,WAAW,CAAC,CAAC+Q,GAAG,EAAEyE,SAAS,KAAK;IACrD,IAAI,CAACtT,YAAY,IAAImB,SAAS,CAACuC,OAAO,CAACsK,MAAM,KAAK,CAAC,EAAE;;IAErD;IACA;IACA,IAAI+G,CAAC,GAAG,CAAC;IACT,KAAK,IAAIhE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5P,SAAS,CAACuC,OAAO,CAACsK,MAAM,EAAE+C,CAAC,EAAE,EAAE;MACjD,MAAM5M,KAAK,GAAGhD,SAAS,CAACuC,OAAO,CAACqN,CAAC,CAAC;;MAElC;MACA5M,KAAK,CAACR,CAAC,IAAIQ,KAAK,CAAC2O,EAAE,IAAIQ,SAAS,GAAG,EAAE,CAAC;MACtCnP,KAAK,CAACP,CAAC,IAAIO,KAAK,CAAC4O,EAAE,IAAIO,SAAS,GAAG,EAAE,CAAC;;MAEtC;MACAnP,KAAK,CAAC2O,EAAE,IAAI3O,KAAK,CAACiP,OAAO;MACzBjP,KAAK,CAAC4O,EAAE,IAAI5O,KAAK,CAACiP,OAAO;;MAEzB;MACAjP,KAAK,CAAC2N,IAAI,IAAI3N,KAAK,CAACgP,KAAK,IAAIG,SAAS,GAAG,EAAE,CAAC;;MAE5C;MACA,IAAInP,KAAK,CAAC2N,IAAI,GAAG,CAAC,EAAE;QAClB;QACAjD,GAAG,CAACoG,IAAI,CAAC,CAAC;;QAEV;QACA,MAAMnI,KAAK,GAAGpI,IAAI,CAAC+N,KAAK,CAACtO,KAAK,CAAC4O,EAAE,EAAE5O,KAAK,CAAC2O,EAAE,CAAC;QAE5C,IAAI1L,eAAe,CAACG,uBAAuB,EAAE;UAC3C;UACA,MAAM7I,WAAW,GAAG,CAACyF,KAAK,CAACzF,WAAW,IAAI,CAAC,IAAIyF,KAAK,CAAC2N,IAAI;UACzD,MAAMoD,YAAY,GAAG/Q,KAAK,CAACgH,IAAI,GAAGhH,KAAK,CAAC2N,IAAI;;UAE5C;UACA,MAAMqD,aAAa,GAAGtG,GAAG,CAACuG,oBAAoB,CAC5CjR,KAAK,CAACR,CAAC,EACPQ,KAAK,CAACP,CAAC,EACPO,KAAK,CAACR,CAAC,GAAGe,IAAI,CAACuI,GAAG,CAACH,KAAK,CAAC,GAAGpO,WAAW,EACvCyF,KAAK,CAACP,CAAC,GAAGc,IAAI,CAACwI,GAAG,CAACJ,KAAK,CAAC,GAAGpO,WAC9B,CAAC;;UAED;UACAyW,aAAa,CAACE,YAAY,CAAC,CAAC,EAAE9O,cAAc,CAACpC,KAAK,CAACiH,KAAK,EAAEjH,KAAK,CAAC2N,IAAI,GAAG,GAAG,CAAC,CAAC;UAC5EqD,aAAa,CAACE,YAAY,CAAC,GAAG,EAAE9O,cAAc,CAACpC,KAAK,CAACiH,KAAK,EAAEjH,KAAK,CAAC2N,IAAI,GAAG,GAAG,CAAC,CAAC;UAC9EqD,aAAa,CAACE,YAAY,CAAC,CAAC,EAAE9O,cAAc,CAACpC,KAAK,CAACiH,KAAK,EAAE,CAAC,CAAC,CAAC;;UAE7D;UACAyD,GAAG,CAACyG,SAAS,CAAC,CAAC;UACfzG,GAAG,CAAC0G,MAAM,CAACpR,KAAK,CAACR,CAAC,EAAEQ,KAAK,CAACP,CAAC,CAAC;UAC5BiL,GAAG,CAAC2G,MAAM,CACRrR,KAAK,CAACR,CAAC,GAAGe,IAAI,CAACuI,GAAG,CAACH,KAAK,CAAC,GAAGpO,WAAW,EACvCyF,KAAK,CAACP,CAAC,GAAGc,IAAI,CAACwI,GAAG,CAACJ,KAAK,CAAC,GAAGpO,WAC9B,CAAC;UACDmQ,GAAG,CAAC4G,SAAS,GAAGP,YAAY,GAAG,GAAG;UAClCrG,GAAG,CAAC6G,OAAO,GAAG,OAAO;UACrB7G,GAAG,CAAC8G,WAAW,GAAGR,aAAa;UAC/BtG,GAAG,CAAC+G,MAAM,CAAC,CAAC;;UAEZ;UACA,IAAIxO,eAAe,CAACE,OAAO,EAAE;YAC3BuH,GAAG,CAACgH,WAAW,GAAG1R,KAAK,CAACiH,KAAK;YAC7ByD,GAAG,CAACiH,UAAU,GAAGZ,YAAY,GAAG,CAAC;UACnC;UAEArG,GAAG,CAACyG,SAAS,CAAC,CAAC;UACfzG,GAAG,CAACkH,GAAG,CAAC5R,KAAK,CAACR,CAAC,EAAEQ,KAAK,CAACP,CAAC,EAAEsR,YAAY,GAAG,GAAG,EAAE,CAAC,EAAExQ,IAAI,CAACqI,EAAE,GAAG,CAAC,CAAC;UAC7D8B,GAAG,CAACmH,SAAS,GAAGzP,cAAc,CAACpC,KAAK,CAACiH,KAAK,EAAEjH,KAAK,CAAC2N,IAAI,CAAC;UACvDjD,GAAG,CAACoH,IAAI,CAAC,CAAC;QACZ,CAAC,MAAM;UACL;UACA,MAAMvX,WAAW,GAAG,CAACyF,KAAK,CAACzF,WAAW,IAAI,CAAC,IAAIyF,KAAK,CAAC2N,IAAI;UACzD,MAAMoD,YAAY,GAAG/Q,KAAK,CAACgH,IAAI,GAAGhH,KAAK,CAAC2N,IAAI;;UAE5C;UACAjD,GAAG,CAACyG,SAAS,CAAC,CAAC;UACfzG,GAAG,CAAC0G,MAAM,CAACpR,KAAK,CAACR,CAAC,EAAEQ,KAAK,CAACP,CAAC,CAAC;UAC5BiL,GAAG,CAAC2G,MAAM,CACRrR,KAAK,CAACR,CAAC,GAAGe,IAAI,CAACuI,GAAG,CAACH,KAAK,CAAC,GAAGpO,WAAW,EACvCyF,KAAK,CAACP,CAAC,GAAGc,IAAI,CAACwI,GAAG,CAACJ,KAAK,CAAC,GAAGpO,WAC9B,CAAC;UACDmQ,GAAG,CAAC4G,SAAS,GAAGP,YAAY,GAAG,GAAG;UAClCrG,GAAG,CAAC6G,OAAO,GAAG,OAAO;UACrB7G,GAAG,CAAC8G,WAAW,GAAGpP,cAAc,CAACpC,KAAK,CAACiH,KAAK,EAAEjH,KAAK,CAAC2N,IAAI,GAAG,GAAG,CAAC;UAC/DjD,GAAG,CAAC+G,MAAM,CAAC,CAAC;QACd;QAEA/G,GAAG,CAACqH,OAAO,CAAC,CAAC;;QAEb;QACA,IAAInF,CAAC,KAAKgE,CAAC,EAAE;UACX5T,SAAS,CAACuC,OAAO,CAACqR,CAAC,CAAC,GAAG5Q,KAAK;QAC9B;QACA4Q,CAAC,EAAE;MACL,CAAC,MAAM;QACL;QACA3Q,cAAc,CAACV,OAAO,CAACY,MAAM,CAACkO,IAAI,CAACrO,KAAK,CAAC;MAC3C;IACF;;IAEA;IACA,IAAI4Q,CAAC,GAAG5T,SAAS,CAACuC,OAAO,CAACsK,MAAM,EAAE;MAChC7M,SAAS,CAACuC,OAAO,CAACsK,MAAM,GAAG+G,CAAC;IAC9B;EACF,CAAC,EAAE,CAAC/U,YAAY,EAAEoH,eAAe,CAACG,uBAAuB,EAAEH,eAAe,CAACE,OAAO,EAAEf,cAAc,CAAC,CAAC;;EAEpG;EACA,MAAM4P,eAAe,GAAGrY,WAAW,CAAC,CAAC+Q,GAAG,EAAEuH,cAAc,EAAEC,SAAS,KAAK;IACtE;IACAnV,UAAU,CAACwC,OAAO,CAAC4S,OAAO,CAACrS,MAAM,IAAI;MACnC;MACA,IAAI,CAACA,MAAM,CAAC4M,SAAS,IAAI,CAAC5M,MAAM,CAAC4M,SAAS,CAAC,CAAC,CAAC,EAAE;;MAE/C;MACA,IAAI0F,cAAc,GAAGtS,MAAM,CAACwC,OAAO;MACnC,IAAIxC,MAAM,CAAC2M,QAAQ,GAAG3M,MAAM,CAACkN,aAAa,EAAE;QAC1C,MAAMqF,YAAY,GAAG,CAACvS,MAAM,CAAC2M,QAAQ,GAAG3M,MAAM,CAACkN,aAAa,KAAK,CAAC,GAAGlN,MAAM,CAACkN,aAAa,CAAC;QAC1FoF,cAAc,GAAGtS,MAAM,CAACwC,OAAO,IAAI,CAAC,GAAG+P,YAAY,CAAC;MACtD;;MAEA;MACA,MAAMC,UAAU,GAAGJ,SAAS,GAAG,KAAK;MACpC,MAAMK,WAAW,GAAGhS,IAAI,CAACwI,GAAG,CAACuJ,UAAU,GAAGxS,MAAM,CAACoN,UAAU,GAAGpN,MAAM,CAACmN,UAAU,CAAC,GAAG,GAAG,GAAG,GAAG;;MAE5F;MACA,MAAMuF,OAAO,GAAG5X,cAAc,GAAGqX,cAAc,IAAInS,MAAM,CAACkH,IAAI,GAAG3M,aAAa,CAAC,GAAG,CAAC;;MAEnF;MACA,IAAIyF,MAAM,CAACqN,QAAQ,IAAI,CAACrN,MAAM,CAACwN,cAAc,IAAIxN,MAAM,CAAC2M,QAAQ,IAAI3M,MAAM,CAACuN,cAAc,EAAE;QACzFvN,MAAM,CAACwN,cAAc,GAAG,IAAI;QAC5B,MAAMmF,aAAa,GAAG3S,MAAM,CAAC4M,SAAS,CAAC,CAAC,CAAC;;QAEzC;QACA,MAAMgG,aAAa,GAAG;UAAElT,CAAC,EAAE,CAAC;UAAEC,CAAC,EAAE;QAAE,CAAC;QACpCkK,eAAe,CAAC7J,MAAM,CAAC2M,QAAQ,EAAE3M,MAAM,CAACoJ,IAAI,EAAEwJ,aAAa,CAAC;;QAE5D;QACAA,aAAa,CAAClT,CAAC,IAAI,GAAG;QACtBkT,aAAa,CAACjT,CAAC,IAAI,GAAG;;QAEtB;QACAmO,WAAW,CACT6E,aAAa,CAACjT,CAAC,EACfiT,aAAa,CAAChT,CAAC,GAAG+S,OAAO,EACzB1S,MAAM,CAACyN,SAAS,EAChBzN,MAAM,CAAC2N,WAAW,EAClB3N,MAAM,CAAC0N,cAAc,EACrBkF,aACF,CAAC;;QAED;QACA5S,MAAM,CAAC6S,kBAAkB,GAAGT,SAAS;QACrCpS,MAAM,CAAC8S,cAAc,GAAG,IAAI;QAC5B9S,MAAM,CAAC+S,cAAc,GAAG/S,MAAM,CAACwC,OAAO,CAAC,CAAC;MAC1C;;MAEA;MACA,IAAIxC,MAAM,CAAC8S,cAAc,EAAE;QACzB;QACA,MAAME,YAAY,GAAG,GAAG;QACxB,MAAMT,YAAY,GAAG9R,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,CAAC0R,SAAS,GAAGpS,MAAM,CAAC6S,kBAAkB,IAAIG,YAAY,CAAC;;QAExF;QACA,MAAMC,QAAQ,GAAG,CAAC,GAAGV,YAAY,GAAGA,YAAY,CAAC,CAAC;QAClDD,cAAc,IAAIW,QAAQ;;QAE1B;QACA,IAAIV,YAAY,IAAI,IAAI,EAAE;UACxBvS,MAAM,CAACkT,mBAAmB,GAAG,IAAI;QACnC;MACF;;MAEA;MACA,IAAI/P,eAAe,CAACG,uBAAuB,EAAE;QAC3C;QACA;QACA,IAAIH,eAAe,CAACE,OAAO,EAAE;UAC3BuH,GAAG,CAACgH,WAAW,GAAGhX,SAAS;UAC3BgQ,GAAG,CAACiH,UAAU,GAAG7R,MAAM,CAACkH,IAAI,GAAG,CAAC,GAAGuL,WAAW;QAChD;;QAEA;QACA7H,GAAG,CAAC6G,OAAO,GAAG,OAAO;QAErB,KAAK,IAAI3E,CAAC,GAAG9M,MAAM,CAAC4M,SAAS,CAAC7C,MAAM,GAAG,CAAC,EAAE+C,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;UACrD,MAAMqG,IAAI,GAAGnT,MAAM,CAAC4M,SAAS,CAACE,CAAC,CAAC;UAChC,MAAMsG,IAAI,GAAGpT,MAAM,CAAC4M,SAAS,CAACE,CAAC,GAAG,CAAC,CAAC;UAEpC,IAAI,CAACqG,IAAI,IAAI,CAACC,IAAI,EAAE;;UAEpB;UACA,MAAMC,cAAc,GAAGf,cAAc,IAAI,CAAC,GAAGxF,CAAC,GAAG9M,MAAM,CAAC4M,SAAS,CAAC7C,MAAM,CAAC,GAAG0I,WAAW;;UAEvF;UACA,IAAIY,cAAc,GAAG,IAAI,EAAE;;UAE3B;UACA,MAAMC,YAAY,GAAGtT,MAAM,CAACkH,IAAI,IAAI,CAAC,GAAG4F,CAAC,GAAG9M,MAAM,CAAC4M,SAAS,CAAC7C,MAAM,GAAG,GAAG,CAAC;;UAE1E;UACAa,GAAG,CAACyG,SAAS,CAAC,CAAC;UACfzG,GAAG,CAAC0G,MAAM,CAAC6B,IAAI,CAACzT,CAAC,EAAEyT,IAAI,CAACxT,CAAC,GAAG+S,OAAO,CAAC;UACpC9H,GAAG,CAAC2G,MAAM,CAAC6B,IAAI,CAAC1T,CAAC,EAAE0T,IAAI,CAACzT,CAAC,GAAG+S,OAAO,CAAC;;UAEpC;UACA9H,GAAG,CAAC4G,SAAS,GAAG8B,YAAY;UAC5B1I,GAAG,CAAC8G,WAAW,GAAGpP,cAAc,CAACzH,UAAU,EAAEwY,cAAc,CAAC;UAC5DzI,GAAG,CAAC+G,MAAM,CAAC,CAAC;QACd;;QAEA;QACA,IAAI3R,MAAM,CAAC4M,SAAS,CAAC,CAAC,CAAC,EAAE;UACvB,MAAM2G,OAAO,GAAGvT,MAAM,CAAC4M,SAAS,CAAC,CAAC,CAAC;;UAEnC;UACA,IAAIzJ,eAAe,CAACC,SAAS,EAAE;YAC7BwH,GAAG,CAACgH,WAAW,GAAGhX,SAAS;YAC3BgQ,GAAG,CAACiH,UAAU,GAAG7R,MAAM,CAACkH,IAAI,GAAG,CAAC,GAAGuL,WAAW;UAChD;;UAEA;UACA7H,GAAG,CAACyG,SAAS,CAAC,CAAC;UACfzG,GAAG,CAACkH,GAAG,CAACyB,OAAO,CAAC7T,CAAC,EAAE6T,OAAO,CAAC5T,CAAC,GAAG+S,OAAO,EAAE1S,MAAM,CAACkH,IAAI,GAAG,GAAG,EAAE,CAAC,EAAEzG,IAAI,CAACqI,EAAE,GAAG,CAAC,CAAC;UAC1E8B,GAAG,CAACmH,SAAS,GAAGzP,cAAc,CAAC1H,SAAS,EAAE0X,cAAc,GAAG,GAAG,GAAGG,WAAW,CAAC;UAC7E7H,GAAG,CAACoH,IAAI,CAAC,CAAC;;UAEV;UACApH,GAAG,CAACyG,SAAS,CAAC,CAAC;UACfzG,GAAG,CAACkH,GAAG,CAACyB,OAAO,CAAC7T,CAAC,EAAE6T,OAAO,CAAC5T,CAAC,GAAG+S,OAAO,EAAE1S,MAAM,CAACkH,IAAI,GAAG,GAAG,EAAE,CAAC,EAAEzG,IAAI,CAACqI,EAAE,GAAG,CAAC,CAAC;UAC1E8B,GAAG,CAACmH,SAAS,GAAGzP,cAAc,CAAC3H,SAAS,EAAE2X,cAAc,GAAGG,WAAW,CAAC;UACvE7H,GAAG,CAACoH,IAAI,CAAC,CAAC;QACZ;MACF,CAAC,MAAM;QACL;QACA;QACApH,GAAG,CAACyG,SAAS,CAAC,CAAC;QACf,MAAMkC,OAAO,GAAGvT,MAAM,CAAC4M,SAAS,CAAC,CAAC,CAAC;QACnC,IAAI,CAAC2G,OAAO,EAAE;QAEd3I,GAAG,CAAC0G,MAAM,CAACiC,OAAO,CAAC7T,CAAC,EAAE6T,OAAO,CAAC5T,CAAC,GAAG+S,OAAO,CAAC;QAE1C,KAAK,IAAI5F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG9M,MAAM,CAAC4M,SAAS,CAAC7C,MAAM,EAAE+C,CAAC,IAAI,CAAC,EAAE;UACnD,MAAM0G,GAAG,GAAGxT,MAAM,CAAC4M,SAAS,CAACE,CAAC,CAAC;UAC/B,IAAI,CAAC0G,GAAG,EAAE;UACV5I,GAAG,CAAC2G,MAAM,CAACiC,GAAG,CAAC9T,CAAC,EAAE8T,GAAG,CAAC7T,CAAC,GAAG+S,OAAO,CAAC;QACpC;;QAEA;QACA,MAAMe,QAAQ,GAAG7I,GAAG,CAACuG,oBAAoB,CACvCoC,OAAO,CAAC7T,CAAC,EAAE6T,OAAO,CAAC5T,CAAC,GAAG+S,OAAO,EAC9B1S,MAAM,CAAC4M,SAAS,CAAC5M,MAAM,CAAC4M,SAAS,CAAC7C,MAAM,GAAG,CAAC,CAAC,CAACrK,CAAC,EAC/CM,MAAM,CAAC4M,SAAS,CAAC5M,MAAM,CAAC4M,SAAS,CAAC7C,MAAM,GAAG,CAAC,CAAC,CAACpK,CAAC,GAAG+S,OACpD,CAAC;QAEDe,QAAQ,CAACrC,YAAY,CAAC,CAAC,EAAE9O,cAAc,CAAC3H,SAAS,EAAE2X,cAAc,GAAGG,WAAW,CAAC,CAAC;QACjFgB,QAAQ,CAACrC,YAAY,CAAC,GAAG,EAAE9O,cAAc,CAAC1H,SAAS,EAAE0X,cAAc,GAAG,GAAG,GAAGG,WAAW,CAAC,CAAC;QACzFgB,QAAQ,CAACrC,YAAY,CAAC,CAAC,EAAE9O,cAAc,CAACzH,UAAU,EAAE,CAAC,CAAC,CAAC;QAEvD+P,GAAG,CAAC8G,WAAW,GAAG+B,QAAQ;QAC1B7I,GAAG,CAAC4G,SAAS,GAAGxR,MAAM,CAACkH,IAAI;QAC3B0D,GAAG,CAAC6G,OAAO,GAAG,OAAO;QACrB7G,GAAG,CAAC+G,MAAM,CAAC,CAAC;;QAEZ;QACA/G,GAAG,CAACyG,SAAS,CAAC,CAAC;QACfzG,GAAG,CAACkH,GAAG,CAACyB,OAAO,CAAC7T,CAAC,EAAE6T,OAAO,CAAC5T,CAAC,GAAG+S,OAAO,EAAE1S,MAAM,CAACkH,IAAI,GAAG,GAAG,EAAE,CAAC,EAAEzG,IAAI,CAACqI,EAAE,GAAG,CAAC,CAAC;QAC1E8B,GAAG,CAACmH,SAAS,GAAGzP,cAAc,CAAC3H,SAAS,EAAE2X,cAAc,GAAGG,WAAW,CAAC;QACvE7H,GAAG,CAACoH,IAAI,CAAC,CAAC;MACZ;IACF,CAAC,CAAC;EACJ,CAAC,EAAE,CACD7O,eAAe,CAACG,uBAAuB,EACvCH,eAAe,CAACE,OAAO,EACvBF,eAAe,CAACC,SAAS,EACzBtI,cAAc,EACdP,aAAa,EACbK,SAAS,EACTC,UAAU,EACVF,SAAS,EACT2H,cAAc,EACdwL,WAAW,EACXjE,eAAe,CAChB,CAAC;;EAEF;EACA,MAAM6J,kBAAkB,GAAAhX,GAAA,CAAG7C,WAAW,CAAA6C,GAAA,CAAC,CAAC2H,EAAE,EAAE+N,SAAS,KAAK;IAAA1V,GAAA;IACxD;IACA;;IAEA,IAAI,CAAC2H,EAAE,IAAI,CAACtE,gBAAgB,CAACN,OAAO,CAACO,MAAM,EAAE;;IAE7C;IACAqE,EAAE,CAACsP,KAAK,CAACtP,EAAE,CAACuP,gBAAgB,CAAC;;IAE7B;IACA,MAAMC,aAAa,GAAG9T,gBAAgB,CAACN,OAAO,CAACO,MAAM;IACrDqE,EAAE,CAACiL,UAAU,CAACuE,aAAa,CAACtN,OAAO,CAAC;;IAEpC;IACAlC,EAAE,CAACkL,SAAS,CACVsE,aAAa,CAACzM,QAAQ,CAACC,UAAU,EACjCzK,SAAS,CAAC6C,OAAO,CAACrB,KAAK,EACvBxB,SAAS,CAAC6C,OAAO,CAACvF,MACpB,CAAC;;IAED;IACA;IACA;IACA;IACA;;IAEA;IACA+C,UAAU,CAACwC,OAAO,CAAC4S,OAAO,CAACrS,MAAM,IAAI;MACnC,IAAIA,MAAM,CAACqN,QAAQ,IAAI,CAACrN,MAAM,CAACwN,cAAc,IAAIxN,MAAM,CAAC2M,QAAQ,IAAI3M,MAAM,CAACuN,cAAc,EAAE;QACzFvN,MAAM,CAACwN,cAAc,GAAG,IAAI;QAC5B,MAAMmF,aAAa,GAAG3S,MAAM,CAAC4M,SAAS,CAAC,CAAC,CAAC;;QAEzC;QACA,MAAMgG,aAAa,GAAG;UAAElT,CAAC,EAAE,CAAC;UAAEC,CAAC,EAAE;QAAE,CAAC;QACpCkK,eAAe,CAAC7J,MAAM,CAAC2M,QAAQ,EAAE3M,MAAM,CAACoJ,IAAI,EAAEwJ,aAAa,CAAC;;QAE5D;QACA;QACA9E,WAAW,CACT6E,aAAa,CAACjT,CAAC,EACfiT,aAAa,CAAChT,CAAC,EACfK,MAAM,CAACyN,SAAS,EAChBzN,MAAM,CAAC2N,WAAW,EAClB3N,MAAM,CAAC0N,cAAc,EACrBkF,aACF,CAAC;MACH;IACF,CAAC,CAAC;EAEJ,CAAC;IAAA,QAtCCvO,EAAE,CAACiL,UAAU;EAAA,IAsCZ,CAACxB,WAAW,EAAEjE,eAAe,CAAC,CAAC;;EAElC;EACA,MAAMiK,aAAa,GAAGja,WAAW,CAAEwV,SAAS,IAAK;IAC/C;IACA;IACA,MAAM0E,eAAe,GAAGtT,IAAI,CAACC,GAAG,CAAC2O,SAAS,EAAE,EAAE,CAAC;;IAE/C;IACA,KAAK,IAAIvC,CAAC,GAAG7P,UAAU,CAACwC,OAAO,CAACsK,MAAM,GAAG,CAAC,EAAE+C,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACvD,MAAM9M,MAAM,GAAG/C,UAAU,CAACwC,OAAO,CAACqN,CAAC,CAAC;;MAEpC;MACA9M,MAAM,CAAC2M,QAAQ,IAAI3M,MAAM,CAACiN,KAAK,IAAI8G,eAAe,GAAG,IAAI,CAAC;;MAE1D;MACA,IAAI/T,MAAM,CAAC2M,QAAQ,IAAI,CAAC,IAAK3M,MAAM,CAACkT,mBAAmB,IAAIlT,MAAM,CAACwN,cAAe,EAAE;QACjF;QACAxN,MAAM,CAAC5F,MAAM,GAAG,KAAK;QACrB4F,MAAM,CAACkT,mBAAmB,GAAG,KAAK,CAAC,CAAC;QACpClT,MAAM,CAACwN,cAAc,GAAG,KAAK,CAAC,CAAC;QAC/BxN,MAAM,CAAC8S,cAAc,GAAG,KAAK,CAAC,CAAC;QAC/B9S,MAAM,CAAC6S,kBAAkB,GAAG,CAAC,CAAC,CAAC;QAC/B1S,cAAc,CAACV,OAAO,CAACW,OAAO,CAACmO,IAAI,CAACvO,MAAM,CAAC;QAC3C/C,UAAU,CAACwC,OAAO,CAACuU,MAAM,CAAClH,CAAC,EAAE,CAAC,CAAC;QAC/B;MACF;;MAEA;MACA,MAAMmH,UAAU,GAAG/K,YAAY,CAACzI,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEV,MAAM,CAAC2M,QAAQ,CAAC,EAAE3M,MAAM,CAACoJ,IAAI,EAAE5J,UAAU,CAACC,OAAO,CAAC;;MAE9F;MACA;MACA;MACA,IAAI,CAACO,MAAM,CAAC4M,SAAS,IAAI5M,MAAM,CAAC4M,SAAS,CAAC7C,MAAM,GAAG,CAAC,EAAE;;MAEtD;MACA,KAAK,IAAI+G,CAAC,GAAG9Q,MAAM,CAAC4M,SAAS,CAAC7C,MAAM,GAAG,CAAC,EAAE+G,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QACpD,MAAMrR,OAAO,GAAGO,MAAM,CAAC4M,SAAS,CAACkE,CAAC,CAAC;QACnC,MAAMjP,IAAI,GAAG7B,MAAM,CAAC4M,SAAS,CAACkE,CAAC,GAAG,CAAC,CAAC;QAEpC,IAAI,CAACrR,OAAO,IAAI,CAACoC,IAAI,EAAE;QAEvBpC,OAAO,CAACC,CAAC,GAAGmC,IAAI,CAACnC,CAAC;QAClBD,OAAO,CAACE,CAAC,GAAGkC,IAAI,CAAClC,CAAC;MACpB;;MAEA;MACAK,MAAM,CAAC4M,SAAS,CAAC,CAAC,CAAC,CAAClN,CAAC,GAAGuU,UAAU,CAACvU,CAAC;MACpCM,MAAM,CAAC4M,SAAS,CAAC,CAAC,CAAC,CAACjN,CAAC,GAAGsU,UAAU,CAACtU,CAAC;IACtC;;IAEA;IACA,MAAMoE,GAAG,GAAGD,WAAW,CAACC,GAAG,CAAC,CAAC;IAC7B,MAAMmQ,WAAW,GAAGjX,UAAU,CAACwC,OAAO,CAACsK,MAAM,GAAG5G,eAAe,CAAC9I,aAAa;IAC7E,MAAM8Z,WAAW,GAAG,CAACnZ,SAAS,IAAI+I,GAAG,IAAIvG,gBAAgB,CAACiC,OAAO;IAEjE,IAAIyU,WAAW,IAAIC,WAAW,EAAE;MAC9B,MAAMC,SAAS,GAAGrH,gBAAgB,CAAC,CAAC;MACpC,IAAIqH,SAAS,EAAE;QACbnX,UAAU,CAACwC,OAAO,CAAC8O,IAAI,CAAC6F,SAAS,CAAC;;QAElC;QACA,IAAIpZ,SAAS,EAAE;UACb,MAAMqZ,KAAK,GAAG5T,IAAI,CAACqH,MAAM,CAAC,CAAC,IAAI5M,eAAe,GAAGD,eAAe,CAAC,GAAGA,eAAe;UACnFuC,gBAAgB,CAACiC,OAAO,GAAGsE,GAAG,GAAGsQ,KAAK;QACxC;MACF;IACF;IACF;EACA,CAAC,EAAE,CACDlR,eAAe,CAAC9I,aAAa,EAC7BW,SAAS,EACTC,eAAe,EACfC,eAAe,EACf6R,gBAAgB,EAChB7D,YAAY,EACZ1J,UAAU,CACX,CAAC;;EAEF;EACA,MAAM8U,UAAU,GAAGza,WAAW,CAAC,CAACuY,SAAS,EAAEmC,QAAQ,KAAK;IACtD;IACA,IAAI,CAAC7V,SAAS,IAAI,CAACtE,MAAM,IAAKwB,oBAAoB,IAAI4C,oBAAqB,IAAI0C,QAAQ,CAAC2C,MAAM,EAAE;MAC9F1G,iBAAiB,CAACsC,OAAO,GAAGkM,qBAAqB,CAAC6I,IAAI,IAAIF,UAAU,CAACE,IAAI,EAAED,QAAQ,CAAC,CAAC;MACrF;IACF;IAEA,MAAME,eAAe,GAAG,IAAI,GAAG5Y,MAAM;IACrC,MAAM6Y,OAAO,GAAGtC,SAAS,GAAGhV,gBAAgB,CAACqC,OAAO;IAEpD,IAAIiV,OAAO,IAAID,eAAe,IAAIrX,gBAAgB,CAACqC,OAAO,KAAK,CAAC,EAAE;MAChE;MACA,MAAMkV,KAAK,GAAGvX,gBAAgB,CAACqC,OAAO,KAAK,CAAC,GAAG,EAAE,GAAGiV,OAAO;;MAE3D;MACAtX,gBAAgB,CAACqC,OAAO,GAAG2S,SAAS,GAAIsC,OAAO,GAAGD,eAAgB;;MAElE;MACAF,QAAQ,CAAC9T,IAAI,CAACC,GAAG,CAACiU,KAAK,EAAE,EAAE,CAAC,CAAC;;MAE7B;MACArX,aAAa,CAACmC,OAAO,EAAE;MACvB,IAAI2S,SAAS,GAAG/U,eAAe,CAACoC,OAAO,IAAI,IAAI,EAAE;QAC/ClC,aAAa,CAACkC,OAAO,GAAGnC,aAAa,CAACmC,OAAO;QAC7CnC,aAAa,CAACmC,OAAO,GAAG,CAAC;QACzBpC,eAAe,CAACoC,OAAO,GAAG2S,SAAS;;QAEnC;QACA,IAAI1W,KAAK,EAAE;UACTqK,OAAO,CAAC6O,GAAG,CAAC,qBAAqBrX,aAAa,CAACkC,OAAO,cAAcb,aAAa,CAACiW,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC;QACjG;;QAEA;QACA;QACA,IAAIlZ,eAAe,EAAE;UACnB;UACA,IAAI4B,aAAa,CAACkC,OAAO,IAAI5D,MAAM,GAAG,IAAI,EAAE;YAC1CoC,mBAAmB,CAACwB,OAAO,IAAI,CAAC;UAClC,CAAC,MAAM,IAAIlC,aAAa,CAACkC,OAAO,GAAG5D,MAAM,GAAG,GAAG,EAAE;YAC/CoC,mBAAmB,CAACwB,OAAO,GAAG,CAAC;UACjC;;UAEA;UACA,IAAI1B,qBAAqB,CAAC0B,OAAO,EAAE;YACjCgM,YAAY,CAAC1N,qBAAqB,CAAC0B,OAAO,CAAC;UAC7C;UAEA1B,qBAAqB,CAAC0B,OAAO,GAAGiM,UAAU,CAAC,MAAM;YAC/C;YACA,IAAInO,aAAa,CAACkC,OAAO,GAAG5D,MAAM,GAAG,GAAG,EAAE;cACxC;cACAgD,gBAAgB,CAACgD,IAAI,IAAI;gBACvB,MAAMiT,UAAU,GAAGrU,IAAI,CAACiC,GAAG,CAAC,GAAG,EAAEb,IAAI,GAAG,GAAG,CAAC;gBAC5C7D,oBAAoB,CAACyB,OAAO,GAAGqV,UAAU;gBACzC,OAAOA,UAAU;cACnB,CAAC,CAAC;YACJ,CAAC,MAAM,IAAI7W,mBAAmB,CAACwB,OAAO,IAAI,CAAC,IAAIb,aAAa,GAAG,CAAC,EAAE;cAChE;cACAC,gBAAgB,CAACgD,IAAI,IAAI;gBACvB,MAAMiT,UAAU,GAAGrU,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEmB,IAAI,GAAG,IAAI,CAAC;gBAC3C7D,oBAAoB,CAACyB,OAAO,GAAGqV,UAAU;gBACzC,OAAOA,UAAU;cACnB,CAAC,CAAC;YACJ;UACF,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;QACX;MACF;IACF;;IAEA;IACA3X,iBAAiB,CAACsC,OAAO,GAAGkM,qBAAqB,CAAC6I,IAAI,IAAIF,UAAU,CAACE,IAAI,EAAED,QAAQ,CAAC,CAAC;EACvF,CAAC,EAAE,CACD7V,SAAS,EACTtE,MAAM,EACNwB,oBAAoB,EACpB4C,oBAAoB,EACpB3C,MAAM,EACNH,KAAK,EACLC,eAAe,EACfiD,aAAa,CACd,CAAC;;EAEF;EACA,MAAMmW,eAAe,GAAGlb,WAAW,CAAEwV,SAAS,IAAK;IACjD;IACA,IAAI,CAACzS,SAAS,CAAC6C,OAAO,IAAI,CAACnB,aAAa,EAAE;IAE1C,MAAMyF,GAAG,GAAGD,WAAW,CAACC,GAAG,CAAC,CAAC;;IAE7B;IACA,IAAIoO,cAAc,GAAG,CAAC;IACtB,IAAIrX,cAAc,EAAE;MAClBqX,cAAc,GAAG1U,iBAAiB,CAACgC,OAAO,GAAG1E,iBAAiB;IAChE;;IAEA;IACA+Y,aAAa,CAACzE,SAAS,CAAC;;IAExB;IACA,IAAIvQ,mBAAmB,KAAK,OAAO,IAAIhC,QAAQ,CAAC2C,OAAO,EAAE;MACvD;MACAiU,kBAAkB,CAAC5W,QAAQ,CAAC2C,OAAO,EAAEsE,GAAG,CAAC;;MAEzC;MACA,IAAIhI,YAAY,EAAE;QAChBqT,iBAAiB,CAACtS,QAAQ,CAAC2C,OAAO,EAAE4P,SAAS,CAAC;MAChD;IACF,CAAC,MAAM;MACL;MACA,MAAMzE,GAAG,GAAG/N,MAAM,CAAC4C,OAAO;MAC1B,IAAI,CAACmL,GAAG,EAAE;;MAEV;MACA;MACAA,GAAG,CAACoK,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE9W,UAAU,CAACE,KAAK,EAAEF,UAAU,CAAChE,MAAM,CAAC;;MAExD;MACAgY,eAAe,CAACtH,GAAG,EAAEuH,cAAc,EAAEpO,GAAG,CAAC;;MAEzC;MACA,IAAIhI,YAAY,EAAE;QAChBgV,cAAc,CAACnG,GAAG,EAAEyE,SAAS,CAAC;MAChC;;MAEA;MACA,IAAI3T,KAAK,EAAE;QACTkP,GAAG,CAACmH,SAAS,GAAG,0BAA0B;QAC1CnH,GAAG,CAACqK,IAAI,GAAG,gBAAgB;QAC3BrK,GAAG,CAACsK,QAAQ,CAAC,QAAQ3X,aAAa,CAACkC,OAAO,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;QACrDmL,GAAG,CAACsK,QAAQ,CAAC,YAAYjY,UAAU,CAACwC,OAAO,CAACsK,MAAM,IAAI5G,eAAe,CAAC9I,aAAa,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;QAC9FuQ,GAAG,CAACsK,QAAQ,CAAC,YAAYtW,aAAa,CAACiW,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;QAC5DjK,GAAG,CAACsK,QAAQ,CAAC,cAAcpW,mBAAmB,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;QAEzD,IAAI/C,YAAY,EAAE;UAChB6O,GAAG,CAACsK,QAAQ,CAAC,WAAWhY,SAAS,CAACuC,OAAO,CAACsK,MAAM,EAAE,EAAE,EAAE,EAAE,GAAG,CAAC;UAC5Da,GAAG,CAACsK,QAAQ,CAAC,eAAepX,iBAAiB,CAAC2B,OAAO,EAAE,EAAE,EAAE,EAAE,GAAG,CAAC;QACnE;MACF;IACF;EACF,CAAC,EAAE,CACDnB,aAAa,EACbJ,UAAU,EACViF,eAAe,CAAC9I,aAAa,EAC7BS,cAAc,EACdC,iBAAiB,EACjB+D,mBAAmB,EACnBpD,KAAK,EACLoY,aAAa,EACb5B,eAAe,EACfwB,kBAAkB,EAClB3X,YAAY,EACZgV,cAAc,EACd3B,iBAAiB,EACjBxQ,aAAa,CACd,CAAC;;EAEF;EACAjF,SAAS,CAAC,MAAM;IACd,IAAI,CAACS,MAAM,IAAI,CAACkE,aAAa,IAAI,CAACJ,UAAU,CAACE,KAAK,IAAI,CAACF,UAAU,CAAChE,MAAM,EAAE;MACxE;IACF;;IAEA;IACAmD,eAAe,CAACoC,OAAO,GAAGqE,WAAW,CAACC,GAAG,CAAC,CAAC;IAC3CzG,aAAa,CAACmC,OAAO,GAAG,CAAC;IACzBrC,gBAAgB,CAACqC,OAAO,GAAG,CAAC;IAE5BtC,iBAAiB,CAACsC,OAAO,GAAGkM,qBAAqB,CAACyG,SAAS,IAAI;MAC7DkC,UAAU,CAAClC,SAAS,EAAE2C,eAAe,CAAC;IACxC,CAAC,CAAC;;IAEF;IACA,OAAO,MAAM;MACX,IAAI5X,iBAAiB,CAACsC,OAAO,EAAE;QAC7B0V,oBAAoB,CAAChY,iBAAiB,CAACsC,OAAO,CAAC;MACjD;;MAEA;MACA,IAAI1B,qBAAqB,CAAC0B,OAAO,EAAE;QACjCgM,YAAY,CAAC1N,qBAAqB,CAAC0B,OAAO,CAAC;MAC7C;IACF,CAAC;EACH,CAAC,EAAE,CACDrF,MAAM,EACNkE,aAAa,EACbJ,UAAU,EACVoW,UAAU,EACVS,eAAe,CAChB,CAAC;EAEF,oBACE/a,OAAA;IACEob,GAAG,EAAEzY,YAAa;IAClBgO,KAAK,EAAE;MACL3D,QAAQ,EAAE,UAAU;MACpBqO,GAAG,EAAE,CAAC;MACNC,IAAI,EAAE,CAAC;MACPlX,KAAK,EAAE,MAAM;MACblE,MAAM,EAAEA,MAAM;MACdqb,QAAQ,EAAE,QAAQ;MAClBC,aAAa,EAAE,MAAM;MACrBrb,MAAM,EAAEA,MAAM;MACd;MACAsb,kBAAkB,EAAE,QAAQ;MAC5BC,SAAS,EAAE,eAAe;MAC1BC,UAAU,EAAE;IACd,CAAE;IACF,eAAY,MAAM;IAAAC,QAAA,eAElB5b,OAAA;MACEob,GAAG,EAAExY,SAAU;MACf+N,KAAK,EAAE;QACL3D,QAAQ,EAAE,UAAU;QACpBqO,GAAG,EAAE,CAAC;QACNC,IAAI,EAAE,CAAC;QACPlX,KAAK,EAAE,MAAM;QACblE,MAAM,EAAE,MAAM;QACd;QACA2b,cAAc,EAAE,cAAc;QAC9B;QACAJ,kBAAkB,EAAE,QAAQ;QAC5BC,SAAS,EAAE,eAAe;QAC1BC,UAAU,EAAE,WAAW;QACvB;QACAG,MAAM,EAAE;MACV;IAAE;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACH;EAAC;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACC,CAAC;AAEV,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AANA3Z,GAAA,CAjyDMtC,YAAY;AAAAkc,EAAA,GAAZlc,YAAY;AAwyDlB,OAAO,MAAMmc,kBAAkB,GAAIC,KAAK,IAAK;EAC3C,MAAMC,YAAY,GAAG;IACnB3b,SAAS,EAAE,wBAAwB;IACnCC,SAAS,EAAE,0BAA0B;IACrCC,UAAU,EAAE,yBAAyB;IACrCP,aAAa,EAAE,CAAC;IAChBC,aAAa,EAAE,CAAC;IAChBC,WAAW,EAAE,IAAI;IACjBC,WAAW,EAAE,GAAG;IAChBC,aAAa,EAAE,EAAE;IACjBS,iBAAiB,EAAE,GAAG;IACtBH,SAAS,EAAE,IAAI;IACfC,eAAe,EAAE,GAAG;IACpBC,eAAe,EAAE,IAAI;IACrBa,YAAY,EAAE,IAAI;IAClBM,gBAAgB,EAAE,GAAG;IACrBD,iBAAiB,EAAE,GAAG;IACtBD,kBAAkB,EAAE;EACtB,CAAC;EAED,oBAAOnC,OAAA,CAACC,YAAY;IAAA,GAAKqc,YAAY;IAAA,GAAMD;EAAK;IAAAN,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAG,CAAC;AACtD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AANAK,GAAA,GAvBaH,kBAAkB;AA8B/B,OAAO,MAAMI,qBAAqB,GAAIH,KAAK,IAAK;EAC9C,MAAMI,eAAe,GAAG;IACtB9b,SAAS,EAAE,wBAAwB;IACnCC,SAAS,EAAE,0BAA0B;IACrCC,UAAU,EAAE,0BAA0B;IACtCP,aAAa,EAAE,CAAC;IAChBC,aAAa,EAAE,CAAC;IAChBC,WAAW,EAAE,IAAI;IACjBC,WAAW,EAAE,GAAG;IAChBC,aAAa,EAAE,EAAE;IACjBS,iBAAiB,EAAE,GAAG;IACtBH,SAAS,EAAE,IAAI;IACfC,eAAe,EAAE,GAAG;IACpBC,eAAe,EAAE,IAAI;IACrBa,YAAY,EAAE,IAAI;IAClBM,gBAAgB,EAAE;EACpB,CAAC;EAED,oBAAOrC,OAAA,CAACC,YAAY;IAAA,GAAKwc,eAAe;IAAA,GAAMJ;EAAK;IAAAN,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAG,CAAC;AACzD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AANAQ,GAAA,GArBaF,qBAAqB;AA4BlC,OAAO,MAAMG,gBAAgB,GAAIN,KAAK,IAAK;EACzC,MAAMO,UAAU,GAAG;IACjBjc,SAAS,EAAE,wBAAwB;IACnCC,SAAS,EAAE,0BAA0B;IACrCC,UAAU,EAAE,0BAA0B;IACtCP,aAAa,EAAE,CAAC;IAChBC,aAAa,EAAE,CAAC;IAChBC,WAAW,EAAE,IAAI;IACjBC,WAAW,EAAE,GAAG;IAChBC,aAAa,EAAE,EAAE;IACjBS,iBAAiB,EAAE,GAAG;IACtBH,SAAS,EAAE,IAAI;IACfC,eAAe,EAAE,GAAG;IACpBC,eAAe,EAAE,IAAI;IACrBa,YAAY,EAAE,IAAI;IAClBM,gBAAgB,EAAE;EACpB,CAAC;EAED,oBAAOrC,OAAA,CAACC,YAAY;IAAA,GAAK2c,UAAU;IAAA,GAAMP;EAAK;IAAAN,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAG,CAAC;AACpD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPAW,GAAA,GArBaF,gBAAgB;AA6B7B,OAAO,MAAMG,eAAe,GAAIT,KAAK,IAAK;EACxC,MAAMU,SAAS,GAAG;IAChB3b,IAAI,EAAE,QAAQ;IACdC,SAAS,EAAE,KAAK;IAChBf,aAAa,EAAE,CAAC;IAChBC,aAAa,EAAE,CAAC;IAChBC,WAAW,EAAE,IAAI;IACjBC,WAAW,EAAE,GAAG;IAChBC,aAAa,EAAE,EAAE;IACjBS,iBAAiB,EAAE,IAAI;IACvBH,SAAS,EAAE,IAAI;IACfC,eAAe,EAAE,GAAG;IACpBC,eAAe,EAAE,IAAI;IACrBa,YAAY,EAAE,IAAI;IAClBM,gBAAgB,EAAE,GAAG;IACrBF,kBAAkB,EAAE;EACtB,CAAC;EAED,oBAAOnC,OAAA,CAACC,YAAY;IAAA,GAAK8c,SAAS;IAAA,GAAMV;EAAK;IAAAN,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAG,CAAC;AACnD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPAc,GAAA,GArBaF,eAAe;AA6B5B,OAAO,MAAMG,kBAAkB,GAAIZ,KAAK,IAAK;EAC3C,MAAMa,YAAY,GAAG;IACnB9b,IAAI,EAAE,QAAQ;IACdd,aAAa,EAAE,CAAC;IAChBC,aAAa,EAAE,CAAC;IAChBC,WAAW,EAAE,IAAI;IACjBC,WAAW,EAAE,GAAG;IAChBC,aAAa,EAAE,EAAE;IACjBc,YAAY,EAAE,GAAG;IACjBC,YAAY,EAAE,GAAG;IACjBN,iBAAiB,EAAE,IAAI;IACvBH,SAAS,EAAE,IAAI;IACfC,eAAe,EAAE,GAAG;IACpBC,eAAe,EAAE,IAAI;IACrBa,YAAY,EAAE,IAAI;IAClBM,gBAAgB,EAAE,GAAG;IACrBF,kBAAkB,EAAE;EACtB,CAAC;EAED,oBAAOnC,OAAA,CAACC,YAAY;IAAA,GAAKid,YAAY;IAAA,GAAMb;EAAK;IAAAN,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAG,CAAC;AACtD,CAAC;AAACiB,GAAA,GApBWF,kBAAkB;AAsB/B,eAAehd,YAAY;AAAC,IAAAkc,EAAA,EAAAI,GAAA,EAAAG,GAAA,EAAAG,GAAA,EAAAG,GAAA,EAAAG,GAAA;AAAAC,YAAA,CAAAjB,EAAA;AAAAiB,YAAA,CAAAb,GAAA;AAAAa,YAAA,CAAAV,GAAA;AAAAU,YAAA,CAAAP,GAAA;AAAAO,YAAA,CAAAJ,GAAA;AAAAI,YAAA,CAAAD,GAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}