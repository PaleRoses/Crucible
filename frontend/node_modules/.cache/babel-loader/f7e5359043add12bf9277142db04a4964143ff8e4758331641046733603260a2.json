{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/Background.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect, useCallback, useMemo } from 'react';\n\n/**\n * StellarBackground Component - Enterprise Performance Optimized Version\n * \n * Creates a highly performant animated stellar background with constellations,\n * subtle star movement, and occasional rare effects like twinkling and meteor bursts.\n * \n * Features:\n * - Advanced performance optimizations with adaptive quality scaling\n * - Memory and battery-efficient rendering pipeline\n * - Accessibility compliance with reduced motion support\n * - Supports hardware acceleration and high-DPI displays\n * - Smooth, fluid motion independent of cursor position\n * - Subtle constellation effects and rare \"twinkle burst\" events\n * \n * @param {Object} props - Component props\n * @param {string|number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=0] - Z-index for the container\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.starDensity=100] - Number of stars to render\n * @param {number} [props.starMaxSize=2] - Maximum size of stars\n * @param {number} [props.constellationCount=3] - Number of constellations to render\n * @param {number} [props.constellationComplexity=6] - Number of stars per constellation\n * @param {number} [props.horizontalSpeed=0.2] - Base speed of horizontal movement\n * @param {number} [props.starTwinkleFrequency=0.003] - Frequency of star twinkling (0-1)\n * @param {number} [props.rareEffectProbability=0.0005] - Probability of rare effects (0-1)\n * @param {string} [props.starColor='rgba(255, 255, 255, 0.8)'] - Base color for stars\n * @param {string} [props.constellationColor='rgba(191, 173, 127, 0.2)'] - Color for constellation lines\n * @param {boolean} [props.adaptiveQuality=true] - Enable adaptive quality based on device\n * @param {boolean} [props.respectReducedMotion=true] - Respect reduced motion preferences\n * @param {number} [props.maxFPS=30] - Target maximum frames per second\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst StellarBackground = ({\n  height = '100vh',\n  zIndex = 0,\n  active = true,\n  starDensity = 100,\n  starMaxSize = 2,\n  constellationCount = 3,\n  constellationComplexity = 6,\n  horizontalSpeed = 0.2,\n  starTwinkleFrequency = 0.003,\n  rareEffectProbability = 0.0005,\n  starColor = 'rgba(255, 255, 255, 0.8)',\n  constellationColor = 'rgba(191, 173, 127, 0.2)',\n  adaptiveQuality = true,\n  respectReducedMotion = true,\n  maxFPS = 30\n}) => {\n  _s();\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const ctxRef = useRef(null);\n  const starsRef = useRef([]);\n  const constellationsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const fpsTimestampRef = useRef(0);\n  const frameCountRef = useRef(0);\n  const currentFpsRef = useRef(30);\n  const worldOffsetRef = useRef({\n    x: 0,\n    y: 0\n  });\n  const visibilityChangeTimeRef = useRef(0);\n  const qualityChangeTimerRef = useRef(null);\n  const stableFrameCountRef = useRef(0);\n  const twinkleEffectsRef = useRef([]);\n  const burstEffectsRef = useRef([]);\n\n  // Component state\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0,\n    pixelRatio: 1\n  });\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [isVisible, setIsVisible] = useState(false);\n  const [qualityFactor, setQualityFactor] = useState(1);\n  // Device capabilities used for adaptive quality settings\n  const deviceCapabilitiesRef = useRef({\n    memory: 4,\n    cores: 4,\n    batteryLevel: 1,\n    isMobile: false\n  });\n\n  // Pre-allocate objects to avoid garbage collection during animation\n  // Note: pointCache is used in certain operations that require temporary vector storage\n\n  // Precompute color variants to avoid string operations during animation\n  const colorCacheRef = useRef(new Map());\n\n  // Adaptive settings based on quality factor\n  const adaptedSettings = useMemo(() => {\n    if (!adaptiveQuality || qualityFactor === 1) {\n      return {\n        starDensity,\n        constellationCount,\n        useShadow: true,\n        useGlow: true,\n        useHighQualityRendering: true\n      };\n    }\n\n    // Adjust quality-dependent parameters\n    return {\n      starDensity: Math.max(40, Math.floor(starDensity * qualityFactor)),\n      constellationCount: Math.max(1, Math.floor(constellationCount * qualityFactor)),\n      useShadow: qualityFactor > 0.5,\n      useGlow: qualityFactor > 0.3,\n      useHighQualityRendering: qualityFactor > 0.7\n    };\n  }, [adaptiveQuality, qualityFactor, starDensity, constellationCount]);\n\n  // Detects device capabilities and sets up optimization strategies\n  const detectCapabilities = useCallback(() => {\n    // Device memory, hardware concurrency, and mobile detection\n    const memory = navigator.deviceMemory || 4;\n    const cores = navigator.hardwareConcurrency || 4;\n    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n\n    // Update device capabilities ref\n    deviceCapabilitiesRef.current = {\n      memory,\n      cores,\n      batteryLevel: 1,\n      isCharging: true,\n      isMobile\n    };\n\n    // Calculate quality factor based on capabilities\n    if (adaptiveQuality) {\n      // Base score from hardware\n      const performanceScore = memory * cores / (isMobile ? 2 : 1);\n\n      // Scale quality based on performance score\n      let quality = 1;\n      if (performanceScore > 16) {\n        quality = 1; // High-end devices\n      } else if (performanceScore > 8) {\n        quality = 0.8; // Mid-range devices\n      } else if (performanceScore > 4) {\n        quality = 0.6; // Low-end devices\n      } else {\n        quality = 0.4; // Very low-end devices\n      }\n      setQualityFactor(quality);\n    }\n  }, [adaptiveQuality]);\n\n  // Get cached color with opacity\n  const getCachedColor = useCallback((baseColor, opacity) => {\n    // Ensure opacity is always valid to prevent rendering glitches\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n\n    // Round opacity to reduce cache size while maintaining visual quality\n    const roundedOpacity = Math.round(safeOpacity * 100) / 100;\n    const key = `${baseColor}-${roundedOpacity}`;\n    if (!colorCacheRef.current.has(key)) {\n      const newColor = baseColor.replace(/[\\d.]+\\)$/, roundedOpacity + ')');\n      colorCacheRef.current.set(key, newColor);\n    }\n    return colorCacheRef.current.get(key);\n  }, []);\n\n  // Detect device capabilities and preferences on mount\n  useEffect(() => {\n    // Check for reduced motion preference\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    const handleReducedMotionChange = e => {\n      setPrefersReducedMotion(e.matches);\n    };\n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n\n    // Detect device capabilities\n    detectCapabilities();\n\n    // Setup visibility change detection to pause when tab is inactive\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        visibilityChangeTimeRef.current = performance.now();\n      } else {\n        // Adjust timing references after visibility changes\n        const timeDelta = performance.now() - visibilityChangeTimeRef.current;\n        lastTimestampRef.current += timeDelta;\n      }\n    };\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n\n    // Cleanup\n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  }, [detectCapabilities]);\n\n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current || !containerRef.current) return false;\n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    const rect = container.getBoundingClientRect();\n    const pixelRatio = window.devicePixelRatio || 1;\n\n    // Calculate dimensions - ensure valid integers to prevent rendering issues\n    const displayWidth = Math.floor(rect.width);\n    const displayHeight = typeof height === 'string' && height.endsWith('vh') ? Math.floor(parseInt(height, 10) / 100 * window.innerHeight) : Math.floor(parseInt(height, 10) || window.innerHeight);\n\n    // Set canvas size accounting for pixel ratio\n    canvas.width = displayWidth * pixelRatio;\n    canvas.height = displayHeight * pixelRatio;\n    canvas.style.width = `${displayWidth}px`;\n    canvas.style.height = `${displayHeight}px`;\n\n    // 2D Canvas context\n    const ctx = canvas.getContext('2d', {\n      alpha: true,\n      desynchronized: true,\n      willReadFrequently: false\n    });\n    if (!ctx) return false;\n\n    // Scale context for high-DPI displays\n    ctx.scale(pixelRatio, pixelRatio);\n\n    // Configure context for high-quality rendering\n    if (adaptedSettings.useHighQualityRendering) {\n      ctx.imageSmoothingEnabled = true;\n      ctx.imageSmoothingQuality = 'high';\n    }\n    ctxRef.current = ctx;\n    setDimensions({\n      width: displayWidth,\n      height: displayHeight,\n      pixelRatio\n    });\n    return true;\n  }, [height, adaptedSettings.useHighQualityRendering]);\n\n  // Setup canvas resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Create a ResizeObserver to detect container size changes\n    const resizeObserver = new ResizeObserver(() => {\n      var _resizeObserverRef$cu;\n      // Debounce resize operations\n      if ((_resizeObserverRef$cu = resizeObserverRef.current) !== null && _resizeObserverRef$cu !== void 0 && _resizeObserverRef$cu.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n      const timeout = setTimeout(() => {\n        if (setupCanvas()) {\n          // Re-initialize stars and constellations when canvas is resized\n          initializeStars();\n          initializeConstellations();\n          setIsInitialized(true);\n        }\n      }, 100); // 100ms debounce\n\n      resizeObserverRef.current = {\n        timeout\n      };\n    });\n\n    // Capture current reference to avoid closure issues in cleanup\n    const currentContainer = containerRef.current;\n\n    // Start observing the container\n    resizeObserver.observe(currentContainer);\n    const resizeObserverRef = {\n      observer: resizeObserver\n    };\n\n    // Initial setup\n    setupCanvas();\n    return () => {\n      if (resizeObserverRef.observer) {\n        resizeObserverRef.observer.disconnect();\n      }\n      if (resizeObserverRef.timeout) {\n        clearTimeout(resizeObserverRef.timeout);\n      }\n    };\n  }, [setupCanvas]);\n\n  // Setup intersection observer to only animate when visible\n  useEffect(() => {\n    if (!containerRef.current) return;\n    const observer = new IntersectionObserver(entries => {\n      const isIntersecting = entries[0].isIntersecting;\n\n      // Only change state if visibility actually changed\n      if (isIntersecting !== isVisible) {\n        setIsVisible(isIntersecting);\n        if (isIntersecting) {\n          // Reset timing references when becoming visible again\n          lastTimestampRef.current = 0;\n        }\n      }\n    }, {\n      threshold: 0.01,\n      rootMargin: '100px'\n    });\n\n    // Store current reference to avoid closure issues\n    const currentContainerRef = containerRef.current;\n    observer.observe(currentContainerRef);\n    const visibilityObserverRef = {\n      current: observer\n    };\n    return () => {\n      if (visibilityObserverRef.current) {\n        visibilityObserverRef.current.disconnect();\n      }\n    };\n  }, [isVisible]);\n\n  // Initialize stars - defined inside the component to access the latest references\n  const initializeStars = () => {\n    if (!dimensions.width || !dimensions.height) return;\n    const stars = [];\n    const count = adaptedSettings.starDensity;\n\n    // Create stars with varied properties\n    for (let i = 0; i < count; i++) {\n      // Base star parameters\n      const star = {\n        x: Math.random() * dimensions.width,\n        y: Math.random() * dimensions.height,\n        z: Math.random() * 3 + 0.5,\n        // Z-depth for parallax effect\n        size: Math.random() * starMaxSize + 0.5,\n        twinkleSpeed: Math.random() * 0.02 + 0.005,\n        twinklePhase: Math.random() * Math.PI * 2,\n        brightness: 0.5 + Math.random() * 0.5,\n        originalBrightness: 0.5 + Math.random() * 0.5,\n        // Slightly varying colors for natural look\n        colorVariation: Math.random() * 0.2,\n        // Random layer factor for movement speed\n        layer: Math.floor(Math.random() * 3) // 0, 1, or 2\n      };\n      stars.push(star);\n    }\n    starsRef.current = stars;\n  };\n\n  // Initialize constellations - defined inside the component to access the latest references\n  const initializeConstellations = () => {\n    if (!dimensions.width || !dimensions.height || starsRef.current.length === 0) return;\n    const constellations = [];\n    const allStars = starsRef.current;\n    const count = adaptedSettings.constellationCount;\n\n    // Create constellations\n    for (let c = 0; c < count; c++) {\n      // Select a random star as the constellation center\n      const centerStarIndex = Math.floor(Math.random() * allStars.length);\n      const centerStar = allStars[centerStarIndex];\n\n      // Create complex connections between nearby stars\n      const points = [centerStarIndex];\n      const connections = [];\n\n      // Find nearby stars to connect\n      const potentialConnections = [];\n      for (let i = 0; i < allStars.length; i++) {\n        if (i === centerStarIndex) continue;\n        const star = allStars[i];\n        const dx = star.x - centerStar.x;\n        const dy = star.y - centerStar.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        // Only consider stars within a reasonable distance\n        const maxDistance = Math.min(dimensions.width, dimensions.height) * 0.25;\n        if (distance < maxDistance) {\n          potentialConnections.push({\n            index: i,\n            distance\n          });\n        }\n      }\n\n      // Sort by distance and take the closest ones\n      potentialConnections.sort((a, b) => a.distance - b.distance);\n\n      // Connect stars to form the constellation\n      // Only use as many as we have available, up to constellationComplexity\n      const starCount = Math.min(potentialConnections.length, constellationComplexity - 1);\n      for (let i = 0; i < starCount; i++) {\n        const starIndex = potentialConnections[i].index;\n        points.push(starIndex);\n\n        // Connect to center star or previous star in sequence\n        if (i === 0) {\n          connections.push([centerStarIndex, starIndex]);\n        } else {\n          // Sometimes connect back to earlier stars for more complex shapes\n          const connectToIndex = Math.random() < 0.7 ? potentialConnections[i - 1].index // Connect to previous star\n          : points[Math.floor(Math.random() * points.length)]; // Connect to random star in constellation\n\n          connections.push([connectToIndex, starIndex]);\n        }\n\n        // Add occasional branches for visual interest\n        if (i > 1 && Math.random() < 0.3 && i < starCount - 1) {\n          const branchTarget = points[Math.floor(Math.random() * (points.length - 1))];\n          connections.push([starIndex, branchTarget]);\n        }\n      }\n\n      // Set constellation properties\n      const constellation = {\n        points,\n        connections,\n        progress: 0,\n        fadeState: 'in',\n        // 'in', 'visible', 'out'\n        opacity: 0,\n        lastStateChange: 0,\n        visibleDuration: 40000 + Math.random() * 20000,\n        // 40-60 seconds visibility\n        transitionDuration: 5000 + Math.random() * 3000,\n        // 5-8 seconds fade in/out\n        lineWidth: 0.5 + Math.random() * 0.5,\n        pulsePhase: Math.random() * Math.PI * 2,\n        pulseSpeed: 0.0001 + Math.random() * 0.0002\n      };\n      constellations.push(constellation);\n    }\n    constellationsRef.current = constellations;\n  };\n\n  // Create a twinkling effect at a specific star\n  const createTwinkleEffect = useCallback(star => {\n    if (prefersReducedMotion && respectReducedMotion) return;\n\n    // Create a subtle shine effect\n    const twinkle = {\n      x: star.x,\n      y: star.y,\n      size: star.size * (1.5 + Math.random() * 1),\n      brightness: star.originalBrightness * (1.2 + Math.random() * 0.5),\n      // More gradual and natural fading\n      life: 1.0,\n      decay: 0.01 + Math.random() * 0.02,\n      // Adding subtle drift to appear more natural\n      drift: {\n        x: (Math.random() * 2 - 1) * 0.2,\n        y: (Math.random() * 2 - 1) * 0.2\n      },\n      // Random chance for different qualities\n      enhancedEffect: Math.random() < 0.15,\n      // 15% chance for enhanced effect\n      // Layer matching for consistent movement\n      layer: star.layer\n    };\n    twinkleEffectsRef.current.push(twinkle);\n  }, [prefersReducedMotion, respectReducedMotion]);\n\n  // Create a rare burst effect (similar to meteor burst but more subtle)\n  const createBurstEffect = useCallback((x, y, size) => {\n    if (prefersReducedMotion && respectReducedMotion) return;\n\n    // Skip if we already have too many burst effects (performance optimization)\n    if (burstEffectsRef.current.length > 15) return;\n\n    // Number of particles in burst - lower than meteor for subtlety\n    const particleCount = Math.floor(4 + Math.random() * 8);\n\n    // Create a subtle burst of particles\n    for (let i = 0; i < particleCount; i++) {\n      // Calculate particle direction - full 360° radial\n      const angle = Math.random() * Math.PI * 2;\n\n      // Speed - very slow for a subtle effect\n      const speed = 0.05 + Math.random() * 0.15;\n\n      // Calculate velocity components\n      const vx = Math.cos(angle) * speed;\n      const vy = Math.sin(angle) * speed;\n\n      // Create small particles\n      const particleSize = size * (0.3 + Math.random() * 0.4);\n\n      // Create the burst particle\n      const burst = {\n        x: x,\n        y: y,\n        vx: vx,\n        vy: vy,\n        size: particleSize,\n        life: 1.0,\n        decay: 0.005 + Math.random() * 0.01,\n        // Slower decay for longer effect\n        // Golden hues for subtle elegance\n        color: Math.random() < 0.7 ? 'rgba(255, 255, 255, 0.8)' : 'rgba(191, 173, 127, 0.7)',\n        // Elegant diminishing velocity\n        damping: 0.98 + Math.random() * 0.01\n      };\n      burstEffectsRef.current.push(burst);\n    }\n  }, [prefersReducedMotion, respectReducedMotion]);\n\n  // Update stars and world position\n  const updateStarsAndBackground = useCallback(deltaTime => {\n    // Apply a maximum delta time to prevent large jumps after tab switching\n    const cappedDeltaTime = Math.min(deltaTime, 50);\n\n    // Update world offset for horizontal scrolling effect\n    // Apply different speeds based on quality factor to prevent excessive motion on low-end devices\n    const speedFactor = Math.min(1, qualityFactor + 0.4);\n    worldOffsetRef.current.x += horizontalSpeed * speedFactor * (cappedDeltaTime / 16);\n\n    // Ensure world offset wraps around cleanly\n    if (worldOffsetRef.current.x > dimensions.width) {\n      worldOffsetRef.current.x -= dimensions.width;\n    }\n\n    // Update each star\n    for (const star of starsRef.current) {\n      // Apply twinkle effect using sin wave\n      const timeFactor = performance.now() * 0.001;\n      const twinkleEffect = Math.pow(Math.sin(timeFactor * star.twinkleSpeed + star.twinklePhase) * 0.5 + 0.5, 1.5);\n\n      // More subtle brightness variation\n      star.brightness = star.originalBrightness * (0.8 + twinkleEffect * 0.4);\n\n      // Move stars based on their layer (parallax effect)\n      // Layer 0 (distant): slowest, Layer 2 (closest): fastest\n      const layerSpeedFactor = 0.5 + star.layer * 0.25;\n\n      // Apply horizontal movement based on world offset\n      star.movementX = -worldOffsetRef.current.x * layerSpeedFactor * (star.z * 0.4);\n\n      // Wrap stars around when they move off-screen\n      // Calculate effective position with wrapped movement\n      const effectiveX = (star.x + star.movementX) % dimensions.width;\n      if (effectiveX < 0) {\n        star.effectiveX = effectiveX + dimensions.width;\n      } else {\n        star.effectiveX = effectiveX;\n      }\n      star.effectiveY = star.y;\n\n      // Random chance to create twinkle effect\n      if (Math.random() < starTwinkleFrequency * (cappedDeltaTime / 16) * qualityFactor) {\n        createTwinkleEffect(star);\n      }\n\n      // Very rare chance for a burst effect - slightly higher for brighter stars\n      if (Math.random() < rareEffectProbability * star.brightness * (cappedDeltaTime / 16) * qualityFactor) {\n        createBurstEffect(star.effectiveX, star.effectiveY, star.size * 2);\n      }\n    }\n\n    // Update twinkle effects\n    for (let i = twinkleEffectsRef.current.length - 1; i >= 0; i--) {\n      const twinkle = twinkleEffectsRef.current[i];\n\n      // Update life\n      twinkle.life -= twinkle.decay * (cappedDeltaTime / 16);\n\n      // Apply subtle drift for more natural movement\n      twinkle.x += twinkle.drift.x * (cappedDeltaTime / 16);\n      twinkle.y += twinkle.drift.y * (cappedDeltaTime / 16);\n\n      // Apply same world offset as the parent star's layer\n      const layerSpeedFactor = 0.5 + twinkle.layer * 0.25;\n      twinkle.movementX = -worldOffsetRef.current.x * layerSpeedFactor * 0.4;\n\n      // Calculate effective position\n      const effectiveX = (twinkle.x + twinkle.movementX) % dimensions.width;\n      if (effectiveX < 0) {\n        twinkle.effectiveX = effectiveX + dimensions.width;\n      } else {\n        twinkle.effectiveX = effectiveX;\n      }\n      twinkle.effectiveY = twinkle.y;\n\n      // Remove expired effects\n      if (twinkle.life <= 0) {\n        twinkleEffectsRef.current.splice(i, 1);\n      }\n    }\n\n    // Update burst effects\n    for (let i = burstEffectsRef.current.length - 1; i >= 0; i--) {\n      const burst = burstEffectsRef.current[i];\n\n      // Update position\n      burst.x += burst.vx * (cappedDeltaTime / 16);\n      burst.y += burst.vy * (cappedDeltaTime / 16);\n\n      // Apply damping to velocity for natural deceleration\n      burst.vx *= burst.damping;\n      burst.vy *= burst.damping;\n\n      // Update life\n      burst.life -= burst.decay * (cappedDeltaTime / 16);\n\n      // Remove expired effects\n      if (burst.life <= 0) {\n        burstEffectsRef.current.splice(i, 1);\n      }\n    }\n\n    // Update constellations\n    const now = performance.now();\n    for (const constellation of constellationsRef.current) {\n      // Update constellation state based on timing\n      const timeSinceStateChange = now - constellation.lastStateChange;\n      if (constellation.fadeState === 'in') {\n        // Fading in\n        constellation.progress = Math.min(1, timeSinceStateChange / constellation.transitionDuration);\n        constellation.opacity = constellation.progress * 0.7; // Max opacity 0.7\n\n        if (constellation.progress >= 1) {\n          constellation.fadeState = 'visible';\n          constellation.lastStateChange = now;\n        }\n      } else if (constellation.fadeState === 'visible') {\n        // Fully visible\n        if (timeSinceStateChange >= constellation.visibleDuration) {\n          constellation.fadeState = 'out';\n          constellation.lastStateChange = now;\n          constellation.progress = 1;\n        }\n\n        // Subtle pulsing while visible\n        const pulsePhase = constellation.pulsePhase + now * constellation.pulseSpeed;\n        const pulseFactor = Math.sin(pulsePhase) * 0.1 + 0.9; // 0.8-1.0 range\n        constellation.opacity = 0.7 * pulseFactor;\n      } else if (constellation.fadeState === 'out') {\n        // Fading out\n        constellation.progress = 1 - Math.min(1, timeSinceStateChange / constellation.transitionDuration);\n        constellation.opacity = constellation.progress * 0.7;\n        if (constellation.progress <= 0) {\n          // Reset constellation with new parameters\n          constellation.fadeState = 'in';\n          constellation.lastStateChange = now + Math.random() * 10000; // Staggered reappearance\n          constellation.visibleDuration = 40000 + Math.random() * 20000;\n          constellation.transitionDuration = 5000 + Math.random() * 3000;\n          constellation.pulsePhase = Math.random() * Math.PI * 2;\n\n          // Occasional reshuffling of constellation connections for variety\n          if (Math.random() < 0.3) {\n            const connections = constellation.connections;\n            for (let i = 0; i < connections.length; i++) {\n              if (Math.random() < 0.4) {\n                // Rewire this connection to a different point\n                const targetOptions = constellation.points.filter(p => p !== connections[i][0] && p !== connections[i][1]);\n                if (targetOptions.length > 0) {\n                  const newTarget = targetOptions[Math.floor(Math.random() * targetOptions.length)];\n                  connections[i][Math.random() < 0.5 ? 0 : 1] = newTarget;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }, [dimensions, horizontalSpeed, qualityFactor, starTwinkleFrequency, rareEffectProbability, createTwinkleEffect, createBurstEffect]);\n\n  // Render stars and constellations\n  const renderStarsAndConstellations = useCallback(ctx => {\n    // Clear canvas with optimized clear method\n    ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n\n    // Determine if we should use quality renderings based on settings\n    const useQualityRendering = adaptedSettings.useHighQualityRendering;\n    const useGlow = adaptedSettings.useGlow;\n\n    // Render stars first (background layer)\n    for (const star of starsRef.current) {\n      // Skip if not in visible area\n      if (star.effectiveX < -10 || star.effectiveX > dimensions.width + 10 || star.effectiveY < -10 || star.effectiveY > dimensions.height + 10) {\n        continue;\n      }\n\n      // Basic star rendering for all quality levels\n      ctx.beginPath();\n      if (useQualityRendering) {\n        // High quality rendering with soft glow\n        // Set shadow for glow effect if enabled\n        if (useGlow) {\n          ctx.shadowColor = getCachedColor(starColor, star.brightness * 0.8);\n          ctx.shadowBlur = star.size * 3;\n        }\n\n        // Draw star with gradient for more natural appearance\n        const gradient = ctx.createRadialGradient(star.effectiveX, star.effectiveY, 0, star.effectiveX, star.effectiveY, star.size * 1.2);\n        gradient.addColorStop(0, getCachedColor(starColor, star.brightness));\n        gradient.addColorStop(0.5, getCachedColor(starColor, star.brightness * 0.6));\n        gradient.addColorStop(1, getCachedColor(starColor, 0));\n        ctx.fillStyle = gradient;\n        ctx.arc(star.effectiveX, star.effectiveY, star.size, 0, Math.PI * 2);\n        ctx.fill();\n      } else {\n        // Simplified rendering for lower performance devices\n        ctx.fillStyle = getCachedColor(starColor, star.brightness);\n        ctx.arc(star.effectiveX, star.effectiveY, star.size * 0.8, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n\n    // Reset shadow to avoid affecting other elements\n    if (useGlow) {\n      ctx.shadowBlur = 0;\n    }\n\n    // Render constellations\n    for (const constellation of constellationsRef.current) {\n      if (constellation.opacity <= 0.01) continue;\n      const allStars = starsRef.current;\n\n      // Set constellation line style\n      ctx.strokeStyle = getCachedColor(constellationColor, constellation.opacity);\n      ctx.lineWidth = constellation.lineWidth;\n\n      // Optimized rendering by batching lines\n      ctx.beginPath();\n\n      // Draw constellation connections\n      for (const [fromIndex, toIndex] of constellation.connections) {\n        const fromStar = allStars[fromIndex];\n        const toStar = allStars[toIndex];\n        if (!fromStar || !toStar) continue;\n\n        // Use effective positions that account for movement\n        ctx.moveTo(fromStar.effectiveX, fromStar.effectiveY);\n        ctx.lineTo(toStar.effectiveX, toStar.effectiveY);\n      }\n\n      // Apply glow to constellation lines if enabled\n      if (useGlow) {\n        ctx.shadowColor = getCachedColor(constellationColor, constellation.opacity * 0.5);\n        ctx.shadowBlur = 3;\n      }\n      ctx.stroke();\n\n      // Reset shadow\n      if (useGlow) {\n        ctx.shadowBlur = 0;\n      }\n    }\n\n    // Render twinkle effects above regular stars\n    for (const twinkle of twinkleEffectsRef.current) {\n      // Skip if not in visible area\n      if (twinkle.effectiveX < -10 || twinkle.effectiveX > dimensions.width + 10 || twinkle.effectiveY < -10 || twinkle.effectiveY > dimensions.height + 10) {\n        continue;\n      }\n      const opacity = twinkle.life * twinkle.brightness;\n      if (useQualityRendering && twinkle.enhancedEffect) {\n        // Enhanced twinkle effect for some stars\n        // Outer glow\n        if (useGlow) {\n          ctx.shadowColor = getCachedColor(starColor, opacity * 0.6);\n          ctx.shadowBlur = twinkle.size * 3;\n        }\n\n        // Draw twinkle with gradient\n        const gradient = ctx.createRadialGradient(twinkle.effectiveX, twinkle.effectiveY, 0, twinkle.effectiveX, twinkle.effectiveY, twinkle.size * 1.5);\n        gradient.addColorStop(0, getCachedColor(starColor, opacity));\n        gradient.addColorStop(0.4, getCachedColor(starColor, opacity * 0.7));\n        gradient.addColorStop(1, getCachedColor(starColor, 0));\n        ctx.beginPath();\n        ctx.fillStyle = gradient;\n        ctx.arc(twinkle.effectiveX, twinkle.effectiveY, twinkle.size, 0, Math.PI * 2);\n        ctx.fill();\n\n        // Inner core\n        ctx.beginPath();\n        ctx.fillStyle = getCachedColor(starColor, opacity * 1.2);\n        ctx.arc(twinkle.effectiveX, twinkle.effectiveY, twinkle.size * 0.4, 0, Math.PI * 2);\n        ctx.fill();\n      } else {\n        // Simple twinkle effect\n        ctx.beginPath();\n        if (useGlow) {\n          ctx.shadowColor = getCachedColor(starColor, opacity * 0.5);\n          ctx.shadowBlur = twinkle.size * 2;\n        }\n        ctx.fillStyle = getCachedColor(starColor, opacity);\n        ctx.arc(twinkle.effectiveX, twinkle.effectiveY, twinkle.size * 0.9, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n\n    // Reset shadow\n    if (useGlow) {\n      ctx.shadowBlur = 0;\n    }\n\n    // Render burst effects\n    for (const burst of burstEffectsRef.current) {\n      const opacity = burst.life * 0.8;\n      if (useQualityRendering) {\n        // Apply shadow/glow\n        if (useGlow) {\n          ctx.shadowColor = getCachedColor(burst.color, opacity * 0.6);\n          ctx.shadowBlur = burst.size * 2;\n        }\n\n        // Draw particle with fade out\n        ctx.beginPath();\n        ctx.fillStyle = getCachedColor(burst.color, opacity);\n        ctx.arc(burst.x, burst.y, burst.size * burst.life, 0, Math.PI * 2);\n        ctx.fill();\n      } else {\n        // Simple particle rendering\n        ctx.beginPath();\n        ctx.fillStyle = getCachedColor(burst.color, opacity);\n        ctx.arc(burst.x, burst.y, burst.size * burst.life * 0.8, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n  }, [dimensions, adaptedSettings.useHighQualityRendering, adaptedSettings.useGlow, starColor, constellationColor, getCachedColor]);\n\n  // FPS limiter for consistent animation speed\n  const fpsLimiter = useCallback((timestamp, callback) => {\n    // Skip animation if hidden, inactive, or reduced motion\n    if (!isVisible || !active || respectReducedMotion && prefersReducedMotion || document.hidden) {\n      animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n      return;\n    }\n    const targetFrameTime = 1000 / maxFPS;\n    const elapsed = timestamp - lastTimestampRef.current;\n    if (elapsed >= targetFrameTime || lastTimestampRef.current === 0) {\n      // Calculate correct delta\n      const delta = lastTimestampRef.current === 0 ? 16 : elapsed;\n\n      // Update timestamp, limiting delta to avoid jumps after inactivity\n      lastTimestampRef.current = timestamp - elapsed % targetFrameTime;\n\n      // Run animation callback with capped delta time\n      callback(Math.min(delta, 50));\n\n      // FPS tracking\n      frameCountRef.current++;\n      if (timestamp - fpsTimestampRef.current >= 1000) {\n        currentFpsRef.current = frameCountRef.current;\n        frameCountRef.current = 0;\n        fpsTimestampRef.current = timestamp;\n\n        // Dynamic quality adjustment based on performance\n        if (adaptiveQuality) {\n          // Check if FPS is stable\n          if (currentFpsRef.current >= maxFPS * 0.9) {\n            stableFrameCountRef.current += 1;\n          } else if (currentFpsRef.current < maxFPS * 0.7) {\n            stableFrameCountRef.current = 0;\n          }\n\n          // Avoid frequent quality changes by using a timer\n          if (qualityChangeTimerRef.current) {\n            clearTimeout(qualityChangeTimerRef.current);\n          }\n          qualityChangeTimerRef.current = setTimeout(() => {\n            // Only change quality if FPS has been stable or is very low\n            if (currentFpsRef.current < maxFPS * 0.7) {\n              // If FPS is below 70% of target, reduce quality\n              setQualityFactor(prev => Math.max(0.4, prev * 0.9));\n            } else if (stableFrameCountRef.current >= 3 && qualityFactor < 1) {\n              // If FPS has been high for several frames, gradually increase quality\n              setQualityFactor(prev => Math.min(1, prev * 1.05));\n            }\n          }, 500);\n        }\n      }\n    }\n\n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n  }, [isVisible, active, respectReducedMotion, prefersReducedMotion, maxFPS, adaptiveQuality, qualityFactor]);\n\n  // Main animation handler\n  const handleAnimation = useCallback(deltaTime => {\n    // Skip if component is not ready\n    if (!canvasRef.current || !isInitialized || !dimensions.width || !dimensions.height) return;\n\n    // Update star positions and background\n    updateStarsAndBackground(deltaTime);\n\n    // Render the scene\n    renderStarsAndConstellations(ctxRef.current);\n  }, [isInitialized, dimensions, updateStarsAndBackground, renderStarsAndConstellations]);\n\n  // Initialize stars and constellations once dimensions are available\n  useEffect(() => {\n    if (dimensions.width && dimensions.height) {\n      initializeStars();\n      initializeConstellations();\n      setIsInitialized(true);\n    }\n  }, [dimensions, adaptedSettings.starDensity, adaptedSettings.constellationCount, starMaxSize]);\n\n  // Main animation loop\n  useEffect(() => {\n    if (!active || !isInitialized || !dimensions.width || !dimensions.height) {\n      return;\n    }\n\n    // Start animation with FPS limiter\n    fpsTimestampRef.current = performance.now();\n    frameCountRef.current = 0;\n    lastTimestampRef.current = 0;\n    animationFrameRef.current = requestAnimationFrame(timestamp => {\n      fpsLimiter(timestamp, handleAnimation);\n    });\n\n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      if (qualityChangeTimerRef.current) {\n        clearTimeout(qualityChangeTimerRef.current);\n      }\n    };\n  }, [active, isInitialized, dimensions, fpsLimiter, handleAnimation]);\n\n  // Apply reduced motion adjustments\n  const reducedMotionStyles = useMemo(() => {\n    if (prefersReducedMotion && respectReducedMotion) {\n      return {\n        // Subtle static look for reduced motion preference\n        animation: 'none',\n        transition: 'none'\n      };\n    }\n    return {};\n  }, [prefersReducedMotion, respectReducedMotion]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: height,\n      overflow: 'hidden',\n      pointerEvents: 'none',\n      zIndex: zIndex,\n      ...reducedMotionStyles,\n      // Hardware acceleration\n      backfaceVisibility: 'hidden',\n      transform: 'translateZ(0)',\n      willChange: 'transform'\n    },\n    \"aria-hidden\": \"true\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        // Additional rendering optimizations\n        imageRendering: 'high-quality',\n        // Hardware acceleration\n        backfaceVisibility: 'hidden',\n        transform: 'translateZ(0)',\n        willChange: 'transform',\n        // Ensures proper subpixel rendering\n        filter: 'none'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1039,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1020,\n    columnNumber: 5\n  }, this);\n};\n\n/**\n * Dark Fantasy Stellar Background - Preset Configuration\n * A background with richer golden-hued stars and elegant constellations\n */\n_s(StellarBackground, \"D5SBBQcGb3rhq0699Onm+XLbXSM=\");\n_c = StellarBackground;\nexport const DarkFantasyStellarBackground = props => {\n  const darkFantasyPreset = {\n    starDensity: 120,\n    starMaxSize: 2.2,\n    constellationCount: 4,\n    constellationComplexity: 8,\n    horizontalSpeed: 0.15,\n    starTwinkleFrequency: 0.004,\n    rareEffectProbability: 0.0006,\n    starColor: 'rgba(255, 253, 240, 0.85)',\n    constellationColor: 'rgba(207, 181, 59, 0.25)',\n    maxFPS: 30\n  };\n  return /*#__PURE__*/_jsxDEV(StellarBackground, {\n    ...darkFantasyPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1079,\n    columnNumber: 10\n  }, this);\n};\n_c2 = DarkFantasyStellarBackground;\nexport default StellarBackground;\nvar _c, _c2;\n$RefreshReg$(_c, \"StellarBackground\");\n$RefreshReg$(_c2, \"DarkFantasyStellarBackground\");","map":{"version":3,"names":["React","useRef","useState","useEffect","useCallback","useMemo","jsxDEV","_jsxDEV","StellarBackground","height","zIndex","active","starDensity","starMaxSize","constellationCount","constellationComplexity","horizontalSpeed","starTwinkleFrequency","rareEffectProbability","starColor","constellationColor","adaptiveQuality","respectReducedMotion","maxFPS","_s","containerRef","canvasRef","ctxRef","starsRef","constellationsRef","animationFrameRef","lastTimestampRef","fpsTimestampRef","frameCountRef","currentFpsRef","worldOffsetRef","x","y","visibilityChangeTimeRef","qualityChangeTimerRef","stableFrameCountRef","twinkleEffectsRef","burstEffectsRef","dimensions","setDimensions","width","pixelRatio","isInitialized","setIsInitialized","prefersReducedMotion","setPrefersReducedMotion","isVisible","setIsVisible","qualityFactor","setQualityFactor","deviceCapabilitiesRef","memory","cores","batteryLevel","isMobile","colorCacheRef","Map","adaptedSettings","useShadow","useGlow","useHighQualityRendering","Math","max","floor","detectCapabilities","navigator","deviceMemory","hardwareConcurrency","test","userAgent","current","isCharging","performanceScore","quality","getCachedColor","baseColor","opacity","safeOpacity","min","roundedOpacity","round","key","has","newColor","replace","set","get","reducedMotionQuery","window","matchMedia","matches","handleReducedMotionChange","e","addEventListener","handleVisibilityChange","document","hidden","performance","now","timeDelta","removeEventListener","setupCanvas","canvas","container","rect","getBoundingClientRect","devicePixelRatio","displayWidth","displayHeight","endsWith","parseInt","innerHeight","style","ctx","getContext","alpha","desynchronized","willReadFrequently","scale","imageSmoothingEnabled","imageSmoothingQuality","resizeObserver","ResizeObserver","_resizeObserverRef$cu","resizeObserverRef","timeout","clearTimeout","setTimeout","initializeStars","initializeConstellations","currentContainer","observe","observer","disconnect","IntersectionObserver","entries","isIntersecting","threshold","rootMargin","currentContainerRef","visibilityObserverRef","stars","count","i","star","random","z","size","twinkleSpeed","twinklePhase","PI","brightness","originalBrightness","colorVariation","layer","push","length","constellations","allStars","c","centerStarIndex","centerStar","points","connections","potentialConnections","dx","dy","distance","sqrt","maxDistance","index","sort","a","b","starCount","starIndex","connectToIndex","branchTarget","constellation","progress","fadeState","lastStateChange","visibleDuration","transitionDuration","lineWidth","pulsePhase","pulseSpeed","createTwinkleEffect","twinkle","life","decay","drift","enhancedEffect","createBurstEffect","particleCount","angle","speed","vx","cos","vy","sin","particleSize","burst","color","damping","updateStarsAndBackground","deltaTime","cappedDeltaTime","speedFactor","timeFactor","twinkleEffect","pow","layerSpeedFactor","movementX","effectiveX","effectiveY","splice","timeSinceStateChange","pulseFactor","targetOptions","filter","p","newTarget","renderStarsAndConstellations","clearRect","useQualityRendering","beginPath","shadowColor","shadowBlur","gradient","createRadialGradient","addColorStop","fillStyle","arc","fill","strokeStyle","fromIndex","toIndex","fromStar","toStar","moveTo","lineTo","stroke","fpsLimiter","timestamp","callback","requestAnimationFrame","time","targetFrameTime","elapsed","delta","prev","handleAnimation","cancelAnimationFrame","reducedMotionStyles","animation","transition","ref","position","top","left","overflow","pointerEvents","backfaceVisibility","transform","willChange","children","imageRendering","fileName","_jsxFileName","lineNumber","columnNumber","_c","DarkFantasyStellarBackground","props","darkFantasyPreset","_c2","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/Background.jsx"],"sourcesContent":["import React, { useRef, useState, useEffect, useCallback, useMemo } from 'react';\n\n/**\n * StellarBackground Component - Enterprise Performance Optimized Version\n * \n * Creates a highly performant animated stellar background with constellations,\n * subtle star movement, and occasional rare effects like twinkling and meteor bursts.\n * \n * Features:\n * - Advanced performance optimizations with adaptive quality scaling\n * - Memory and battery-efficient rendering pipeline\n * - Accessibility compliance with reduced motion support\n * - Supports hardware acceleration and high-DPI displays\n * - Smooth, fluid motion independent of cursor position\n * - Subtle constellation effects and rare \"twinkle burst\" events\n * \n * @param {Object} props - Component props\n * @param {string|number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=0] - Z-index for the container\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.starDensity=100] - Number of stars to render\n * @param {number} [props.starMaxSize=2] - Maximum size of stars\n * @param {number} [props.constellationCount=3] - Number of constellations to render\n * @param {number} [props.constellationComplexity=6] - Number of stars per constellation\n * @param {number} [props.horizontalSpeed=0.2] - Base speed of horizontal movement\n * @param {number} [props.starTwinkleFrequency=0.003] - Frequency of star twinkling (0-1)\n * @param {number} [props.rareEffectProbability=0.0005] - Probability of rare effects (0-1)\n * @param {string} [props.starColor='rgba(255, 255, 255, 0.8)'] - Base color for stars\n * @param {string} [props.constellationColor='rgba(191, 173, 127, 0.2)'] - Color for constellation lines\n * @param {boolean} [props.adaptiveQuality=true] - Enable adaptive quality based on device\n * @param {boolean} [props.respectReducedMotion=true] - Respect reduced motion preferences\n * @param {number} [props.maxFPS=30] - Target maximum frames per second\n */\nconst StellarBackground = ({\n  height = '100vh',\n  zIndex = 0,\n  active = true,\n  starDensity = 100,\n  starMaxSize = 2,\n  constellationCount = 3,\n  constellationComplexity = 6,\n  horizontalSpeed = 0.2,\n  starTwinkleFrequency = 0.003,\n  rareEffectProbability = 0.0005,\n  starColor = 'rgba(255, 255, 255, 0.8)',\n  constellationColor = 'rgba(191, 173, 127, 0.2)',\n  adaptiveQuality = true,\n  respectReducedMotion = true,\n  maxFPS = 30\n}) => {\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const ctxRef = useRef(null);\n  const starsRef = useRef([]);\n  const constellationsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const fpsTimestampRef = useRef(0);\n  const frameCountRef = useRef(0);\n  const currentFpsRef = useRef(30);\n  const worldOffsetRef = useRef({ x: 0, y: 0 });\n  const visibilityChangeTimeRef = useRef(0);\n  const qualityChangeTimerRef = useRef(null);\n  const stableFrameCountRef = useRef(0);\n  const twinkleEffectsRef = useRef([]);\n  const burstEffectsRef = useRef([]);\n  \n  // Component state\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0, pixelRatio: 1 });\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [isVisible, setIsVisible] = useState(false);\n  const [qualityFactor, setQualityFactor] = useState(1);\n  // Device capabilities used for adaptive quality settings\n  const deviceCapabilitiesRef = useRef({\n    memory: 4,\n    cores: 4,\n    batteryLevel: 1,\n    isMobile: false\n  });\n  \n  // Pre-allocate objects to avoid garbage collection during animation\n  // Note: pointCache is used in certain operations that require temporary vector storage\n  \n  // Precompute color variants to avoid string operations during animation\n  const colorCacheRef = useRef(new Map());\n  \n  // Adaptive settings based on quality factor\n  const adaptedSettings = useMemo(() => {\n    if (!adaptiveQuality || qualityFactor === 1) {\n      return {\n        starDensity,\n        constellationCount,\n        useShadow: true,\n        useGlow: true,\n        useHighQualityRendering: true\n      };\n    }\n    \n    // Adjust quality-dependent parameters\n    return {\n      starDensity: Math.max(40, Math.floor(starDensity * qualityFactor)),\n      constellationCount: Math.max(1, Math.floor(constellationCount * qualityFactor)),\n      useShadow: qualityFactor > 0.5,\n      useGlow: qualityFactor > 0.3,\n      useHighQualityRendering: qualityFactor > 0.7\n    };\n  }, [adaptiveQuality, qualityFactor, starDensity, constellationCount]);\n  \n  // Detects device capabilities and sets up optimization strategies\n  const detectCapabilities = useCallback(() => {\n    // Device memory, hardware concurrency, and mobile detection\n    const memory = navigator.deviceMemory || 4;\n    const cores = navigator.hardwareConcurrency || 4;\n    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n    \n    // Update device capabilities ref\n    deviceCapabilitiesRef.current = {\n      memory,\n      cores,\n      batteryLevel: 1,\n      isCharging: true,\n      isMobile\n    };\n    \n    // Calculate quality factor based on capabilities\n    if (adaptiveQuality) {\n      // Base score from hardware\n      const performanceScore = (memory * cores) / (isMobile ? 2 : 1);\n      \n      // Scale quality based on performance score\n      let quality = 1;\n      \n      if (performanceScore > 16) {\n        quality = 1; // High-end devices\n      } else if (performanceScore > 8) {\n        quality = 0.8; // Mid-range devices\n      } else if (performanceScore > 4) {\n        quality = 0.6; // Low-end devices\n      } else {\n        quality = 0.4; // Very low-end devices\n      }\n      \n      setQualityFactor(quality);\n    }\n  }, [adaptiveQuality]);\n  \n  // Get cached color with opacity\n  const getCachedColor = useCallback((baseColor, opacity) => {\n    // Ensure opacity is always valid to prevent rendering glitches\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    \n    // Round opacity to reduce cache size while maintaining visual quality\n    const roundedOpacity = Math.round(safeOpacity * 100) / 100;\n    const key = `${baseColor}-${roundedOpacity}`;\n    \n    if (!colorCacheRef.current.has(key)) {\n      const newColor = baseColor.replace(/[\\d.]+\\)$/, roundedOpacity + ')');\n      colorCacheRef.current.set(key, newColor);\n    }\n    \n    return colorCacheRef.current.get(key);\n  }, []);\n  \n  // Detect device capabilities and preferences on mount\n  useEffect(() => {\n    // Check for reduced motion preference\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    \n    const handleReducedMotionChange = (e) => {\n      setPrefersReducedMotion(e.matches);\n    };\n    \n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n    \n    // Detect device capabilities\n    detectCapabilities();\n    \n    // Setup visibility change detection to pause when tab is inactive\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        visibilityChangeTimeRef.current = performance.now();\n      } else {\n        // Adjust timing references after visibility changes\n        const timeDelta = performance.now() - visibilityChangeTimeRef.current;\n        lastTimestampRef.current += timeDelta;\n      }\n    };\n    \n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    \n    // Cleanup\n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  }, [detectCapabilities]);\n  \n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current || !containerRef.current) return false;\n    \n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    const rect = container.getBoundingClientRect();\n    const pixelRatio = window.devicePixelRatio || 1;\n    \n    // Calculate dimensions - ensure valid integers to prevent rendering issues\n    const displayWidth = Math.floor(rect.width);\n    const displayHeight = typeof height === 'string' && height.endsWith('vh') \n      ? Math.floor((parseInt(height, 10) / 100) * window.innerHeight)\n      : Math.floor(parseInt(height, 10) || window.innerHeight);\n    \n    // Set canvas size accounting for pixel ratio\n    canvas.width = displayWidth * pixelRatio;\n    canvas.height = displayHeight * pixelRatio;\n    canvas.style.width = `${displayWidth}px`;\n    canvas.style.height = `${displayHeight}px`;\n    \n    // 2D Canvas context\n    const ctx = canvas.getContext('2d', {\n      alpha: true,\n      desynchronized: true,\n      willReadFrequently: false\n    });\n    \n    if (!ctx) return false;\n    \n    // Scale context for high-DPI displays\n    ctx.scale(pixelRatio, pixelRatio);\n    \n    // Configure context for high-quality rendering\n    if (adaptedSettings.useHighQualityRendering) {\n      ctx.imageSmoothingEnabled = true;\n      ctx.imageSmoothingQuality = 'high';\n    }\n    \n    ctxRef.current = ctx;\n    \n    setDimensions({\n      width: displayWidth,\n      height: displayHeight,\n      pixelRatio\n    });\n    \n    return true;\n  }, [height, adaptedSettings.useHighQualityRendering]);\n  \n  // Setup canvas resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n    \n    // Create a ResizeObserver to detect container size changes\n    const resizeObserver = new ResizeObserver(() => {\n      // Debounce resize operations\n      if (resizeObserverRef.current?.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n      \n      const timeout = setTimeout(() => {\n        if (setupCanvas()) {\n          // Re-initialize stars and constellations when canvas is resized\n          initializeStars();\n          initializeConstellations();\n          setIsInitialized(true);\n        }\n      }, 100); // 100ms debounce\n      \n      resizeObserverRef.current = { timeout };\n    });\n    \n    // Capture current reference to avoid closure issues in cleanup\n    const currentContainer = containerRef.current;\n    \n    // Start observing the container\n    resizeObserver.observe(currentContainer);\n    const resizeObserverRef = { observer: resizeObserver };\n    \n    // Initial setup\n    setupCanvas();\n    \n    return () => {\n      if (resizeObserverRef.observer) {\n        resizeObserverRef.observer.disconnect();\n      }\n      if (resizeObserverRef.timeout) {\n        clearTimeout(resizeObserverRef.timeout);\n      }\n    };\n  }, [setupCanvas]);\n  \n  // Setup intersection observer to only animate when visible\n  useEffect(() => {\n    if (!containerRef.current) return;\n    \n    const observer = new IntersectionObserver(\n      entries => {\n        const isIntersecting = entries[0].isIntersecting;\n        \n        // Only change state if visibility actually changed\n        if (isIntersecting !== isVisible) {\n          setIsVisible(isIntersecting);\n          \n          if (isIntersecting) {\n            // Reset timing references when becoming visible again\n            lastTimestampRef.current = 0;\n          }\n        }\n      },\n      {\n        threshold: 0.01,\n        rootMargin: '100px'\n      }\n    );\n    \n    // Store current reference to avoid closure issues\n    const currentContainerRef = containerRef.current;\n    observer.observe(currentContainerRef);\n    const visibilityObserverRef = { current: observer };\n    \n    return () => {\n      if (visibilityObserverRef.current) {\n        visibilityObserverRef.current.disconnect();\n      }\n    };\n  }, [isVisible]);\n  \n  // Initialize stars - defined inside the component to access the latest references\n  const initializeStars = () => {\n    if (!dimensions.width || !dimensions.height) return;\n    \n    const stars = [];\n    const count = adaptedSettings.starDensity;\n    \n    // Create stars with varied properties\n    for (let i = 0; i < count; i++) {\n      // Base star parameters\n      const star = {\n        x: Math.random() * dimensions.width,\n        y: Math.random() * dimensions.height,\n        z: Math.random() * 3 + 0.5, // Z-depth for parallax effect\n        size: Math.random() * starMaxSize + 0.5,\n        twinkleSpeed: Math.random() * 0.02 + 0.005,\n        twinklePhase: Math.random() * Math.PI * 2,\n        brightness: 0.5 + Math.random() * 0.5,\n        originalBrightness: 0.5 + Math.random() * 0.5,\n        // Slightly varying colors for natural look\n        colorVariation: Math.random() * 0.2,\n        // Random layer factor for movement speed\n        layer: Math.floor(Math.random() * 3) // 0, 1, or 2\n      };\n      \n      stars.push(star);\n    }\n    \n    starsRef.current = stars;\n  };\n  \n  // Initialize constellations - defined inside the component to access the latest references\n  const initializeConstellations = () => {\n    if (!dimensions.width || !dimensions.height || starsRef.current.length === 0) return;\n    \n    const constellations = [];\n    const allStars = starsRef.current;\n    const count = adaptedSettings.constellationCount;\n    \n    // Create constellations\n    for (let c = 0; c < count; c++) {\n      // Select a random star as the constellation center\n      const centerStarIndex = Math.floor(Math.random() * allStars.length);\n      const centerStar = allStars[centerStarIndex];\n      \n      // Create complex connections between nearby stars\n      const points = [centerStarIndex];\n      const connections = [];\n      \n      // Find nearby stars to connect\n      const potentialConnections = [];\n      \n      for (let i = 0; i < allStars.length; i++) {\n        if (i === centerStarIndex) continue;\n        \n        const star = allStars[i];\n        const dx = star.x - centerStar.x;\n        const dy = star.y - centerStar.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        \n        // Only consider stars within a reasonable distance\n        const maxDistance = Math.min(dimensions.width, dimensions.height) * 0.25;\n        if (distance < maxDistance) {\n          potentialConnections.push({\n            index: i,\n            distance\n          });\n        }\n      }\n      \n      // Sort by distance and take the closest ones\n      potentialConnections.sort((a, b) => a.distance - b.distance);\n      \n      // Connect stars to form the constellation\n      // Only use as many as we have available, up to constellationComplexity\n      const starCount = Math.min(potentialConnections.length, constellationComplexity - 1);\n      \n      for (let i = 0; i < starCount; i++) {\n        const starIndex = potentialConnections[i].index;\n        points.push(starIndex);\n        \n        // Connect to center star or previous star in sequence\n        if (i === 0) {\n          connections.push([centerStarIndex, starIndex]);\n        } else {\n          // Sometimes connect back to earlier stars for more complex shapes\n          const connectToIndex = Math.random() < 0.7\n            ? potentialConnections[i - 1].index // Connect to previous star\n            : points[Math.floor(Math.random() * points.length)]; // Connect to random star in constellation\n            \n          connections.push([connectToIndex, starIndex]);\n        }\n        \n        // Add occasional branches for visual interest\n        if (i > 1 && Math.random() < 0.3 && i < starCount - 1) {\n          const branchTarget = points[Math.floor(Math.random() * (points.length - 1))];\n          connections.push([starIndex, branchTarget]);\n        }\n      }\n      \n      // Set constellation properties\n      const constellation = {\n        points,\n        connections,\n        progress: 0,\n        fadeState: 'in', // 'in', 'visible', 'out'\n        opacity: 0,\n        lastStateChange: 0,\n        visibleDuration: 40000 + Math.random() * 20000, // 40-60 seconds visibility\n        transitionDuration: 5000 + Math.random() * 3000, // 5-8 seconds fade in/out\n        lineWidth: 0.5 + Math.random() * 0.5,\n        pulsePhase: Math.random() * Math.PI * 2,\n        pulseSpeed: 0.0001 + Math.random() * 0.0002\n      };\n      \n      constellations.push(constellation);\n    }\n    \n    constellationsRef.current = constellations;\n  };\n  \n  // Create a twinkling effect at a specific star\n  const createTwinkleEffect = useCallback((star) => {\n    if (prefersReducedMotion && respectReducedMotion) return;\n    \n    // Create a subtle shine effect\n    const twinkle = {\n      x: star.x,\n      y: star.y,\n      size: star.size * (1.5 + Math.random() * 1),\n      brightness: star.originalBrightness * (1.2 + Math.random() * 0.5),\n      // More gradual and natural fading\n      life: 1.0,\n      decay: 0.01 + Math.random() * 0.02,\n      // Adding subtle drift to appear more natural\n      drift: {\n        x: (Math.random() * 2 - 1) * 0.2,\n        y: (Math.random() * 2 - 1) * 0.2\n      },\n      // Random chance for different qualities\n      enhancedEffect: Math.random() < 0.15, // 15% chance for enhanced effect\n      // Layer matching for consistent movement\n      layer: star.layer\n    };\n    \n    twinkleEffectsRef.current.push(twinkle);\n  }, [prefersReducedMotion, respectReducedMotion]);\n  \n  // Create a rare burst effect (similar to meteor burst but more subtle)\n  const createBurstEffect = useCallback((x, y, size) => {\n    if (prefersReducedMotion && respectReducedMotion) return;\n    \n    // Skip if we already have too many burst effects (performance optimization)\n    if (burstEffectsRef.current.length > 15) return;\n    \n    // Number of particles in burst - lower than meteor for subtlety\n    const particleCount = Math.floor(4 + Math.random() * 8);\n    \n    // Create a subtle burst of particles\n    for (let i = 0; i < particleCount; i++) {\n      // Calculate particle direction - full 360° radial\n      const angle = Math.random() * Math.PI * 2;\n      \n      // Speed - very slow for a subtle effect\n      const speed = 0.05 + Math.random() * 0.15;\n      \n      // Calculate velocity components\n      const vx = Math.cos(angle) * speed;\n      const vy = Math.sin(angle) * speed;\n      \n      // Create small particles\n      const particleSize = size * (0.3 + Math.random() * 0.4);\n      \n      // Create the burst particle\n      const burst = {\n        x: x,\n        y: y,\n        vx: vx,\n        vy: vy,\n        size: particleSize,\n        life: 1.0,\n        decay: 0.005 + Math.random() * 0.01, // Slower decay for longer effect\n        // Golden hues for subtle elegance\n        color: Math.random() < 0.7 \n          ? 'rgba(255, 255, 255, 0.8)' \n          : 'rgba(191, 173, 127, 0.7)',\n        // Elegant diminishing velocity\n        damping: 0.98 + Math.random() * 0.01\n      };\n      \n      burstEffectsRef.current.push(burst);\n    }\n  }, [prefersReducedMotion, respectReducedMotion]);\n  \n  // Update stars and world position\n  const updateStarsAndBackground = useCallback((deltaTime) => {\n    // Apply a maximum delta time to prevent large jumps after tab switching\n    const cappedDeltaTime = Math.min(deltaTime, 50);\n    \n    // Update world offset for horizontal scrolling effect\n    // Apply different speeds based on quality factor to prevent excessive motion on low-end devices\n    const speedFactor = Math.min(1, qualityFactor + 0.4);\n    worldOffsetRef.current.x += horizontalSpeed * speedFactor * (cappedDeltaTime / 16);\n    \n    // Ensure world offset wraps around cleanly\n    if (worldOffsetRef.current.x > dimensions.width) {\n      worldOffsetRef.current.x -= dimensions.width;\n    }\n    \n    // Update each star\n    for (const star of starsRef.current) {\n      // Apply twinkle effect using sin wave\n      const timeFactor = performance.now() * 0.001;\n      const twinkleEffect = Math.pow(Math.sin(timeFactor * star.twinkleSpeed + star.twinklePhase) * 0.5 + 0.5, 1.5);\n      \n      // More subtle brightness variation\n      star.brightness = star.originalBrightness * (0.8 + twinkleEffect * 0.4);\n      \n      // Move stars based on their layer (parallax effect)\n      // Layer 0 (distant): slowest, Layer 2 (closest): fastest\n      const layerSpeedFactor = 0.5 + (star.layer * 0.25);\n      \n      // Apply horizontal movement based on world offset\n      star.movementX = -worldOffsetRef.current.x * layerSpeedFactor * (star.z * 0.4);\n      \n      // Wrap stars around when they move off-screen\n      // Calculate effective position with wrapped movement\n      const effectiveX = (star.x + star.movementX) % dimensions.width;\n      if (effectiveX < 0) {\n        star.effectiveX = effectiveX + dimensions.width;\n      } else {\n        star.effectiveX = effectiveX;\n      }\n      \n      star.effectiveY = star.y;\n      \n      // Random chance to create twinkle effect\n      if (Math.random() < starTwinkleFrequency * (cappedDeltaTime / 16) * qualityFactor) {\n        createTwinkleEffect(star);\n      }\n      \n      // Very rare chance for a burst effect - slightly higher for brighter stars\n      if (Math.random() < rareEffectProbability * star.brightness * (cappedDeltaTime / 16) * qualityFactor) {\n        createBurstEffect(star.effectiveX, star.effectiveY, star.size * 2);\n      }\n    }\n    \n    // Update twinkle effects\n    for (let i = twinkleEffectsRef.current.length - 1; i >= 0; i--) {\n      const twinkle = twinkleEffectsRef.current[i];\n      \n      // Update life\n      twinkle.life -= twinkle.decay * (cappedDeltaTime / 16);\n      \n      // Apply subtle drift for more natural movement\n      twinkle.x += twinkle.drift.x * (cappedDeltaTime / 16);\n      twinkle.y += twinkle.drift.y * (cappedDeltaTime / 16);\n      \n      // Apply same world offset as the parent star's layer\n      const layerSpeedFactor = 0.5 + (twinkle.layer * 0.25);\n      twinkle.movementX = -worldOffsetRef.current.x * layerSpeedFactor * 0.4;\n      \n      // Calculate effective position\n      const effectiveX = (twinkle.x + twinkle.movementX) % dimensions.width;\n      if (effectiveX < 0) {\n        twinkle.effectiveX = effectiveX + dimensions.width;\n      } else {\n        twinkle.effectiveX = effectiveX;\n      }\n      \n      twinkle.effectiveY = twinkle.y;\n      \n      // Remove expired effects\n      if (twinkle.life <= 0) {\n        twinkleEffectsRef.current.splice(i, 1);\n      }\n    }\n    \n    // Update burst effects\n    for (let i = burstEffectsRef.current.length - 1; i >= 0; i--) {\n      const burst = burstEffectsRef.current[i];\n      \n      // Update position\n      burst.x += burst.vx * (cappedDeltaTime / 16);\n      burst.y += burst.vy * (cappedDeltaTime / 16);\n      \n      // Apply damping to velocity for natural deceleration\n      burst.vx *= burst.damping;\n      burst.vy *= burst.damping;\n      \n      // Update life\n      burst.life -= burst.decay * (cappedDeltaTime / 16);\n      \n      // Remove expired effects\n      if (burst.life <= 0) {\n        burstEffectsRef.current.splice(i, 1);\n      }\n    }\n    \n    // Update constellations\n    const now = performance.now();\n    for (const constellation of constellationsRef.current) {\n      // Update constellation state based on timing\n      const timeSinceStateChange = now - constellation.lastStateChange;\n      \n      if (constellation.fadeState === 'in') {\n        // Fading in\n        constellation.progress = Math.min(1, timeSinceStateChange / constellation.transitionDuration);\n        constellation.opacity = constellation.progress * 0.7; // Max opacity 0.7\n        \n        if (constellation.progress >= 1) {\n          constellation.fadeState = 'visible';\n          constellation.lastStateChange = now;\n        }\n      } else if (constellation.fadeState === 'visible') {\n        // Fully visible\n        if (timeSinceStateChange >= constellation.visibleDuration) {\n          constellation.fadeState = 'out';\n          constellation.lastStateChange = now;\n          constellation.progress = 1;\n        }\n        \n        // Subtle pulsing while visible\n        const pulsePhase = constellation.pulsePhase + now * constellation.pulseSpeed;\n        const pulseFactor = Math.sin(pulsePhase) * 0.1 + 0.9; // 0.8-1.0 range\n        constellation.opacity = 0.7 * pulseFactor;\n      } else if (constellation.fadeState === 'out') {\n        // Fading out\n        constellation.progress = 1 - Math.min(1, timeSinceStateChange / constellation.transitionDuration);\n        constellation.opacity = constellation.progress * 0.7;\n        \n        if (constellation.progress <= 0) {\n          // Reset constellation with new parameters\n          constellation.fadeState = 'in';\n          constellation.lastStateChange = now + Math.random() * 10000; // Staggered reappearance\n          constellation.visibleDuration = 40000 + Math.random() * 20000;\n          constellation.transitionDuration = 5000 + Math.random() * 3000;\n          constellation.pulsePhase = Math.random() * Math.PI * 2;\n          \n          // Occasional reshuffling of constellation connections for variety\n          if (Math.random() < 0.3) {\n            const connections = constellation.connections;\n            for (let i = 0; i < connections.length; i++) {\n              if (Math.random() < 0.4) {\n                // Rewire this connection to a different point\n                const targetOptions = constellation.points.filter(p => \n                  p !== connections[i][0] && p !== connections[i][1]);\n                \n                if (targetOptions.length > 0) {\n                  const newTarget = targetOptions[Math.floor(Math.random() * targetOptions.length)];\n                  connections[i][Math.random() < 0.5 ? 0 : 1] = newTarget;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }, [\n    dimensions, \n    horizontalSpeed, \n    qualityFactor, \n    starTwinkleFrequency, \n    rareEffectProbability, \n    createTwinkleEffect, \n    createBurstEffect\n  ]);\n  \n  // Render stars and constellations\n  const renderStarsAndConstellations = useCallback((ctx) => {\n    // Clear canvas with optimized clear method\n    ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n    \n    // Determine if we should use quality renderings based on settings\n    const useQualityRendering = adaptedSettings.useHighQualityRendering;\n    const useGlow = adaptedSettings.useGlow;\n    \n    // Render stars first (background layer)\n    for (const star of starsRef.current) {\n      // Skip if not in visible area\n      if (star.effectiveX < -10 || star.effectiveX > dimensions.width + 10 ||\n          star.effectiveY < -10 || star.effectiveY > dimensions.height + 10) {\n        continue;\n      }\n      \n      // Basic star rendering for all quality levels\n      ctx.beginPath();\n      \n      if (useQualityRendering) {\n        // High quality rendering with soft glow\n        // Set shadow for glow effect if enabled\n        if (useGlow) {\n          ctx.shadowColor = getCachedColor(starColor, star.brightness * 0.8);\n          ctx.shadowBlur = star.size * 3;\n        }\n        \n        // Draw star with gradient for more natural appearance\n        const gradient = ctx.createRadialGradient(\n          star.effectiveX, star.effectiveY, 0,\n          star.effectiveX, star.effectiveY, star.size * 1.2\n        );\n        \n        gradient.addColorStop(0, getCachedColor(starColor, star.brightness));\n        gradient.addColorStop(0.5, getCachedColor(starColor, star.brightness * 0.6));\n        gradient.addColorStop(1, getCachedColor(starColor, 0));\n        \n        ctx.fillStyle = gradient;\n        ctx.arc(star.effectiveX, star.effectiveY, star.size, 0, Math.PI * 2);\n        ctx.fill();\n      } else {\n        // Simplified rendering for lower performance devices\n        ctx.fillStyle = getCachedColor(starColor, star.brightness);\n        ctx.arc(star.effectiveX, star.effectiveY, star.size * 0.8, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n    \n    // Reset shadow to avoid affecting other elements\n    if (useGlow) {\n      ctx.shadowBlur = 0;\n    }\n    \n    // Render constellations\n    for (const constellation of constellationsRef.current) {\n      if (constellation.opacity <= 0.01) continue;\n      \n      const allStars = starsRef.current;\n      \n      // Set constellation line style\n      ctx.strokeStyle = getCachedColor(constellationColor, constellation.opacity);\n      ctx.lineWidth = constellation.lineWidth;\n      \n      // Optimized rendering by batching lines\n      ctx.beginPath();\n      \n      // Draw constellation connections\n      for (const [fromIndex, toIndex] of constellation.connections) {\n        const fromStar = allStars[fromIndex];\n        const toStar = allStars[toIndex];\n        \n        if (!fromStar || !toStar) continue;\n        \n        // Use effective positions that account for movement\n        ctx.moveTo(fromStar.effectiveX, fromStar.effectiveY);\n        ctx.lineTo(toStar.effectiveX, toStar.effectiveY);\n      }\n      \n      // Apply glow to constellation lines if enabled\n      if (useGlow) {\n        ctx.shadowColor = getCachedColor(constellationColor, constellation.opacity * 0.5);\n        ctx.shadowBlur = 3;\n      }\n      \n      ctx.stroke();\n      \n      // Reset shadow\n      if (useGlow) {\n        ctx.shadowBlur = 0;\n      }\n    }\n    \n    // Render twinkle effects above regular stars\n    for (const twinkle of twinkleEffectsRef.current) {\n      // Skip if not in visible area\n      if (twinkle.effectiveX < -10 || twinkle.effectiveX > dimensions.width + 10 ||\n          twinkle.effectiveY < -10 || twinkle.effectiveY > dimensions.height + 10) {\n        continue;\n      }\n      \n      const opacity = twinkle.life * twinkle.brightness;\n      \n      if (useQualityRendering && twinkle.enhancedEffect) {\n        // Enhanced twinkle effect for some stars\n        // Outer glow\n        if (useGlow) {\n          ctx.shadowColor = getCachedColor(starColor, opacity * 0.6);\n          ctx.shadowBlur = twinkle.size * 3;\n        }\n        \n        // Draw twinkle with gradient\n        const gradient = ctx.createRadialGradient(\n          twinkle.effectiveX, twinkle.effectiveY, 0,\n          twinkle.effectiveX, twinkle.effectiveY, twinkle.size * 1.5\n        );\n        \n        gradient.addColorStop(0, getCachedColor(starColor, opacity));\n        gradient.addColorStop(0.4, getCachedColor(starColor, opacity * 0.7));\n        gradient.addColorStop(1, getCachedColor(starColor, 0));\n        \n        ctx.beginPath();\n        ctx.fillStyle = gradient;\n        ctx.arc(twinkle.effectiveX, twinkle.effectiveY, twinkle.size, 0, Math.PI * 2);\n        ctx.fill();\n        \n        // Inner core\n        ctx.beginPath();\n        ctx.fillStyle = getCachedColor(starColor, opacity * 1.2);\n        ctx.arc(twinkle.effectiveX, twinkle.effectiveY, twinkle.size * 0.4, 0, Math.PI * 2);\n        ctx.fill();\n      } else {\n        // Simple twinkle effect\n        ctx.beginPath();\n        if (useGlow) {\n          ctx.shadowColor = getCachedColor(starColor, opacity * 0.5);\n          ctx.shadowBlur = twinkle.size * 2;\n        }\n        ctx.fillStyle = getCachedColor(starColor, opacity);\n        ctx.arc(twinkle.effectiveX, twinkle.effectiveY, twinkle.size * 0.9, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n    \n    // Reset shadow\n    if (useGlow) {\n      ctx.shadowBlur = 0;\n    }\n    \n    // Render burst effects\n    for (const burst of burstEffectsRef.current) {\n      const opacity = burst.life * 0.8;\n      \n      if (useQualityRendering) {\n        // Apply shadow/glow\n        if (useGlow) {\n          ctx.shadowColor = getCachedColor(burst.color, opacity * 0.6);\n          ctx.shadowBlur = burst.size * 2;\n        }\n        \n        // Draw particle with fade out\n        ctx.beginPath();\n        ctx.fillStyle = getCachedColor(burst.color, opacity);\n        ctx.arc(burst.x, burst.y, burst.size * burst.life, 0, Math.PI * 2);\n        ctx.fill();\n      } else {\n        // Simple particle rendering\n        ctx.beginPath();\n        ctx.fillStyle = getCachedColor(burst.color, opacity);\n        ctx.arc(burst.x, burst.y, burst.size * burst.life * 0.8, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n  }, [\n    dimensions, \n    adaptedSettings.useHighQualityRendering, \n    adaptedSettings.useGlow, \n    starColor, \n    constellationColor, \n    getCachedColor\n  ]);\n  \n  // FPS limiter for consistent animation speed\n  const fpsLimiter = useCallback((timestamp, callback) => {\n    // Skip animation if hidden, inactive, or reduced motion\n    if (!isVisible || !active || (respectReducedMotion && prefersReducedMotion) || document.hidden) {\n      animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n      return;\n    }\n    \n    const targetFrameTime = 1000 / maxFPS;\n    const elapsed = timestamp - lastTimestampRef.current;\n    \n    if (elapsed >= targetFrameTime || lastTimestampRef.current === 0) {\n      // Calculate correct delta\n      const delta = lastTimestampRef.current === 0 ? 16 : elapsed;\n      \n      // Update timestamp, limiting delta to avoid jumps after inactivity\n      lastTimestampRef.current = timestamp - (elapsed % targetFrameTime);\n      \n      // Run animation callback with capped delta time\n      callback(Math.min(delta, 50));\n      \n      // FPS tracking\n      frameCountRef.current++;\n      if (timestamp - fpsTimestampRef.current >= 1000) {\n        currentFpsRef.current = frameCountRef.current;\n        frameCountRef.current = 0;\n        fpsTimestampRef.current = timestamp;\n        \n        // Dynamic quality adjustment based on performance\n        if (adaptiveQuality) {\n          // Check if FPS is stable\n          if (currentFpsRef.current >= maxFPS * 0.9) {\n            stableFrameCountRef.current += 1;\n          } else if (currentFpsRef.current < maxFPS * 0.7) {\n            stableFrameCountRef.current = 0;\n          }\n          \n          // Avoid frequent quality changes by using a timer\n          if (qualityChangeTimerRef.current) {\n            clearTimeout(qualityChangeTimerRef.current);\n          }\n          \n          qualityChangeTimerRef.current = setTimeout(() => {\n            // Only change quality if FPS has been stable or is very low\n            if (currentFpsRef.current < maxFPS * 0.7) {\n              // If FPS is below 70% of target, reduce quality\n              setQualityFactor(prev => Math.max(0.4, prev * 0.9));\n            } else if (stableFrameCountRef.current >= 3 && qualityFactor < 1) {\n              // If FPS has been high for several frames, gradually increase quality\n              setQualityFactor(prev => Math.min(1, prev * 1.05));\n            }\n          }, 500);\n        }\n      }\n    }\n    \n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n  }, [\n    isVisible,\n    active,\n    respectReducedMotion,\n    prefersReducedMotion,\n    maxFPS,\n    adaptiveQuality,\n    qualityFactor\n  ]);\n  \n  // Main animation handler\n  const handleAnimation = useCallback((deltaTime) => {\n    // Skip if component is not ready\n    if (!canvasRef.current || !isInitialized || !dimensions.width || !dimensions.height) return;\n    \n    // Update star positions and background\n    updateStarsAndBackground(deltaTime);\n    \n    // Render the scene\n    renderStarsAndConstellations(ctxRef.current);\n  }, [\n    isInitialized,\n    dimensions,\n    updateStarsAndBackground,\n    renderStarsAndConstellations\n  ]);\n  \n  // Initialize stars and constellations once dimensions are available\n  useEffect(() => {\n    if (dimensions.width && dimensions.height) {\n      initializeStars();\n      initializeConstellations();\n      setIsInitialized(true);\n    }\n  }, [dimensions, adaptedSettings.starDensity, adaptedSettings.constellationCount, starMaxSize]);\n  \n  // Main animation loop\n  useEffect(() => {\n    if (!active || !isInitialized || !dimensions.width || !dimensions.height) {\n      return;\n    }\n    \n    // Start animation with FPS limiter\n    fpsTimestampRef.current = performance.now();\n    frameCountRef.current = 0;\n    lastTimestampRef.current = 0;\n    \n    animationFrameRef.current = requestAnimationFrame(timestamp => {\n      fpsLimiter(timestamp, handleAnimation);\n    });\n    \n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      \n      if (qualityChangeTimerRef.current) {\n        clearTimeout(qualityChangeTimerRef.current);\n      }\n    };\n  }, [\n    active,\n    isInitialized,\n    dimensions,\n    fpsLimiter,\n    handleAnimation\n  ]);\n  \n  // Apply reduced motion adjustments\n  const reducedMotionStyles = useMemo(() => {\n    if (prefersReducedMotion && respectReducedMotion) {\n      return {\n        // Subtle static look for reduced motion preference\n        animation: 'none',\n        transition: 'none'\n      };\n    }\n    return {};\n  }, [prefersReducedMotion, respectReducedMotion]);\n  \n  return (\n    <div \n      ref={containerRef}\n      style={{ \n        position: 'absolute',\n        top: 0, \n        left: 0, \n        width: '100%', \n        height: height,\n        overflow: 'hidden', \n        pointerEvents: 'none', \n        zIndex: zIndex,\n        ...reducedMotionStyles,\n        // Hardware acceleration\n        backfaceVisibility: 'hidden',\n        transform: 'translateZ(0)',\n        willChange: 'transform'\n      }}\n      aria-hidden=\"true\"\n    >\n      <canvas \n        ref={canvasRef} \n        style={{ \n          position: 'absolute', \n          top: 0, \n          left: 0, \n          width: '100%', \n          height: '100%',\n          // Additional rendering optimizations\n          imageRendering: 'high-quality',\n          // Hardware acceleration\n          backfaceVisibility: 'hidden',\n          transform: 'translateZ(0)',\n          willChange: 'transform',\n          // Ensures proper subpixel rendering\n          filter: 'none'\n        }} \n      />\n    </div>\n  );\n};\n\n/**\n * Dark Fantasy Stellar Background - Preset Configuration\n * A background with richer golden-hued stars and elegant constellations\n */\nexport const DarkFantasyStellarBackground = (props) => {\n  const darkFantasyPreset = {\n    starDensity: 120,\n    starMaxSize: 2.2,\n    constellationCount: 4,\n    constellationComplexity: 8,\n    horizontalSpeed: 0.15,\n    starTwinkleFrequency: 0.004,\n    rareEffectProbability: 0.0006,\n    starColor: 'rgba(255, 253, 240, 0.85)',\n    constellationColor: 'rgba(207, 181, 59, 0.25)',\n    maxFPS: 30\n  };\n  \n  return <StellarBackground {...darkFantasyPreset} {...props} />;\n};\n\nexport default StellarBackground;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}