{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/Background.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect, useCallback, useMemo } from 'react';\n\n/**\n * Optimized Background Component\n * \n * Creates an immersive stellar background with realistic star particles\n * with performance optimizations to prevent excessive re-rendering.\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Background = () => {\n  _s();\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const starsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimeRef = useRef(0);\n\n  // Component state - minimized to prevent re-renders\n  const [isInitialized, setIsInitialized] = useState(false);\n\n  // Store dimensions in a ref to avoid re-renders when they change\n  const dimensionsRef = useRef({\n    width: 0,\n    height: 0,\n    pixelRatio: 1\n  });\n\n  // Configuration - wrapped in useMemo to prevent recreation on each render\n  const CONFIG = useMemo(() => ({\n    // Reduced star count for better performance\n    starCount: 100,\n    starSizeMin: 0.8,\n    starSizeMax: 2.5,\n    starOpacityMin: 0.15,\n    starOpacityMax: 0.85,\n    // Simplified motion parameters\n    baseMovementSpeed: 0.00008,\n    // Reduced movement speed\n    pulseFrequency: 0.00003,\n    // Disabled parallax effect for better performance\n    parallaxEnabled: false,\n    // Performance parameters\n    maxFPS: 30,\n    useRays: false // Disable ray rendering for better performance\n  }), []);\n\n  // Warm, golden color palette - wrapped in useMemo\n  const COLORS = useMemo(() => ({\n    // Simplified color palette\n    stars: ['rgba(255, 243, 200, alpha)',\n    // Warm yellow\n    'rgba(255, 231, 164, alpha)',\n    // Golden\n    'rgba(252, 249, 231, alpha)' // Off-white gold\n    ],\n    // Background gradient colors\n    background: {\n      topColor: 'rgb(8, 8, 12)',\n      bottomColor: 'rgb(15, 15, 20)'\n    }\n  }), []);\n\n  // Pre-generated color values to avoid string replacements during animation\n  const colorCache = useMemo(() => {\n    const cache = {};\n    COLORS.stars.forEach(baseColor => {\n      cache[baseColor] = {};\n      for (let opacity = 0; opacity <= 10; opacity++) {\n        const value = opacity / 10;\n        cache[baseColor][value] = baseColor.replace(/alpha\\)$/, `${value})`);\n      }\n    });\n    return cache;\n  }, [COLORS.stars]);\n\n  // Get color with opacity from cache (faster than string replacement)\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    // Round to nearest 0.1 to use cached values\n    const roundedOpacity = Math.round(safeOpacity * 10) / 10;\n    return colorCache[baseColor][roundedOpacity] || baseColor.replace(/alpha\\)$/, `${safeOpacity})`);\n  }, [colorCache]);\n\n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) return false;\n    const canvas = canvasRef.current;\n\n    // Get viewport dimensions\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const pixelRatio = window.devicePixelRatio || 1;\n\n    // Set canvas size accounting for pixel ratio\n    canvas.width = width * pixelRatio;\n    canvas.height = height * pixelRatio;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n\n    // Ensure canvas is visible with a background color\n    const ctx = canvas.getContext('2d', {\n      alpha: false\n    }); // Optimize for non-transparent canvas\n    if (ctx) {\n      ctx.fillStyle = 'rgb(15, 15, 20)';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n\n    // Update dimensions ref instead of state\n    dimensionsRef.current = {\n      width,\n      height,\n      pixelRatio\n    };\n    return true;\n  }, []);\n\n  // Initialize stars with proper properties\n  const initializeStars = useCallback(() => {\n    const {\n      width,\n      height\n    } = dimensionsRef.current;\n    if (!width || !height) return;\n\n    // Clear existing stars\n    starsRef.current = [];\n\n    // Create stars with simplified properties\n    for (let i = 0; i < CONFIG.starCount; i++) {\n      const star = {};\n\n      // Position\n      star.x = Math.random() * width;\n      star.y = Math.random() * height;\n      star.z = Math.random() * 0.8 + 0.1; // Depth (0.1 to 0.9)\n\n      // Visual properties\n      star.size = (Math.random() * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n      star.baseOpacity = Math.random() * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n      star.opacity = star.baseOpacity;\n\n      // Simplified animation properties\n      star.pulsePhase = Math.random() * Math.PI * 2;\n      star.pulseSpeed = Math.random() * 0.002 + 0.001;\n      star.movementSpeed = (Math.random() * 0.2 + 0.9) * CONFIG.baseMovementSpeed * (1.1 - star.z);\n\n      // Color variation\n      const colorIndex = Math.floor(Math.random() * COLORS.stars.length);\n      star.color = COLORS.stars[colorIndex];\n\n      // Store in ref\n      starsRef.current.push(star);\n    }\n  }, [CONFIG, COLORS.stars]);\n\n  // Setup canvas resize observer\n  useEffect(() => {\n    const handleResize = () => {\n      if (setupCanvas()) {\n        // Reinitialize stars after resize\n        initializeStars();\n        setIsInitialized(true);\n      }\n    };\n\n    // Throttle resize events\n    let resizeTimer;\n    const throttledResize = () => {\n      if (!resizeTimer) {\n        resizeTimer = setTimeout(() => {\n          resizeTimer = null;\n          handleResize();\n        }, 200); // 200ms throttle\n      }\n    };\n    window.addEventListener('resize', throttledResize);\n\n    // Initial setup\n    setupCanvas();\n    return () => {\n      window.removeEventListener('resize', throttledResize);\n      if (resizeTimer) clearTimeout(resizeTimer);\n    };\n  }, [setupCanvas, initializeStars]);\n\n  // Update animation state - optimized for performance\n  const updateAnimation = useCallback((deltaTime, timestamp) => {\n    const {\n      width,\n      height\n    } = dimensionsRef.current;\n\n    // Global time factor for animations\n    const timeFactor = timestamp * 0.001;\n\n    // Update stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n\n      // Simplified movement based on time\n      star.x += Math.sin(timeFactor * 0.2 + star.pulsePhase) * star.movementSpeed * deltaTime;\n      star.y += Math.cos(timeFactor * 0.3 + star.pulsePhase * 1.3) * star.movementSpeed * deltaTime;\n\n      // Wrap around screen edges\n      if (star.x < 0) star.x = width;\n      if (star.x > width) star.x = 0;\n      if (star.y < 0) star.y = height;\n      if (star.y > height) star.y = 0;\n\n      // Simplified pulsing effect\n      const pulseFactor = Math.sin(timeFactor * star.pulseSpeed + star.pulsePhase) * 0.15 + 0.85;\n      star.opacity = star.baseOpacity * pulseFactor;\n    }\n  }, []);\n\n  // Optimized star rendering\n  const drawStar = useCallback((ctx, star) => {\n    // Skip rendering almost invisible stars\n    if (star.opacity < 0.05) return;\n\n    // Simplified star rendering without creating new gradients every frame\n    ctx.beginPath();\n    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n    ctx.fillStyle = getColor(star.color, star.opacity);\n    ctx.fill();\n\n    // Simplified glow effect without expensive gradient creation\n    if (star.opacity > 0.3) {\n      ctx.beginPath();\n      ctx.arc(star.x, star.y, star.size * 1.8, 0, Math.PI * 2);\n      ctx.fillStyle = getColor(star.color, star.opacity * 0.4);\n      ctx.fill();\n    }\n  }, [getColor]);\n\n  // Render the scene - optimized for performance\n  const renderScene = useCallback(() => {\n    if (!canvasRef.current) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d', {\n      alpha: false\n    });\n    if (!ctx) return;\n    const {\n      width,\n      height,\n      pixelRatio\n    } = dimensionsRef.current;\n\n    // Clear canvas\n    ctx.fillStyle = COLORS.background.topColor;\n    ctx.fillRect(0, 0, width * pixelRatio, height * pixelRatio);\n\n    // Apply device pixel ratio scaling only once\n    ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n\n    // Enable global composition for better glow effect\n    ctx.globalCompositeOperation = 'lighter';\n\n    // Draw stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      drawStar(ctx, starsRef.current[i]);\n    }\n\n    // Reset global composition\n    ctx.globalCompositeOperation = 'source-over';\n  }, [COLORS.background.topColor, drawStar]);\n\n  // Main animation loop - optimized with timing control\n  const animate = useCallback(timestamp => {\n    if (!isInitialized) {\n      animationFrameRef.current = requestAnimationFrame(animate);\n      return;\n    }\n\n    // Limit FPS\n    const minFrameTime = 1000 / CONFIG.maxFPS;\n    const elapsed = timestamp - (lastTimeRef.current || 0);\n    if (elapsed < minFrameTime) {\n      animationFrameRef.current = requestAnimationFrame(animate);\n      return;\n    }\n\n    // Calculate delta time with cap to prevent large jumps\n    const deltaTime = lastTimeRef.current ? Math.min(elapsed, 50) : 16;\n    lastTimeRef.current = timestamp;\n\n    // Update animation state\n    updateAnimation(deltaTime, timestamp);\n\n    // Render scene\n    renderScene();\n\n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(animate);\n  }, [isInitialized, CONFIG.maxFPS, updateAnimation, renderScene]);\n\n  // Initialize animation when component is ready\n  useEffect(() => {\n    if (!isInitialized && dimensionsRef.current.width && dimensionsRef.current.height) {\n      initializeStars();\n      setIsInitialized(true);\n    }\n  }, [isInitialized, initializeStars]);\n\n  // Start animation loop\n  useEffect(() => {\n    if (!isInitialized) return;\n\n    // Start animation\n    animationFrameRef.current = requestAnimationFrame(animate);\n\n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [isInitialized, animate]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      width: '100vw',\n      height: '100vh',\n      overflow: 'hidden',\n      zIndex: -1,\n      pointerEvents: 'none'\n    },\n    \"aria-hidden\": \"true\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 324,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 310,\n    columnNumber: 5\n  }, this);\n};\n_s(Background, \"zW41q7NMg8SQ5alz4kYMu3iYpWI=\");\n_c = Background;\nexport default Background;\nvar _c;\n$RefreshReg$(_c, \"Background\");","map":{"version":3,"names":["React","useRef","useState","useEffect","useCallback","useMemo","jsxDEV","_jsxDEV","Background","_s","containerRef","canvasRef","starsRef","animationFrameRef","lastTimeRef","isInitialized","setIsInitialized","dimensionsRef","width","height","pixelRatio","CONFIG","starCount","starSizeMin","starSizeMax","starOpacityMin","starOpacityMax","baseMovementSpeed","pulseFrequency","parallaxEnabled","maxFPS","useRays","COLORS","stars","background","topColor","bottomColor","colorCache","cache","forEach","baseColor","opacity","value","replace","getColor","safeOpacity","Math","max","min","roundedOpacity","round","setupCanvas","current","canvas","window","innerWidth","innerHeight","devicePixelRatio","style","ctx","getContext","alpha","fillStyle","fillRect","initializeStars","i","star","x","random","y","z","size","baseOpacity","pulsePhase","PI","pulseSpeed","movementSpeed","colorIndex","floor","length","color","push","handleResize","resizeTimer","throttledResize","setTimeout","addEventListener","removeEventListener","clearTimeout","updateAnimation","deltaTime","timestamp","timeFactor","sin","cos","pulseFactor","drawStar","beginPath","arc","fill","renderScene","setTransform","globalCompositeOperation","animate","requestAnimationFrame","minFrameTime","elapsed","cancelAnimationFrame","ref","position","top","left","overflow","zIndex","pointerEvents","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/Background.jsx"],"sourcesContent":["import React, { useRef, useState, useEffect, useCallback, useMemo } from 'react';\n\n/**\n * Optimized Background Component\n * \n * Creates an immersive stellar background with realistic star particles\n * with performance optimizations to prevent excessive re-rendering.\n */\nconst Background = () => {\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const starsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimeRef = useRef(0);\n  \n  // Component state - minimized to prevent re-renders\n  const [isInitialized, setIsInitialized] = useState(false);\n  \n  // Store dimensions in a ref to avoid re-renders when they change\n  const dimensionsRef = useRef({ width: 0, height: 0, pixelRatio: 1 });\n  \n  // Configuration - wrapped in useMemo to prevent recreation on each render\n  const CONFIG = useMemo(() => ({\n    // Reduced star count for better performance\n    starCount: 100,\n    starSizeMin: 0.8,\n    starSizeMax: 2.5,\n    starOpacityMin: 0.15,\n    starOpacityMax: 0.85,\n    \n    // Simplified motion parameters\n    baseMovementSpeed: 0.00008,  // Reduced movement speed\n    pulseFrequency: 0.00003,\n    \n    // Disabled parallax effect for better performance\n    parallaxEnabled: false,\n    \n    // Performance parameters\n    maxFPS: 30,\n    useRays: false  // Disable ray rendering for better performance\n  }), []);\n  \n  // Warm, golden color palette - wrapped in useMemo\n  const COLORS = useMemo(() => ({\n    // Simplified color palette\n    stars: [\n      'rgba(255, 243, 200, alpha)', // Warm yellow\n      'rgba(255, 231, 164, alpha)', // Golden\n      'rgba(252, 249, 231, alpha)'  // Off-white gold\n    ],\n    \n    // Background gradient colors\n    background: {\n      topColor: 'rgb(8, 8, 12)',\n      bottomColor: 'rgb(15, 15, 20)'\n    }\n  }), []);\n  \n  // Pre-generated color values to avoid string replacements during animation\n  const colorCache = useMemo(() => {\n    const cache = {};\n    COLORS.stars.forEach(baseColor => {\n      cache[baseColor] = {};\n      for (let opacity = 0; opacity <= 10; opacity++) {\n        const value = opacity / 10;\n        cache[baseColor][value] = baseColor.replace(/alpha\\)$/, `${value})`);\n      }\n    });\n    return cache;\n  }, [COLORS.stars]);\n  \n  // Get color with opacity from cache (faster than string replacement)\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    // Round to nearest 0.1 to use cached values\n    const roundedOpacity = Math.round(safeOpacity * 10) / 10;\n    return colorCache[baseColor][roundedOpacity] || baseColor.replace(/alpha\\)$/, `${safeOpacity})`);\n  }, [colorCache]);\n  \n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) return false;\n    \n    const canvas = canvasRef.current;\n    \n    // Get viewport dimensions\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const pixelRatio = window.devicePixelRatio || 1;\n    \n    // Set canvas size accounting for pixel ratio\n    canvas.width = width * pixelRatio;\n    canvas.height = height * pixelRatio;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n    \n    // Ensure canvas is visible with a background color\n    const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for non-transparent canvas\n    if (ctx) {\n      ctx.fillStyle = 'rgb(15, 15, 20)';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    \n    // Update dimensions ref instead of state\n    dimensionsRef.current = { width, height, pixelRatio };\n    \n    return true;\n  }, []);\n  \n  // Initialize stars with proper properties\n  const initializeStars = useCallback(() => {\n    const { width, height } = dimensionsRef.current;\n    if (!width || !height) return;\n    \n    // Clear existing stars\n    starsRef.current = [];\n    \n    // Create stars with simplified properties\n    for (let i = 0; i < CONFIG.starCount; i++) {\n      const star = {};\n      \n      // Position\n      star.x = Math.random() * width;\n      star.y = Math.random() * height;\n      star.z = Math.random() * 0.8 + 0.1; // Depth (0.1 to 0.9)\n      \n      // Visual properties\n      star.size = (Math.random() * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n      star.baseOpacity = Math.random() * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n      star.opacity = star.baseOpacity;\n      \n      // Simplified animation properties\n      star.pulsePhase = Math.random() * Math.PI * 2;\n      star.pulseSpeed = Math.random() * 0.002 + 0.001;\n      star.movementSpeed = (Math.random() * 0.2 + 0.9) * CONFIG.baseMovementSpeed * (1.1 - star.z);\n      \n      // Color variation\n      const colorIndex = Math.floor(Math.random() * COLORS.stars.length);\n      star.color = COLORS.stars[colorIndex];\n      \n      // Store in ref\n      starsRef.current.push(star);\n    }\n  }, [CONFIG, COLORS.stars]);\n  \n  // Setup canvas resize observer\n  useEffect(() => {\n    const handleResize = () => {\n      if (setupCanvas()) {\n        // Reinitialize stars after resize\n        initializeStars();\n        setIsInitialized(true);\n      }\n    };\n    \n    // Throttle resize events\n    let resizeTimer;\n    const throttledResize = () => {\n      if (!resizeTimer) {\n        resizeTimer = setTimeout(() => {\n          resizeTimer = null;\n          handleResize();\n        }, 200); // 200ms throttle\n      }\n    };\n    \n    window.addEventListener('resize', throttledResize);\n    \n    // Initial setup\n    setupCanvas();\n    \n    return () => {\n      window.removeEventListener('resize', throttledResize);\n      if (resizeTimer) clearTimeout(resizeTimer);\n    };\n  }, [setupCanvas, initializeStars]);\n  \n  // Update animation state - optimized for performance\n  const updateAnimation = useCallback((deltaTime, timestamp) => {\n    const { width, height } = dimensionsRef.current;\n    \n    // Global time factor for animations\n    const timeFactor = timestamp * 0.001;\n    \n    // Update stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n      \n      // Simplified movement based on time\n      star.x += Math.sin(timeFactor * 0.2 + star.pulsePhase) * star.movementSpeed * deltaTime;\n      star.y += Math.cos(timeFactor * 0.3 + star.pulsePhase * 1.3) * star.movementSpeed * deltaTime;\n      \n      // Wrap around screen edges\n      if (star.x < 0) star.x = width;\n      if (star.x > width) star.x = 0;\n      if (star.y < 0) star.y = height;\n      if (star.y > height) star.y = 0;\n      \n      // Simplified pulsing effect\n      const pulseFactor = Math.sin(timeFactor * star.pulseSpeed + star.pulsePhase) * 0.15 + 0.85;\n      star.opacity = star.baseOpacity * pulseFactor;\n    }\n  }, []);\n  \n  // Optimized star rendering\n  const drawStar = useCallback((ctx, star) => {\n    // Skip rendering almost invisible stars\n    if (star.opacity < 0.05) return;\n\n    // Simplified star rendering without creating new gradients every frame\n    ctx.beginPath();\n    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n    ctx.fillStyle = getColor(star.color, star.opacity);\n    ctx.fill();\n    \n    // Simplified glow effect without expensive gradient creation\n    if (star.opacity > 0.3) {\n      ctx.beginPath();\n      ctx.arc(star.x, star.y, star.size * 1.8, 0, Math.PI * 2);\n      ctx.fillStyle = getColor(star.color, star.opacity * 0.4);\n      ctx.fill();\n    }\n  }, [getColor]);\n  \n  // Render the scene - optimized for performance\n  const renderScene = useCallback(() => {\n    if (!canvasRef.current) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d', { alpha: false });\n    \n    if (!ctx) return;\n    \n    const { width, height, pixelRatio } = dimensionsRef.current;\n    \n    // Clear canvas\n    ctx.fillStyle = COLORS.background.topColor;\n    ctx.fillRect(0, 0, width * pixelRatio, height * pixelRatio);\n    \n    // Apply device pixel ratio scaling only once\n    ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    \n    // Enable global composition for better glow effect\n    ctx.globalCompositeOperation = 'lighter';\n    \n    // Draw stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      drawStar(ctx, starsRef.current[i]);\n    }\n    \n    // Reset global composition\n    ctx.globalCompositeOperation = 'source-over';\n  }, [COLORS.background.topColor, drawStar]);\n  \n  // Main animation loop - optimized with timing control\n  const animate = useCallback((timestamp) => {\n    if (!isInitialized) {\n      animationFrameRef.current = requestAnimationFrame(animate);\n      return;\n    }\n    \n    // Limit FPS\n    const minFrameTime = 1000 / CONFIG.maxFPS;\n    const elapsed = timestamp - (lastTimeRef.current || 0);\n    \n    if (elapsed < minFrameTime) {\n      animationFrameRef.current = requestAnimationFrame(animate);\n      return;\n    }\n    \n    // Calculate delta time with cap to prevent large jumps\n    const deltaTime = lastTimeRef.current ? Math.min(elapsed, 50) : 16;\n    lastTimeRef.current = timestamp;\n    \n    // Update animation state\n    updateAnimation(deltaTime, timestamp);\n    \n    // Render scene\n    renderScene();\n    \n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(animate);\n  }, [isInitialized, CONFIG.maxFPS, updateAnimation, renderScene]);\n  \n  // Initialize animation when component is ready\n  useEffect(() => {\n    if (!isInitialized && dimensionsRef.current.width && dimensionsRef.current.height) {\n      initializeStars();\n      setIsInitialized(true);\n    }\n  }, [isInitialized, initializeStars]);\n  \n  // Start animation loop\n  useEffect(() => {\n    if (!isInitialized) return;\n    \n    // Start animation\n    animationFrameRef.current = requestAnimationFrame(animate);\n    \n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [isInitialized, animate]);\n  \n  return (\n    <div\n      ref={containerRef}\n      style={{\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        width: '100vw',\n        height: '100vh',\n        overflow: 'hidden',\n        zIndex: -1,\n        pointerEvents: 'none'\n      }}\n      aria-hidden=\"true\"\n    >\n      <canvas\n        ref={canvasRef}\n        style={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%'\n        }}\n      />\n    </div>\n  );\n};\n\nexport default Background;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}