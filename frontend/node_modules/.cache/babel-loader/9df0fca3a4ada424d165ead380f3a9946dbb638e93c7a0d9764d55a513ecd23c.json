{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/MeteorShower.jsx\",\n  _s2 = $RefreshSig$();\nimport React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';\n\n/**\n * MeteorShower Component - Enterprise Performance Optimized Version\n * \n * Creates a highly performant animated meteor shower effect where meteors\n * arc across the sky with comet-like trails and fade away naturally.\n * \n * Features:\n * - Advanced performance optimizations with WebGL acceleration option\n * - Adaptive quality scaling based on device capabilities\n * - Memory and battery-efficient rendering pipeline\n * - Accessibility compliance with reduced motion support\n * - Supports hardware acceleration and high-DPI displays\n * \n * @param {Object} props - Component props\n * @param {string|number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=5] - Z-index for the container\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.meteorDensity=15] - Number of meteors to maintain on screen\n * @param {number} [props.meteorMinSize=1] - Minimum size of meteors\n * @param {number} [props.meteorMaxSize=3] - Maximum size of meteors\n * @param {number} [props.meteorSpeed=0.08] - Base speed of meteors\n * @param {number} [props.trailLength=180] - Length of meteor trails\n * @param {number} [props.trailSegments=20] - Number of segments in each trail\n * @param {string} [props.coreColor='rgba(255, 255, 255, 1)'] - Core color for meteors\n * @param {string} [props.glowColor='rgba(255, 253, 227, 0.9)'] - Glow color for meteors\n * @param {string} [props.trailColor='rgba(191, 173, 127, 0.8)'] - Trail color for meteors\n * @param {boolean} [props.enableParallax=false] - Enable parallax effect on scroll\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of parallax effect\n * @param {boolean} [props.staggered=true] - Enable staggered meteor appearance\n * @param {number} [props.minStaggerDelay=200] - Minimum delay between meteor spawns (ms)\n * @param {number} [props.maxStaggerDelay=2000] - Maximum delay between meteor spawns (ms)\n * @param {number} [props.journeyCompletion=0.9] - When meteors complete their journey (0-1)\n * @param {string} [props.mode='arc'] - Animation mode: 'arc' or 'linear'\n * @param {string} [props.direction='both'] - Direction: 'left', 'right', 'both', or 'top'\n * @param {number} [props.baseAngle=30] - Base angle for linear meteors (degrees)\n * @param {number} [props.angleVariation=15] - Random variation to apply to the base angle\n * @param {boolean} [props.debug=false] - Enable debug visualization\n * @param {boolean} [props.adaptiveQuality=true] - Enable adaptive quality based on device\n * @param {boolean} [props.respectReducedMotion=true] - Respect reduced motion preferences\n * @param {number} [props.maxFPS=60] - Target maximum frames per second\n * @param {boolean} [props.useWebGL=false] - Use WebGL rendering for better performance\n * @param {boolean} [props.enableBursts=false] - Enable meteor burst effects\n * @param {boolean} [props.enableBattery=true] - Enable battery-saving optimizations\n * @param {string} [props.renderingMode='auto'] - Rendering mode: 'auto', '2d', or 'webgl'\n * @param {boolean} [props.enableOffscreenRendering=true] - Enable offscreen canvas when available\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MeteorShower = ({\n  height = '100vh',\n  zIndex = 5,\n  active = true,\n  meteorDensity = 15,\n  meteorMinSize = 1,\n  meteorMaxSize = 3,\n  meteorSpeed = 0.08,\n  trailLength = 180,\n  trailSegments = 20,\n  coreColor = 'rgba(255, 255, 255, 1)',\n  glowColor = 'rgba(255, 253, 227, 0.9)',\n  trailColor = 'rgba(191, 173, 127, 0.8)',\n  enableParallax = false,\n  parallaxIntensity = 0.2,\n  staggered = true,\n  minStaggerDelay = 200,\n  maxStaggerDelay = 2000,\n  journeyCompletion = 0.9,\n  mode = 'arc',\n  direction = 'both',\n  baseAngle = 30,\n  angleVariation = 15,\n  debug = false,\n  adaptiveQuality = true,\n  respectReducedMotion = true,\n  maxFPS = 60,\n  useWebGL = false,\n  enableBursts = false,\n  enableBattery = true,\n  renderingMode = 'auto',\n  enableOffscreenRendering = true\n}) => {\n  _s2();\n  var _s = $RefreshSig$();\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const ctxRef = useRef(null);\n  const webGLRef = useRef(null);\n  const offscreenCanvasRef = useRef(null);\n  const workerRef = useRef(null);\n  const meteorsRef = useRef([]);\n  const burstsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const fpsTimestampRef = useRef(0);\n  const frameCountRef = useRef(0);\n  const currentFpsRef = useRef(60);\n  const nextSpawnTimeRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n  const resizeObserverRef = useRef(null);\n  const visibilityObserverRef = useRef(null);\n  const batteryRef = useRef(null);\n  const visibilityChangeTimeRef = useRef(0);\n\n  // Component state\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0,\n    pixelRatio: 1\n  });\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [isVisible, setIsVisible] = useState(false);\n  const [qualityFactor, setQualityFactor] = useState(1);\n  const [actualRenderingMode, setActualRenderingMode] = useState('2d');\n  const [deviceCapabilities, setDeviceCapabilities] = useState({\n    memory: 4,\n    cores: 4,\n    batteryLevel: 1,\n    isMobile: false,\n    supportsWebGL: false,\n    supportsOffscreenCanvas: false\n  });\n\n  // Pre-allocate objects to avoid garbage collection during animation\n  const pointCache = useRef({\n    current: {\n      x: 0,\n      y: 0\n    },\n    segment: {\n      x: 0,\n      y: 0\n    }\n  }).current;\n\n  // Precomputed constants for bezier calculations\n  const bezierConstants = useRef({\n    controlPoints: [],\n    weights: []\n  }).current;\n\n  // Precompute color variants to avoid string operations during animation\n  const colorCacheRef = useRef(new Map());\n\n  // WebGL shader programs and buffers\n  const webGLProgramsRef = useRef({\n    meteor: null,\n    trail: null,\n    burst: null\n  });\n\n  // Object pools for efficient memory usage\n  const objectPoolsRef = useRef({\n    meteors: [],\n    bursts: [],\n    vectors: []\n  });\n\n  // Detects device capabilities and sets up optimization strategies\n  const detectCapabilities = useCallback(() => {\n    // Device memory, hardware concurrency, and battery\n    const memory = navigator.deviceMemory || 4;\n    const cores = navigator.hardwareConcurrency || 4;\n    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n\n    // Check WebGL support\n    let supportsWebGL = false;\n    try {\n      const canvas = document.createElement('canvas');\n      supportsWebGL = !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));\n    } catch (e) {\n      supportsWebGL = false;\n    }\n\n    // Check offscreen canvas support\n    const supportsOffscreenCanvas = typeof OffscreenCanvas !== 'undefined';\n\n    // Get battery info if available\n    if (navigator.getBattery && enableBattery) {\n      navigator.getBattery().then(battery => {\n        batteryRef.current = battery;\n        const updateBattery = () => {\n          setDeviceCapabilities(prev => ({\n            ...prev,\n            batteryLevel: battery.level,\n            isCharging: battery.charging\n          }));\n\n          // Reduce quality if on battery and below 30%\n          if (!battery.charging && battery.level < 0.3 && adaptiveQuality) {\n            setQualityFactor(prev => Math.min(prev, 0.6));\n          }\n        };\n\n        // Add battery event listeners\n        battery.addEventListener('levelchange', updateBattery);\n        battery.addEventListener('chargingchange', updateBattery);\n\n        // Initial update\n        updateBattery();\n      });\n    }\n\n    // Determine initial rendering mode\n    let initialRenderingMode = '2d';\n    if (renderingMode === 'auto') {\n      if (useWebGL && supportsWebGL) {\n        initialRenderingMode = 'webgl';\n      } else {\n        initialRenderingMode = '2d';\n      }\n    } else {\n      initialRenderingMode = renderingMode === 'webgl' && supportsWebGL ? 'webgl' : '2d';\n    }\n    setActualRenderingMode(initialRenderingMode);\n\n    // Set device capabilities state\n    setDeviceCapabilities({\n      memory,\n      cores,\n      batteryLevel: 1,\n      isCharging: true,\n      isMobile,\n      supportsWebGL,\n      supportsOffscreenCanvas\n    });\n\n    // Calculate quality factor based on capabilities\n    if (adaptiveQuality) {\n      // Base score from hardware\n      const performanceScore = memory * cores / (isMobile ? 2 : 1);\n\n      // Scale quality based on performance score\n      let quality = 1;\n      if (performanceScore > 16) {\n        quality = 1; // High-end devices\n      } else if (performanceScore > 8) {\n        quality = 0.8; // Mid-range devices\n      } else if (performanceScore > 4) {\n        quality = 0.6; // Low-end devices\n      } else {\n        quality = 0.4; // Very low-end devices\n      }\n      setQualityFactor(quality);\n    }\n  }, [useWebGL, renderingMode, adaptiveQuality, enableBattery]);\n\n  // Get cached color with opacity\n  const getCachedColor = useCallback((baseColor, opacity) => {\n    // Round opacity to reduce cache size while maintaining visual quality\n    const roundedOpacity = Math.round(opacity * 100) / 100;\n    const key = `${baseColor}-${roundedOpacity}`;\n    if (!colorCacheRef.current.has(key)) {\n      const newColor = baseColor.replace(/[\\d.]+\\)$/, roundedOpacity + ')');\n      colorCacheRef.current.set(key, newColor);\n    }\n    return colorCacheRef.current.get(key);\n  }, []);\n\n  // Adaptive settings based on quality factor\n  const adaptedSettings = useMemo(() => {\n    if (!adaptiveQuality || qualityFactor === 1) {\n      return {\n        meteorDensity,\n        trailSegments,\n        useShadow: true,\n        useGlow: true,\n        useHighQualityRendering: true\n      };\n    }\n\n    // Adjust quality-dependent parameters\n    return {\n      meteorDensity: Math.max(3, Math.floor(meteorDensity * qualityFactor)),\n      trailSegments: Math.max(5, Math.floor(trailSegments * qualityFactor)),\n      useShadow: qualityFactor > 0.5,\n      useGlow: qualityFactor > 0.3,\n      useHighQualityRendering: qualityFactor > 0.7\n    };\n  }, [adaptiveQuality, qualityFactor, meteorDensity, trailSegments]);\n\n  // Detect device capabilities and preferences on mount\n  useEffect(() => {\n    // Check for reduced motion preference\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    const handleReducedMotionChange = e => {\n      setPrefersReducedMotion(e.matches);\n    };\n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n\n    // Detect device capabilities\n    detectCapabilities();\n\n    // Setup visibility change detection to pause when tab is inactive\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        visibilityChangeTimeRef.current = performance.now();\n      } else {\n        // Adjust timing references after visibility changes\n        const timeDelta = performance.now() - visibilityChangeTimeRef.current;\n        lastTimestampRef.current += timeDelta;\n        nextSpawnTimeRef.current += timeDelta;\n      }\n    };\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n\n    // Capture current worker ref to avoid closure issues\n    const currentWorker = workerRef.current;\n\n    // Cleanup\n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n\n      // Clean up worker if active\n      if (currentWorker) {\n        currentWorker.terminate();\n      }\n    };\n  }, [detectCapabilities]);\n\n  // Initialize WebGL context and shaders if using WebGL\n  const initWebGL = useCallback(() => {\n    if (!canvasRef.current || actualRenderingMode !== 'webgl') return false;\n    try {\n      // Get WebGL context\n      const gl = canvasRef.current.getContext('webgl', {\n        alpha: true,\n        antialias: true,\n        premultipliedAlpha: false,\n        depth: false\n      });\n      if (!gl) return false;\n      webGLRef.current = gl;\n\n      // Create shader programs, vertex buffers, etc.\n      // This is a simplified placeholder - a real implementation would include\n      // proper shaders, attribute locations, and uniform setup\n\n      // Enable blending for transparency\n      gl.enable(gl.BLEND);\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n      // Set clear color to fully transparent\n      gl.clearColor(0.0, 0.0, 0.0, 0.0);\n\n      // Get current dimensions for viewport\n      const canvasWidth = canvasRef.current.width;\n      const canvasHeight = canvasRef.current.height;\n\n      // Set viewport\n      gl.viewport(0, 0, canvasWidth, canvasHeight);\n\n      // Simple vertex shader for meteor particles\n      const vertexShaderSource = `\n        attribute vec2 aPosition;\n        attribute float aSize;\n        attribute vec4 aColor;\n        \n        varying vec4 vColor;\n        \n        uniform vec2 uResolution;\n        \n        void main() {\n          // Convert to clip space\n          vec2 position = (aPosition / uResolution) * 2.0 - 1.0;\n          position.y = -position.y;\n          \n          gl_Position = vec4(position, 0, 1);\n          gl_PointSize = aSize;\n          vColor = aColor;\n        }\n      `;\n\n      // Simple fragment shader for meteor particles\n      const fragmentShaderSource = `\n        precision mediump float;\n        varying vec4 vColor;\n        \n        void main() {\n          // Calculate distance from center for circular point\n          float distance = length(gl_PointCoord - vec2(0.5, 0.5));\n          if (distance > 0.5) {\n            discard; // Outside circle\n          }\n          \n          // Softer edges\n          float alpha = smoothstep(0.5, 0.4, distance) * vColor.a;\n          gl_FragColor = vec4(vColor.rgb, alpha);\n        }\n      `;\n\n      // Compile shader program (simplified)\n      const createShader = (gl, type, source) => {\n        const shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        return shader;\n      };\n      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n      const program = gl.createProgram();\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n\n      // Store the program\n      webGLProgramsRef.current.meteor = {\n        program,\n        attributes: {\n          position: gl.getAttribLocation(program, 'aPosition'),\n          size: gl.getAttribLocation(program, 'aSize'),\n          color: gl.getAttribLocation(program, 'aColor')\n        },\n        uniforms: {\n          resolution: gl.getUniformLocation(program, 'uResolution')\n        }\n      };\n      return true;\n    } catch (error) {\n      console.error('WebGL initialization error:', error);\n      setActualRenderingMode('2d');\n      return false;\n    }\n  }, [actualRenderingMode]);\n\n  // Calculate path parameters for a meteor based on selected mode\n  const calculateMeteorPath = useCallback((width, height) => {\n    if (mode === 'arc') {\n      // Arc path logic with optimized parameters\n      const startX = Math.random() * width * 1.5 - width * 0.25;\n      const startY = Math.random() * -100 - 50;\n      const curveDirection = Math.random() > 0.5 ? 1 : -1;\n      const curveIntensity = Math.random() * 0.4 + 0.2;\n      const endX = startX + curveDirection * width * curveIntensity;\n      const endY = height * journeyCompletion;\n      const controlX = (startX + endX) / 2 + curveDirection * width * curveIntensity;\n      const controlY = (startY + endY) * 0.5;\n      return {\n        pathType: 'arc',\n        start: {\n          x: startX,\n          y: startY\n        },\n        control: {\n          x: controlX,\n          y: controlY\n        },\n        end: {\n          x: endX,\n          y: endY\n        }\n      };\n    } else if (mode === 'linear') {\n      // Linear path logic with enhanced direction control\n      let meteorDirection = direction;\n      if (direction === 'both') {\n        meteorDirection = Math.random() > 0.5 ? 'left' : 'right';\n      }\n      let angle;\n      if (direction === 'top') {\n        angle = (30 + (Math.random() * 2 - 1) * 5) * Math.PI / 180;\n      } else {\n        angle = (baseAngle + (Math.random() * 2 - 1) * angleVariation) * Math.PI / 180;\n      }\n      let startX;\n      if (meteorDirection === 'left') {\n        startX = Math.random() * (width * 0.3) - width * 0.1;\n      } else if (meteorDirection === 'right') {\n        startX = width - Math.random() * (width * 0.3) + width * 0.1;\n      } else if (direction === 'top') {\n        const position = Math.random();\n        if (position < 0.5) {\n          startX = Math.random() * (width * 0.35);\n        } else if (position < 0.85) {\n          startX = width * 0.35 + Math.random() * (width * 0.35);\n        } else {\n          startX = width * 0.7 + Math.random() * (width * 0.3);\n        }\n      }\n      const startY = Math.random() * -100 - 50;\n      const distanceToTravel = height * journeyCompletion / Math.cos(angle);\n      let endX, endY;\n      if (meteorDirection === 'left' || direction === 'top') {\n        endX = startX + distanceToTravel * Math.sin(angle);\n        endY = startY + distanceToTravel * Math.cos(angle);\n      } else {\n        endX = startX - distanceToTravel * Math.sin(angle);\n        endY = startY + distanceToTravel * Math.cos(angle);\n      }\n      return {\n        pathType: 'linear',\n        start: {\n          x: startX,\n          y: startY\n        },\n        end: {\n          x: endX,\n          y: endY\n        },\n        direction: meteorDirection\n      };\n    }\n  }, [mode, direction, baseAngle, angleVariation, journeyCompletion]);\n\n  // Get point along path with highly optimized calculations\n  const getPathPoint = useCallback((t, path, outPoint = {\n    x: 0,\n    y: 0\n  }) => {\n    if (path.pathType === 'arc') {\n      // Optimized quadratic bezier calculation using pre-computed terms\n      const invT = 1 - t;\n      const invTSquared = invT * invT;\n      const tSquared = t * t;\n      const term1 = invTSquared;\n      const term2 = 2 * invT * t;\n      const term3 = tSquared;\n      outPoint.x = term1 * path.start.x + term2 * path.control.x + term3 * path.end.x;\n      outPoint.y = term1 * path.start.y + term2 * path.control.y + term3 * path.end.y;\n    } else {\n      // Linear interpolation with minimal operations\n      outPoint.x = path.start.x + (path.end.x - path.start.x) * t;\n      outPoint.y = path.start.y + (path.end.y - path.start.y) * t;\n    }\n    return outPoint;\n  }, []);\n\n  // Calculate velocity at a point on the path (for trail orientation)\n  // Will be used in future implementations for advanced trail effects and particle systems\n  /* eslint-disable-next-line no-unused-vars */\n  const getPathVelocity = useCallback((t, path, outVelocity = {\n    x: 0,\n    y: 0\n  }) => {\n    if (path.pathType === 'arc') {\n      // Derivative of quadratic bezier\n      const term1 = 2 * (1 - t);\n      const term2 = 2 * t;\n      outVelocity.x = term1 * (path.control.x - path.start.x) + term2 * (path.end.x - path.control.x);\n      outVelocity.y = term1 * (path.control.y - path.start.y) + term2 * (path.end.y - path.control.y);\n    } else {\n      // Constant velocity for linear paths\n      outVelocity.x = path.end.x - path.start.x;\n      outVelocity.y = path.end.y - path.start.y;\n\n      // Normalize\n      const length = Math.sqrt(outVelocity.x * outVelocity.x + outVelocity.y * outVelocity.y);\n      if (length > 0) {\n        outVelocity.x /= length;\n        outVelocity.y /= length;\n      }\n    }\n    return outVelocity;\n  }, []);\n\n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current || !containerRef.current) return false;\n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    const rect = container.getBoundingClientRect();\n    const pixelRatio = window.devicePixelRatio || 1;\n\n    // Calculate dimensions\n    const displayWidth = rect.width;\n    const displayHeight = typeof height === 'string' && height.endsWith('vh') ? parseInt(height, 10) / 100 * window.innerHeight : parseInt(height, 10) || window.innerHeight;\n\n    // Set canvas size accounting for pixel ratio\n    canvas.width = displayWidth * pixelRatio;\n    canvas.height = displayHeight * pixelRatio;\n    canvas.style.width = `${displayWidth}px`;\n    canvas.style.height = `${displayHeight}px`;\n\n    // Get appropriate rendering context\n    if (actualRenderingMode === 'webgl') {\n      initWebGL();\n    } else {\n      // 2D Canvas context\n      const ctx = canvas.getContext('2d', {\n        alpha: true,\n        desynchronized: true,\n        willReadFrequently: false\n      });\n      if (!ctx) return false;\n\n      // Scale context for high-DPI displays\n      ctx.scale(pixelRatio, pixelRatio);\n\n      // Configure context for high-quality rendering\n      if (adaptedSettings.useHighQualityRendering) {\n        ctx.imageSmoothingEnabled = true;\n        ctx.imageSmoothingQuality = 'high';\n      }\n      ctxRef.current = ctx;\n    }\n\n    // Initialize offscreen canvas if supported and enabled\n    if (enableOffscreenRendering && typeof OffscreenCanvas !== 'undefined' && deviceCapabilities.supportsOffscreenCanvas) {\n      try {\n        // Create offscreen canvas\n        const offscreen = new OffscreenCanvas(displayWidth * pixelRatio, displayHeight * pixelRatio);\n\n        // Get 2D context for offscreen canvas\n        const offscreenCtx = offscreen.getContext('2d');\n        if (offscreenCtx) {\n          offscreenCtx.scale(pixelRatio, pixelRatio);\n          offscreenCanvasRef.current = {\n            canvas: offscreen,\n            ctx: offscreenCtx\n          };\n        }\n      } catch (error) {\n        console.warn('Offscreen canvas initialization error:', error);\n      }\n    }\n    setDimensions({\n      width: displayWidth,\n      height: displayHeight,\n      pixelRatio\n    });\n    return true;\n  }, [height, actualRenderingMode, initWebGL, enableOffscreenRendering, deviceCapabilities.supportsOffscreenCanvas, adaptedSettings.useHighQualityRendering]);\n\n  // Setup canvas resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Create a ResizeObserver to detect container size changes\n    const resizeObserver = new ResizeObserver(entries => {\n      // Debounce resize operations\n      if (resizeObserverRef.current.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n      resizeObserverRef.current.timeout = setTimeout(() => {\n        requestAnimationFrame(() => {\n          if (setupCanvas()) {\n            setIsInitialized(true);\n          }\n        });\n      }, 100); // 100ms debounce\n    });\n\n    // Capture current reference to avoid closure issues in cleanup\n    const currentContainer = containerRef.current;\n\n    // Start observing the container\n    resizeObserver.observe(currentContainer);\n    resizeObserverRef.current = {\n      observer: resizeObserver\n    };\n\n    // Initial setup\n    setupCanvas();\n    setIsInitialized(true);\n    return () => {\n      if (resizeObserverRef.current.observer) {\n        resizeObserverRef.current.observer.disconnect();\n      }\n      if (resizeObserverRef.current.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n    };\n  }, [setupCanvas]);\n\n  // Setup intersection observer to only animate when visible\n  useEffect(() => {\n    if (!containerRef.current) return;\n    const observer = new IntersectionObserver(entries => {\n      const isIntersecting = entries[0].isIntersecting;\n\n      // Only change state if visibility actually changed\n      if (isIntersecting !== isVisible) {\n        setIsVisible(isIntersecting);\n        if (isIntersecting) {\n          // Reset timing references when becoming visible again\n          lastTimestampRef.current = 0;\n          nextSpawnTimeRef.current = performance.now();\n        }\n      }\n    }, {\n      threshold: 0.01,\n      rootMargin: '100px'\n    });\n\n    // Store current reference to avoid closure issues\n    const currentContainerRef = containerRef.current;\n    observer.observe(currentContainerRef);\n    visibilityObserverRef.current = observer;\n    return () => {\n      if (visibilityObserverRef.current) {\n        visibilityObserverRef.current.disconnect();\n      }\n    };\n  }, [isVisible]);\n\n  // Handle parallax effect on scroll if enabled\n  useEffect(() => {\n    if (!enableParallax) return;\n\n    // Use passive event listener for better performance\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    window.addEventListener('scroll', handleScroll, {\n      passive: true\n    });\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [enableParallax]);\n\n  // Get a meteor from the object pool or create a new one\n  const getMeteor = useCallback(() => {\n    // Try to get from pool first\n    const pool = objectPoolsRef.current.meteors;\n    let meteor;\n    if (pool.length > 0) {\n      meteor = pool.pop();\n      // Reset meteor properties\n      meteor.progress = 0;\n      meteor.active = true;\n    } else {\n      // Create new if pool is empty\n      meteor = {\n        progress: 0,\n        active: true,\n        positions: Array(adaptedSettings.trailSegments)\n      };\n\n      // Pre-allocate position objects\n      for (let i = 0; i < adaptedSettings.trailSegments; i++) {\n        meteor.positions[i] = {\n          x: 0,\n          y: 0\n        };\n      }\n    }\n    return meteor;\n  }, [adaptedSettings.trailSegments]);\n\n  // Initialize a meteor with all required properties\n  const initializeMeteor = useCallback(() => {\n    const {\n      width,\n      height\n    } = dimensions;\n    if (!width || !height) return null;\n\n    // Get meteor from pool\n    const meteor = getMeteor();\n\n    // Calculate path based on mode\n    const path = calculateMeteorPath(width, height);\n\n    // Set path and initial position\n    meteor.path = path;\n    for (let i = 0; i < meteor.positions.length; i++) {\n      meteor.positions[i].x = path.start.x;\n      meteor.positions[i].y = path.start.y;\n    }\n\n    // Set meteor properties\n    meteor.size = Math.random() * (meteorMaxSize - meteorMinSize) + meteorMinSize;\n    meteor.speed = meteorSpeed * (Math.random() * 0.5 + 0.75);\n    meteor.opacity = Math.random() * 0.3 + 0.7;\n    meteor.fadeThreshold = 0.7 + Math.random() * 0.2;\n    meteor.pulsePhase = Math.random() * Math.PI * 2;\n    meteor.pulseSpeed = Math.random() * 0.01 + 0.005;\n\n    // Add burst properties if enabled\n    if (enableBursts && Math.random() < 0.3) {\n      // 30% chance of meteor having burst\n      meteor.hasBurst = true;\n      meteor.burstThreshold = 0.9 + Math.random() * 0.08; // Trigger near the end\n      meteor.burstTriggered = false;\n      meteor.burstSize = meteor.size * (2 + Math.random() * 3);\n      meteor.burstParticles = 5 + Math.floor(Math.random() * 8);\n    } else {\n      meteor.hasBurst = false;\n    }\n    return meteor;\n  }, [dimensions, calculateMeteorPath, meteorMinSize, meteorMaxSize, meteorSpeed, enableBursts, getMeteor]);\n\n  // Create a burst effect at a specified position\n  const createBurst = useCallback((x, y, size, color, particleCount) => {\n    // Skip if bursts are not enabled\n    if (!enableBursts) return;\n\n    // Create particles in a circular pattern\n    for (let i = 0; i < particleCount; i++) {\n      const angle = i / particleCount * Math.PI * 2;\n      const speed = 0.5 + Math.random() * 1.5;\n      const burst = {\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        size: size * (0.3 + Math.random() * 0.4),\n        life: 1.0,\n        decay: 0.01 + Math.random() * 0.03,\n        color\n      };\n      burstsRef.current.push(burst);\n    }\n  }, [enableBursts]);\n\n  // FPS limiter for consistent animation speed\n  const fpsLimiter = useCallback((timestamp, callback) => {\n    // Skip animation if hidden, inactive, or reduced motion\n    if (!isVisible || !active || respectReducedMotion && prefersReducedMotion || document.hidden) {\n      animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n      return;\n    }\n    const targetFrameTime = 1000 / maxFPS;\n    const elapsed = timestamp - lastTimestampRef.current;\n    if (elapsed >= targetFrameTime || lastTimestampRef.current === 0) {\n      // Calculate correct delta\n      const delta = lastTimestampRef.current === 0 ? 16 : elapsed;\n\n      // Update timestamp, limiting delta to avoid jumps after inactivity\n      lastTimestampRef.current = timestamp - elapsed % targetFrameTime;\n\n      // Run animation callback with capped delta time\n      callback(Math.min(delta, 50));\n\n      // FPS tracking for debug and adaptive quality\n      frameCountRef.current++;\n      if (timestamp - fpsTimestampRef.current >= 1000) {\n        currentFpsRef.current = frameCountRef.current;\n        frameCountRef.current = 0;\n        fpsTimestampRef.current = timestamp;\n\n        // Log FPS in debug mode\n        if (debug) {\n          console.log(`MeteorShower FPS: ${currentFpsRef.current}, Quality: ${qualityFactor.toFixed(2)}`);\n        }\n\n        // Dynamic quality adjustment based on performance\n        if (adaptiveQuality && currentFpsRef.current < maxFPS * 0.7) {\n          // If FPS is below 70% of target, reduce quality\n          setQualityFactor(prev => Math.max(0.4, prev * 0.9));\n        } else if (adaptiveQuality && currentFpsRef.current >= maxFPS * 0.95 && qualityFactor < 1) {\n          // If FPS is near target and quality is reduced, gradually increase\n          setQualityFactor(prev => Math.min(1, prev * 1.05));\n        }\n      }\n    }\n\n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n  }, [isVisible, active, respectReducedMotion, prefersReducedMotion, maxFPS, debug, adaptiveQuality, qualityFactor]);\n\n  // 2D Canvas rendering method for meteors\n  const renderMeteors2D = useCallback((ctx, parallaxOffset, timestamp) => {\n    // Process and render each meteor\n    meteorsRef.current.forEach(meteor => {\n      // Calculate opacity based on progress\n      let currentOpacity = meteor.opacity;\n      if (meteor.progress > meteor.fadeThreshold) {\n        const fadeProgress = (meteor.progress - meteor.fadeThreshold) / (1 - meteor.fadeThreshold);\n        currentOpacity = meteor.opacity * (1 - fadeProgress);\n      }\n\n      // Apply pulse effect\n      const timeFactor = timestamp * 0.001;\n      const pulseEffect = Math.sin(timeFactor * meteor.pulseSpeed + meteor.pulsePhase) * 0.2 + 0.8;\n\n      // Parallax offset adjustment\n      const adjustY = enableParallax ? parallaxOffset * (meteor.size / meteorMaxSize) : 0;\n\n      // Check if we should create a burst effect\n      if (meteor.hasBurst && !meteor.burstTriggered && meteor.progress >= meteor.burstThreshold) {\n        meteor.burstTriggered = true;\n        const burstPosition = meteor.positions[0];\n        createBurst(burstPosition.x, burstPosition.y + adjustY, meteor.burstSize, glowColor, meteor.burstParticles);\n      }\n\n      // Optimized rendering approach\n      if (adaptedSettings.useHighQualityRendering) {\n        // High-quality rendering with shadows\n        // Set shadow for glow effect if enabled\n        if (adaptedSettings.useGlow) {\n          ctx.shadowColor = glowColor;\n          ctx.shadowBlur = meteor.size * 3 * pulseEffect;\n        }\n\n        // Draw trail segments\n        ctx.lineCap = 'round';\n        for (let i = meteor.positions.length - 2; i >= 0; i--) {\n          const pos1 = meteor.positions[i];\n          const pos2 = meteor.positions[i + 1];\n          if (!pos1 || !pos2) continue;\n\n          // Calculate segment opacity (decreases along the trail)\n          const segmentOpacity = currentOpacity * (1 - i / meteor.positions.length) * pulseEffect;\n\n          // Skip if nearly invisible\n          if (segmentOpacity < 0.02) continue;\n\n          // Calculate segment width (decreases along the trail)\n          const segmentWidth = meteor.size * (1 - i / meteor.positions.length * 0.7);\n\n          // Draw line segment\n          ctx.beginPath();\n          ctx.moveTo(pos1.x, pos1.y + adjustY);\n          ctx.lineTo(pos2.x, pos2.y + adjustY);\n\n          // Set line style\n          ctx.lineWidth = segmentWidth;\n          ctx.strokeStyle = getCachedColor(trailColor, segmentOpacity);\n          ctx.stroke();\n        }\n\n        // Draw meteor head\n        if (meteor.positions[0]) {\n          const headPos = meteor.positions[0];\n\n          // Set shadow for head\n          if (adaptedSettings.useShadow) {\n            ctx.shadowColor = glowColor;\n            ctx.shadowBlur = meteor.size * 5 * pulseEffect;\n          }\n\n          // Draw outer glow\n          ctx.beginPath();\n          ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 1.5, 0, Math.PI * 2);\n          ctx.fillStyle = getCachedColor(glowColor, currentOpacity * 0.7 * pulseEffect);\n          ctx.fill();\n\n          // Draw inner core\n          ctx.beginPath();\n          ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 0.7, 0, Math.PI * 2);\n          ctx.fillStyle = getCachedColor(coreColor, currentOpacity * pulseEffect);\n          ctx.fill();\n        }\n      } else {\n        // Performance-optimized rendering for lower-end devices\n        // Draw simplified trail\n        ctx.beginPath();\n        const headPos = meteor.positions[0];\n        if (!headPos) return;\n        ctx.moveTo(headPos.x, headPos.y + adjustY);\n        for (let i = 1; i < meteor.positions.length; i += 2) {\n          const pos = meteor.positions[i];\n          if (!pos) continue;\n          ctx.lineTo(pos.x, pos.y + adjustY);\n        }\n\n        // Gradient trail\n        const gradient = ctx.createLinearGradient(headPos.x, headPos.y + adjustY, meteor.positions[meteor.positions.length - 1].x, meteor.positions[meteor.positions.length - 1].y + adjustY);\n        gradient.addColorStop(0, getCachedColor(coreColor, currentOpacity * pulseEffect));\n        gradient.addColorStop(0.3, getCachedColor(glowColor, currentOpacity * 0.7 * pulseEffect));\n        gradient.addColorStop(1, getCachedColor(trailColor, 0));\n        ctx.strokeStyle = gradient;\n        ctx.lineWidth = meteor.size;\n        ctx.lineCap = 'round';\n        ctx.stroke();\n\n        // Simple head\n        ctx.beginPath();\n        ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 0.7, 0, Math.PI * 2);\n        ctx.fillStyle = getCachedColor(coreColor, currentOpacity * pulseEffect);\n        ctx.fill();\n      }\n    });\n  }, [adaptedSettings.useHighQualityRendering, adaptedSettings.useGlow, adaptedSettings.useShadow, enableParallax, meteorMaxSize, glowColor, trailColor, coreColor, getCachedColor, createBurst]);\n\n  // WebGL rendering method\n  const renderMeteorsWebGL = _s(useCallback(_s((gl, timestamp) => {\n    _s();\n    // This is a simplified placeholder for WebGL rendering\n    // A full implementation would use the shaders and buffers set up earlier\n\n    if (!gl || !webGLProgramsRef.current.meteor) return;\n\n    // Clear canvas\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    // Use meteor shader program\n    const meteorProgram = webGLProgramsRef.current.meteor;\n    gl.useProgram(meteorProgram.program);\n\n    // Set uniforms\n    gl.uniform2f(meteorProgram.uniforms.resolution, canvasRef.current.width, canvasRef.current.height);\n\n    // This is where we would bind vertex buffers and render particles\n    // For a real implementation, you would:\n    // 1. Update vertex buffer with current meteor positions\n    // 2. Set attributes for position, size, color\n    // 3. Draw using gl.POINTS or other appropriate primitives\n  }, \"ZdQBZ3rq7bWAAMQq6hlVCmYF0jM=\", false, function () {\n    return [gl.useProgram];\n  }), []), \"ZdQBZ3rq7bWAAMQq6hlVCmYF0jM=\", true);\n\n  // Render burst particles\n  const renderBursts = useCallback((ctx, deltaTime) => {\n    if (!enableBursts || burstsRef.current.length === 0) return;\n\n    // Process and render each burst particle\n    for (let i = burstsRef.current.length - 1; i >= 0; i--) {\n      const burst = burstsRef.current[i];\n\n      // Update position\n      burst.x += burst.vx;\n      burst.y += burst.vy;\n\n      // Apply gravity\n      burst.vy += 0.05;\n\n      // Reduce life\n      burst.life -= burst.decay * (deltaTime / 16);\n\n      // Remove if dead\n      if (burst.life <= 0) {\n        burstsRef.current.splice(i, 1);\n        continue;\n      }\n\n      // Draw particle\n      ctx.beginPath();\n      ctx.arc(burst.x, burst.y, burst.size * burst.life, 0, Math.PI * 2);\n      ctx.fillStyle = getCachedColor(burst.color, burst.life * 0.7);\n      ctx.fill();\n    }\n  }, [enableBursts, getCachedColor]);\n\n  // Update meteor positions\n  const updateMeteors = useCallback(deltaTime => {\n    const {\n      width,\n      height\n    } = dimensions;\n\n    // Process meteors\n    for (let i = meteorsRef.current.length - 1; i >= 0; i--) {\n      const meteor = meteorsRef.current[i];\n\n      // Update progress based on speed and delta time\n      meteor.progress += meteor.speed * (deltaTime / 1000);\n\n      // Check if meteor has completed its path\n      if (meteor.progress >= 1) {\n        // Return to object pool\n        meteor.active = false;\n        objectPoolsRef.current.meteors.push(meteor);\n        meteorsRef.current.splice(i, 1);\n        continue;\n      }\n\n      // Calculate current position along the path\n      const currentPos = getPathPoint(Math.min(1, meteor.progress), meteor.path, pointCache.current);\n\n      // Update position history (for trail) using optimized array management\n      // Shift positions array - this is more efficient than splice/unshift for small arrays\n      for (let j = meteor.positions.length - 1; j > 0; j--) {\n        const current = meteor.positions[j];\n        const prev = meteor.positions[j - 1];\n        current.x = prev.x;\n        current.y = prev.y;\n      }\n\n      // Update head position\n      meteor.positions[0].x = currentPos.x;\n      meteor.positions[0].y = currentPos.y;\n    }\n\n    // Spawn new meteors if needed\n    const now = performance.now();\n    const spawnNeeded = meteorsRef.current.length < adaptedSettings.meteorDensity;\n    const canSpawnNow = !staggered || now >= nextSpawnTimeRef.current;\n    if (spawnNeeded && canSpawnNow) {\n      const newMeteor = initializeMeteor();\n      if (newMeteor) {\n        meteorsRef.current.push(newMeteor);\n\n        // Set next spawn time if staggering is enabled\n        if (staggered) {\n          const delay = Math.random() * (maxStaggerDelay - minStaggerDelay) + minStaggerDelay;\n          nextSpawnTimeRef.current = now + delay;\n        }\n      }\n    }\n  }, [dimensions, adaptedSettings.meteorDensity, staggered, minStaggerDelay, maxStaggerDelay, initializeMeteor, getPathPoint, pointCache]);\n\n  // Main animation handler\n  const handleAnimation = useCallback(deltaTime => {\n    // Skip if component is not ready\n    if (!canvasRef.current || !isInitialized) return;\n    const now = performance.now();\n\n    // Calculate parallax offset if enabled\n    let parallaxOffset = 0;\n    if (enableParallax) {\n      parallaxOffset = scrollPositionRef.current * parallaxIntensity;\n    }\n\n    // Update meteor positions\n    updateMeteors(deltaTime);\n\n    // Render based on selected mode\n    if (actualRenderingMode === 'webgl' && webGLRef.current) {\n      // WebGL rendering path\n      renderMeteorsWebGL(webGLRef.current, now);\n    } else {\n      // Canvas 2D rendering path\n      const ctx = ctxRef.current;\n      if (!ctx) return;\n\n      // Clear canvas with optimized clear (only clear used area)\n      ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n\n      // Render meteors\n      renderMeteors2D(ctx, parallaxOffset, now);\n\n      // Render burst particles\n      if (enableBursts) {\n        renderBursts(ctx, deltaTime);\n      }\n\n      // Debug visualization\n      if (debug) {\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n        ctx.font = '12px monospace';\n        ctx.fillText(`FPS: ${currentFpsRef.current}`, 10, 20);\n        ctx.fillText(`Meteors: ${meteorsRef.current.length}/${adaptedSettings.meteorDensity}`, 10, 40);\n        ctx.fillText(`Quality: ${qualityFactor.toFixed(2)}`, 10, 60);\n        ctx.fillText(`Rendering: ${actualRenderingMode}`, 10, 80);\n        if (enableBursts) {\n          ctx.fillText(`Bursts: ${burstsRef.current.length}`, 10, 100);\n        }\n      }\n    }\n  }, [isInitialized, dimensions, adaptedSettings.meteorDensity, enableParallax, parallaxIntensity, actualRenderingMode, debug, updateMeteors, renderMeteors2D, renderMeteorsWebGL, enableBursts, renderBursts, qualityFactor]);\n\n  // Main animation loop\n  useEffect(() => {\n    if (!active || !isInitialized || !dimensions.width || !dimensions.height) {\n      return;\n    }\n\n    // Start animation with FPS limiter\n    fpsTimestampRef.current = performance.now();\n    frameCountRef.current = 0;\n    lastTimestampRef.current = 0;\n    animationFrameRef.current = requestAnimationFrame(timestamp => {\n      fpsLimiter(timestamp, handleAnimation);\n    });\n\n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [active, isInitialized, dimensions, fpsLimiter, handleAnimation]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: height,\n      overflow: 'hidden',\n      pointerEvents: 'none',\n      zIndex: zIndex,\n      // Hardware acceleration\n      backfaceVisibility: 'hidden',\n      transform: 'translateZ(0)',\n      willChange: 'transform'\n    },\n    \"aria-hidden\": \"true\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        // Additional rendering optimizations\n        imageRendering: 'high-quality',\n        // Hardware acceleration\n        backfaceVisibility: 'hidden',\n        transform: 'translateZ(0)',\n        willChange: 'transform',\n        // Ensures proper subpixel rendering\n        filter: 'none'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1270,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1252,\n    columnNumber: 5\n  }, this);\n};\n\n/**\n * GoldenMeteorShower Component\n * \n * A preset version of the MeteorShower with a golden/amber color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_s2(MeteorShower, \"OhYmt5nNwJaFE7LXxwRu6cxqw1M=\");\n_c = MeteorShower;\nexport const GoldenMeteorShower = props => {\n  const goldenPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 253, 227, 0.9)',\n    trailColor: 'rgba(191, 173, 127, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 200,\n    maxStaggerDelay: 2000\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...goldenPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1315,\n    columnNumber: 10\n  }, this);\n};\n\n/**\n * CelestialMeteorShower Component\n * \n * A preset version of the MeteorShower with a bluish-purple color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c2 = GoldenMeteorShower;\nexport const CelestialMeteorShower = props => {\n  const celestialPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(220, 225, 255, 0.9)',\n    trailColor: 'rgba(150, 160, 255, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 300,\n    maxStaggerDelay: 1800\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...celestialPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1341,\n    columnNumber: 10\n  }, this);\n};\n\n/**\n * RubyMeteorShower Component\n * \n * A preset version of the MeteorShower with a red color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c3 = CelestialMeteorShower;\nexport const RubyMeteorShower = props => {\n  const rubyPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 200, 200, 0.9)',\n    trailColor: 'rgba(220, 100, 100, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 350,\n    maxStaggerDelay: 2200\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...rubyPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1367,\n    columnNumber: 10\n  }, this);\n};\n\n/**\n * TopMeteorShower Component\n * \n * A preset version of the MeteorShower with meteors falling from the top of the screen\n * at a consistent 30-degree angle, distributed with emphasis on left and center areas.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c4 = RubyMeteorShower;\nexport const TopMeteorShower = props => {\n  const topPreset = {\n    mode: 'linear',\n    direction: 'top',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.12,\n    trailLength: 200,\n    trailSegments: 25,\n    journeyCompletion: 0.95,\n    staggered: true,\n    minStaggerDelay: 100,\n    maxStaggerDelay: 1000\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...topPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1393,\n    columnNumber: 10\n  }, this);\n};\n_c5 = TopMeteorShower;\nexport default MeteorShower;\nvar _c, _c2, _c3, _c4, _c5;\n$RefreshReg$(_c, \"MeteorShower\");\n$RefreshReg$(_c2, \"GoldenMeteorShower\");\n$RefreshReg$(_c3, \"CelestialMeteorShower\");\n$RefreshReg$(_c4, \"RubyMeteorShower\");\n$RefreshReg$(_c5, \"TopMeteorShower\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useCallback","useMemo","jsxDEV","_jsxDEV","MeteorShower","height","zIndex","active","meteorDensity","meteorMinSize","meteorMaxSize","meteorSpeed","trailLength","trailSegments","coreColor","glowColor","trailColor","enableParallax","parallaxIntensity","staggered","minStaggerDelay","maxStaggerDelay","journeyCompletion","mode","direction","baseAngle","angleVariation","debug","adaptiveQuality","respectReducedMotion","maxFPS","useWebGL","enableBursts","enableBattery","renderingMode","enableOffscreenRendering","_s2","_s","$RefreshSig$","containerRef","canvasRef","ctxRef","webGLRef","offscreenCanvasRef","workerRef","meteorsRef","burstsRef","animationFrameRef","lastTimestampRef","fpsTimestampRef","frameCountRef","currentFpsRef","nextSpawnTimeRef","scrollPositionRef","resizeObserverRef","visibilityObserverRef","batteryRef","visibilityChangeTimeRef","dimensions","setDimensions","width","pixelRatio","isInitialized","setIsInitialized","prefersReducedMotion","setPrefersReducedMotion","isVisible","setIsVisible","qualityFactor","setQualityFactor","actualRenderingMode","setActualRenderingMode","deviceCapabilities","setDeviceCapabilities","memory","cores","batteryLevel","isMobile","supportsWebGL","supportsOffscreenCanvas","pointCache","current","x","y","segment","bezierConstants","controlPoints","weights","colorCacheRef","Map","webGLProgramsRef","meteor","trail","burst","objectPoolsRef","meteors","bursts","vectors","detectCapabilities","navigator","deviceMemory","hardwareConcurrency","test","userAgent","canvas","document","createElement","window","WebGLRenderingContext","getContext","e","OffscreenCanvas","getBattery","then","battery","updateBattery","prev","level","isCharging","charging","Math","min","addEventListener","initialRenderingMode","performanceScore","quality","getCachedColor","baseColor","opacity","roundedOpacity","round","key","has","newColor","replace","set","get","adaptedSettings","useShadow","useGlow","useHighQualityRendering","max","floor","reducedMotionQuery","matchMedia","matches","handleReducedMotionChange","handleVisibilityChange","hidden","performance","now","timeDelta","currentWorker","removeEventListener","terminate","initWebGL","gl","alpha","antialias","premultipliedAlpha","depth","enable","BLEND","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","clearColor","canvasWidth","canvasHeight","viewport","vertexShaderSource","fragmentShaderSource","createShader","type","source","shader","shaderSource","compileShader","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","program","createProgram","attachShader","linkProgram","attributes","position","getAttribLocation","size","color","uniforms","resolution","getUniformLocation","error","console","calculateMeteorPath","startX","random","startY","curveDirection","curveIntensity","endX","endY","controlX","controlY","pathType","start","control","end","meteorDirection","angle","PI","distanceToTravel","cos","sin","getPathPoint","t","path","outPoint","invT","invTSquared","tSquared","term1","term2","term3","getPathVelocity","outVelocity","length","sqrt","setupCanvas","container","rect","getBoundingClientRect","devicePixelRatio","displayWidth","displayHeight","endsWith","parseInt","innerHeight","style","ctx","desynchronized","willReadFrequently","scale","imageSmoothingEnabled","imageSmoothingQuality","offscreen","offscreenCtx","warn","resizeObserver","ResizeObserver","entries","timeout","clearTimeout","setTimeout","requestAnimationFrame","currentContainer","observe","observer","disconnect","IntersectionObserver","isIntersecting","threshold","rootMargin","currentContainerRef","handleScroll","scrollY","passive","getMeteor","pool","pop","progress","positions","Array","i","initializeMeteor","speed","fadeThreshold","pulsePhase","pulseSpeed","hasBurst","burstThreshold","burstTriggered","burstSize","burstParticles","createBurst","particleCount","vx","vy","life","decay","push","fpsLimiter","timestamp","callback","time","targetFrameTime","elapsed","delta","log","toFixed","renderMeteors2D","parallaxOffset","forEach","currentOpacity","fadeProgress","timeFactor","pulseEffect","adjustY","burstPosition","shadowColor","shadowBlur","lineCap","pos1","pos2","segmentOpacity","segmentWidth","beginPath","moveTo","lineTo","lineWidth","strokeStyle","stroke","headPos","arc","fillStyle","fill","pos","gradient","createLinearGradient","addColorStop","renderMeteorsWebGL","clear","COLOR_BUFFER_BIT","meteorProgram","useProgram","uniform2f","renderBursts","deltaTime","splice","updateMeteors","currentPos","j","spawnNeeded","canSpawnNow","newMeteor","delay","handleAnimation","clearRect","font","fillText","cancelAnimationFrame","ref","top","left","overflow","pointerEvents","backfaceVisibility","transform","willChange","children","imageRendering","filter","fileName","_jsxFileName","lineNumber","columnNumber","_c","GoldenMeteorShower","props","goldenPreset","_c2","CelestialMeteorShower","celestialPreset","_c3","RubyMeteorShower","rubyPreset","_c4","TopMeteorShower","topPreset","_c5","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/MeteorShower.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';\n\n/**\n * MeteorShower Component - Enterprise Performance Optimized Version\n * \n * Creates a highly performant animated meteor shower effect where meteors\n * arc across the sky with comet-like trails and fade away naturally.\n * \n * Features:\n * - Advanced performance optimizations with WebGL acceleration option\n * - Adaptive quality scaling based on device capabilities\n * - Memory and battery-efficient rendering pipeline\n * - Accessibility compliance with reduced motion support\n * - Supports hardware acceleration and high-DPI displays\n * \n * @param {Object} props - Component props\n * @param {string|number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=5] - Z-index for the container\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.meteorDensity=15] - Number of meteors to maintain on screen\n * @param {number} [props.meteorMinSize=1] - Minimum size of meteors\n * @param {number} [props.meteorMaxSize=3] - Maximum size of meteors\n * @param {number} [props.meteorSpeed=0.08] - Base speed of meteors\n * @param {number} [props.trailLength=180] - Length of meteor trails\n * @param {number} [props.trailSegments=20] - Number of segments in each trail\n * @param {string} [props.coreColor='rgba(255, 255, 255, 1)'] - Core color for meteors\n * @param {string} [props.glowColor='rgba(255, 253, 227, 0.9)'] - Glow color for meteors\n * @param {string} [props.trailColor='rgba(191, 173, 127, 0.8)'] - Trail color for meteors\n * @param {boolean} [props.enableParallax=false] - Enable parallax effect on scroll\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of parallax effect\n * @param {boolean} [props.staggered=true] - Enable staggered meteor appearance\n * @param {number} [props.minStaggerDelay=200] - Minimum delay between meteor spawns (ms)\n * @param {number} [props.maxStaggerDelay=2000] - Maximum delay between meteor spawns (ms)\n * @param {number} [props.journeyCompletion=0.9] - When meteors complete their journey (0-1)\n * @param {string} [props.mode='arc'] - Animation mode: 'arc' or 'linear'\n * @param {string} [props.direction='both'] - Direction: 'left', 'right', 'both', or 'top'\n * @param {number} [props.baseAngle=30] - Base angle for linear meteors (degrees)\n * @param {number} [props.angleVariation=15] - Random variation to apply to the base angle\n * @param {boolean} [props.debug=false] - Enable debug visualization\n * @param {boolean} [props.adaptiveQuality=true] - Enable adaptive quality based on device\n * @param {boolean} [props.respectReducedMotion=true] - Respect reduced motion preferences\n * @param {number} [props.maxFPS=60] - Target maximum frames per second\n * @param {boolean} [props.useWebGL=false] - Use WebGL rendering for better performance\n * @param {boolean} [props.enableBursts=false] - Enable meteor burst effects\n * @param {boolean} [props.enableBattery=true] - Enable battery-saving optimizations\n * @param {string} [props.renderingMode='auto'] - Rendering mode: 'auto', '2d', or 'webgl'\n * @param {boolean} [props.enableOffscreenRendering=true] - Enable offscreen canvas when available\n */\nconst MeteorShower = ({\n  height = '100vh',\n  zIndex = 5,\n  active = true,\n  meteorDensity = 15,\n  meteorMinSize = 1,\n  meteorMaxSize = 3,\n  meteorSpeed = 0.08,\n  trailLength = 180,\n  trailSegments = 20,\n  coreColor = 'rgba(255, 255, 255, 1)',\n  glowColor = 'rgba(255, 253, 227, 0.9)',\n  trailColor = 'rgba(191, 173, 127, 0.8)',\n  enableParallax = false,\n  parallaxIntensity = 0.2,\n  staggered = true,\n  minStaggerDelay = 200,\n  maxStaggerDelay = 2000,\n  journeyCompletion = 0.9,\n  mode = 'arc',\n  direction = 'both',\n  baseAngle = 30,\n  angleVariation = 15,\n  debug = false,\n  adaptiveQuality = true,\n  respectReducedMotion = true,\n  maxFPS = 60,\n  useWebGL = false,\n  enableBursts = false,\n  enableBattery = true,\n  renderingMode = 'auto',\n  enableOffscreenRendering = true\n}) => {\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const ctxRef = useRef(null);\n  const webGLRef = useRef(null);\n  const offscreenCanvasRef = useRef(null);\n  const workerRef = useRef(null);\n  const meteorsRef = useRef([]);\n  const burstsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const fpsTimestampRef = useRef(0);\n  const frameCountRef = useRef(0);\n  const currentFpsRef = useRef(60);\n  const nextSpawnTimeRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n  const resizeObserverRef = useRef(null);\n  const visibilityObserverRef = useRef(null);\n  const batteryRef = useRef(null);\n  const visibilityChangeTimeRef = useRef(0);\n  \n  // Component state\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0, pixelRatio: 1 });\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [isVisible, setIsVisible] = useState(false);\n  const [qualityFactor, setQualityFactor] = useState(1);\n  const [actualRenderingMode, setActualRenderingMode] = useState('2d');\n  const [deviceCapabilities, setDeviceCapabilities] = useState({\n    memory: 4,\n    cores: 4,\n    batteryLevel: 1,\n    isMobile: false,\n    supportsWebGL: false,\n    supportsOffscreenCanvas: false\n  });\n  \n  // Pre-allocate objects to avoid garbage collection during animation\n  const pointCache = useRef({\n    current: { x: 0, y: 0 },\n    segment: { x: 0, y: 0 }\n  }).current;\n  \n  // Precomputed constants for bezier calculations\n  const bezierConstants = useRef({\n    controlPoints: [],\n    weights: []\n  }).current;\n  \n  // Precompute color variants to avoid string operations during animation\n  const colorCacheRef = useRef(new Map());\n  \n  // WebGL shader programs and buffers\n  const webGLProgramsRef = useRef({\n    meteor: null,\n    trail: null,\n    burst: null\n  });\n  \n  // Object pools for efficient memory usage\n  const objectPoolsRef = useRef({\n    meteors: [],\n    bursts: [],\n    vectors: []\n  });\n  \n  // Detects device capabilities and sets up optimization strategies\n  const detectCapabilities = useCallback(() => {\n    // Device memory, hardware concurrency, and battery\n    const memory = navigator.deviceMemory || 4;\n    const cores = navigator.hardwareConcurrency || 4;\n    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n    \n    // Check WebGL support\n    let supportsWebGL = false;\n    try {\n      const canvas = document.createElement('canvas');\n      supportsWebGL = !!(window.WebGLRenderingContext && \n        (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));\n    } catch (e) {\n      supportsWebGL = false;\n    }\n    \n    // Check offscreen canvas support\n    const supportsOffscreenCanvas = typeof OffscreenCanvas !== 'undefined';\n    \n    // Get battery info if available\n    if (navigator.getBattery && enableBattery) {\n      navigator.getBattery().then(battery => {\n        batteryRef.current = battery;\n        \n        const updateBattery = () => {\n          setDeviceCapabilities(prev => ({\n            ...prev,\n            batteryLevel: battery.level,\n            isCharging: battery.charging\n          }));\n          \n          // Reduce quality if on battery and below 30%\n          if (!battery.charging && battery.level < 0.3 && adaptiveQuality) {\n            setQualityFactor(prev => Math.min(prev, 0.6));\n          }\n        };\n        \n        // Add battery event listeners\n        battery.addEventListener('levelchange', updateBattery);\n        battery.addEventListener('chargingchange', updateBattery);\n        \n        // Initial update\n        updateBattery();\n      });\n    }\n    \n    // Determine initial rendering mode\n    let initialRenderingMode = '2d';\n    if (renderingMode === 'auto') {\n      if (useWebGL && supportsWebGL) {\n        initialRenderingMode = 'webgl';\n      } else {\n        initialRenderingMode = '2d';\n      }\n    } else {\n      initialRenderingMode = renderingMode === 'webgl' && supportsWebGL ? 'webgl' : '2d';\n    }\n    \n    setActualRenderingMode(initialRenderingMode);\n    \n    // Set device capabilities state\n    setDeviceCapabilities({\n      memory,\n      cores,\n      batteryLevel: 1,\n      isCharging: true,\n      isMobile,\n      supportsWebGL,\n      supportsOffscreenCanvas\n    });\n    \n    // Calculate quality factor based on capabilities\n    if (adaptiveQuality) {\n      // Base score from hardware\n      const performanceScore = (memory * cores) / (isMobile ? 2 : 1);\n      \n      // Scale quality based on performance score\n      let quality = 1;\n      \n      if (performanceScore > 16) {\n        quality = 1; // High-end devices\n      } else if (performanceScore > 8) {\n        quality = 0.8; // Mid-range devices\n      } else if (performanceScore > 4) {\n        quality = 0.6; // Low-end devices\n      } else {\n        quality = 0.4; // Very low-end devices\n      }\n      \n      setQualityFactor(quality);\n    }\n  }, [useWebGL, renderingMode, adaptiveQuality, enableBattery]);\n  \n  // Get cached color with opacity\n  const getCachedColor = useCallback((baseColor, opacity) => {\n    // Round opacity to reduce cache size while maintaining visual quality\n    const roundedOpacity = Math.round(opacity * 100) / 100;\n    const key = `${baseColor}-${roundedOpacity}`;\n    \n    if (!colorCacheRef.current.has(key)) {\n      const newColor = baseColor.replace(/[\\d.]+\\)$/, roundedOpacity + ')');\n      colorCacheRef.current.set(key, newColor);\n    }\n    \n    return colorCacheRef.current.get(key);\n  }, []);\n  \n  // Adaptive settings based on quality factor\n  const adaptedSettings = useMemo(() => {\n    if (!adaptiveQuality || qualityFactor === 1) {\n      return {\n        meteorDensity,\n        trailSegments,\n        useShadow: true,\n        useGlow: true,\n        useHighQualityRendering: true\n      };\n    }\n    \n    // Adjust quality-dependent parameters\n    return {\n      meteorDensity: Math.max(3, Math.floor(meteorDensity * qualityFactor)),\n      trailSegments: Math.max(5, Math.floor(trailSegments * qualityFactor)),\n      useShadow: qualityFactor > 0.5,\n      useGlow: qualityFactor > 0.3,\n      useHighQualityRendering: qualityFactor > 0.7\n    };\n  }, [adaptiveQuality, qualityFactor, meteorDensity, trailSegments]);\n  \n  // Detect device capabilities and preferences on mount\n  useEffect(() => {\n    // Check for reduced motion preference\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    \n    const handleReducedMotionChange = (e) => {\n      setPrefersReducedMotion(e.matches);\n    };\n    \n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n    \n    // Detect device capabilities\n    detectCapabilities();\n    \n    // Setup visibility change detection to pause when tab is inactive\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        visibilityChangeTimeRef.current = performance.now();\n      } else {\n        // Adjust timing references after visibility changes\n        const timeDelta = performance.now() - visibilityChangeTimeRef.current;\n        lastTimestampRef.current += timeDelta;\n        nextSpawnTimeRef.current += timeDelta;\n      }\n    };\n    \n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    \n    // Capture current worker ref to avoid closure issues\n    const currentWorker = workerRef.current;\n    \n    // Cleanup\n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n      \n      // Clean up worker if active\n      if (currentWorker) {\n        currentWorker.terminate();\n      }\n    };\n  }, [detectCapabilities]);\n  \n  // Initialize WebGL context and shaders if using WebGL\n  const initWebGL = useCallback(() => {\n    if (!canvasRef.current || actualRenderingMode !== 'webgl') return false;\n    \n    try {\n      // Get WebGL context\n      const gl = canvasRef.current.getContext('webgl', {\n        alpha: true,\n        antialias: true,\n        premultipliedAlpha: false,\n        depth: false\n      });\n      \n      if (!gl) return false;\n      \n      webGLRef.current = gl;\n      \n      // Create shader programs, vertex buffers, etc.\n      // This is a simplified placeholder - a real implementation would include\n      // proper shaders, attribute locations, and uniform setup\n      \n      // Enable blending for transparency\n      gl.enable(gl.BLEND);\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n      \n      // Set clear color to fully transparent\n      gl.clearColor(0.0, 0.0, 0.0, 0.0);\n      \n      // Get current dimensions for viewport\n      const canvasWidth = canvasRef.current.width;\n      const canvasHeight = canvasRef.current.height;\n      \n      // Set viewport\n      gl.viewport(0, 0, canvasWidth, canvasHeight);\n      \n      // Simple vertex shader for meteor particles\n      const vertexShaderSource = `\n        attribute vec2 aPosition;\n        attribute float aSize;\n        attribute vec4 aColor;\n        \n        varying vec4 vColor;\n        \n        uniform vec2 uResolution;\n        \n        void main() {\n          // Convert to clip space\n          vec2 position = (aPosition / uResolution) * 2.0 - 1.0;\n          position.y = -position.y;\n          \n          gl_Position = vec4(position, 0, 1);\n          gl_PointSize = aSize;\n          vColor = aColor;\n        }\n      `;\n      \n      // Simple fragment shader for meteor particles\n      const fragmentShaderSource = `\n        precision mediump float;\n        varying vec4 vColor;\n        \n        void main() {\n          // Calculate distance from center for circular point\n          float distance = length(gl_PointCoord - vec2(0.5, 0.5));\n          if (distance > 0.5) {\n            discard; // Outside circle\n          }\n          \n          // Softer edges\n          float alpha = smoothstep(0.5, 0.4, distance) * vColor.a;\n          gl_FragColor = vec4(vColor.rgb, alpha);\n        }\n      `;\n      \n      // Compile shader program (simplified)\n      const createShader = (gl, type, source) => {\n        const shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        return shader;\n      };\n      \n      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n      \n      const program = gl.createProgram();\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n      \n      // Store the program\n      webGLProgramsRef.current.meteor = {\n        program,\n        attributes: {\n          position: gl.getAttribLocation(program, 'aPosition'),\n          size: gl.getAttribLocation(program, 'aSize'),\n          color: gl.getAttribLocation(program, 'aColor')\n        },\n        uniforms: {\n          resolution: gl.getUniformLocation(program, 'uResolution')\n        }\n      };\n      \n      return true;\n    } catch (error) {\n      console.error('WebGL initialization error:', error);\n      setActualRenderingMode('2d');\n      return false;\n    }\n  }, [actualRenderingMode]);\n  \n  // Calculate path parameters for a meteor based on selected mode\n  const calculateMeteorPath = useCallback((width, height) => {\n    if (mode === 'arc') {\n      // Arc path logic with optimized parameters\n      const startX = Math.random() * width * 1.5 - width * 0.25;\n      const startY = Math.random() * -100 - 50;\n      \n      const curveDirection = Math.random() > 0.5 ? 1 : -1;\n      const curveIntensity = Math.random() * 0.4 + 0.2;\n      \n      const endX = startX + (curveDirection * width * curveIntensity);\n      const endY = height * journeyCompletion;\n      \n      const controlX = (startX + endX) / 2 + (curveDirection * width * curveIntensity);\n      const controlY = (startY + endY) * 0.5;\n      \n      return {\n        pathType: 'arc',\n        start: { x: startX, y: startY },\n        control: { x: controlX, y: controlY },\n        end: { x: endX, y: endY }\n      };\n    } else if (mode === 'linear') {\n      // Linear path logic with enhanced direction control\n      let meteorDirection = direction;\n      if (direction === 'both') {\n        meteorDirection = Math.random() > 0.5 ? 'left' : 'right';\n      }\n      \n      let angle;\n      if (direction === 'top') {\n        angle = ((30 + (Math.random() * 2 - 1) * 5) * Math.PI) / 180;\n      } else {\n        angle = ((baseAngle + (Math.random() * 2 - 1) * angleVariation) * Math.PI) / 180;\n      }\n      \n      let startX;\n      if (meteorDirection === 'left') {\n        startX = Math.random() * (width * 0.3) - (width * 0.1);\n      } else if (meteorDirection === 'right') {\n        startX = width - Math.random() * (width * 0.3) + (width * 0.1);\n      } else if (direction === 'top') {\n        const position = Math.random();\n        if (position < 0.5) {\n          startX = Math.random() * (width * 0.35);\n        } else if (position < 0.85) {\n          startX = width * 0.35 + Math.random() * (width * 0.35);\n        } else {\n          startX = width * 0.7 + Math.random() * (width * 0.3);\n        }\n      }\n      \n      const startY = Math.random() * -100 - 50;\n      const distanceToTravel = (height * journeyCompletion) / Math.cos(angle);\n      \n      let endX, endY;\n      if (meteorDirection === 'left' || direction === 'top') {\n        endX = startX + distanceToTravel * Math.sin(angle);\n        endY = startY + distanceToTravel * Math.cos(angle);\n      } else {\n        endX = startX - distanceToTravel * Math.sin(angle);\n        endY = startY + distanceToTravel * Math.cos(angle);\n      }\n      \n      return {\n        pathType: 'linear',\n        start: { x: startX, y: startY },\n        end: { x: endX, y: endY },\n        direction: meteorDirection\n      };\n    }\n  }, [mode, direction, baseAngle, angleVariation, journeyCompletion]);\n  \n  // Get point along path with highly optimized calculations\n  const getPathPoint = useCallback((t, path, outPoint = { x: 0, y: 0 }) => {\n    if (path.pathType === 'arc') {\n      // Optimized quadratic bezier calculation using pre-computed terms\n      const invT = 1 - t;\n      const invTSquared = invT * invT;\n      const tSquared = t * t;\n      const term1 = invTSquared;\n      const term2 = 2 * invT * t;\n      const term3 = tSquared;\n      \n      outPoint.x = term1 * path.start.x + term2 * path.control.x + term3 * path.end.x;\n      outPoint.y = term1 * path.start.y + term2 * path.control.y + term3 * path.end.y;\n    } else {\n      // Linear interpolation with minimal operations\n      outPoint.x = path.start.x + (path.end.x - path.start.x) * t;\n      outPoint.y = path.start.y + (path.end.y - path.start.y) * t;\n    }\n    \n    return outPoint;\n  }, []);\n  \n  // Calculate velocity at a point on the path (for trail orientation)\n  // Will be used in future implementations for advanced trail effects and particle systems\n  /* eslint-disable-next-line no-unused-vars */\n  const getPathVelocity = useCallback((t, path, outVelocity = { x: 0, y: 0 }) => {\n    if (path.pathType === 'arc') {\n      // Derivative of quadratic bezier\n      const term1 = 2 * (1 - t);\n      const term2 = 2 * t;\n      \n      outVelocity.x = term1 * (path.control.x - path.start.x) + term2 * (path.end.x - path.control.x);\n      outVelocity.y = term1 * (path.control.y - path.start.y) + term2 * (path.end.y - path.control.y);\n    } else {\n      // Constant velocity for linear paths\n      outVelocity.x = path.end.x - path.start.x;\n      outVelocity.y = path.end.y - path.start.y;\n      \n      // Normalize\n      const length = Math.sqrt(outVelocity.x * outVelocity.x + outVelocity.y * outVelocity.y);\n      if (length > 0) {\n        outVelocity.x /= length;\n        outVelocity.y /= length;\n      }\n    }\n    \n    return outVelocity;\n  }, []);\n  \n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current || !containerRef.current) return false;\n    \n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    const rect = container.getBoundingClientRect();\n    const pixelRatio = window.devicePixelRatio || 1;\n    \n    // Calculate dimensions\n    const displayWidth = rect.width;\n    const displayHeight = typeof height === 'string' && height.endsWith('vh') \n      ? (parseInt(height, 10) / 100) * window.innerHeight\n      : parseInt(height, 10) || window.innerHeight;\n    \n    // Set canvas size accounting for pixel ratio\n    canvas.width = displayWidth * pixelRatio;\n    canvas.height = displayHeight * pixelRatio;\n    canvas.style.width = `${displayWidth}px`;\n    canvas.style.height = `${displayHeight}px`;\n    \n    // Get appropriate rendering context\n    if (actualRenderingMode === 'webgl') {\n      initWebGL();\n    } else {\n      // 2D Canvas context\n      const ctx = canvas.getContext('2d', {\n        alpha: true,\n        desynchronized: true,\n        willReadFrequently: false\n      });\n      \n      if (!ctx) return false;\n      \n      // Scale context for high-DPI displays\n      ctx.scale(pixelRatio, pixelRatio);\n      \n      // Configure context for high-quality rendering\n      if (adaptedSettings.useHighQualityRendering) {\n        ctx.imageSmoothingEnabled = true;\n        ctx.imageSmoothingQuality = 'high';\n      }\n      \n      ctxRef.current = ctx;\n    }\n    \n    // Initialize offscreen canvas if supported and enabled\n    if (enableOffscreenRendering && typeof OffscreenCanvas !== 'undefined' &&\n        deviceCapabilities.supportsOffscreenCanvas) {\n      try {\n        // Create offscreen canvas\n        const offscreen = new OffscreenCanvas(\n          displayWidth * pixelRatio,\n          displayHeight * pixelRatio\n        );\n        \n        // Get 2D context for offscreen canvas\n        const offscreenCtx = offscreen.getContext('2d');\n        if (offscreenCtx) {\n          offscreenCtx.scale(pixelRatio, pixelRatio);\n          offscreenCanvasRef.current = {\n            canvas: offscreen,\n            ctx: offscreenCtx\n          };\n        }\n      } catch (error) {\n        console.warn('Offscreen canvas initialization error:', error);\n      }\n    }\n    \n    setDimensions({\n      width: displayWidth,\n      height: displayHeight,\n      pixelRatio\n    });\n    \n    return true;\n  }, [height, actualRenderingMode, initWebGL, enableOffscreenRendering, deviceCapabilities.supportsOffscreenCanvas, adaptedSettings.useHighQualityRendering]);\n  \n  // Setup canvas resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n    \n    // Create a ResizeObserver to detect container size changes\n    const resizeObserver = new ResizeObserver(entries => {\n      // Debounce resize operations\n      if (resizeObserverRef.current.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n      \n      resizeObserverRef.current.timeout = setTimeout(() => {\n        requestAnimationFrame(() => {\n          if (setupCanvas()) {\n            setIsInitialized(true);\n          }\n        });\n      }, 100); // 100ms debounce\n    });\n    \n    // Capture current reference to avoid closure issues in cleanup\n    const currentContainer = containerRef.current;\n    \n    // Start observing the container\n    resizeObserver.observe(currentContainer);\n    resizeObserverRef.current = { observer: resizeObserver };\n    \n    // Initial setup\n    setupCanvas();\n    setIsInitialized(true);\n    \n    return () => {\n      if (resizeObserverRef.current.observer) {\n        resizeObserverRef.current.observer.disconnect();\n      }\n      if (resizeObserverRef.current.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n    };\n  }, [setupCanvas]);\n  \n  // Setup intersection observer to only animate when visible\n  useEffect(() => {\n    if (!containerRef.current) return;\n    \n    const observer = new IntersectionObserver(\n      entries => {\n        const isIntersecting = entries[0].isIntersecting;\n        \n        // Only change state if visibility actually changed\n        if (isIntersecting !== isVisible) {\n          setIsVisible(isIntersecting);\n          \n          if (isIntersecting) {\n            // Reset timing references when becoming visible again\n            lastTimestampRef.current = 0;\n            nextSpawnTimeRef.current = performance.now();\n          }\n        }\n      },\n      {\n        threshold: 0.01,\n        rootMargin: '100px'\n      }\n    );\n    \n    // Store current reference to avoid closure issues\n    const currentContainerRef = containerRef.current;\n    observer.observe(currentContainerRef);\n    visibilityObserverRef.current = observer;\n    \n    return () => {\n      if (visibilityObserverRef.current) {\n        visibilityObserverRef.current.disconnect();\n      }\n    };\n  }, [isVisible]);\n  \n  // Handle parallax effect on scroll if enabled\n  useEffect(() => {\n    if (!enableParallax) return;\n    \n    // Use passive event listener for better performance\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    \n    window.addEventListener('scroll', handleScroll, { passive: true });\n    \n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [enableParallax]);\n  \n  // Get a meteor from the object pool or create a new one\n  const getMeteor = useCallback(() => {\n    // Try to get from pool first\n    const pool = objectPoolsRef.current.meteors;\n    let meteor;\n    \n    if (pool.length > 0) {\n      meteor = pool.pop();\n      // Reset meteor properties\n      meteor.progress = 0;\n      meteor.active = true;\n    } else {\n      // Create new if pool is empty\n      meteor = {\n        progress: 0,\n        active: true,\n        positions: Array(adaptedSettings.trailSegments)\n      };\n      \n      // Pre-allocate position objects\n      for (let i = 0; i < adaptedSettings.trailSegments; i++) {\n        meteor.positions[i] = { x: 0, y: 0 };\n      }\n    }\n    \n    return meteor;\n  }, [adaptedSettings.trailSegments]);\n  \n  // Initialize a meteor with all required properties\n  const initializeMeteor = useCallback(() => {\n    const { width, height } = dimensions;\n    \n    if (!width || !height) return null;\n    \n    // Get meteor from pool\n    const meteor = getMeteor();\n    \n    // Calculate path based on mode\n    const path = calculateMeteorPath(width, height);\n    \n    // Set path and initial position\n    meteor.path = path;\n    for (let i = 0; i < meteor.positions.length; i++) {\n      meteor.positions[i].x = path.start.x;\n      meteor.positions[i].y = path.start.y;\n    }\n    \n    // Set meteor properties\n    meteor.size = Math.random() * (meteorMaxSize - meteorMinSize) + meteorMinSize;\n    meteor.speed = meteorSpeed * (Math.random() * 0.5 + 0.75);\n    meteor.opacity = Math.random() * 0.3 + 0.7;\n    meteor.fadeThreshold = 0.7 + Math.random() * 0.2;\n    meteor.pulsePhase = Math.random() * Math.PI * 2;\n    meteor.pulseSpeed = Math.random() * 0.01 + 0.005;\n    \n    // Add burst properties if enabled\n    if (enableBursts && Math.random() < 0.3) { // 30% chance of meteor having burst\n      meteor.hasBurst = true;\n      meteor.burstThreshold = 0.9 + Math.random() * 0.08; // Trigger near the end\n      meteor.burstTriggered = false;\n      meteor.burstSize = meteor.size * (2 + Math.random() * 3);\n      meteor.burstParticles = 5 + Math.floor(Math.random() * 8);\n    } else {\n      meteor.hasBurst = false;\n    }\n    \n    return meteor;\n  }, [\n    dimensions,\n    calculateMeteorPath,\n    meteorMinSize,\n    meteorMaxSize,\n    meteorSpeed,\n    enableBursts,\n    getMeteor\n  ]);\n  \n  // Create a burst effect at a specified position\n  const createBurst = useCallback((x, y, size, color, particleCount) => {\n    // Skip if bursts are not enabled\n    if (!enableBursts) return;\n    \n    // Create particles in a circular pattern\n    for (let i = 0; i < particleCount; i++) {\n      const angle = (i / particleCount) * Math.PI * 2;\n      const speed = 0.5 + Math.random() * 1.5;\n      \n      const burst = {\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        size: size * (0.3 + Math.random() * 0.4),\n        life: 1.0,\n        decay: 0.01 + Math.random() * 0.03,\n        color\n      };\n      \n      burstsRef.current.push(burst);\n    }\n  }, [enableBursts]);\n  \n  // FPS limiter for consistent animation speed\n  const fpsLimiter = useCallback((timestamp, callback) => {\n    // Skip animation if hidden, inactive, or reduced motion\n    if (!isVisible || !active || (respectReducedMotion && prefersReducedMotion) || document.hidden) {\n      animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n      return;\n    }\n    \n    const targetFrameTime = 1000 / maxFPS;\n    const elapsed = timestamp - lastTimestampRef.current;\n    \n    if (elapsed >= targetFrameTime || lastTimestampRef.current === 0) {\n      // Calculate correct delta\n      const delta = lastTimestampRef.current === 0 ? 16 : elapsed;\n      \n      // Update timestamp, limiting delta to avoid jumps after inactivity\n      lastTimestampRef.current = timestamp - (elapsed % targetFrameTime);\n      \n      // Run animation callback with capped delta time\n      callback(Math.min(delta, 50));\n      \n      // FPS tracking for debug and adaptive quality\n      frameCountRef.current++;\n      if (timestamp - fpsTimestampRef.current >= 1000) {\n        currentFpsRef.current = frameCountRef.current;\n        frameCountRef.current = 0;\n        fpsTimestampRef.current = timestamp;\n        \n        // Log FPS in debug mode\n        if (debug) {\n          console.log(`MeteorShower FPS: ${currentFpsRef.current}, Quality: ${qualityFactor.toFixed(2)}`);\n        }\n        \n        // Dynamic quality adjustment based on performance\n        if (adaptiveQuality && currentFpsRef.current < maxFPS * 0.7) {\n          // If FPS is below 70% of target, reduce quality\n          setQualityFactor(prev => Math.max(0.4, prev * 0.9));\n        } else if (adaptiveQuality && currentFpsRef.current >= maxFPS * 0.95 && qualityFactor < 1) {\n          // If FPS is near target and quality is reduced, gradually increase\n          setQualityFactor(prev => Math.min(1, prev * 1.05));\n        }\n      }\n    }\n    \n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n  }, [\n    isVisible,\n    active,\n    respectReducedMotion,\n    prefersReducedMotion,\n    maxFPS,\n    debug,\n    adaptiveQuality,\n    qualityFactor\n  ]);\n  \n  // 2D Canvas rendering method for meteors\n  const renderMeteors2D = useCallback((ctx, parallaxOffset, timestamp) => {\n    // Process and render each meteor\n    meteorsRef.current.forEach(meteor => {\n      // Calculate opacity based on progress\n      let currentOpacity = meteor.opacity;\n      if (meteor.progress > meteor.fadeThreshold) {\n        const fadeProgress = (meteor.progress - meteor.fadeThreshold) / (1 - meteor.fadeThreshold);\n        currentOpacity = meteor.opacity * (1 - fadeProgress);\n      }\n      \n      // Apply pulse effect\n      const timeFactor = timestamp * 0.001;\n      const pulseEffect = Math.sin(timeFactor * meteor.pulseSpeed + meteor.pulsePhase) * 0.2 + 0.8;\n      \n      // Parallax offset adjustment\n      const adjustY = enableParallax ? parallaxOffset * (meteor.size / meteorMaxSize) : 0;\n      \n      // Check if we should create a burst effect\n      if (meteor.hasBurst && !meteor.burstTriggered && meteor.progress >= meteor.burstThreshold) {\n        meteor.burstTriggered = true;\n        const burstPosition = meteor.positions[0];\n        createBurst(\n          burstPosition.x,\n          burstPosition.y + adjustY,\n          meteor.burstSize,\n          glowColor,\n          meteor.burstParticles\n        );\n      }\n      \n      // Optimized rendering approach\n      if (adaptedSettings.useHighQualityRendering) {\n        // High-quality rendering with shadows\n        // Set shadow for glow effect if enabled\n        if (adaptedSettings.useGlow) {\n          ctx.shadowColor = glowColor;\n          ctx.shadowBlur = meteor.size * 3 * pulseEffect;\n        }\n        \n        // Draw trail segments\n        ctx.lineCap = 'round';\n        \n        for (let i = meteor.positions.length - 2; i >= 0; i--) {\n          const pos1 = meteor.positions[i];\n          const pos2 = meteor.positions[i + 1];\n          \n          if (!pos1 || !pos2) continue;\n          \n          // Calculate segment opacity (decreases along the trail)\n          const segmentOpacity = currentOpacity * (1 - i / meteor.positions.length) * pulseEffect;\n          \n          // Skip if nearly invisible\n          if (segmentOpacity < 0.02) continue;\n          \n          // Calculate segment width (decreases along the trail)\n          const segmentWidth = meteor.size * (1 - i / meteor.positions.length * 0.7);\n          \n          // Draw line segment\n          ctx.beginPath();\n          ctx.moveTo(pos1.x, pos1.y + adjustY);\n          ctx.lineTo(pos2.x, pos2.y + adjustY);\n          \n          // Set line style\n          ctx.lineWidth = segmentWidth;\n          ctx.strokeStyle = getCachedColor(trailColor, segmentOpacity);\n          ctx.stroke();\n        }\n        \n        // Draw meteor head\n        if (meteor.positions[0]) {\n          const headPos = meteor.positions[0];\n          \n          // Set shadow for head\n          if (adaptedSettings.useShadow) {\n            ctx.shadowColor = glowColor;\n            ctx.shadowBlur = meteor.size * 5 * pulseEffect;\n          }\n          \n          // Draw outer glow\n          ctx.beginPath();\n          ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 1.5, 0, Math.PI * 2);\n          ctx.fillStyle = getCachedColor(glowColor, currentOpacity * 0.7 * pulseEffect);\n          ctx.fill();\n          \n          // Draw inner core\n          ctx.beginPath();\n          ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 0.7, 0, Math.PI * 2);\n          ctx.fillStyle = getCachedColor(coreColor, currentOpacity * pulseEffect);\n          ctx.fill();\n        }\n      } else {\n        // Performance-optimized rendering for lower-end devices\n        // Draw simplified trail\n        ctx.beginPath();\n        const headPos = meteor.positions[0];\n        if (!headPos) return;\n        \n        ctx.moveTo(headPos.x, headPos.y + adjustY);\n        \n        for (let i = 1; i < meteor.positions.length; i += 2) {\n          const pos = meteor.positions[i];\n          if (!pos) continue;\n          ctx.lineTo(pos.x, pos.y + adjustY);\n        }\n        \n        // Gradient trail\n        const gradient = ctx.createLinearGradient(\n          headPos.x, headPos.y + adjustY,\n          meteor.positions[meteor.positions.length - 1].x,\n          meteor.positions[meteor.positions.length - 1].y + adjustY\n        );\n        \n        gradient.addColorStop(0, getCachedColor(coreColor, currentOpacity * pulseEffect));\n        gradient.addColorStop(0.3, getCachedColor(glowColor, currentOpacity * 0.7 * pulseEffect));\n        gradient.addColorStop(1, getCachedColor(trailColor, 0));\n        \n        ctx.strokeStyle = gradient;\n        ctx.lineWidth = meteor.size;\n        ctx.lineCap = 'round';\n        ctx.stroke();\n        \n        // Simple head\n        ctx.beginPath();\n        ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 0.7, 0, Math.PI * 2);\n        ctx.fillStyle = getCachedColor(coreColor, currentOpacity * pulseEffect);\n        ctx.fill();\n      }\n    });\n  }, [\n    adaptedSettings.useHighQualityRendering,\n    adaptedSettings.useGlow,\n    adaptedSettings.useShadow,\n    enableParallax,\n    meteorMaxSize,\n    glowColor,\n    trailColor,\n    coreColor,\n    getCachedColor,\n    createBurst\n  ]);\n  \n  // WebGL rendering method\n  const renderMeteorsWebGL = useCallback((gl, timestamp) => {\n    // This is a simplified placeholder for WebGL rendering\n    // A full implementation would use the shaders and buffers set up earlier\n    \n    if (!gl || !webGLProgramsRef.current.meteor) return;\n    \n    // Clear canvas\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    \n    // Use meteor shader program\n    const meteorProgram = webGLProgramsRef.current.meteor;\n    gl.useProgram(meteorProgram.program);\n    \n    // Set uniforms\n    gl.uniform2f(\n      meteorProgram.uniforms.resolution,\n      canvasRef.current.width,\n      canvasRef.current.height\n    );\n    \n    // This is where we would bind vertex buffers and render particles\n    // For a real implementation, you would:\n    // 1. Update vertex buffer with current meteor positions\n    // 2. Set attributes for position, size, color\n    // 3. Draw using gl.POINTS or other appropriate primitives\n    \n  }, []);\n  \n  // Render burst particles\n  const renderBursts = useCallback((ctx, deltaTime) => {\n    if (!enableBursts || burstsRef.current.length === 0) return;\n    \n    // Process and render each burst particle\n    for (let i = burstsRef.current.length - 1; i >= 0; i--) {\n      const burst = burstsRef.current[i];\n      \n      // Update position\n      burst.x += burst.vx;\n      burst.y += burst.vy;\n      \n      // Apply gravity\n      burst.vy += 0.05;\n      \n      // Reduce life\n      burst.life -= burst.decay * (deltaTime / 16);\n      \n      // Remove if dead\n      if (burst.life <= 0) {\n        burstsRef.current.splice(i, 1);\n        continue;\n      }\n      \n      // Draw particle\n      ctx.beginPath();\n      ctx.arc(burst.x, burst.y, burst.size * burst.life, 0, Math.PI * 2);\n      ctx.fillStyle = getCachedColor(burst.color, burst.life * 0.7);\n      ctx.fill();\n    }\n  }, [enableBursts, getCachedColor]);\n  \n  // Update meteor positions\n  const updateMeteors = useCallback((deltaTime) => {\n    const { width, height } = dimensions;\n    \n    // Process meteors\n    for (let i = meteorsRef.current.length - 1; i >= 0; i--) {\n      const meteor = meteorsRef.current[i];\n      \n      // Update progress based on speed and delta time\n      meteor.progress += meteor.speed * (deltaTime / 1000);\n      \n      // Check if meteor has completed its path\n      if (meteor.progress >= 1) {\n        // Return to object pool\n        meteor.active = false;\n        objectPoolsRef.current.meteors.push(meteor);\n        meteorsRef.current.splice(i, 1);\n        continue;\n      }\n      \n      // Calculate current position along the path\n      const currentPos = getPathPoint(Math.min(1, meteor.progress), meteor.path, pointCache.current);\n      \n      // Update position history (for trail) using optimized array management\n      // Shift positions array - this is more efficient than splice/unshift for small arrays\n      for (let j = meteor.positions.length - 1; j > 0; j--) {\n        const current = meteor.positions[j];\n        const prev = meteor.positions[j - 1];\n        \n        current.x = prev.x;\n        current.y = prev.y;\n      }\n      \n      // Update head position\n      meteor.positions[0].x = currentPos.x;\n      meteor.positions[0].y = currentPos.y;\n    }\n    \n    // Spawn new meteors if needed\n    const now = performance.now();\n    const spawnNeeded = meteorsRef.current.length < adaptedSettings.meteorDensity;\n    const canSpawnNow = !staggered || now >= nextSpawnTimeRef.current;\n    \n    if (spawnNeeded && canSpawnNow) {\n      const newMeteor = initializeMeteor();\n      if (newMeteor) {\n        meteorsRef.current.push(newMeteor);\n        \n        // Set next spawn time if staggering is enabled\n        if (staggered) {\n          const delay = Math.random() * (maxStaggerDelay - minStaggerDelay) + minStaggerDelay;\n          nextSpawnTimeRef.current = now + delay;\n        }\n      }\n    }\n  }, [\n    dimensions,\n    adaptedSettings.meteorDensity,\n    staggered,\n    minStaggerDelay,\n    maxStaggerDelay,\n    initializeMeteor,\n    getPathPoint,\n    pointCache\n  ]);\n  \n  // Main animation handler\n  const handleAnimation = useCallback((deltaTime) => {\n    // Skip if component is not ready\n    if (!canvasRef.current || !isInitialized) return;\n    \n    const now = performance.now();\n    \n    // Calculate parallax offset if enabled\n    let parallaxOffset = 0;\n    if (enableParallax) {\n      parallaxOffset = scrollPositionRef.current * parallaxIntensity;\n    }\n    \n    // Update meteor positions\n    updateMeteors(deltaTime);\n    \n    // Render based on selected mode\n    if (actualRenderingMode === 'webgl' && webGLRef.current) {\n      // WebGL rendering path\n      renderMeteorsWebGL(webGLRef.current, now);\n    } else {\n      // Canvas 2D rendering path\n      const ctx = ctxRef.current;\n      if (!ctx) return;\n      \n      // Clear canvas with optimized clear (only clear used area)\n      ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n      \n      // Render meteors\n      renderMeteors2D(ctx, parallaxOffset, now);\n      \n      // Render burst particles\n      if (enableBursts) {\n        renderBursts(ctx, deltaTime);\n      }\n      \n      // Debug visualization\n      if (debug) {\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n        ctx.font = '12px monospace';\n        ctx.fillText(`FPS: ${currentFpsRef.current}`, 10, 20);\n        ctx.fillText(`Meteors: ${meteorsRef.current.length}/${adaptedSettings.meteorDensity}`, 10, 40);\n        ctx.fillText(`Quality: ${qualityFactor.toFixed(2)}`, 10, 60);\n        ctx.fillText(`Rendering: ${actualRenderingMode}`, 10, 80);\n        \n        if (enableBursts) {\n          ctx.fillText(`Bursts: ${burstsRef.current.length}`, 10, 100);\n        }\n      }\n    }\n  }, [\n    isInitialized,\n    dimensions,\n    adaptedSettings.meteorDensity,\n    enableParallax,\n    parallaxIntensity,\n    actualRenderingMode,\n    debug,\n    updateMeteors,\n    renderMeteors2D,\n    renderMeteorsWebGL,\n    enableBursts,\n    renderBursts,\n    qualityFactor\n  ]);\n  \n  // Main animation loop\n  useEffect(() => {\n    if (!active || !isInitialized || !dimensions.width || !dimensions.height) {\n      return;\n    }\n    \n    // Start animation with FPS limiter\n    fpsTimestampRef.current = performance.now();\n    frameCountRef.current = 0;\n    lastTimestampRef.current = 0;\n    \n    animationFrameRef.current = requestAnimationFrame(timestamp => {\n      fpsLimiter(timestamp, handleAnimation);\n    });\n    \n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [\n    active,\n    isInitialized,\n    dimensions,\n    fpsLimiter,\n    handleAnimation\n  ]);\n  \n  return (\n    <div \n      ref={containerRef}\n      style={{ \n        position: 'absolute',\n        top: 0, \n        left: 0, \n        width: '100%', \n        height: height,\n        overflow: 'hidden', \n        pointerEvents: 'none', \n        zIndex: zIndex,\n        // Hardware acceleration\n        backfaceVisibility: 'hidden',\n        transform: 'translateZ(0)',\n        willChange: 'transform'\n      }}\n      aria-hidden=\"true\"\n    >\n      <canvas \n        ref={canvasRef} \n        style={{ \n          position: 'absolute', \n          top: 0, \n          left: 0, \n          width: '100%', \n          height: '100%',\n          // Additional rendering optimizations\n          imageRendering: 'high-quality',\n          // Hardware acceleration\n          backfaceVisibility: 'hidden',\n          transform: 'translateZ(0)',\n          willChange: 'transform',\n          // Ensures proper subpixel rendering\n          filter: 'none'\n        }} \n      />\n    </div>\n  );\n};\n\n/**\n * GoldenMeteorShower Component\n * \n * A preset version of the MeteorShower with a golden/amber color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const GoldenMeteorShower = (props) => {\n  const goldenPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 253, 227, 0.9)',\n    trailColor: 'rgba(191, 173, 127, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 200,\n    maxStaggerDelay: 2000,\n  };\n  \n  return <MeteorShower {...goldenPreset} {...props} />;\n};\n\n/**\n * CelestialMeteorShower Component\n * \n * A preset version of the MeteorShower with a bluish-purple color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const CelestialMeteorShower = (props) => {\n  const celestialPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(220, 225, 255, 0.9)',\n    trailColor: 'rgba(150, 160, 255, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 300,\n    maxStaggerDelay: 1800,\n  };\n  \n  return <MeteorShower {...celestialPreset} {...props} />;\n};\n\n/**\n * RubyMeteorShower Component\n * \n * A preset version of the MeteorShower with a red color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const RubyMeteorShower = (props) => {\n  const rubyPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 200, 200, 0.9)',\n    trailColor: 'rgba(220, 100, 100, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 350,\n    maxStaggerDelay: 2200,\n  };\n  \n  return <MeteorShower {...rubyPreset} {...props} />;\n};\n\n/**\n * TopMeteorShower Component\n * \n * A preset version of the MeteorShower with meteors falling from the top of the screen\n * at a consistent 30-degree angle, distributed with emphasis on left and center areas.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const TopMeteorShower = (props) => {\n  const topPreset = {\n    mode: 'linear',\n    direction: 'top',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.12,\n    trailLength: 200,\n    trailSegments: 25,\n    journeyCompletion: 0.95,\n    staggered: true,\n    minStaggerDelay: 100,\n    maxStaggerDelay: 1000,\n  };\n  \n  return <MeteorShower {...topPreset} {...props} />;\n};\n\nexport default MeteorShower;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}