{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/effects/scrollingeffects/SlidingBackground.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\n\n/**\n * SlidingBackground Component\n * \n * A highly configurable component that creates a parallax background with fade effects\n * that can be positioned at the top, middle, or bottom of the viewport.\n * \n * @param {Object} props - Component props\n * @param {string} props.image - URL of the background image\n * @param {string} [props.position='top'] - Position of the focused area ('top', 'middle', 'bottom')\n * @param {string|number} [props.height='33vh'] - Height of the component\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of the parallax effect (0-1)\n * @param {number} [props.parallaxLimitPercent=30] - Maximum percentage of component height the image can move with parallax\n * @param {boolean} [props.clampParallax=true] - Whether to clamp parallax movement to prevent image from moving too far\n * @param {number} [props.fadeSize=0.4] - Size of the fade effect (0-1, as a fraction of the component)\n * @param {string} [props.backgroundColor='#000'] - Background color for the fade effect\n * @param {number} [props.zIndex=0] - z-index of the component\n * @param {number} [props.blurAmount=0] - Amount of blur for the fade transition (px)\n * @param {number} [props.opacity=1] - Opacity of the background image\n * @param {string} [props.backgroundSize='cover'] - Background size property\n * @param {string} [props.backgroundPosition] - Background position (overrides position setting)\n * @param {string} [props.transitionEffect='gradient'] - Type of transition effect ('gradient', 'dissolve')\n * @param {boolean} [props.fitContainer=true] - Whether the background should be constrained to fit its container\n * @param {number} [props.heightMultiplier=1.2] - How much larger the background image should be than its container (1=same size)\n * @param {React.ReactNode} [props.children] - Content to render on top of the background\n */\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst SlidingBackground = ({\n  image,\n  position = 'top',\n  height = '33vh',\n  parallaxIntensity = 0.2,\n  parallaxLimitPercent = 30,\n  clampParallax = true,\n  fadeSize = 0.4,\n  backgroundColor = '#000',\n  zIndex = 0,\n  blurAmount = 0,\n  opacity = 1,\n  backgroundSize = 'cover',\n  backgroundPosition,\n  transitionEffect = 'gradient',\n  fitContainer = true,\n  heightMultiplier = 1.2,\n  children\n}) => {\n  _s();\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const [scrollPosition, setScrollPosition] = useState(0);\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0\n  });\n  const [imageLoaded, setImageLoaded] = useState(false);\n  const imageRef = useRef(null);\n  const animationFrameRef = useRef(null);\n\n  // Define renderDissolveEffect with useCallback BEFORE it's used in any useEffect\n  const renderDissolveEffect = useCallback(() => {\n    if (!canvasRef.current || !imageRef.current || !dimensions.width || !dimensions.height) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const img = imageRef.current;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Calculate parallax offset with clamping if enabled\n    let parallaxOffset = scrollPosition * parallaxIntensity;\n\n    // Clamp parallax movement if enabled\n    if (clampParallax) {\n      const maxOffset = canvas.height * parallaxLimitPercent / 100;\n      parallaxOffset = Math.max(Math.min(parallaxOffset, maxOffset), -maxOffset);\n    }\n\n    // Calculate image dimensions to maintain aspect ratio while covering the canvas\n    const imgAspect = img.width / img.height;\n    const canvasAspect = canvas.width / canvas.height;\n    let drawWidth, drawHeight, offsetX, offsetY;\n    if (fitContainer) {\n      // Apply heightMultiplier to make image larger than container if needed\n      if (imgAspect > canvasAspect) {\n        // Image is wider than canvas (relative to height)\n        drawHeight = canvas.height * heightMultiplier;\n        drawWidth = drawHeight * imgAspect;\n        offsetX = (canvas.width - drawWidth) / 2;\n        offsetY = (canvas.height - drawHeight) / 2;\n      } else {\n        // Image is taller than canvas (relative to width)\n        drawWidth = canvas.width * heightMultiplier;\n        drawHeight = drawWidth / imgAspect;\n        offsetX = (canvas.width - drawWidth) / 2;\n        offsetY = (canvas.height - drawHeight) / 2;\n      }\n    } else {\n      // Original behavior - cover the canvas\n      if (imgAspect > canvasAspect) {\n        // Image is wider than canvas (relative to height)\n        drawHeight = canvas.height;\n        drawWidth = drawHeight * imgAspect;\n        offsetX = (canvas.width - drawWidth) / 2;\n        offsetY = 0;\n      } else {\n        // Image is taller than canvas (relative to width)\n        drawWidth = canvas.width;\n        drawHeight = drawWidth / imgAspect;\n        offsetX = 0;\n        offsetY = (canvas.height - drawHeight) / 2;\n      }\n    }\n\n    // Adjust based on position setting\n    if (position === 'top') {\n      offsetY = 0;\n    } else if (position === 'bottom') {\n      offsetY = canvas.height - drawHeight;\n    } else if (position === 'middle') {\n      offsetY = (canvas.height - drawHeight) / 2;\n    }\n\n    // Apply parallax\n    offsetY += parallaxOffset;\n\n    // Draw the image\n    ctx.globalAlpha = opacity;\n    ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);\n\n    // Apply blur if specified\n    if (blurAmount > 0) {\n      ctx.filter = `blur(${blurAmount}px)`;\n      ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);\n      ctx.filter = 'none';\n    }\n\n    // Determine which edges should fade based on position\n    const shouldFadeTop = position === 'bottom' || position === 'middle';\n    const shouldFadeBottom = position === 'top' || position === 'middle';\n\n    // Top dissolve effect\n    if (shouldFadeTop) {\n      const fadeHeight = Math.floor(canvas.height * fadeSize);\n      const imageData = ctx.getImageData(0, 0, canvas.width, fadeHeight);\n      const pixels = imageData.data;\n      for (let y = 0; y < fadeHeight; y++) {\n        const fadeRatio = 1 - y / fadeHeight;\n        for (let x = 0; x < canvas.width; x++) {\n          const pixelIndex = (y * canvas.width + x) * 4;\n\n          // Apply dissolve effect with random pattern\n          if (Math.random() < fadeRatio * 0.8) {\n            pixels[pixelIndex + 3] = 0; // Set alpha to 0 (transparent)\n          } else {\n            // Gradually decrease opacity\n            pixels[pixelIndex + 3] = pixels[pixelIndex + 3] * (1 - fadeRatio);\n          }\n        }\n      }\n      ctx.putImageData(imageData, 0, 0);\n\n      // Add gradient overlay\n      const gradient = ctx.createLinearGradient(0, 0, 0, fadeHeight);\n      gradient.addColorStop(0, backgroundColor);\n      gradient.addColorStop(1, 'rgba(0,0,0,0)');\n      ctx.fillStyle = gradient;\n      ctx.globalAlpha = 0.7;\n      ctx.fillRect(0, 0, canvas.width, fadeHeight);\n    }\n\n    // Bottom dissolve effect\n    if (shouldFadeBottom) {\n      const fadeHeight = Math.floor(canvas.height * fadeSize);\n      const startY = canvas.height - fadeHeight;\n      const imageData = ctx.getImageData(0, startY, canvas.width, fadeHeight);\n      const pixels = imageData.data;\n      for (let y = 0; y < fadeHeight; y++) {\n        const fadeRatio = y / fadeHeight;\n        for (let x = 0; x < canvas.width; x++) {\n          const pixelIndex = (y * canvas.width + x) * 4;\n\n          // Apply dissolve effect with random pattern\n          if (Math.random() < fadeRatio * 0.8) {\n            pixels[pixelIndex + 3] = 0; // Set alpha to 0 (transparent)\n          } else {\n            // Gradually decrease opacity\n            pixels[pixelIndex + 3] = pixels[pixelIndex + 3] * (1 - fadeRatio);\n          }\n        }\n      }\n      ctx.putImageData(imageData, 0, startY);\n\n      // Add gradient overlay\n      const gradient = ctx.createLinearGradient(0, startY, 0, canvas.height);\n      gradient.addColorStop(0, 'rgba(0,0,0,0)');\n      gradient.addColorStop(1, backgroundColor);\n      ctx.fillStyle = gradient;\n      ctx.globalAlpha = 0.7;\n      ctx.fillRect(0, startY, canvas.width, fadeHeight);\n    }\n  }, [scrollPosition, parallaxIntensity, parallaxLimitPercent, clampParallax, position, opacity, blurAmount, fadeSize, backgroundColor, dimensions.width, dimensions.height, fitContainer, heightMultiplier]);\n\n  // Handle scroll events for parallax\n  useEffect(() => {\n    const handleScroll = () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      animationFrameRef.current = requestAnimationFrame(() => {\n        setScrollPosition(window.scrollY);\n      });\n    };\n    window.addEventListener('scroll', handleScroll, {\n      passive: true\n    });\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, []);\n\n  // Update canvas when scroll position changes (for parallax)\n  useEffect(() => {\n    if (imageLoaded && transitionEffect === 'dissolve') {\n      renderDissolveEffect();\n    }\n  }, [scrollPosition, imageLoaded, transitionEffect, renderDissolveEffect]);\n\n  // Update dimensions on resize and initialize canvas\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (containerRef.current) {\n        const rect = containerRef.current.getBoundingClientRect();\n        const newDimensions = {\n          width: rect.width,\n          height: rect.height\n        };\n        setDimensions(newDimensions);\n        if (canvasRef.current && transitionEffect === 'dissolve') {\n          canvasRef.current.width = newDimensions.width;\n          canvasRef.current.height = newDimensions.height;\n          if (imageLoaded) {\n            renderDissolveEffect();\n          }\n        }\n      }\n    };\n\n    // Load image if using canvas-based effects\n    if (transitionEffect === 'dissolve') {\n      const img = new Image();\n      img.crossOrigin = \"Anonymous\";\n      img.src = image;\n      img.onload = () => {\n        imageRef.current = img;\n        setImageLoaded(true);\n        updateDimensions();\n      };\n    }\n    updateDimensions();\n    window.addEventListener('resize', updateDimensions);\n    return () => {\n      window.removeEventListener('resize', updateDimensions);\n    };\n  }, [image, transitionEffect, renderDissolveEffect, imageLoaded]);\n\n  // Calculate parallax transformation for CSS-based version with clamping if enabled\n  let parallaxOffset = scrollPosition * parallaxIntensity;\n\n  // Clamp parallax movement if enabled\n  if (clampParallax && dimensions.height) {\n    const maxOffset = dimensions.height * parallaxLimitPercent / 100;\n    parallaxOffset = Math.max(Math.min(parallaxOffset, maxOffset), -maxOffset);\n  }\n\n  // Determine background position based on position setting\n  let bgPosition = backgroundPosition;\n  if (!bgPosition) {\n    switch (position) {\n      case 'top':\n        bgPosition = 'center top';\n        break;\n      case 'bottom':\n        bgPosition = 'center bottom';\n        break;\n      case 'middle':\n      default:\n        bgPosition = 'center center';\n    }\n  }\n\n  // Determine which edges should fade based on position setting\n  const shouldFadeTop = position === 'bottom' || position === 'middle';\n  const shouldFadeBottom = position === 'top' || position === 'middle';\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'relative',\n      width: '100%',\n      height,\n      overflow: 'hidden',\n      zIndex\n    },\n    children: [transitionEffect === 'gradient' && /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: fitContainer ? `${heightMultiplier * 100}%` : '100%',\n          backgroundImage: `url(${image})`,\n          backgroundSize: fitContainer ? 'contain' : backgroundSize,\n          backgroundRepeat: 'no-repeat',\n          backgroundPosition: bgPosition,\n          transform: `translateY(${parallaxOffset}px)`,\n          transition: 'transform 0.1s ease-out',\n          opacity,\n          filter: blurAmount > 0 ? `blur(${blurAmount}px)` : 'none'\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 338,\n        columnNumber: 11\n      }, this), shouldFadeTop && /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: `${fadeSize * 100}%`,\n          background: `linear-gradient(to bottom, ${backgroundColor} 0%, rgba(0,0,0,0) 100%)`,\n          pointerEvents: 'none'\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 358,\n        columnNumber: 13\n      }, this), shouldFadeBottom && /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: 'absolute',\n          bottom: 0,\n          left: 0,\n          width: '100%',\n          height: `${fadeSize * 100}%`,\n          background: `linear-gradient(to top, ${backgroundColor} 0%, rgba(0,0,0,0) 100%)`,\n          pointerEvents: 'none'\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 373,\n        columnNumber: 13\n      }, this)]\n    }, void 0, true), transitionEffect === 'dissolve' && /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 390,\n      columnNumber: 9\n    }, this), children && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: 'relative',\n        zIndex: 1,\n        width: '100%',\n        height: '100%'\n      },\n      children: children\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 404,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 325,\n    columnNumber: 5\n  }, this);\n};\n_s(SlidingBackground, \"LDoSKgKDReXShZyKLDGoDJW0aVI=\");\n_c = SlidingBackground;\nexport default SlidingBackground;\nvar _c;\n$RefreshReg$(_c, \"SlidingBackground\");","map":{"version":3,"names":["React","useRef","useEffect","useState","useCallback","jsxDEV","_jsxDEV","Fragment","_Fragment","SlidingBackground","image","position","height","parallaxIntensity","parallaxLimitPercent","clampParallax","fadeSize","backgroundColor","zIndex","blurAmount","opacity","backgroundSize","backgroundPosition","transitionEffect","fitContainer","heightMultiplier","children","_s","containerRef","canvasRef","scrollPosition","setScrollPosition","dimensions","setDimensions","width","imageLoaded","setImageLoaded","imageRef","animationFrameRef","renderDissolveEffect","current","canvas","ctx","getContext","img","clearRect","parallaxOffset","maxOffset","Math","max","min","imgAspect","canvasAspect","drawWidth","drawHeight","offsetX","offsetY","globalAlpha","drawImage","filter","shouldFadeTop","shouldFadeBottom","fadeHeight","floor","imageData","getImageData","pixels","data","y","fadeRatio","x","pixelIndex","random","putImageData","gradient","createLinearGradient","addColorStop","fillStyle","fillRect","startY","handleScroll","cancelAnimationFrame","requestAnimationFrame","window","scrollY","addEventListener","passive","removeEventListener","updateDimensions","rect","getBoundingClientRect","newDimensions","Image","crossOrigin","src","onload","bgPosition","ref","style","overflow","top","left","backgroundImage","backgroundRepeat","transform","transition","fileName","_jsxFileName","lineNumber","columnNumber","background","pointerEvents","bottom","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/effects/scrollingeffects/SlidingBackground.jsx"],"sourcesContent":["import React, { useRef, useEffect, useState, useCallback } from 'react';\n\n/**\n * SlidingBackground Component\n * \n * A highly configurable component that creates a parallax background with fade effects\n * that can be positioned at the top, middle, or bottom of the viewport.\n * \n * @param {Object} props - Component props\n * @param {string} props.image - URL of the background image\n * @param {string} [props.position='top'] - Position of the focused area ('top', 'middle', 'bottom')\n * @param {string|number} [props.height='33vh'] - Height of the component\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of the parallax effect (0-1)\n * @param {number} [props.parallaxLimitPercent=30] - Maximum percentage of component height the image can move with parallax\n * @param {boolean} [props.clampParallax=true] - Whether to clamp parallax movement to prevent image from moving too far\n * @param {number} [props.fadeSize=0.4] - Size of the fade effect (0-1, as a fraction of the component)\n * @param {string} [props.backgroundColor='#000'] - Background color for the fade effect\n * @param {number} [props.zIndex=0] - z-index of the component\n * @param {number} [props.blurAmount=0] - Amount of blur for the fade transition (px)\n * @param {number} [props.opacity=1] - Opacity of the background image\n * @param {string} [props.backgroundSize='cover'] - Background size property\n * @param {string} [props.backgroundPosition] - Background position (overrides position setting)\n * @param {string} [props.transitionEffect='gradient'] - Type of transition effect ('gradient', 'dissolve')\n * @param {boolean} [props.fitContainer=true] - Whether the background should be constrained to fit its container\n * @param {number} [props.heightMultiplier=1.2] - How much larger the background image should be than its container (1=same size)\n * @param {React.ReactNode} [props.children] - Content to render on top of the background\n */\nconst SlidingBackground = ({\n  image,\n  position = 'top',\n  height = '33vh',\n  parallaxIntensity = 0.2,\n  parallaxLimitPercent = 30,\n  clampParallax = true,\n  fadeSize = 0.4,\n  backgroundColor = '#000',\n  zIndex = 0,\n  blurAmount = 0,\n  opacity = 1,\n  backgroundSize = 'cover',\n  backgroundPosition,\n  transitionEffect = 'gradient',\n  fitContainer = true,\n  heightMultiplier = 1.2,\n  children\n}) => {\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const [scrollPosition, setScrollPosition] = useState(0);\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n  const [imageLoaded, setImageLoaded] = useState(false);\n  const imageRef = useRef(null);\n  const animationFrameRef = useRef(null);\n  \n  // Define renderDissolveEffect with useCallback BEFORE it's used in any useEffect\n  const renderDissolveEffect = useCallback(() => {\n    if (!canvasRef.current || !imageRef.current || !dimensions.width || !dimensions.height) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const img = imageRef.current;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // Calculate parallax offset with clamping if enabled\n    let parallaxOffset = scrollPosition * parallaxIntensity;\n    \n    // Clamp parallax movement if enabled\n    if (clampParallax) {\n      const maxOffset = (canvas.height * parallaxLimitPercent) / 100;\n      parallaxOffset = Math.max(Math.min(parallaxOffset, maxOffset), -maxOffset);\n    }\n    \n    // Calculate image dimensions to maintain aspect ratio while covering the canvas\n    const imgAspect = img.width / img.height;\n    const canvasAspect = canvas.width / canvas.height;\n    \n    let drawWidth, drawHeight, offsetX, offsetY;\n    \n    if (fitContainer) {\n      // Apply heightMultiplier to make image larger than container if needed\n      if (imgAspect > canvasAspect) {\n        // Image is wider than canvas (relative to height)\n        drawHeight = canvas.height * heightMultiplier;\n        drawWidth = drawHeight * imgAspect;\n        offsetX = (canvas.width - drawWidth) / 2;\n        offsetY = (canvas.height - drawHeight) / 2;\n      } else {\n        // Image is taller than canvas (relative to width)\n        drawWidth = canvas.width * heightMultiplier;\n        drawHeight = drawWidth / imgAspect;\n        offsetX = (canvas.width - drawWidth) / 2;\n        offsetY = (canvas.height - drawHeight) / 2;\n      }\n    } else {\n      // Original behavior - cover the canvas\n      if (imgAspect > canvasAspect) {\n        // Image is wider than canvas (relative to height)\n        drawHeight = canvas.height;\n        drawWidth = drawHeight * imgAspect;\n        offsetX = (canvas.width - drawWidth) / 2;\n        offsetY = 0;\n      } else {\n        // Image is taller than canvas (relative to width)\n        drawWidth = canvas.width;\n        drawHeight = drawWidth / imgAspect;\n        offsetX = 0;\n        offsetY = (canvas.height - drawHeight) / 2;\n      }\n    }\n    \n    // Adjust based on position setting\n    if (position === 'top') {\n      offsetY = 0;\n    } else if (position === 'bottom') {\n      offsetY = canvas.height - drawHeight;\n    } else if (position === 'middle') {\n      offsetY = (canvas.height - drawHeight) / 2;\n    }\n    \n    // Apply parallax\n    offsetY += parallaxOffset;\n    \n    // Draw the image\n    ctx.globalAlpha = opacity;\n    ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);\n    \n    // Apply blur if specified\n    if (blurAmount > 0) {\n      ctx.filter = `blur(${blurAmount}px)`;\n      ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);\n      ctx.filter = 'none';\n    }\n    \n    // Determine which edges should fade based on position\n    const shouldFadeTop = position === 'bottom' || position === 'middle';\n    const shouldFadeBottom = position === 'top' || position === 'middle';\n    \n    // Top dissolve effect\n    if (shouldFadeTop) {\n      const fadeHeight = Math.floor(canvas.height * fadeSize);\n      const imageData = ctx.getImageData(0, 0, canvas.width, fadeHeight);\n      const pixels = imageData.data;\n      \n      for (let y = 0; y < fadeHeight; y++) {\n        const fadeRatio = 1 - (y / fadeHeight);\n        \n        for (let x = 0; x < canvas.width; x++) {\n          const pixelIndex = (y * canvas.width + x) * 4;\n          \n          // Apply dissolve effect with random pattern\n          if (Math.random() < fadeRatio * 0.8) {\n            pixels[pixelIndex + 3] = 0; // Set alpha to 0 (transparent)\n          } else {\n            // Gradually decrease opacity\n            pixels[pixelIndex + 3] = pixels[pixelIndex + 3] * (1 - fadeRatio);\n          }\n        }\n      }\n      \n      ctx.putImageData(imageData, 0, 0);\n      \n      // Add gradient overlay\n      const gradient = ctx.createLinearGradient(0, 0, 0, fadeHeight);\n      gradient.addColorStop(0, backgroundColor);\n      gradient.addColorStop(1, 'rgba(0,0,0,0)');\n      \n      ctx.fillStyle = gradient;\n      ctx.globalAlpha = 0.7;\n      ctx.fillRect(0, 0, canvas.width, fadeHeight);\n    }\n    \n    // Bottom dissolve effect\n    if (shouldFadeBottom) {\n      const fadeHeight = Math.floor(canvas.height * fadeSize);\n      const startY = canvas.height - fadeHeight;\n      const imageData = ctx.getImageData(0, startY, canvas.width, fadeHeight);\n      const pixels = imageData.data;\n      \n      for (let y = 0; y < fadeHeight; y++) {\n        const fadeRatio = y / fadeHeight;\n        \n        for (let x = 0; x < canvas.width; x++) {\n          const pixelIndex = (y * canvas.width + x) * 4;\n          \n          // Apply dissolve effect with random pattern\n          if (Math.random() < fadeRatio * 0.8) {\n            pixels[pixelIndex + 3] = 0; // Set alpha to 0 (transparent)\n          } else {\n            // Gradually decrease opacity\n            pixels[pixelIndex + 3] = pixels[pixelIndex + 3] * (1 - fadeRatio);\n          }\n        }\n      }\n      \n      ctx.putImageData(imageData, 0, startY);\n      \n      // Add gradient overlay\n      const gradient = ctx.createLinearGradient(0, startY, 0, canvas.height);\n      gradient.addColorStop(0, 'rgba(0,0,0,0)');\n      gradient.addColorStop(1, backgroundColor);\n      \n      ctx.fillStyle = gradient;\n      ctx.globalAlpha = 0.7;\n      ctx.fillRect(0, startY, canvas.width, fadeHeight);\n    }\n  }, [\n    scrollPosition,\n    parallaxIntensity,\n    parallaxLimitPercent,\n    clampParallax,\n    position,\n    opacity,\n    blurAmount,\n    fadeSize,\n    backgroundColor,\n    dimensions.width,\n    dimensions.height,\n    fitContainer,\n    heightMultiplier\n  ]);\n  \n  // Handle scroll events for parallax\n  useEffect(() => {\n    const handleScroll = () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      \n      animationFrameRef.current = requestAnimationFrame(() => {\n        setScrollPosition(window.scrollY);\n      });\n    };\n    \n    window.addEventListener('scroll', handleScroll, { passive: true });\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, []);\n  \n  // Update canvas when scroll position changes (for parallax)\n  useEffect(() => {\n    if (imageLoaded && transitionEffect === 'dissolve') {\n      renderDissolveEffect();\n    }\n  }, [scrollPosition, imageLoaded, transitionEffect, renderDissolveEffect]);\n  \n  // Update dimensions on resize and initialize canvas\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (containerRef.current) {\n        const rect = containerRef.current.getBoundingClientRect();\n        const newDimensions = { \n          width: rect.width, \n          height: rect.height \n        };\n        \n        setDimensions(newDimensions);\n        \n        if (canvasRef.current && transitionEffect === 'dissolve') {\n          canvasRef.current.width = newDimensions.width;\n          canvasRef.current.height = newDimensions.height;\n          \n          if (imageLoaded) {\n            renderDissolveEffect();\n          }\n        }\n      }\n    };\n    \n    // Load image if using canvas-based effects\n    if (transitionEffect === 'dissolve') {\n      const img = new Image();\n      img.crossOrigin = \"Anonymous\";\n      img.src = image;\n      img.onload = () => {\n        imageRef.current = img;\n        setImageLoaded(true);\n        updateDimensions();\n      };\n    }\n    \n    updateDimensions();\n    window.addEventListener('resize', updateDimensions);\n    \n    return () => {\n      window.removeEventListener('resize', updateDimensions);\n    };\n  }, [image, transitionEffect, renderDissolveEffect, imageLoaded]);\n  \n  // Calculate parallax transformation for CSS-based version with clamping if enabled\n  let parallaxOffset = scrollPosition * parallaxIntensity;\n  \n  // Clamp parallax movement if enabled\n  if (clampParallax && dimensions.height) {\n    const maxOffset = (dimensions.height * parallaxLimitPercent) / 100;\n    parallaxOffset = Math.max(Math.min(parallaxOffset, maxOffset), -maxOffset);\n  }\n  \n  // Determine background position based on position setting\n  let bgPosition = backgroundPosition;\n  if (!bgPosition) {\n    switch (position) {\n      case 'top':\n        bgPosition = 'center top';\n        break;\n      case 'bottom':\n        bgPosition = 'center bottom';\n        break;\n      case 'middle':\n      default:\n        bgPosition = 'center center';\n    }\n  }\n  \n  // Determine which edges should fade based on position setting\n  const shouldFadeTop = position === 'bottom' || position === 'middle';\n  const shouldFadeBottom = position === 'top' || position === 'middle';\n  \n  return (\n    <div\n      ref={containerRef}\n      style={{\n        position: 'relative',\n        width: '100%',\n        height,\n        overflow: 'hidden',\n        zIndex\n      }}\n    >\n      {/* CSS-based gradient transition */}\n      {transitionEffect === 'gradient' && (\n        <>\n          <div\n            style={{\n              position: 'absolute',\n              top: 0,\n              left: 0,\n              width: '100%',\n              height: fitContainer ? `${heightMultiplier * 100}%` : '100%',\n              backgroundImage: `url(${image})`,\n              backgroundSize: fitContainer ? 'contain' : backgroundSize,\n              backgroundRepeat: 'no-repeat',\n              backgroundPosition: bgPosition,\n              transform: `translateY(${parallaxOffset}px)`,\n              transition: 'transform 0.1s ease-out',\n              opacity,\n              filter: blurAmount > 0 ? `blur(${blurAmount}px)` : 'none'\n            }}\n          />\n          \n          {/* Top fade gradient */}\n          {shouldFadeTop && (\n            <div\n              style={{\n                position: 'absolute',\n                top: 0,\n                left: 0,\n                width: '100%',\n                height: `${fadeSize * 100}%`,\n                background: `linear-gradient(to bottom, ${backgroundColor} 0%, rgba(0,0,0,0) 100%)`,\n                pointerEvents: 'none'\n              }}\n            />\n          )}\n          \n          {/* Bottom fade gradient */}\n          {shouldFadeBottom && (\n            <div\n              style={{\n                position: 'absolute',\n                bottom: 0,\n                left: 0,\n                width: '100%',\n                height: `${fadeSize * 100}%`,\n                background: `linear-gradient(to top, ${backgroundColor} 0%, rgba(0,0,0,0) 100%)`,\n                pointerEvents: 'none'\n              }}\n            />\n          )}\n        </>\n      )}\n      \n      {/* Canvas-based dissolve transition */}\n      {transitionEffect === 'dissolve' && (\n        <canvas\n          ref={canvasRef}\n          style={{\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            width: '100%',\n            height: '100%'\n          }}\n        />\n      )}\n      \n      {/* Content container */}\n      {children && (\n        <div\n          style={{\n            position: 'relative',\n            zIndex: 1,\n            width: '100%',\n            height: '100%'\n          }}\n        >\n          {children}\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default SlidingBackground;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}