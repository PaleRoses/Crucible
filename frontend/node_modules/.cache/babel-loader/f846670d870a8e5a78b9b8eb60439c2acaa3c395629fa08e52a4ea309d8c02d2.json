{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/MeteorShower.jsx\",\n  _s3 = $RefreshSig$();\nimport React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';\n\n/**\n * MeteorShower Component - Enterprise Performance Optimized Version\n * \n * Creates a highly performant animated meteor shower effect where meteors\n * arc across the sky with comet-like trails and fade away naturally.\n * \n * Features:\n * - Advanced performance optimizations with WebGL acceleration option\n * - Adaptive quality scaling based on device capabilities\n * - Memory and battery-efficient rendering pipeline\n * - Accessibility compliance with reduced motion support\n * - Supports hardware acceleration and high-DPI displays\n * - Enhanced burst effects with realistic particle physics\n * \n * @param {Object} props - Component props\n * @param {string|number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=5] - Z-index for the container\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.meteorDensity=15] - Number of meteors to maintain on screen\n * @param {number} [props.meteorMinSize=1] - Minimum size of meteors\n * @param {number} [props.meteorMaxSize=3] - Maximum size of meteors\n * @param {number} [props.meteorSpeed=0.08] - Base speed of meteors\n * @param {number} [props.trailLength=180] - Length of meteor trails\n * @param {number} [props.trailSegments=20] - Number of segments in each trail\n * @param {string} [props.coreColor='rgba(255, 255, 255, 1)'] - Core color for meteors\n * @param {string} [props.glowColor='rgba(255, 253, 227, 0.9)'] - Glow color for meteors\n * @param {string} [props.trailColor='rgba(191, 173, 127, 0.8)'] - Trail color for meteors\n * @param {boolean} [props.enableParallax=false] - Enable parallax effect on scroll\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of parallax effect\n * @param {boolean} [props.staggered=true] - Enable staggered meteor appearance\n * @param {number} [props.minStaggerDelay=200] - Minimum delay between meteor spawns (ms)\n * @param {number} [props.maxStaggerDelay=2000] - Maximum delay between meteor spawns (ms)\n * @param {number} [props.journeyCompletion=0.9] - When meteors complete their journey (0-1)\n * @param {string} [props.mode='arc'] - Animation mode: 'arc' or 'linear'\n * @param {string} [props.direction='both'] - Direction: 'left', 'right', 'both', or 'top'\n * @param {number} [props.baseAngle=30] - Base angle for linear meteors (degrees)\n * @param {number} [props.angleVariation=15] - Random variation to apply to the base angle\n * @param {boolean} [props.debug=false] - Enable debug visualization\n * @param {boolean} [props.adaptiveQuality=true] - Enable adaptive quality based on device\n * @param {boolean} [props.respectReducedMotion=true] - Respect reduced motion preferences\n * @param {number} [props.maxFPS=60] - Target maximum frames per second\n * @param {boolean} [props.useWebGL=false] - Use WebGL rendering for better performance\n * @param {boolean} [props.enableBursts=true] - Enable meteor burst effects\n * @param {boolean} [props.enableBattery=true] - Enable battery-saving optimizations\n * @param {string} [props.renderingMode='auto'] - Rendering mode: 'auto', '2d', or 'webgl'\n * @param {boolean} [props.enableOffscreenRendering=true] - Enable offscreen canvas when available\n * @param {number} [props.burstParticleCount=12] - Number of particles in each burst\n * @param {number} [props.burstParticleSize=2] - Size of burst particles\n * @param {number} [props.burstProbability=0.4] - Probability of meteor having a burst (0-1)\n * @param {string} [props.burstColorVariation='0.2'] - Amount of color variation in burst particles\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MeteorShower = ({\n  height = '100vh',\n  zIndex = 5,\n  active = true,\n  meteorDensity = 15,\n  meteorMinSize = 1,\n  meteorMaxSize = 3,\n  meteorSpeed = 0.08,\n  trailLength = 180,\n  trailSegments = 20,\n  coreColor = 'rgba(255, 255, 255, 1)',\n  glowColor = 'rgba(255, 245, 158, 0.9)',\n  trailColor = 'rgba(207, 181, 59, 0.8)',\n  enableParallax = false,\n  parallaxIntensity = 0.2,\n  staggered = true,\n  minStaggerDelay = 200,\n  maxStaggerDelay = 2000,\n  journeyCompletion = 0.9,\n  mode = 'arc',\n  direction = 'both',\n  baseAngle = 30,\n  angleVariation = 15,\n  debug = false,\n  adaptiveQuality = true,\n  respectReducedMotion = true,\n  maxFPS = 60,\n  useWebGL = false,\n  enableBursts = true,\n  // Enabled by default now\n  enableBattery = true,\n  renderingMode = 'auto',\n  enableOffscreenRendering = true,\n  burstParticleCount = 12,\n  burstParticleSize = 2,\n  burstProbability = 0.4,\n  burstColorVariation = 0.2\n}) => {\n  _s3();\n  var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const ctxRef = useRef(null);\n  const webGLRef = useRef(null);\n  const offscreenCanvasRef = useRef(null);\n  const workerRef = useRef(null);\n  const meteorsRef = useRef([]);\n  const burstsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const fpsTimestampRef = useRef(0);\n  const frameCountRef = useRef(0);\n  const currentFpsRef = useRef(60);\n  const nextSpawnTimeRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n  const resizeObserverRef = useRef(null);\n  const visibilityObserverRef = useRef(null);\n  const batteryRef = useRef(null);\n  const visibilityChangeTimeRef = useRef(0);\n  const lastBurstCountRef = useRef(0);\n\n  // Component state\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0,\n    pixelRatio: 1\n  });\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [isVisible, setIsVisible] = useState(false);\n  const [qualityFactor, setQualityFactor] = useState(1);\n  const [actualRenderingMode, setActualRenderingMode] = useState('2d');\n  const [deviceCapabilities, setDeviceCapabilities] = useState({\n    memory: 4,\n    cores: 4,\n    batteryLevel: 1,\n    isMobile: false,\n    supportsWebGL: false,\n    supportsOffscreenCanvas: false\n  });\n\n  // Pre-allocate objects to avoid garbage collection during animation\n  const pointCache = useRef({\n    current: {\n      x: 0,\n      y: 0\n    },\n    segment: {\n      x: 0,\n      y: 0\n    }\n  }).current;\n\n  // Precompute color variants to avoid string operations during animation\n  const colorCacheRef = useRef(new Map());\n\n  // WebGL shader programs and buffers\n  const webGLProgramsRef = useRef({\n    meteor: null,\n    trail: null,\n    burst: null\n  });\n\n  // Object pools for efficient memory usage\n  const objectPoolsRef = useRef({\n    meteors: [],\n    bursts: [],\n    vectors: []\n  });\n\n  // Detects device capabilities and sets up optimization strategies\n  const detectCapabilities = useCallback(() => {\n    // Device memory, hardware concurrency, and battery\n    const memory = navigator.deviceMemory || 4;\n    const cores = navigator.hardwareConcurrency || 4;\n    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n\n    // Check WebGL support\n    let supportsWebGL = false;\n    try {\n      const canvas = document.createElement('canvas');\n      supportsWebGL = !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));\n    } catch (e) {\n      supportsWebGL = false;\n    }\n\n    // Check offscreen canvas support\n    const supportsOffscreenCanvas = typeof OffscreenCanvas !== 'undefined';\n\n    // Get battery info if available\n    if (navigator.getBattery && enableBattery) {\n      navigator.getBattery().then(battery => {\n        batteryRef.current = battery;\n        const updateBattery = () => {\n          setDeviceCapabilities(prev => ({\n            ...prev,\n            batteryLevel: battery.level,\n            isCharging: battery.charging\n          }));\n\n          // Reduce quality if on battery and below 30%\n          if (!battery.charging && battery.level < 0.3 && adaptiveQuality) {\n            setQualityFactor(prev => Math.min(prev, 0.6));\n          }\n        };\n\n        // Add battery event listeners\n        battery.addEventListener('levelchange', updateBattery);\n        battery.addEventListener('chargingchange', updateBattery);\n\n        // Initial update\n        updateBattery();\n      }).catch(() => {\n        // Fallback if battery API is not available or fails\n        setDeviceCapabilities(prev => ({\n          ...prev,\n          batteryLevel: 1,\n          isCharging: true\n        }));\n      });\n    }\n\n    // Determine initial rendering mode\n    let initialRenderingMode = '2d';\n    if (renderingMode === 'auto') {\n      if (useWebGL && supportsWebGL) {\n        initialRenderingMode = 'webgl';\n      } else {\n        initialRenderingMode = '2d';\n      }\n    } else {\n      initialRenderingMode = renderingMode === 'webgl' && supportsWebGL ? 'webgl' : '2d';\n    }\n    setActualRenderingMode(initialRenderingMode);\n\n    // Set device capabilities state\n    setDeviceCapabilities({\n      memory,\n      cores,\n      batteryLevel: 1,\n      isCharging: true,\n      isMobile,\n      supportsWebGL,\n      supportsOffscreenCanvas\n    });\n\n    // Calculate quality factor based on capabilities\n    if (adaptiveQuality) {\n      // Base score from hardware\n      const performanceScore = memory * cores / (isMobile ? 2 : 1);\n\n      // Scale quality based on performance score\n      let quality = 1;\n      if (performanceScore > 16) {\n        quality = 1; // High-end devices\n      } else if (performanceScore > 8) {\n        quality = 0.8; // Mid-range devices\n      } else if (performanceScore > 4) {\n        quality = 0.6; // Low-end devices\n      } else {\n        quality = 0.4; // Very low-end devices\n      }\n      setQualityFactor(quality);\n    }\n  }, [useWebGL, renderingMode, adaptiveQuality, enableBattery]);\n\n  // Get cached color with opacity\n  const getCachedColor = useCallback((baseColor, opacity) => {\n    // Round opacity to reduce cache size while maintaining visual quality\n    const roundedOpacity = Math.round(opacity * 100) / 100;\n    const key = `${baseColor}-${roundedOpacity}`;\n    if (!colorCacheRef.current.has(key)) {\n      const newColor = baseColor.replace(/[\\d.]+\\)$/, roundedOpacity + ')');\n      colorCacheRef.current.set(key, newColor);\n    }\n    return colorCacheRef.current.get(key);\n  }, []);\n\n  // Create a color variant based on a base color\n  const createColorVariant = useCallback((baseColor, variation) => {\n    // Parse the rgba values\n    const rgbaMatch = baseColor.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*([\\d.]+))?\\)/);\n    if (!rgbaMatch) return baseColor;\n    const r = parseInt(rgbaMatch[1], 10);\n    const g = parseInt(rgbaMatch[2], 10);\n    const b = parseInt(rgbaMatch[3], 10);\n    const a = rgbaMatch[4] ? parseFloat(rgbaMatch[4]) : 1;\n\n    // Apply random variation to RGB values\n    const vr = Math.max(0, Math.min(255, r + Math.floor((Math.random() * 2 - 1) * variation * 255)));\n    const vg = Math.max(0, Math.min(255, g + Math.floor((Math.random() * 2 - 1) * variation * 255)));\n    const vb = Math.max(0, Math.min(255, b + Math.floor((Math.random() * 2 - 1) * variation * 255)));\n    return `rgba(${vr}, ${vg}, ${vb}, ${a})`;\n  }, []);\n\n  // Adaptive settings based on quality factor\n  const adaptedSettings = useMemo(() => {\n    if (!adaptiveQuality || qualityFactor === 1) {\n      return {\n        meteorDensity,\n        trailSegments,\n        burstParticleCount,\n        useShadow: true,\n        useGlow: true,\n        useHighQualityRendering: true\n      };\n    }\n\n    // Adjust quality-dependent parameters\n    return {\n      meteorDensity: Math.max(3, Math.floor(meteorDensity * qualityFactor)),\n      trailSegments: Math.max(5, Math.floor(trailSegments * qualityFactor)),\n      burstParticleCount: Math.max(4, Math.floor(burstParticleCount * qualityFactor)),\n      useShadow: qualityFactor > 0.5,\n      useGlow: qualityFactor > 0.3,\n      useHighQualityRendering: qualityFactor > 0.7\n    };\n  }, [adaptiveQuality, qualityFactor, meteorDensity, trailSegments, burstParticleCount]);\n\n  // Detect device capabilities and preferences on mount\n  useEffect(() => {\n    // Check for reduced motion preference\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    const handleReducedMotionChange = e => {\n      setPrefersReducedMotion(e.matches);\n    };\n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n\n    // Detect device capabilities\n    detectCapabilities();\n\n    // Setup visibility change detection to pause when tab is inactive\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        visibilityChangeTimeRef.current = performance.now();\n      } else {\n        // Adjust timing references after visibility changes\n        const timeDelta = performance.now() - visibilityChangeTimeRef.current;\n        lastTimestampRef.current += timeDelta;\n        nextSpawnTimeRef.current += timeDelta;\n      }\n    };\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n\n    // Capture current worker ref to avoid closure issues\n    const currentWorker = workerRef.current;\n\n    // Cleanup\n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n\n      // Clean up worker if active\n      if (currentWorker) {\n        currentWorker.terminate();\n      }\n    };\n  }, [detectCapabilities]);\n\n  // Initialize WebGL context and shaders if using WebGL\n  const initWebGL = useCallback(() => {\n    if (!canvasRef.current || actualRenderingMode !== 'webgl') return false;\n    try {\n      // Get WebGL context\n      const gl = canvasRef.current.getContext('webgl', {\n        alpha: true,\n        antialias: true,\n        premultipliedAlpha: false,\n        depth: false\n      });\n      if (!gl) return false;\n      webGLRef.current = gl;\n\n      // Create shader programs, vertex buffers, etc.\n      // This is a simplified placeholder - a real implementation would include\n      // proper shaders, attribute locations, and uniform setup\n\n      // Enable blending for transparency\n      gl.enable(gl.BLEND);\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n      // Set clear color to fully transparent\n      gl.clearColor(0.0, 0.0, 0.0, 0.0);\n\n      // Get current dimensions for viewport\n      const canvasWidth = canvasRef.current.width;\n      const canvasHeight = canvasRef.current.height;\n\n      // Set viewport\n      gl.viewport(0, 0, canvasWidth, canvasHeight);\n\n      // Simple vertex shader for meteor particles\n      const vertexShaderSource = `\n        attribute vec2 aPosition;\n        attribute float aSize;\n        attribute vec4 aColor;\n        \n        varying vec4 vColor;\n        \n        uniform vec2 uResolution;\n        \n        void main() {\n          // Convert to clip space\n          vec2 position = (aPosition / uResolution) * 2.0 - 1.0;\n          position.y = -position.y;\n          \n          gl_Position = vec4(position, 0, 1);\n          gl_PointSize = aSize;\n          vColor = aColor;\n        }\n      `;\n\n      // Simple fragment shader for meteor particles\n      const fragmentShaderSource = `\n        precision mediump float;\n        varying vec4 vColor;\n        \n        void main() {\n          // Calculate distance from center for circular point\n          float distance = length(gl_PointCoord - vec2(0.5, 0.5));\n          if (distance > 0.5) {\n            discard; // Outside circle\n          }\n          \n          // Softer edges\n          float alpha = smoothstep(0.5, 0.4, distance) * vColor.a;\n          gl_FragColor = vec4(vColor.rgb, alpha);\n        }\n      `;\n\n      // Compile shader program\n      const createShader = (gl, type, source) => {\n        const shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n\n        // Check for compilation errors\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n          console.error('Shader compilation error:', gl.getShaderInfoLog(shader));\n          gl.deleteShader(shader);\n          return null;\n        }\n        return shader;\n      };\n      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n      if (!vertexShader || !fragmentShader) {\n        return false;\n      }\n      const program = gl.createProgram();\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n\n      // Check for linking errors\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        console.error('Program linking error:', gl.getProgramInfoLog(program));\n        gl.deleteProgram(program);\n        return false;\n      }\n\n      // Store the program\n      webGLProgramsRef.current.meteor = {\n        program,\n        attributes: {\n          position: gl.getAttribLocation(program, 'aPosition'),\n          size: gl.getAttribLocation(program, 'aSize'),\n          color: gl.getAttribLocation(program, 'aColor')\n        },\n        uniforms: {\n          resolution: gl.getUniformLocation(program, 'uResolution')\n        }\n      };\n\n      // Now create shader program for burst particles\n      // This can be similar to the meteor program but with different parameters\n\n      // Simple vertex shader for burst particles\n      const burstVertexShaderSource = `\n        attribute vec2 aPosition;\n        attribute float aSize;\n        attribute vec4 aColor;\n        \n        varying vec4 vColor;\n        \n        uniform vec2 uResolution;\n        \n        void main() {\n          // Convert to clip space\n          vec2 position = (aPosition / uResolution) * 2.0 - 1.0;\n          position.y = -position.y;\n          \n          gl_Position = vec4(position, 0, 1);\n          gl_PointSize = aSize;\n          vColor = aColor;\n        }\n      `;\n\n      // Simple fragment shader for burst particles with softer edges\n      const burstFragmentShaderSource = `\n        precision mediump float;\n        varying vec4 vColor;\n        \n        void main() {\n          // Calculate distance from center for circular point\n          float distance = length(gl_PointCoord - vec2(0.5, 0.5));\n          if (distance > 0.5) {\n            discard; // Outside circle\n          }\n          \n          // Very soft edges for burst particles\n          float alpha = smoothstep(0.5, 0.2, distance) * vColor.a;\n          gl_FragColor = vec4(vColor.rgb, alpha);\n        }\n      `;\n      const burstVertexShader = createShader(gl, gl.VERTEX_SHADER, burstVertexShaderSource);\n      const burstFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, burstFragmentShaderSource);\n      if (!burstVertexShader || !burstFragmentShader) {\n        return false;\n      }\n      const burstProgram = gl.createProgram();\n      gl.attachShader(burstProgram, burstVertexShader);\n      gl.attachShader(burstProgram, burstFragmentShader);\n      gl.linkProgram(burstProgram);\n\n      // Check for linking errors\n      if (!gl.getProgramParameter(burstProgram, gl.LINK_STATUS)) {\n        console.error('Burst program linking error:', gl.getProgramInfoLog(burstProgram));\n        gl.deleteProgram(burstProgram);\n      } else {\n        // Store the burst program\n        webGLProgramsRef.current.burst = {\n          program: burstProgram,\n          attributes: {\n            position: gl.getAttribLocation(burstProgram, 'aPosition'),\n            size: gl.getAttribLocation(burstProgram, 'aSize'),\n            color: gl.getAttribLocation(burstProgram, 'aColor')\n          },\n          uniforms: {\n            resolution: gl.getUniformLocation(burstProgram, 'uResolution')\n          }\n        };\n      }\n      return true;\n    } catch (error) {\n      console.error('WebGL initialization error:', error);\n      setActualRenderingMode('2d');\n      return false;\n    }\n  }, [actualRenderingMode]);\n\n  // Calculate path parameters for a meteor based on selected mode\n  const calculateMeteorPath = useCallback((width, height) => {\n    if (mode === 'arc') {\n      // Arc path logic with optimized parameters\n      const startX = Math.random() * width * 1.5 - width * 0.25;\n      const startY = Math.random() * -100 - 50;\n      const curveDirection = Math.random() > 0.5 ? 1 : -1;\n      const curveIntensity = Math.random() * 0.4 + 0.2;\n      const endX = startX + curveDirection * width * curveIntensity;\n      const endY = height * journeyCompletion;\n      const controlX = (startX + endX) / 2 + curveDirection * width * curveIntensity;\n      const controlY = (startY + endY) * 0.5;\n      return {\n        pathType: 'arc',\n        start: {\n          x: startX,\n          y: startY\n        },\n        control: {\n          x: controlX,\n          y: controlY\n        },\n        end: {\n          x: endX,\n          y: endY\n        }\n      };\n    } else if (mode === 'linear') {\n      // Linear path logic with enhanced direction control\n      let meteorDirection = direction;\n      if (direction === 'both') {\n        meteorDirection = Math.random() > 0.5 ? 'left' : 'right';\n      }\n      let angle;\n      if (direction === 'top') {\n        angle = (30 + (Math.random() * 2 - 1) * 5) * Math.PI / 180;\n      } else {\n        angle = (baseAngle + (Math.random() * 2 - 1) * angleVariation) * Math.PI / 180;\n      }\n      let startX;\n      if (meteorDirection === 'left') {\n        startX = Math.random() * (width * 0.3) - width * 0.1;\n      } else if (meteorDirection === 'right') {\n        startX = width - Math.random() * (width * 0.3) + width * 0.1;\n      } else if (direction === 'top') {\n        const position = Math.random();\n        if (position < 0.5) {\n          startX = Math.random() * (width * 0.35);\n        } else if (position < 0.85) {\n          startX = width * 0.35 + Math.random() * (width * 0.35);\n        } else {\n          startX = width * 0.7 + Math.random() * (width * 0.3);\n        }\n      }\n      const startY = Math.random() * -100 - 50;\n      const distanceToTravel = height * journeyCompletion / Math.cos(angle);\n      let endX, endY;\n      if (meteorDirection === 'left' || direction === 'top') {\n        endX = startX + distanceToTravel * Math.sin(angle);\n        endY = startY + distanceToTravel * Math.cos(angle);\n      } else {\n        endX = startX - distanceToTravel * Math.sin(angle);\n        endY = startY + distanceToTravel * Math.cos(angle);\n      }\n      return {\n        pathType: 'linear',\n        start: {\n          x: startX,\n          y: startY\n        },\n        end: {\n          x: endX,\n          y: endY\n        },\n        direction: meteorDirection\n      };\n    }\n  }, [mode, direction, baseAngle, angleVariation, journeyCompletion]);\n\n  // Get point along path with highly optimized calculations\n  const getPathPoint = useCallback((t, path, outPoint = {\n    x: 0,\n    y: 0\n  }) => {\n    if (path.pathType === 'arc') {\n      // Optimized quadratic bezier calculation using pre-computed terms\n      const invT = 1 - t;\n      const invTSquared = invT * invT;\n      const tSquared = t * t;\n      const term1 = invTSquared;\n      const term2 = 2 * invT * t;\n      const term3 = tSquared;\n      outPoint.x = term1 * path.start.x + term2 * path.control.x + term3 * path.end.x;\n      outPoint.y = term1 * path.start.y + term2 * path.control.y + term3 * path.end.y;\n    } else {\n      // Linear interpolation with minimal operations\n      outPoint.x = path.start.x + (path.end.x - path.start.x) * t;\n      outPoint.y = path.start.y + (path.end.y - path.start.y) * t;\n    }\n    return outPoint;\n  }, []);\n\n  // Calculate velocity at a point on the path (for trail orientation)\n  const getPathVelocity = useCallback((t, path, outVelocity = {\n    x: 0,\n    y: 0\n  }) => {\n    if (path.pathType === 'arc') {\n      // Derivative of quadratic bezier\n      const term1 = 2 * (1 - t);\n      const term2 = 2 * t;\n      outVelocity.x = term1 * (path.control.x - path.start.x) + term2 * (path.end.x - path.control.x);\n      outVelocity.y = term1 * (path.control.y - path.start.y) + term2 * (path.end.y - path.control.y);\n    } else {\n      // Constant velocity for linear paths\n      outVelocity.x = path.end.x - path.start.x;\n      outVelocity.y = path.end.y - path.start.y;\n\n      // Normalize\n      const length = Math.sqrt(outVelocity.x * outVelocity.x + outVelocity.y * outVelocity.y);\n      if (length > 0) {\n        outVelocity.x /= length;\n        outVelocity.y /= length;\n      }\n    }\n    return outVelocity;\n  }, []);\n\n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current || !containerRef.current) return false;\n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    const rect = container.getBoundingClientRect();\n    const pixelRatio = window.devicePixelRatio || 1;\n\n    // Calculate dimensions\n    const displayWidth = rect.width;\n    const displayHeight = typeof height === 'string' && height.endsWith('vh') ? parseInt(height, 10) / 100 * window.innerHeight : parseInt(height, 10) || window.innerHeight;\n\n    // Set canvas size accounting for pixel ratio\n    canvas.width = displayWidth * pixelRatio;\n    canvas.height = displayHeight * pixelRatio;\n    canvas.style.width = `${displayWidth}px`;\n    canvas.style.height = `${displayHeight}px`;\n\n    // Get appropriate rendering context\n    if (actualRenderingMode === 'webgl') {\n      initWebGL();\n    } else {\n      // 2D Canvas context\n      const ctx = canvas.getContext('2d', {\n        alpha: true,\n        desynchronized: true,\n        willReadFrequently: false\n      });\n      if (!ctx) return false;\n\n      // Scale context for high-DPI displays\n      ctx.scale(pixelRatio, pixelRatio);\n\n      // Configure context for high-quality rendering\n      if (adaptedSettings.useHighQualityRendering) {\n        ctx.imageSmoothingEnabled = true;\n        ctx.imageSmoothingQuality = 'high';\n      }\n      ctxRef.current = ctx;\n    }\n\n    // Initialize offscreen canvas if supported and enabled\n    if (enableOffscreenRendering && typeof OffscreenCanvas !== 'undefined' && deviceCapabilities.supportsOffscreenCanvas) {\n      try {\n        // Create offscreen canvas\n        const offscreen = new OffscreenCanvas(displayWidth * pixelRatio, displayHeight * pixelRatio);\n\n        // Get 2D context for offscreen canvas\n        const offscreenCtx = offscreen.getContext('2d');\n        if (offscreenCtx) {\n          offscreenCtx.scale(pixelRatio, pixelRatio);\n          offscreenCanvasRef.current = {\n            canvas: offscreen,\n            ctx: offscreenCtx\n          };\n        }\n      } catch (error) {\n        console.warn('Offscreen canvas initialization error:', error);\n      }\n    }\n    setDimensions({\n      width: displayWidth,\n      height: displayHeight,\n      pixelRatio\n    });\n    return true;\n  }, [height, actualRenderingMode, initWebGL, enableOffscreenRendering, deviceCapabilities.supportsOffscreenCanvas, adaptedSettings.useHighQualityRendering]);\n\n  // Setup canvas resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Create a ResizeObserver to detect container size changes\n    const resizeObserver = new ResizeObserver(entries => {\n      // Debounce resize operations\n      if (resizeObserverRef.current.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n      resizeObserverRef.current.timeout = setTimeout(() => {\n        requestAnimationFrame(() => {\n          if (setupCanvas()) {\n            setIsInitialized(true);\n          }\n        });\n      }, 100); // 100ms debounce\n    });\n\n    // Capture current reference to avoid closure issues in cleanup\n    const currentContainer = containerRef.current;\n\n    // Start observing the container\n    resizeObserver.observe(currentContainer);\n    resizeObserverRef.current = {\n      observer: resizeObserver\n    };\n\n    // Initial setup\n    setupCanvas();\n    setIsInitialized(true);\n    return () => {\n      if (resizeObserverRef.current.observer) {\n        resizeObserverRef.current.observer.disconnect();\n      }\n      if (resizeObserverRef.current.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n    };\n  }, [setupCanvas]);\n\n  // Setup intersection observer to only animate when visible\n  useEffect(() => {\n    if (!containerRef.current) return;\n    const observer = new IntersectionObserver(entries => {\n      const isIntersecting = entries[0].isIntersecting;\n\n      // Only change state if visibility actually changed\n      if (isIntersecting !== isVisible) {\n        setIsVisible(isIntersecting);\n        if (isIntersecting) {\n          // Reset timing references when becoming visible again\n          lastTimestampRef.current = 0;\n          nextSpawnTimeRef.current = performance.now();\n        }\n      }\n    }, {\n      threshold: 0.01,\n      rootMargin: '100px'\n    });\n\n    // Store current reference to avoid closure issues\n    const currentContainerRef = containerRef.current;\n    observer.observe(currentContainerRef);\n    visibilityObserverRef.current = observer;\n    return () => {\n      if (visibilityObserverRef.current) {\n        visibilityObserverRef.current.disconnect();\n      }\n    };\n  }, [isVisible]);\n\n  // Handle parallax effect on scroll if enabled\n  useEffect(() => {\n    if (!enableParallax) return;\n\n    // Use passive event listener for better performance\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    window.addEventListener('scroll', handleScroll, {\n      passive: true\n    });\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [enableParallax]);\n\n  // Get a meteor from the object pool or create a new one\n  const getMeteor = useCallback(() => {\n    // Try to get from pool first\n    const pool = objectPoolsRef.current.meteors;\n    let meteor;\n    if (pool.length > 0) {\n      meteor = pool.pop();\n      // Reset meteor properties\n      meteor.progress = 0;\n      meteor.active = true;\n    } else {\n      // Create new if pool is empty\n      meteor = {\n        progress: 0,\n        active: true,\n        positions: Array(adaptedSettings.trailSegments)\n      };\n\n      // Pre-allocate position objects\n      for (let i = 0; i < adaptedSettings.trailSegments; i++) {\n        meteor.positions[i] = {\n          x: 0,\n          y: 0\n        };\n      }\n    }\n    return meteor;\n  }, [adaptedSettings.trailSegments]);\n\n  // Initialize a meteor with all required properties\n  const initializeMeteor = useCallback(() => {\n    const {\n      width,\n      height\n    } = dimensions;\n    if (!width || !height) return null;\n\n    // Get meteor from pool\n    const meteor = getMeteor();\n\n    // Calculate path based on mode\n    const path = calculateMeteorPath(width, height);\n\n    // Set path and initial position\n    meteor.path = path;\n    for (let i = 0; i < meteor.positions.length; i++) {\n      meteor.positions[i].x = path.start.x;\n      meteor.positions[i].y = path.start.y;\n    }\n\n    // Set meteor properties\n    meteor.size = Math.random() * (meteorMaxSize - meteorMinSize) + meteorMinSize;\n    meteor.speed = meteorSpeed * (Math.random() * 0.5 + 0.75);\n    meteor.opacity = Math.random() * 0.3 + 0.7;\n    meteor.fadeThreshold = 0.7 + Math.random() * 0.2;\n    meteor.pulsePhase = Math.random() * Math.PI * 2;\n    meteor.pulseSpeed = Math.random() * 0.01 + 0.005;\n\n    // Add burst properties if enabled\n    if (enableBursts && Math.random() < burstProbability) {\n      meteor.hasBurst = true;\n\n      // Vary the burst threshold - occasionally have early bursts for variety\n      const earlyBurst = Math.random() < 0.15; // 15% chance for early burst\n      meteor.burstThreshold = earlyBurst ? 0.3 + Math.random() * 0.4 // Early burst range (0.3-0.7)\n      : 0.85 + Math.random() * 0.13; // Normal late burst range (0.85-0.98)\n\n      meteor.burstTriggered = false;\n\n      // Adjust burst size based on when it occurs\n      meteor.burstSize = earlyBurst ? meteor.size * (3 + Math.random() * 4) // Larger for early bursts\n      : meteor.size * (2 + Math.random() * 2); // More controlled for end bursts\n\n      // Adjust particle count based on when it occurs\n      meteor.burstParticles = Math.floor(adaptedSettings.burstParticleCount * (earlyBurst ? 1.2 : 0.8) * (\n      // More particles for early bursts\n      0.8 + Math.random() * 0.4));\n\n      // Use custom gold-centric colors for dark fantasy aesthetic\n      // No need to use createColorVariant here since we're using specific themed colors\n      meteor.burstColors = ['rgba(255, 215, 0, 1)',\n      // Gold\n      'rgba(218, 165, 32, 1)',\n      // Goldenrod\n      'rgba(212, 175, 55, 1)',\n      // Metallic gold\n      'rgba(207, 181, 59, 1)',\n      // Old gold\n      earlyBurst ? 'rgba(255, 255, 220, 1)' : 'rgba(192, 192, 192, 1)' // Bright for early, silver for late\n      ];\n    } else {\n      meteor.hasBurst = false;\n    }\n    return meteor;\n  }, [dimensions, calculateMeteorPath, meteorMinSize, meteorMaxSize, meteorSpeed, enableBursts, burstProbability, adaptedSettings.burstParticleCount, getMeteor]);\n\n  // Get a burst particle from the object pool or create a new one\n  const getBurstParticle = useCallback(() => {\n    const pool = objectPoolsRef.current.bursts;\n    if (pool.length > 0) {\n      const burst = pool.pop();\n      // Reset properties\n      burst.life = 1.0;\n      return burst;\n    }\n\n    // Create new if pool is empty\n    return {};\n  }, []);\n\n  // Create a burst effect at a specified position\n  const createBurst = useCallback((x, y, size, colors, particleCount, velocityInfluence = {\n    x: 0,\n    y: 0\n  }) => {\n    // Skip if bursts are not enabled\n    if (!enableBursts) return;\n\n    // Limit the number of active burst particles to avoid performance issues\n    const maxBurstParticles = adaptedSettings.useHighQualityRendering ? 300 : 150;\n\n    // If we're already close to the limit, reduce the number of particles\n    let actualParticleCount = particleCount;\n    if (burstsRef.current.length > maxBurstParticles - particleCount) {\n      actualParticleCount = Math.max(4, Math.floor(particleCount * 0.5));\n    }\n\n    // Skip burst creation completely if we're already over the limit\n    if (burstsRef.current.length > maxBurstParticles) {\n      // Remove older bursts to make room\n      const toRemove = Math.min(20, burstsRef.current.length - maxBurstParticles + actualParticleCount);\n      for (let i = 0; i < toRemove; i++) {\n        const oldBurst = burstsRef.current.shift();\n        if (oldBurst) {\n          objectPoolsRef.current.bursts.push(oldBurst);\n        }\n      }\n    }\n\n    // Track burst counts for debug\n    lastBurstCountRef.current = actualParticleCount;\n\n    // Base colors for the dark fantasy aesthetic - gold to silver gradient\n    const baseColors = ['rgba(255, 215, 0, 1)',\n    // Gold\n    'rgba(255, 223, 0, 1)',\n    // Gold (slightly different)\n    'rgba(218, 165, 32, 1)',\n    // Goldenrod\n    'rgba(212, 175, 55, 1)',\n    // Metallic gold\n    'rgba(207, 181, 59, 1)' // Old gold\n    ];\n\n    // Ending colors for the transition\n    const endColors = ['rgba(192, 192, 192, 1)',\n    // Silver\n    'rgba(211, 211, 211, 1)',\n    // Light gray\n    'rgba(169, 169, 169, 1)' // Dark gray\n    ];\n\n    // Create particles in a more focused, elegant burst pattern\n    for (let i = 0; i < actualParticleCount; i++) {\n      // Create a more focused arc of particles in the direction of meteor travel\n      // with some spreading outward\n      const baseAngle = Math.atan2(velocityInfluence.y, velocityInfluence.x);\n\n      // Create a cone of particles that follows the meteor's trajectory\n      // with some variance for an elegant spread\n      const angleSpread = 1.6; // About 90 degrees total\n      const angleVariance = Math.random() * angleSpread - angleSpread / 2;\n      const angle = baseAngle + angleVariance;\n\n      // More elegant speed distribution - less bouncy, more drifting\n      const speedVariance = Math.random() * 0.3 + 0.85; // less variance\n      const baseSpeed = 0.6 + Math.random() * 1.2; // slower overall\n      const speed = baseSpeed * speedVariance;\n\n      // Calculate velocity components\n      // Add a slight upward tendency for some particles to create a rising ember effect\n      const upwardBias = Math.random() * 0.4 - 0.1; // Mostly upward\n      const vx = Math.cos(angle) * speed + velocityInfluence.x * 0.3;\n      const vy = Math.sin(angle) * speed + velocityInfluence.y * 0.3 - upwardBias;\n\n      // More consistent sizing for a refined look\n      const sizeVariance = 0.6 + Math.random() * 0.5; // less variance\n      const particleSize = size * sizeVariance * burstParticleSize * 0.8; // slightly smaller\n\n      // Select a color - preference toward gold but include some silver for variation\n      let color;\n      const colorRoll = Math.random();\n      if (colorRoll < 0.85) {\n        // 85% chance of gold tone\n        const goldIndex = Math.floor(Math.random() * baseColors.length);\n        color = baseColors[goldIndex];\n      } else {\n        // 15% chance of silver tone for variation\n        const silverIndex = Math.floor(Math.random() * endColors.length);\n        color = endColors[silverIndex];\n      }\n\n      // Create the burst particle\n      const burst = getBurstParticle();\n\n      // Set properties\n      burst.x = x + (Math.random() * 4 - 2); // Less initial position variance\n      burst.y = y + (Math.random() * 4 - 2);\n      burst.initialX = burst.x;\n      burst.initialY = burst.y;\n      burst.vx = vx;\n      burst.vy = vy;\n      burst.size = particleSize;\n      burst.initialSize = particleSize;\n      burst.life = 1.0;\n\n      // Longer-lived particles for more elegant effect\n      burst.decay = 0.007 + Math.random() * 0.015; // slower decay\n\n      burst.color = color;\n      burst.initialColor = color; // Store for color transition\n\n      // Subtle rotation for wispy effect\n      burst.rotation = Math.random() * Math.PI;\n      burst.rotationSpeed = (Math.random() * 2 - 1) * 0.03; // slower rotation\n\n      // Replace gravity with upward drift for some particles\n      burst.upwardDrift = Math.random() * 0.05;\n\n      // Higher damping for more elegant movement\n      burst.damping = 0.97 + Math.random() * 0.01;\n\n      // Add to active bursts\n      burstsRef.current.push(burst);\n    }\n  }, [enableBursts, adaptedSettings.useHighQualityRendering, getBurstParticle, burstParticleSize]);\n\n  // Render burst particles with WebGL\n  const renderBurstsWebGL = _s(useCallback(_s((gl, deltaTime) => {\n    _s();\n    if (!enableBursts || burstsRef.current.length === 0 || !webGLProgramsRef.current.burst) return;\n    const burstProgram = webGLProgramsRef.current.burst;\n\n    // Use burst shader program\n    gl.useProgram(burstProgram.program);\n\n    // Set resolution uniform\n    gl.uniform2f(burstProgram.uniforms.resolution, canvasRef.current.width, canvasRef.current.height);\n\n    // Create float32 arrays to hold position, size, and color data\n    // 2 floats per position (x, y)\n    const positions = new Float32Array(burstsRef.current.length * 2);\n    // 1 float per size\n    const sizes = new Float32Array(burstsRef.current.length);\n    // 4 floats per color (r, g, b, a)\n    const colors = new Float32Array(burstsRef.current.length * 4);\n\n    // Process each burst particle and update its data\n    for (let i = 0; i < burstsRef.current.length; i++) {\n      const burst = burstsRef.current[i];\n\n      // Update position\n      burst.x += burst.vx * (deltaTime / 16);\n      burst.y += burst.vy * (deltaTime / 16);\n\n      // Apply gravity if present\n      if (burst.gravity) {\n        burst.vy += burst.gravity * (deltaTime / 16);\n      }\n\n      // Apply damping to velocity\n      burst.vx *= burst.damping;\n      burst.vy *= burst.damping;\n\n      // Update rotation\n      burst.rotation += burst.rotationSpeed * (deltaTime / 16);\n\n      // Reduce life\n      burst.life -= burst.decay * (deltaTime / 16);\n\n      // Map burst data to arrays\n      const posIndex = i * 2;\n      positions[posIndex] = burst.x;\n      positions[posIndex + 1] = burst.y;\n      sizes[i] = burst.size * Math.pow(burst.life, 0.7) * dimensions.pixelRatio;\n\n      // Parse color components from rgba string\n      // This is a simplified placeholder - you'd need proper color parsing\n      const colorIndex = i * 4;\n      colors[colorIndex] = 1.0; // r\n      colors[colorIndex + 1] = 0.9; // g\n      colors[colorIndex + 2] = 0.7; // b\n      colors[colorIndex + 3] = burst.life * 0.7; // a\n    }\n\n    // Create and bind position buffer\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(burstProgram.attributes.position);\n    gl.vertexAttribPointer(burstProgram.attributes.position, 2, gl.FLOAT, false, 0, 0);\n\n    // Create and bind size buffer\n    const sizeBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, sizes, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(burstProgram.attributes.size);\n    gl.vertexAttribPointer(burstProgram.attributes.size, 1, gl.FLOAT, false, 0, 0);\n\n    // Create and bind color buffer\n    const colorBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(burstProgram.attributes.color);\n    gl.vertexAttribPointer(burstProgram.attributes.color, 4, gl.FLOAT, false, 0, 0);\n\n    // Draw points\n    gl.drawArrays(gl.POINTS, 0, burstsRef.current.length);\n\n    // Clean up\n    gl.disableVertexAttribArray(burstProgram.attributes.position);\n    gl.disableVertexAttribArray(burstProgram.attributes.size);\n    gl.disableVertexAttribArray(burstProgram.attributes.color);\n    gl.deleteBuffer(positionBuffer);\n    gl.deleteBuffer(sizeBuffer);\n    gl.deleteBuffer(colorBuffer);\n\n    // Filter out dead particles\n    let j = 0;\n    for (let i = 0; i < burstsRef.current.length; i++) {\n      const burst = burstsRef.current[i];\n      if (burst.life > 0) {\n        // Keep alive particles, compact array\n        if (i !== j) {\n          burstsRef.current[j] = burst;\n        }\n        j++;\n      } else {\n        // Return to object pool\n        objectPoolsRef.current.bursts.push(burst);\n      }\n    }\n\n    // Truncate array to remove dead particles\n    if (j < burstsRef.current.length) {\n      burstsRef.current.length = j;\n    }\n  }, \"ZdQBZ3rq7bWAAMQq6hlVCmYF0jM=\", false, function () {\n    return [gl.useProgram];\n  }), [enableBursts, dimensions.pixelRatio]), \"ZdQBZ3rq7bWAAMQq6hlVCmYF0jM=\", true);\n\n  // Render burst particles with Canvas 2D\n  const renderBursts2D = useCallback((ctx, deltaTime) => {\n    if (!enableBursts || burstsRef.current.length === 0) return;\n\n    // Process and render each burst particle\n    let j = 0;\n    for (let i = 0; i < burstsRef.current.length; i++) {\n      const burst = burstsRef.current[i];\n\n      // Update position with more ethereal, drifting movement\n      burst.x += burst.vx * (deltaTime / 16);\n      burst.y += burst.vy * (deltaTime / 16);\n\n      // Apply slight upward drift instead of gravity for ethereal effect\n      burst.vy -= (burst.upwardDrift || 0.01) * (deltaTime / 16);\n\n      // Apply stronger damping for elegant fade-out\n      burst.vx *= burst.damping;\n      burst.vy *= burst.damping;\n\n      // Update rotation more subtly\n      if (burst.rotation !== undefined) {\n        burst.rotation += (burst.rotationSpeed || 0.01) * (deltaTime / 16);\n      }\n\n      // Reduce life\n      burst.life -= burst.decay * (deltaTime / 16);\n\n      // Keep alive particles\n      if (burst.life > 0) {\n        // Draw particle\n        ctx.save();\n\n        // Calculate fade color - transition from gold to silver\n        const fadeProgress = 1 - burst.life;\n\n        // High-quality rendering with ethereal glow effects\n        if (adaptedSettings.useHighQualityRendering) {\n          // Add shadow for glow effect - more pronounced for fantasy aesthetic\n          if (adaptedSettings.useGlow) {\n            // Transition from golden to silver glow\n            const glowColor = burst.initialColor || glowColor;\n            ctx.shadowColor = glowColor;\n            ctx.shadowBlur = burst.size * (2.5 + fadeProgress) * burst.life;\n          }\n\n          // Create elongated, wispy particles that stretch as they move\n          const baseLength = burst.size * (1 + fadeProgress * 2);\n          const trailLength = baseLength * 2.5;\n\n          // Calculate the particle's movement direction\n          const angle = Math.atan2(burst.vy, burst.vx);\n\n          // Draw wispy, ember-like trail\n          ctx.translate(burst.x, burst.y);\n          ctx.rotate(angle + (burst.rotation || 0));\n\n          // Create gradient for ember trail - gold to silver transition\n          const gradient = ctx.createLinearGradient(0, 0, -trailLength, 0);\n\n          // Determine colors based on life cycle\n          // Start with golden/ember colors, fade to silver/ash\n          const startOpacity = burst.life * 0.8;\n          const endOpacity = burst.life * 0.1;\n\n          // Gold to silver transition\n          const startColor = getCachedColor(burst.color || 'rgba(255, 215, 0, 1)', startOpacity);\n          const midColor = getCachedColor('rgba(232, 224, 185, 1)', startOpacity * 0.6);\n          const endColor = getCachedColor('rgba(192, 192, 192, 1)', endOpacity);\n          gradient.addColorStop(0, startColor);\n          gradient.addColorStop(0.4, midColor);\n          gradient.addColorStop(1, endColor);\n\n          // Draw ember trail as tapered shape\n          ctx.beginPath();\n\n          // Ember head (slightly wider)\n          const headWidth = baseLength * 0.3;\n          ctx.moveTo(0, headWidth);\n\n          // Curved trail sides\n          ctx.quadraticCurveTo(-trailLength / 2, headWidth * 0.8, -trailLength, 0);\n          ctx.quadraticCurveTo(-trailLength / 2, -headWidth * 0.8, 0, -headWidth);\n          ctx.closePath();\n          ctx.fillStyle = gradient;\n          ctx.fill();\n\n          // Add small ember core with brighter glow\n          const coreSize = baseLength * 0.4;\n          ctx.beginPath();\n          ctx.arc(0, 0, coreSize, 0, Math.PI * 2);\n\n          // Core gradient - brighter center\n          const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, coreSize);\n          coreGradient.addColorStop(0, getCachedColor('rgba(255, 255, 220, 1)', burst.life));\n          coreGradient.addColorStop(0.5, getCachedColor(burst.color || 'rgba(255, 215, 0, 1)', burst.life * 0.9));\n          coreGradient.addColorStop(1, getCachedColor(burst.color || 'rgba(255, 215, 0, 1)', burst.life * 0.4));\n          ctx.fillStyle = coreGradient;\n          ctx.fill();\n        } else {\n          // Simpler rendering for lower-end devices - still elegant\n          const angle = Math.atan2(burst.vy, burst.vx);\n\n          // Simple elongated particle\n          ctx.translate(burst.x, burst.y);\n          ctx.rotate(angle);\n\n          // Simple gradient\n          const simpleGradient = ctx.createLinearGradient(0, 0, -burst.size * 3 * burst.life, 0);\n          simpleGradient.addColorStop(0, getCachedColor(burst.color || glowColor, burst.life * 0.8));\n          simpleGradient.addColorStop(1, getCachedColor('rgba(192, 192, 192, 1)', burst.life * 0.2));\n\n          // Draw teardrop shape\n          ctx.beginPath();\n          ctx.arc(0, 0, burst.size * burst.life, 0, Math.PI, true);\n          ctx.lineTo(-burst.size * 3 * burst.life, 0);\n          ctx.closePath();\n          ctx.fillStyle = simpleGradient;\n          ctx.fill();\n        }\n        ctx.restore();\n\n        // Compact alive particles\n        if (i !== j) {\n          burstsRef.current[j] = burst;\n        }\n        j++;\n      } else {\n        // Return to object pool\n        objectPoolsRef.current.bursts.push(burst);\n      }\n    }\n\n    // Truncate array to remove dead particles\n    if (j < burstsRef.current.length) {\n      burstsRef.current.length = j;\n    }\n  }, [enableBursts, adaptedSettings.useHighQualityRendering, adaptedSettings.useGlow, getCachedColor, glowColor]);\n\n  // 2D Canvas rendering method for meteors\n  const renderMeteors2D = useCallback((ctx, parallaxOffset, timestamp) => {\n    // Process and render each meteor\n    meteorsRef.current.forEach(meteor => {\n      // Calculate opacity based on progress\n      let currentOpacity = meteor.opacity;\n      if (meteor.progress > meteor.fadeThreshold) {\n        const fadeProgress = (meteor.progress - meteor.fadeThreshold) / (1 - meteor.fadeThreshold);\n        currentOpacity = meteor.opacity * (1 - fadeProgress);\n      }\n\n      // Apply pulse effect\n      const timeFactor = timestamp * 0.001;\n      const pulseEffect = Math.sin(timeFactor * meteor.pulseSpeed + meteor.pulsePhase) * 0.2 + 0.8;\n\n      // Parallax offset adjustment\n      const adjustY = enableParallax ? parallaxOffset * (meteor.size / meteorMaxSize) : 0;\n\n      // Check if we should create a burst effect\n      if (meteor.hasBurst && !meteor.burstTriggered && meteor.progress >= meteor.burstThreshold) {\n        meteor.burstTriggered = true;\n        const burstPosition = meteor.positions[0];\n\n        // Get velocity at burst point for influence on particles\n        const velocityPoint = {\n          x: 0,\n          y: 0\n        };\n        getPathVelocity(meteor.progress, meteor.path, velocityPoint);\n\n        // Scale velocity for better visual effect\n        velocityPoint.x *= 0.8;\n        velocityPoint.y *= 0.8;\n\n        // Create burst with velocity influence\n        createBurst(burstPosition.x, burstPosition.y + adjustY, meteor.burstSize, meteor.burstColors, meteor.burstParticles, velocityPoint);\n      }\n\n      // Optimized rendering approach\n      if (adaptedSettings.useHighQualityRendering) {\n        // High-quality rendering with shadows\n        // Set shadow for glow effect if enabled\n        if (adaptedSettings.useGlow) {\n          ctx.shadowColor = glowColor;\n          ctx.shadowBlur = meteor.size * 3 * pulseEffect;\n        }\n\n        // Draw trail segments\n        ctx.lineCap = 'round';\n        for (let i = meteor.positions.length - 2; i >= 0; i--) {\n          const pos1 = meteor.positions[i];\n          const pos2 = meteor.positions[i + 1];\n          if (!pos1 || !pos2) continue;\n\n          // Calculate segment opacity (decreases along the trail)\n          const segmentOpacity = currentOpacity * (1 - i / meteor.positions.length) * pulseEffect;\n\n          // Skip if nearly invisible\n          if (segmentOpacity < 0.02) continue;\n\n          // Calculate segment width (decreases along the trail)\n          const segmentWidth = meteor.size * (1 - i / meteor.positions.length * 0.7);\n\n          // Draw line segment\n          ctx.beginPath();\n          ctx.moveTo(pos1.x, pos1.y + adjustY);\n          ctx.lineTo(pos2.x, pos2.y + adjustY);\n\n          // Set line style\n          ctx.lineWidth = segmentWidth;\n          ctx.strokeStyle = getCachedColor(trailColor, segmentOpacity);\n          ctx.stroke();\n        }\n\n        // Draw meteor head\n        if (meteor.positions[0]) {\n          const headPos = meteor.positions[0];\n\n          // Set shadow for head\n          if (adaptedSettings.useShadow) {\n            ctx.shadowColor = glowColor;\n            ctx.shadowBlur = meteor.size * 5 * pulseEffect;\n          }\n\n          // Draw outer glow\n          ctx.beginPath();\n          ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 1.5, 0, Math.PI * 2);\n          ctx.fillStyle = getCachedColor(glowColor, currentOpacity * 0.7 * pulseEffect);\n          ctx.fill();\n\n          // Draw inner core\n          ctx.beginPath();\n          ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 0.7, 0, Math.PI * 2);\n          ctx.fillStyle = getCachedColor(coreColor, currentOpacity * pulseEffect);\n          ctx.fill();\n        }\n      } else {\n        // Performance-optimized rendering for lower-end devices\n        // Draw simplified trail\n        ctx.beginPath();\n        const headPos = meteor.positions[0];\n        if (!headPos) return;\n        ctx.moveTo(headPos.x, headPos.y + adjustY);\n        for (let i = 1; i < meteor.positions.length; i += 2) {\n          const pos = meteor.positions[i];\n          if (!pos) continue;\n          ctx.lineTo(pos.x, pos.y + adjustY);\n        }\n\n        // Gradient trail\n        const gradient = ctx.createLinearGradient(headPos.x, headPos.y + adjustY, meteor.positions[meteor.positions.length - 1].x, meteor.positions[meteor.positions.length - 1].y + adjustY);\n        gradient.addColorStop(0, getCachedColor(coreColor, currentOpacity * pulseEffect));\n        gradient.addColorStop(0.3, getCachedColor(glowColor, currentOpacity * 0.7 * pulseEffect));\n        gradient.addColorStop(1, getCachedColor(trailColor, 0));\n        ctx.strokeStyle = gradient;\n        ctx.lineWidth = meteor.size;\n        ctx.lineCap = 'round';\n        ctx.stroke();\n\n        // Simple head\n        ctx.beginPath();\n        ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 0.7, 0, Math.PI * 2);\n        ctx.fillStyle = getCachedColor(coreColor, currentOpacity * pulseEffect);\n        ctx.fill();\n      }\n    });\n  }, [adaptedSettings.useHighQualityRendering, adaptedSettings.useGlow, adaptedSettings.useShadow, enableParallax, meteorMaxSize, glowColor, trailColor, coreColor, getCachedColor, createBurst, getPathVelocity]);\n\n  // WebGL rendering method\n  const renderMeteorsWebGL = _s2(useCallback(_s2((gl, timestamp) => {\n    _s2();\n    // This is a simplified placeholder for WebGL rendering\n    // A full implementation would use the shaders and buffers set up earlier\n\n    if (!gl || !webGLProgramsRef.current.meteor) return;\n\n    // Clear canvas\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    // Use meteor shader program\n    const meteorProgram = webGLProgramsRef.current.meteor;\n    gl.useProgram(meteorProgram.program);\n\n    // Set uniforms\n    gl.uniform2f(meteorProgram.uniforms.resolution, canvasRef.current.width, canvasRef.current.height);\n\n    // This is where we would bind vertex buffers and render particles\n    // For a real implementation, you would:\n    // 1. Update vertex buffer with current meteor positions\n    // 2. Set attributes for position, size, color\n    // 3. Draw using gl.POINTS or other appropriate primitives\n\n    // Check for burst triggers in WebGL mode too\n    meteorsRef.current.forEach(meteor => {\n      if (meteor.hasBurst && !meteor.burstTriggered && meteor.progress >= meteor.burstThreshold) {\n        meteor.burstTriggered = true;\n        const burstPosition = meteor.positions[0];\n\n        // Get velocity at burst point for influence on particles\n        const velocityPoint = {\n          x: 0,\n          y: 0\n        };\n        getPathVelocity(meteor.progress, meteor.path, velocityPoint);\n\n        // Create burst with velocity influence\n        // This will add particles to be rendered by renderBurstsWebGL\n        createBurst(burstPosition.x, burstPosition.y, meteor.burstSize, meteor.burstColors, meteor.burstParticles, velocityPoint);\n      }\n    });\n  }, \"ZdQBZ3rq7bWAAMQq6hlVCmYF0jM=\", false, function () {\n    return [gl.useProgram];\n  }), [createBurst, getPathVelocity]), \"ZdQBZ3rq7bWAAMQq6hlVCmYF0jM=\", true);\n\n  // Update meteor positions\n  const updateMeteors = useCallback(deltaTime => {\n    // Process meteors without destructuring unused width/height\n    for (let i = meteorsRef.current.length - 1; i >= 0; i--) {\n      const meteor = meteorsRef.current[i];\n\n      // Update progress based on speed and delta time\n      meteor.progress += meteor.speed * (deltaTime / 1000);\n\n      // Check if meteor has completed its path\n      if (meteor.progress >= 1) {\n        // Return to object pool\n        meteor.active = false;\n        objectPoolsRef.current.meteors.push(meteor);\n        meteorsRef.current.splice(i, 1);\n        continue;\n      }\n\n      // Calculate current position along the path\n      const currentPos = getPathPoint(Math.min(1, meteor.progress), meteor.path, pointCache.current);\n\n      // Update position history (for trail) using optimized array management\n      // Shift positions array - this is more efficient than splice/unshift for small arrays\n      for (let j = meteor.positions.length - 1; j > 0; j--) {\n        const current = meteor.positions[j];\n        const prev = meteor.positions[j - 1];\n        current.x = prev.x;\n        current.y = prev.y;\n      }\n\n      // Update head position\n      meteor.positions[0].x = currentPos.x;\n      meteor.positions[0].y = currentPos.y;\n    }\n\n    // Spawn new meteors if needed\n    const now = performance.now();\n    const spawnNeeded = meteorsRef.current.length < adaptedSettings.meteorDensity;\n    const canSpawnNow = !staggered || now >= nextSpawnTimeRef.current;\n    if (spawnNeeded && canSpawnNow) {\n      const newMeteor = initializeMeteor();\n      if (newMeteor) {\n        meteorsRef.current.push(newMeteor);\n\n        // Set next spawn time if staggering is enabled\n        if (staggered) {\n          const delay = Math.random() * (maxStaggerDelay - minStaggerDelay) + minStaggerDelay;\n          nextSpawnTimeRef.current = now + delay;\n        }\n      }\n    }\n    // Dependencies for updateMeteors\n  }, [adaptedSettings.meteorDensity, staggered, minStaggerDelay, maxStaggerDelay, initializeMeteor, getPathPoint, pointCache]);\n\n  // FPS limiter for consistent animation speed\n  const fpsLimiter = useCallback((timestamp, callback) => {\n    // Skip animation if hidden, inactive, or reduced motion\n    if (!isVisible || !active || respectReducedMotion && prefersReducedMotion || document.hidden) {\n      animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n      return;\n    }\n    const targetFrameTime = 1000 / maxFPS;\n    const elapsed = timestamp - lastTimestampRef.current;\n    if (elapsed >= targetFrameTime || lastTimestampRef.current === 0) {\n      // Calculate correct delta\n      const delta = lastTimestampRef.current === 0 ? 16 : elapsed;\n\n      // Update timestamp, limiting delta to avoid jumps after inactivity\n      lastTimestampRef.current = timestamp - elapsed % targetFrameTime;\n\n      // Run animation callback with capped delta time\n      callback(Math.min(delta, 50));\n\n      // FPS tracking for debug and adaptive quality\n      frameCountRef.current++;\n      if (timestamp - fpsTimestampRef.current >= 1000) {\n        currentFpsRef.current = frameCountRef.current;\n        frameCountRef.current = 0;\n        fpsTimestampRef.current = timestamp;\n\n        // Log FPS in debug mode\n        if (debug) {\n          console.log(`MeteorShower FPS: ${currentFpsRef.current}, Quality: ${qualityFactor.toFixed(2)}`);\n        }\n\n        // Dynamic quality adjustment based on performance\n        if (adaptiveQuality && currentFpsRef.current < maxFPS * 0.7) {\n          // If FPS is below 70% of target, reduce quality\n          setQualityFactor(prev => Math.max(0.4, prev * 0.9));\n        } else if (adaptiveQuality && currentFpsRef.current >= maxFPS * 0.95 && qualityFactor < 1) {\n          // If FPS is near target and quality is reduced, gradually increase\n          setQualityFactor(prev => Math.min(1, prev * 1.05));\n        }\n      }\n    }\n\n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n  }, [isVisible, active, respectReducedMotion, prefersReducedMotion, maxFPS, debug, adaptiveQuality, qualityFactor]);\n\n  // Main animation handler\n  const handleAnimation = useCallback(deltaTime => {\n    // Skip if component is not ready\n    if (!canvasRef.current || !isInitialized) return;\n    const now = performance.now();\n\n    // Calculate parallax offset if enabled\n    let parallaxOffset = 0;\n    if (enableParallax) {\n      parallaxOffset = scrollPositionRef.current * parallaxIntensity;\n    }\n\n    // Update meteor positions\n    updateMeteors(deltaTime);\n\n    // Render based on selected mode\n    if (actualRenderingMode === 'webgl' && webGLRef.current) {\n      // WebGL rendering path\n      renderMeteorsWebGL(webGLRef.current, now);\n\n      // Render burst particles with WebGL\n      if (enableBursts) {\n        renderBurstsWebGL(webGLRef.current, deltaTime);\n      }\n    } else {\n      // Canvas 2D rendering path\n      const ctx = ctxRef.current;\n      if (!ctx) return;\n\n      // Clear canvas with optimized clear (only clear used area)\n      ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n\n      // Render meteors\n      renderMeteors2D(ctx, parallaxOffset, now);\n\n      // Render burst particles\n      if (enableBursts) {\n        renderBursts2D(ctx, deltaTime);\n      }\n\n      // Debug visualization\n      if (debug) {\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n        ctx.font = '12px monospace';\n        ctx.fillText(`FPS: ${currentFpsRef.current}`, 10, 20);\n        ctx.fillText(`Meteors: ${meteorsRef.current.length}/${adaptedSettings.meteorDensity}`, 10, 40);\n        ctx.fillText(`Quality: ${qualityFactor.toFixed(2)}`, 10, 60);\n        ctx.fillText(`Rendering: ${actualRenderingMode}`, 10, 80);\n        if (enableBursts) {\n          ctx.fillText(`Bursts: ${burstsRef.current.length}`, 10, 100);\n          ctx.fillText(`Last Burst: ${lastBurstCountRef.current}`, 10, 120);\n        }\n      }\n    }\n  }, [isInitialized, dimensions, adaptedSettings.meteorDensity, enableParallax, parallaxIntensity, actualRenderingMode, debug, updateMeteors, renderMeteors2D, renderMeteorsWebGL, enableBursts, renderBursts2D, renderBurstsWebGL, qualityFactor]);\n\n  // Main animation loop\n  useEffect(() => {\n    if (!active || !isInitialized || !dimensions.width || !dimensions.height) {\n      return;\n    }\n\n    // Start animation with FPS limiter\n    fpsTimestampRef.current = performance.now();\n    frameCountRef.current = 0;\n    lastTimestampRef.current = 0;\n    animationFrameRef.current = requestAnimationFrame(timestamp => {\n      fpsLimiter(timestamp, handleAnimation);\n    });\n\n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [active, isInitialized, dimensions, fpsLimiter, handleAnimation]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: height,\n      overflow: 'hidden',\n      pointerEvents: 'none',\n      zIndex: zIndex,\n      // Hardware acceleration\n      backfaceVisibility: 'hidden',\n      transform: 'translateZ(0)',\n      willChange: 'transform'\n    },\n    \"aria-hidden\": \"true\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        // Additional rendering optimizations\n        imageRendering: 'high-quality',\n        // Hardware acceleration\n        backfaceVisibility: 'hidden',\n        transform: 'translateZ(0)',\n        willChange: 'transform',\n        // Ensures proper subpixel rendering\n        filter: 'none'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1800,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1782,\n    columnNumber: 5\n  }, this);\n};\n\n/**\n * GoldenMeteorShower Component\n * \n * A preset version of the MeteorShower with a golden/amber color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_s3(MeteorShower, \"GxHs95kq1Kx5YXuhQ9Pe0SNDn48=\");\n_c = MeteorShower;\nexport const GoldenMeteorShower = props => {\n  const goldenPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 245, 158, 0.9)',\n    trailColor: 'rgba(207, 181, 59, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 200,\n    maxStaggerDelay: 2000,\n    enableBursts: true,\n    burstProbability: 0.4,\n    burstParticleSize: 1.8,\n    burstParticleCount: 14\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...goldenPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1849,\n    columnNumber: 10\n  }, this);\n};\n\n/**\n * CelestialMeteorShower Component\n * \n * A preset version of the MeteorShower with a bluish-purple color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c2 = GoldenMeteorShower;\nexport const CelestialMeteorShower = props => {\n  const celestialPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(220, 225, 255, 0.9)',\n    trailColor: 'rgba(150, 160, 255, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 300,\n    maxStaggerDelay: 1800,\n    enableBursts: true,\n    burstProbability: 0.35\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...celestialPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1877,\n    columnNumber: 10\n  }, this);\n};\n\n/**\n * RubyMeteorShower Component\n * \n * A preset version of the MeteorShower with a red color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c3 = CelestialMeteorShower;\nexport const RubyMeteorShower = props => {\n  const rubyPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 200, 200, 0.9)',\n    trailColor: 'rgba(220, 100, 100, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 350,\n    maxStaggerDelay: 2200,\n    enableBursts: true,\n    burstProbability: 0.45\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...rubyPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1905,\n    columnNumber: 10\n  }, this);\n};\n\n/**\n * TopMeteorShower Component\n * \n * A preset version of the MeteorShower with meteors falling from the top of the screen\n * at a consistent 30-degree angle, distributed with emphasis on left and center areas.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c4 = RubyMeteorShower;\nexport const TopMeteorShower = props => {\n  const topPreset = {\n    mode: 'linear',\n    direction: 'top',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.12,\n    trailLength: 200,\n    trailSegments: 25,\n    journeyCompletion: 0.95,\n    staggered: true,\n    minStaggerDelay: 100,\n    maxStaggerDelay: 1000,\n    enableBursts: true,\n    burstProbability: 0.5,\n    burstParticleCount: 15\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...topPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1934,\n    columnNumber: 10\n  }, this);\n};\n_c5 = TopMeteorShower;\nexport default MeteorShower;\nvar _c, _c2, _c3, _c4, _c5;\n$RefreshReg$(_c, \"MeteorShower\");\n$RefreshReg$(_c2, \"GoldenMeteorShower\");\n$RefreshReg$(_c3, \"CelestialMeteorShower\");\n$RefreshReg$(_c4, \"RubyMeteorShower\");\n$RefreshReg$(_c5, \"TopMeteorShower\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useCallback","useMemo","jsxDEV","_jsxDEV","MeteorShower","height","zIndex","active","meteorDensity","meteorMinSize","meteorMaxSize","meteorSpeed","trailLength","trailSegments","coreColor","glowColor","trailColor","enableParallax","parallaxIntensity","staggered","minStaggerDelay","maxStaggerDelay","journeyCompletion","mode","direction","baseAngle","angleVariation","debug","adaptiveQuality","respectReducedMotion","maxFPS","useWebGL","enableBursts","enableBattery","renderingMode","enableOffscreenRendering","burstParticleCount","burstParticleSize","burstProbability","burstColorVariation","_s3","_s","$RefreshSig$","_s2","containerRef","canvasRef","ctxRef","webGLRef","offscreenCanvasRef","workerRef","meteorsRef","burstsRef","animationFrameRef","lastTimestampRef","fpsTimestampRef","frameCountRef","currentFpsRef","nextSpawnTimeRef","scrollPositionRef","resizeObserverRef","visibilityObserverRef","batteryRef","visibilityChangeTimeRef","lastBurstCountRef","dimensions","setDimensions","width","pixelRatio","isInitialized","setIsInitialized","prefersReducedMotion","setPrefersReducedMotion","isVisible","setIsVisible","qualityFactor","setQualityFactor","actualRenderingMode","setActualRenderingMode","deviceCapabilities","setDeviceCapabilities","memory","cores","batteryLevel","isMobile","supportsWebGL","supportsOffscreenCanvas","pointCache","current","x","y","segment","colorCacheRef","Map","webGLProgramsRef","meteor","trail","burst","objectPoolsRef","meteors","bursts","vectors","detectCapabilities","navigator","deviceMemory","hardwareConcurrency","test","userAgent","canvas","document","createElement","window","WebGLRenderingContext","getContext","e","OffscreenCanvas","getBattery","then","battery","updateBattery","prev","level","isCharging","charging","Math","min","addEventListener","catch","initialRenderingMode","performanceScore","quality","getCachedColor","baseColor","opacity","roundedOpacity","round","key","has","newColor","replace","set","get","createColorVariant","variation","rgbaMatch","match","r","parseInt","g","b","a","parseFloat","vr","max","floor","random","vg","vb","adaptedSettings","useShadow","useGlow","useHighQualityRendering","reducedMotionQuery","matchMedia","matches","handleReducedMotionChange","handleVisibilityChange","hidden","performance","now","timeDelta","currentWorker","removeEventListener","terminate","initWebGL","gl","alpha","antialias","premultipliedAlpha","depth","enable","BLEND","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","clearColor","canvasWidth","canvasHeight","viewport","vertexShaderSource","fragmentShaderSource","createShader","type","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","error","getShaderInfoLog","deleteShader","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","program","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","attributes","position","getAttribLocation","size","color","uniforms","resolution","getUniformLocation","burstVertexShaderSource","burstFragmentShaderSource","burstVertexShader","burstFragmentShader","burstProgram","calculateMeteorPath","startX","startY","curveDirection","curveIntensity","endX","endY","controlX","controlY","pathType","start","control","end","meteorDirection","angle","PI","distanceToTravel","cos","sin","getPathPoint","t","path","outPoint","invT","invTSquared","tSquared","term1","term2","term3","getPathVelocity","outVelocity","length","sqrt","setupCanvas","container","rect","getBoundingClientRect","devicePixelRatio","displayWidth","displayHeight","endsWith","innerHeight","style","ctx","desynchronized","willReadFrequently","scale","imageSmoothingEnabled","imageSmoothingQuality","offscreen","offscreenCtx","warn","resizeObserver","ResizeObserver","entries","timeout","clearTimeout","setTimeout","requestAnimationFrame","currentContainer","observe","observer","disconnect","IntersectionObserver","isIntersecting","threshold","rootMargin","currentContainerRef","handleScroll","scrollY","passive","getMeteor","pool","pop","progress","positions","Array","i","initializeMeteor","speed","fadeThreshold","pulsePhase","pulseSpeed","hasBurst","earlyBurst","burstThreshold","burstTriggered","burstSize","burstParticles","burstColors","getBurstParticle","life","createBurst","colors","particleCount","velocityInfluence","maxBurstParticles","actualParticleCount","toRemove","oldBurst","shift","push","baseColors","endColors","atan2","angleSpread","angleVariance","speedVariance","baseSpeed","upwardBias","vx","vy","sizeVariance","particleSize","colorRoll","goldIndex","silverIndex","initialX","initialY","initialSize","decay","initialColor","rotation","rotationSpeed","upwardDrift","damping","renderBurstsWebGL","deltaTime","useProgram","uniform2f","Float32Array","sizes","gravity","posIndex","pow","colorIndex","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","enableVertexAttribArray","vertexAttribPointer","FLOAT","sizeBuffer","colorBuffer","drawArrays","POINTS","disableVertexAttribArray","deleteBuffer","j","renderBursts2D","undefined","save","fadeProgress","shadowColor","shadowBlur","baseLength","translate","rotate","gradient","createLinearGradient","startOpacity","endOpacity","startColor","midColor","endColor","addColorStop","beginPath","headWidth","moveTo","quadraticCurveTo","closePath","fillStyle","fill","coreSize","arc","coreGradient","createRadialGradient","simpleGradient","lineTo","restore","renderMeteors2D","parallaxOffset","timestamp","forEach","currentOpacity","timeFactor","pulseEffect","adjustY","burstPosition","velocityPoint","lineCap","pos1","pos2","segmentOpacity","segmentWidth","lineWidth","strokeStyle","stroke","headPos","pos","renderMeteorsWebGL","clear","COLOR_BUFFER_BIT","meteorProgram","updateMeteors","splice","currentPos","spawnNeeded","canSpawnNow","newMeteor","delay","fpsLimiter","callback","time","targetFrameTime","elapsed","delta","log","toFixed","handleAnimation","clearRect","font","fillText","cancelAnimationFrame","ref","top","left","overflow","pointerEvents","backfaceVisibility","transform","willChange","children","imageRendering","filter","fileName","_jsxFileName","lineNumber","columnNumber","_c","GoldenMeteorShower","props","goldenPreset","_c2","CelestialMeteorShower","celestialPreset","_c3","RubyMeteorShower","rubyPreset","_c4","TopMeteorShower","topPreset","_c5","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/MeteorShower.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';\n\n/**\n * MeteorShower Component - Enterprise Performance Optimized Version\n * \n * Creates a highly performant animated meteor shower effect where meteors\n * arc across the sky with comet-like trails and fade away naturally.\n * \n * Features:\n * - Advanced performance optimizations with WebGL acceleration option\n * - Adaptive quality scaling based on device capabilities\n * - Memory and battery-efficient rendering pipeline\n * - Accessibility compliance with reduced motion support\n * - Supports hardware acceleration and high-DPI displays\n * - Enhanced burst effects with realistic particle physics\n * \n * @param {Object} props - Component props\n * @param {string|number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=5] - Z-index for the container\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.meteorDensity=15] - Number of meteors to maintain on screen\n * @param {number} [props.meteorMinSize=1] - Minimum size of meteors\n * @param {number} [props.meteorMaxSize=3] - Maximum size of meteors\n * @param {number} [props.meteorSpeed=0.08] - Base speed of meteors\n * @param {number} [props.trailLength=180] - Length of meteor trails\n * @param {number} [props.trailSegments=20] - Number of segments in each trail\n * @param {string} [props.coreColor='rgba(255, 255, 255, 1)'] - Core color for meteors\n * @param {string} [props.glowColor='rgba(255, 253, 227, 0.9)'] - Glow color for meteors\n * @param {string} [props.trailColor='rgba(191, 173, 127, 0.8)'] - Trail color for meteors\n * @param {boolean} [props.enableParallax=false] - Enable parallax effect on scroll\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of parallax effect\n * @param {boolean} [props.staggered=true] - Enable staggered meteor appearance\n * @param {number} [props.minStaggerDelay=200] - Minimum delay between meteor spawns (ms)\n * @param {number} [props.maxStaggerDelay=2000] - Maximum delay between meteor spawns (ms)\n * @param {number} [props.journeyCompletion=0.9] - When meteors complete their journey (0-1)\n * @param {string} [props.mode='arc'] - Animation mode: 'arc' or 'linear'\n * @param {string} [props.direction='both'] - Direction: 'left', 'right', 'both', or 'top'\n * @param {number} [props.baseAngle=30] - Base angle for linear meteors (degrees)\n * @param {number} [props.angleVariation=15] - Random variation to apply to the base angle\n * @param {boolean} [props.debug=false] - Enable debug visualization\n * @param {boolean} [props.adaptiveQuality=true] - Enable adaptive quality based on device\n * @param {boolean} [props.respectReducedMotion=true] - Respect reduced motion preferences\n * @param {number} [props.maxFPS=60] - Target maximum frames per second\n * @param {boolean} [props.useWebGL=false] - Use WebGL rendering for better performance\n * @param {boolean} [props.enableBursts=true] - Enable meteor burst effects\n * @param {boolean} [props.enableBattery=true] - Enable battery-saving optimizations\n * @param {string} [props.renderingMode='auto'] - Rendering mode: 'auto', '2d', or 'webgl'\n * @param {boolean} [props.enableOffscreenRendering=true] - Enable offscreen canvas when available\n * @param {number} [props.burstParticleCount=12] - Number of particles in each burst\n * @param {number} [props.burstParticleSize=2] - Size of burst particles\n * @param {number} [props.burstProbability=0.4] - Probability of meteor having a burst (0-1)\n * @param {string} [props.burstColorVariation='0.2'] - Amount of color variation in burst particles\n */\nconst MeteorShower = ({\n  height = '100vh',\n  zIndex = 5,\n  active = true,\n  meteorDensity = 15,\n  meteorMinSize = 1,\n  meteorMaxSize = 3,\n  meteorSpeed = 0.08,\n  trailLength = 180,\n  trailSegments = 20,\n  coreColor = 'rgba(255, 255, 255, 1)',\n  glowColor = 'rgba(255, 245, 158, 0.9)',\n  trailColor = 'rgba(207, 181, 59, 0.8)',\n  enableParallax = false,\n  parallaxIntensity = 0.2,\n  staggered = true,\n  minStaggerDelay = 200,\n  maxStaggerDelay = 2000,\n  journeyCompletion = 0.9,\n  mode = 'arc',\n  direction = 'both',\n  baseAngle = 30,\n  angleVariation = 15,\n  debug = false,\n  adaptiveQuality = true,\n  respectReducedMotion = true,\n  maxFPS = 60,\n  useWebGL = false,\n  enableBursts = true, // Enabled by default now\n  enableBattery = true,\n  renderingMode = 'auto',\n  enableOffscreenRendering = true,\n  burstParticleCount = 12,\n  burstParticleSize = 2,\n  burstProbability = 0.4,\n  burstColorVariation = 0.2\n}) => {\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const ctxRef = useRef(null);\n  const webGLRef = useRef(null);\n  const offscreenCanvasRef = useRef(null);\n  const workerRef = useRef(null);\n  const meteorsRef = useRef([]);\n  const burstsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const fpsTimestampRef = useRef(0);\n  const frameCountRef = useRef(0);\n  const currentFpsRef = useRef(60);\n  const nextSpawnTimeRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n  const resizeObserverRef = useRef(null);\n  const visibilityObserverRef = useRef(null);\n  const batteryRef = useRef(null);\n  const visibilityChangeTimeRef = useRef(0);\n  const lastBurstCountRef = useRef(0);\n  \n  // Component state\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0, pixelRatio: 1 });\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [isVisible, setIsVisible] = useState(false);\n  const [qualityFactor, setQualityFactor] = useState(1);\n  const [actualRenderingMode, setActualRenderingMode] = useState('2d');\n  const [deviceCapabilities, setDeviceCapabilities] = useState({\n    memory: 4,\n    cores: 4,\n    batteryLevel: 1,\n    isMobile: false,\n    supportsWebGL: false,\n    supportsOffscreenCanvas: false\n  });\n  \n  // Pre-allocate objects to avoid garbage collection during animation\n  const pointCache = useRef({\n    current: { x: 0, y: 0 },\n    segment: { x: 0, y: 0 }\n  }).current;\n  \n  // Precompute color variants to avoid string operations during animation\n  const colorCacheRef = useRef(new Map());\n  \n  // WebGL shader programs and buffers\n  const webGLProgramsRef = useRef({\n    meteor: null,\n    trail: null,\n    burst: null\n  });\n  \n  // Object pools for efficient memory usage\n  const objectPoolsRef = useRef({\n    meteors: [],\n    bursts: [],\n    vectors: []\n  });\n  \n  // Detects device capabilities and sets up optimization strategies\n  const detectCapabilities = useCallback(() => {\n    // Device memory, hardware concurrency, and battery\n    const memory = navigator.deviceMemory || 4;\n    const cores = navigator.hardwareConcurrency || 4;\n    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n    \n    // Check WebGL support\n    let supportsWebGL = false;\n    try {\n      const canvas = document.createElement('canvas');\n      supportsWebGL = !!(window.WebGLRenderingContext && \n        (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));\n    } catch (e) {\n      supportsWebGL = false;\n    }\n    \n    // Check offscreen canvas support\n    const supportsOffscreenCanvas = typeof OffscreenCanvas !== 'undefined';\n    \n    // Get battery info if available\n    if (navigator.getBattery && enableBattery) {\n      navigator.getBattery().then(battery => {\n        batteryRef.current = battery;\n        \n        const updateBattery = () => {\n          setDeviceCapabilities(prev => ({\n            ...prev,\n            batteryLevel: battery.level,\n            isCharging: battery.charging\n          }));\n          \n          // Reduce quality if on battery and below 30%\n          if (!battery.charging && battery.level < 0.3 && adaptiveQuality) {\n            setQualityFactor(prev => Math.min(prev, 0.6));\n          }\n        };\n        \n        // Add battery event listeners\n        battery.addEventListener('levelchange', updateBattery);\n        battery.addEventListener('chargingchange', updateBattery);\n        \n        // Initial update\n        updateBattery();\n      }).catch(() => {\n        // Fallback if battery API is not available or fails\n        setDeviceCapabilities(prev => ({\n          ...prev,\n          batteryLevel: 1,\n          isCharging: true\n        }));\n      });\n    }\n    \n    // Determine initial rendering mode\n    let initialRenderingMode = '2d';\n    if (renderingMode === 'auto') {\n      if (useWebGL && supportsWebGL) {\n        initialRenderingMode = 'webgl';\n      } else {\n        initialRenderingMode = '2d';\n      }\n    } else {\n      initialRenderingMode = renderingMode === 'webgl' && supportsWebGL ? 'webgl' : '2d';\n    }\n    \n    setActualRenderingMode(initialRenderingMode);\n    \n    // Set device capabilities state\n    setDeviceCapabilities({\n      memory,\n      cores,\n      batteryLevel: 1,\n      isCharging: true,\n      isMobile,\n      supportsWebGL,\n      supportsOffscreenCanvas\n    });\n    \n    // Calculate quality factor based on capabilities\n    if (adaptiveQuality) {\n      // Base score from hardware\n      const performanceScore = (memory * cores) / (isMobile ? 2 : 1);\n      \n      // Scale quality based on performance score\n      let quality = 1;\n      \n      if (performanceScore > 16) {\n        quality = 1; // High-end devices\n      } else if (performanceScore > 8) {\n        quality = 0.8; // Mid-range devices\n      } else if (performanceScore > 4) {\n        quality = 0.6; // Low-end devices\n      } else {\n        quality = 0.4; // Very low-end devices\n      }\n      \n      setQualityFactor(quality);\n    }\n  }, [useWebGL, renderingMode, adaptiveQuality, enableBattery]);\n  \n  // Get cached color with opacity\n  const getCachedColor = useCallback((baseColor, opacity) => {\n    // Round opacity to reduce cache size while maintaining visual quality\n    const roundedOpacity = Math.round(opacity * 100) / 100;\n    const key = `${baseColor}-${roundedOpacity}`;\n    \n    if (!colorCacheRef.current.has(key)) {\n      const newColor = baseColor.replace(/[\\d.]+\\)$/, roundedOpacity + ')');\n      colorCacheRef.current.set(key, newColor);\n    }\n    \n    return colorCacheRef.current.get(key);\n  }, []);\n  \n  // Create a color variant based on a base color\n  const createColorVariant = useCallback((baseColor, variation) => {\n    // Parse the rgba values\n    const rgbaMatch = baseColor.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*([\\d.]+))?\\)/);\n    if (!rgbaMatch) return baseColor;\n    \n    const r = parseInt(rgbaMatch[1], 10);\n    const g = parseInt(rgbaMatch[2], 10);\n    const b = parseInt(rgbaMatch[3], 10);\n    const a = rgbaMatch[4] ? parseFloat(rgbaMatch[4]) : 1;\n    \n    // Apply random variation to RGB values\n    const vr = Math.max(0, Math.min(255, r + Math.floor((Math.random() * 2 - 1) * variation * 255)));\n    const vg = Math.max(0, Math.min(255, g + Math.floor((Math.random() * 2 - 1) * variation * 255)));\n    const vb = Math.max(0, Math.min(255, b + Math.floor((Math.random() * 2 - 1) * variation * 255)));\n    \n    return `rgba(${vr}, ${vg}, ${vb}, ${a})`;\n  }, []);\n  \n  // Adaptive settings based on quality factor\n  const adaptedSettings = useMemo(() => {\n    if (!adaptiveQuality || qualityFactor === 1) {\n      return {\n        meteorDensity,\n        trailSegments,\n        burstParticleCount,\n        useShadow: true,\n        useGlow: true,\n        useHighQualityRendering: true\n      };\n    }\n    \n    // Adjust quality-dependent parameters\n    return {\n      meteorDensity: Math.max(3, Math.floor(meteorDensity * qualityFactor)),\n      trailSegments: Math.max(5, Math.floor(trailSegments * qualityFactor)),\n      burstParticleCount: Math.max(4, Math.floor(burstParticleCount * qualityFactor)),\n      useShadow: qualityFactor > 0.5,\n      useGlow: qualityFactor > 0.3,\n      useHighQualityRendering: qualityFactor > 0.7\n    };\n  }, [adaptiveQuality, qualityFactor, meteorDensity, trailSegments, burstParticleCount]);\n  \n  // Detect device capabilities and preferences on mount\n  useEffect(() => {\n    // Check for reduced motion preference\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    \n    const handleReducedMotionChange = (e) => {\n      setPrefersReducedMotion(e.matches);\n    };\n    \n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n    \n    // Detect device capabilities\n    detectCapabilities();\n    \n    // Setup visibility change detection to pause when tab is inactive\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        visibilityChangeTimeRef.current = performance.now();\n      } else {\n        // Adjust timing references after visibility changes\n        const timeDelta = performance.now() - visibilityChangeTimeRef.current;\n        lastTimestampRef.current += timeDelta;\n        nextSpawnTimeRef.current += timeDelta;\n      }\n    };\n    \n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    \n    // Capture current worker ref to avoid closure issues\n    const currentWorker = workerRef.current;\n    \n    // Cleanup\n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n      \n      // Clean up worker if active\n      if (currentWorker) {\n        currentWorker.terminate();\n      }\n    };\n  }, [detectCapabilities]);\n  \n  // Initialize WebGL context and shaders if using WebGL\n  const initWebGL = useCallback(() => {\n    if (!canvasRef.current || actualRenderingMode !== 'webgl') return false;\n    \n    try {\n      // Get WebGL context\n      const gl = canvasRef.current.getContext('webgl', {\n        alpha: true,\n        antialias: true,\n        premultipliedAlpha: false,\n        depth: false\n      });\n      \n      if (!gl) return false;\n      \n      webGLRef.current = gl;\n      \n      // Create shader programs, vertex buffers, etc.\n      // This is a simplified placeholder - a real implementation would include\n      // proper shaders, attribute locations, and uniform setup\n      \n      // Enable blending for transparency\n      gl.enable(gl.BLEND);\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n      \n      // Set clear color to fully transparent\n      gl.clearColor(0.0, 0.0, 0.0, 0.0);\n      \n      // Get current dimensions for viewport\n      const canvasWidth = canvasRef.current.width;\n      const canvasHeight = canvasRef.current.height;\n      \n      // Set viewport\n      gl.viewport(0, 0, canvasWidth, canvasHeight);\n      \n      // Simple vertex shader for meteor particles\n      const vertexShaderSource = `\n        attribute vec2 aPosition;\n        attribute float aSize;\n        attribute vec4 aColor;\n        \n        varying vec4 vColor;\n        \n        uniform vec2 uResolution;\n        \n        void main() {\n          // Convert to clip space\n          vec2 position = (aPosition / uResolution) * 2.0 - 1.0;\n          position.y = -position.y;\n          \n          gl_Position = vec4(position, 0, 1);\n          gl_PointSize = aSize;\n          vColor = aColor;\n        }\n      `;\n      \n      // Simple fragment shader for meteor particles\n      const fragmentShaderSource = `\n        precision mediump float;\n        varying vec4 vColor;\n        \n        void main() {\n          // Calculate distance from center for circular point\n          float distance = length(gl_PointCoord - vec2(0.5, 0.5));\n          if (distance > 0.5) {\n            discard; // Outside circle\n          }\n          \n          // Softer edges\n          float alpha = smoothstep(0.5, 0.4, distance) * vColor.a;\n          gl_FragColor = vec4(vColor.rgb, alpha);\n        }\n      `;\n      \n      // Compile shader program\n      const createShader = (gl, type, source) => {\n        const shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        \n        // Check for compilation errors\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n          console.error('Shader compilation error:', gl.getShaderInfoLog(shader));\n          gl.deleteShader(shader);\n          return null;\n        }\n        \n        return shader;\n      };\n      \n      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n      \n      if (!vertexShader || !fragmentShader) {\n        return false;\n      }\n      \n      const program = gl.createProgram();\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n      \n      // Check for linking errors\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        console.error('Program linking error:', gl.getProgramInfoLog(program));\n        gl.deleteProgram(program);\n        return false;\n      }\n      \n      // Store the program\n      webGLProgramsRef.current.meteor = {\n        program,\n        attributes: {\n          position: gl.getAttribLocation(program, 'aPosition'),\n          size: gl.getAttribLocation(program, 'aSize'),\n          color: gl.getAttribLocation(program, 'aColor')\n        },\n        uniforms: {\n          resolution: gl.getUniformLocation(program, 'uResolution')\n        }\n      };\n      \n      // Now create shader program for burst particles\n      // This can be similar to the meteor program but with different parameters\n      \n      // Simple vertex shader for burst particles\n      const burstVertexShaderSource = `\n        attribute vec2 aPosition;\n        attribute float aSize;\n        attribute vec4 aColor;\n        \n        varying vec4 vColor;\n        \n        uniform vec2 uResolution;\n        \n        void main() {\n          // Convert to clip space\n          vec2 position = (aPosition / uResolution) * 2.0 - 1.0;\n          position.y = -position.y;\n          \n          gl_Position = vec4(position, 0, 1);\n          gl_PointSize = aSize;\n          vColor = aColor;\n        }\n      `;\n      \n      // Simple fragment shader for burst particles with softer edges\n      const burstFragmentShaderSource = `\n        precision mediump float;\n        varying vec4 vColor;\n        \n        void main() {\n          // Calculate distance from center for circular point\n          float distance = length(gl_PointCoord - vec2(0.5, 0.5));\n          if (distance > 0.5) {\n            discard; // Outside circle\n          }\n          \n          // Very soft edges for burst particles\n          float alpha = smoothstep(0.5, 0.2, distance) * vColor.a;\n          gl_FragColor = vec4(vColor.rgb, alpha);\n        }\n      `;\n      \n      const burstVertexShader = createShader(gl, gl.VERTEX_SHADER, burstVertexShaderSource);\n      const burstFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, burstFragmentShaderSource);\n      \n      if (!burstVertexShader || !burstFragmentShader) {\n        return false;\n      }\n      \n      const burstProgram = gl.createProgram();\n      gl.attachShader(burstProgram, burstVertexShader);\n      gl.attachShader(burstProgram, burstFragmentShader);\n      gl.linkProgram(burstProgram);\n      \n      // Check for linking errors\n      if (!gl.getProgramParameter(burstProgram, gl.LINK_STATUS)) {\n        console.error('Burst program linking error:', gl.getProgramInfoLog(burstProgram));\n        gl.deleteProgram(burstProgram);\n      } else {\n        // Store the burst program\n        webGLProgramsRef.current.burst = {\n          program: burstProgram,\n          attributes: {\n            position: gl.getAttribLocation(burstProgram, 'aPosition'),\n            size: gl.getAttribLocation(burstProgram, 'aSize'),\n            color: gl.getAttribLocation(burstProgram, 'aColor')\n          },\n          uniforms: {\n            resolution: gl.getUniformLocation(burstProgram, 'uResolution')\n          }\n        };\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('WebGL initialization error:', error);\n      setActualRenderingMode('2d');\n      return false;\n    }\n  }, [actualRenderingMode]);\n  \n  // Calculate path parameters for a meteor based on selected mode\n  const calculateMeteorPath = useCallback((width, height) => {\n    if (mode === 'arc') {\n      // Arc path logic with optimized parameters\n      const startX = Math.random() * width * 1.5 - width * 0.25;\n      const startY = Math.random() * -100 - 50;\n      \n      const curveDirection = Math.random() > 0.5 ? 1 : -1;\n      const curveIntensity = Math.random() * 0.4 + 0.2;\n      \n      const endX = startX + (curveDirection * width * curveIntensity);\n      const endY = height * journeyCompletion;\n      \n      const controlX = (startX + endX) / 2 + (curveDirection * width * curveIntensity);\n      const controlY = (startY + endY) * 0.5;\n      \n      return {\n        pathType: 'arc',\n        start: { x: startX, y: startY },\n        control: { x: controlX, y: controlY },\n        end: { x: endX, y: endY }\n      };\n    } else if (mode === 'linear') {\n      // Linear path logic with enhanced direction control\n      let meteorDirection = direction;\n      if (direction === 'both') {\n        meteorDirection = Math.random() > 0.5 ? 'left' : 'right';\n      }\n      \n      let angle;\n      if (direction === 'top') {\n        angle = ((30 + (Math.random() * 2 - 1) * 5) * Math.PI) / 180;\n      } else {\n        angle = ((baseAngle + (Math.random() * 2 - 1) * angleVariation) * Math.PI) / 180;\n      }\n      \n      let startX;\n      if (meteorDirection === 'left') {\n        startX = Math.random() * (width * 0.3) - (width * 0.1);\n      } else if (meteorDirection === 'right') {\n        startX = width - Math.random() * (width * 0.3) + (width * 0.1);\n      } else if (direction === 'top') {\n        const position = Math.random();\n        if (position < 0.5) {\n          startX = Math.random() * (width * 0.35);\n        } else if (position < 0.85) {\n          startX = width * 0.35 + Math.random() * (width * 0.35);\n        } else {\n          startX = width * 0.7 + Math.random() * (width * 0.3);\n        }\n      }\n      \n      const startY = Math.random() * -100 - 50;\n      const distanceToTravel = (height * journeyCompletion) / Math.cos(angle);\n      \n      let endX, endY;\n      if (meteorDirection === 'left' || direction === 'top') {\n        endX = startX + distanceToTravel * Math.sin(angle);\n        endY = startY + distanceToTravel * Math.cos(angle);\n      } else {\n        endX = startX - distanceToTravel * Math.sin(angle);\n        endY = startY + distanceToTravel * Math.cos(angle);\n      }\n      \n      return {\n        pathType: 'linear',\n        start: { x: startX, y: startY },\n        end: { x: endX, y: endY },\n        direction: meteorDirection\n      };\n    }\n  }, [mode, direction, baseAngle, angleVariation, journeyCompletion]);\n  \n  // Get point along path with highly optimized calculations\n  const getPathPoint = useCallback((t, path, outPoint = { x: 0, y: 0 }) => {\n    if (path.pathType === 'arc') {\n      // Optimized quadratic bezier calculation using pre-computed terms\n      const invT = 1 - t;\n      const invTSquared = invT * invT;\n      const tSquared = t * t;\n      const term1 = invTSquared;\n      const term2 = 2 * invT * t;\n      const term3 = tSquared;\n      \n      outPoint.x = term1 * path.start.x + term2 * path.control.x + term3 * path.end.x;\n      outPoint.y = term1 * path.start.y + term2 * path.control.y + term3 * path.end.y;\n    } else {\n      // Linear interpolation with minimal operations\n      outPoint.x = path.start.x + (path.end.x - path.start.x) * t;\n      outPoint.y = path.start.y + (path.end.y - path.start.y) * t;\n    }\n    \n    return outPoint;\n  }, []);\n  \n  // Calculate velocity at a point on the path (for trail orientation)\n  const getPathVelocity = useCallback((t, path, outVelocity = { x: 0, y: 0 }) => {\n    if (path.pathType === 'arc') {\n      // Derivative of quadratic bezier\n      const term1 = 2 * (1 - t);\n      const term2 = 2 * t;\n      \n      outVelocity.x = term1 * (path.control.x - path.start.x) + term2 * (path.end.x - path.control.x);\n      outVelocity.y = term1 * (path.control.y - path.start.y) + term2 * (path.end.y - path.control.y);\n    } else {\n      // Constant velocity for linear paths\n      outVelocity.x = path.end.x - path.start.x;\n      outVelocity.y = path.end.y - path.start.y;\n      \n      // Normalize\n      const length = Math.sqrt(outVelocity.x * outVelocity.x + outVelocity.y * outVelocity.y);\n      if (length > 0) {\n        outVelocity.x /= length;\n        outVelocity.y /= length;\n      }\n    }\n    \n    return outVelocity;\n  }, []);\n  \n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current || !containerRef.current) return false;\n    \n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    const rect = container.getBoundingClientRect();\n    const pixelRatio = window.devicePixelRatio || 1;\n    \n    // Calculate dimensions\n    const displayWidth = rect.width;\n    const displayHeight = typeof height === 'string' && height.endsWith('vh') \n      ? (parseInt(height, 10) / 100) * window.innerHeight\n      : parseInt(height, 10) || window.innerHeight;\n    \n    // Set canvas size accounting for pixel ratio\n    canvas.width = displayWidth * pixelRatio;\n    canvas.height = displayHeight * pixelRatio;\n    canvas.style.width = `${displayWidth}px`;\n    canvas.style.height = `${displayHeight}px`;\n    \n    // Get appropriate rendering context\n    if (actualRenderingMode === 'webgl') {\n      initWebGL();\n    } else {\n      // 2D Canvas context\n      const ctx = canvas.getContext('2d', {\n        alpha: true,\n        desynchronized: true,\n        willReadFrequently: false\n      });\n      \n      if (!ctx) return false;\n      \n      // Scale context for high-DPI displays\n      ctx.scale(pixelRatio, pixelRatio);\n      \n      // Configure context for high-quality rendering\n      if (adaptedSettings.useHighQualityRendering) {\n        ctx.imageSmoothingEnabled = true;\n        ctx.imageSmoothingQuality = 'high';\n      }\n      \n      ctxRef.current = ctx;\n    }\n    \n    // Initialize offscreen canvas if supported and enabled\n    if (enableOffscreenRendering && typeof OffscreenCanvas !== 'undefined' &&\n        deviceCapabilities.supportsOffscreenCanvas) {\n      try {\n        // Create offscreen canvas\n        const offscreen = new OffscreenCanvas(\n          displayWidth * pixelRatio,\n          displayHeight * pixelRatio\n        );\n        \n        // Get 2D context for offscreen canvas\n        const offscreenCtx = offscreen.getContext('2d');\n        if (offscreenCtx) {\n          offscreenCtx.scale(pixelRatio, pixelRatio);\n          offscreenCanvasRef.current = {\n            canvas: offscreen,\n            ctx: offscreenCtx\n          };\n        }\n      } catch (error) {\n        console.warn('Offscreen canvas initialization error:', error);\n      }\n    }\n    \n    setDimensions({\n      width: displayWidth,\n      height: displayHeight,\n      pixelRatio\n    });\n    \n    return true;\n  }, [height, actualRenderingMode, initWebGL, enableOffscreenRendering, deviceCapabilities.supportsOffscreenCanvas, adaptedSettings.useHighQualityRendering]);\n  \n  // Setup canvas resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n    \n    // Create a ResizeObserver to detect container size changes\n    const resizeObserver = new ResizeObserver(entries => {\n      // Debounce resize operations\n      if (resizeObserverRef.current.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n      \n      resizeObserverRef.current.timeout = setTimeout(() => {\n        requestAnimationFrame(() => {\n          if (setupCanvas()) {\n            setIsInitialized(true);\n          }\n        });\n      }, 100); // 100ms debounce\n    });\n    \n    // Capture current reference to avoid closure issues in cleanup\n    const currentContainer = containerRef.current;\n    \n    // Start observing the container\n    resizeObserver.observe(currentContainer);\n    resizeObserverRef.current = { observer: resizeObserver };\n    \n    // Initial setup\n    setupCanvas();\n    setIsInitialized(true);\n    \n    return () => {\n      if (resizeObserverRef.current.observer) {\n        resizeObserverRef.current.observer.disconnect();\n      }\n      if (resizeObserverRef.current.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n    };\n  }, [setupCanvas]);\n  \n  // Setup intersection observer to only animate when visible\n  useEffect(() => {\n    if (!containerRef.current) return;\n    \n    const observer = new IntersectionObserver(\n      entries => {\n        const isIntersecting = entries[0].isIntersecting;\n        \n        // Only change state if visibility actually changed\n        if (isIntersecting !== isVisible) {\n          setIsVisible(isIntersecting);\n          \n          if (isIntersecting) {\n            // Reset timing references when becoming visible again\n            lastTimestampRef.current = 0;\n            nextSpawnTimeRef.current = performance.now();\n          }\n        }\n      },\n      {\n        threshold: 0.01,\n        rootMargin: '100px'\n      }\n    );\n    \n    // Store current reference to avoid closure issues\n    const currentContainerRef = containerRef.current;\n    observer.observe(currentContainerRef);\n    visibilityObserverRef.current = observer;\n    \n    return () => {\n      if (visibilityObserverRef.current) {\n        visibilityObserverRef.current.disconnect();\n      }\n    };\n  }, [isVisible]);\n  \n  // Handle parallax effect on scroll if enabled\n  useEffect(() => {\n    if (!enableParallax) return;\n    \n    // Use passive event listener for better performance\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    \n    window.addEventListener('scroll', handleScroll, { passive: true });\n    \n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [enableParallax]);\n  \n  // Get a meteor from the object pool or create a new one\n  const getMeteor = useCallback(() => {\n    // Try to get from pool first\n    const pool = objectPoolsRef.current.meteors;\n    let meteor;\n    \n    if (pool.length > 0) {\n      meteor = pool.pop();\n      // Reset meteor properties\n      meteor.progress = 0;\n      meteor.active = true;\n    } else {\n      // Create new if pool is empty\n      meteor = {\n        progress: 0,\n        active: true,\n        positions: Array(adaptedSettings.trailSegments)\n      };\n      \n      // Pre-allocate position objects\n      for (let i = 0; i < adaptedSettings.trailSegments; i++) {\n        meteor.positions[i] = { x: 0, y: 0 };\n      }\n    }\n    \n    return meteor;\n  }, [adaptedSettings.trailSegments]);\n  \n  // Initialize a meteor with all required properties\n  const initializeMeteor = useCallback(() => {\n    const { width, height } = dimensions;\n    \n    if (!width || !height) return null;\n    \n    // Get meteor from pool\n    const meteor = getMeteor();\n    \n    // Calculate path based on mode\n    const path = calculateMeteorPath(width, height);\n    \n    // Set path and initial position\n    meteor.path = path;\n    for (let i = 0; i < meteor.positions.length; i++) {\n      meteor.positions[i].x = path.start.x;\n      meteor.positions[i].y = path.start.y;\n    }\n    \n    // Set meteor properties\n    meteor.size = Math.random() * (meteorMaxSize - meteorMinSize) + meteorMinSize;\n    meteor.speed = meteorSpeed * (Math.random() * 0.5 + 0.75);\n    meteor.opacity = Math.random() * 0.3 + 0.7;\n    meteor.fadeThreshold = 0.7 + Math.random() * 0.2;\n    meteor.pulsePhase = Math.random() * Math.PI * 2;\n    meteor.pulseSpeed = Math.random() * 0.01 + 0.005;\n    \n    // Add burst properties if enabled\n    if (enableBursts && Math.random() < burstProbability) {\n      meteor.hasBurst = true;\n      \n      // Vary the burst threshold - occasionally have early bursts for variety\n      const earlyBurst = Math.random() < 0.15; // 15% chance for early burst\n      meteor.burstThreshold = earlyBurst \n        ? 0.3 + Math.random() * 0.4 // Early burst range (0.3-0.7)\n        : 0.85 + Math.random() * 0.13; // Normal late burst range (0.85-0.98)\n      \n      meteor.burstTriggered = false;\n      \n      // Adjust burst size based on when it occurs\n      meteor.burstSize = earlyBurst\n        ? meteor.size * (3 + Math.random() * 4) // Larger for early bursts\n        : meteor.size * (2 + Math.random() * 2); // More controlled for end bursts\n      \n      // Adjust particle count based on when it occurs\n      meteor.burstParticles = Math.floor(\n        adaptedSettings.burstParticleCount * \n        (earlyBurst ? 1.2 : 0.8) * // More particles for early bursts\n        (0.8 + Math.random() * 0.4)\n      );\n      \n      // Use custom gold-centric colors for dark fantasy aesthetic\n      // No need to use createColorVariant here since we're using specific themed colors\n      meteor.burstColors = [\n        'rgba(255, 215, 0, 1)', // Gold\n        'rgba(218, 165, 32, 1)', // Goldenrod\n        'rgba(212, 175, 55, 1)', // Metallic gold\n        'rgba(207, 181, 59, 1)', // Old gold\n        earlyBurst ? 'rgba(255, 255, 220, 1)' : 'rgba(192, 192, 192, 1)' // Bright for early, silver for late\n      ];\n    } else {\n      meteor.hasBurst = false;\n    }\n    \n    return meteor;\n  }, [\n    dimensions,\n    calculateMeteorPath,\n    meteorMinSize,\n    meteorMaxSize,\n    meteorSpeed,\n    enableBursts,\n    burstProbability,\n    adaptedSettings.burstParticleCount,\n    getMeteor\n  ]);\n  \n  // Get a burst particle from the object pool or create a new one\n  const getBurstParticle = useCallback(() => {\n    const pool = objectPoolsRef.current.bursts;\n    \n    if (pool.length > 0) {\n      const burst = pool.pop();\n      // Reset properties\n      burst.life = 1.0;\n      return burst;\n    }\n    \n    // Create new if pool is empty\n    return {};\n  }, []);\n  \n  // Create a burst effect at a specified position\n  const createBurst = useCallback((x, y, size, colors, particleCount, velocityInfluence = { x: 0, y: 0 }) => {\n    // Skip if bursts are not enabled\n    if (!enableBursts) return;\n    \n    // Limit the number of active burst particles to avoid performance issues\n    const maxBurstParticles = adaptedSettings.useHighQualityRendering ? 300 : 150;\n    \n    // If we're already close to the limit, reduce the number of particles\n    let actualParticleCount = particleCount;\n    if (burstsRef.current.length > maxBurstParticles - particleCount) {\n      actualParticleCount = Math.max(4, Math.floor(particleCount * 0.5));\n    }\n    \n    // Skip burst creation completely if we're already over the limit\n    if (burstsRef.current.length > maxBurstParticles) {\n      // Remove older bursts to make room\n      const toRemove = Math.min(20, burstsRef.current.length - maxBurstParticles + actualParticleCount);\n      for (let i = 0; i < toRemove; i++) {\n        const oldBurst = burstsRef.current.shift();\n        if (oldBurst) {\n          objectPoolsRef.current.bursts.push(oldBurst);\n        }\n      }\n    }\n    \n    // Track burst counts for debug\n    lastBurstCountRef.current = actualParticleCount;\n    \n    // Base colors for the dark fantasy aesthetic - gold to silver gradient\n    const baseColors = [\n      'rgba(255, 215, 0, 1)',     // Gold\n      'rgba(255, 223, 0, 1)',     // Gold (slightly different)\n      'rgba(218, 165, 32, 1)',    // Goldenrod\n      'rgba(212, 175, 55, 1)',    // Metallic gold\n      'rgba(207, 181, 59, 1)'     // Old gold\n    ];\n    \n    // Ending colors for the transition\n    const endColors = [\n      'rgba(192, 192, 192, 1)',   // Silver\n      'rgba(211, 211, 211, 1)',   // Light gray\n      'rgba(169, 169, 169, 1)'    // Dark gray\n    ];\n    \n    // Create particles in a more focused, elegant burst pattern\n    for (let i = 0; i < actualParticleCount; i++) {\n      // Create a more focused arc of particles in the direction of meteor travel\n      // with some spreading outward\n      const baseAngle = Math.atan2(velocityInfluence.y, velocityInfluence.x);\n      \n      // Create a cone of particles that follows the meteor's trajectory\n      // with some variance for an elegant spread\n      const angleSpread = 1.6; // About 90 degrees total\n      const angleVariance = (Math.random() * angleSpread - angleSpread/2);\n      const angle = baseAngle + angleVariance;\n      \n      // More elegant speed distribution - less bouncy, more drifting\n      const speedVariance = Math.random() * 0.3 + 0.85; // less variance\n      const baseSpeed = 0.6 + Math.random() * 1.2; // slower overall\n      const speed = baseSpeed * speedVariance;\n      \n      // Calculate velocity components\n      // Add a slight upward tendency for some particles to create a rising ember effect\n      const upwardBias = Math.random() * 0.4 - 0.1; // Mostly upward\n      const vx = Math.cos(angle) * speed + velocityInfluence.x * 0.3;\n      const vy = Math.sin(angle) * speed + velocityInfluence.y * 0.3 - upwardBias;\n      \n      // More consistent sizing for a refined look\n      const sizeVariance = 0.6 + Math.random() * 0.5; // less variance\n      const particleSize = size * sizeVariance * burstParticleSize * 0.8; // slightly smaller\n      \n      // Select a color - preference toward gold but include some silver for variation\n      let color;\n      const colorRoll = Math.random();\n      \n      if (colorRoll < 0.85) {\n        // 85% chance of gold tone\n        const goldIndex = Math.floor(Math.random() * baseColors.length);\n        color = baseColors[goldIndex];\n      } else {\n        // 15% chance of silver tone for variation\n        const silverIndex = Math.floor(Math.random() * endColors.length);\n        color = endColors[silverIndex];\n      }\n      \n      // Create the burst particle\n      const burst = getBurstParticle();\n      \n      // Set properties\n      burst.x = x + (Math.random() * 4 - 2); // Less initial position variance\n      burst.y = y + (Math.random() * 4 - 2);\n      burst.initialX = burst.x;\n      burst.initialY = burst.y;\n      burst.vx = vx;\n      burst.vy = vy;\n      burst.size = particleSize;\n      burst.initialSize = particleSize;\n      burst.life = 1.0;\n      \n      // Longer-lived particles for more elegant effect\n      burst.decay = 0.007 + Math.random() * 0.015; // slower decay\n      \n      burst.color = color;\n      burst.initialColor = color; // Store for color transition\n      \n      // Subtle rotation for wispy effect\n      burst.rotation = Math.random() * Math.PI;\n      burst.rotationSpeed = (Math.random() * 2 - 1) * 0.03; // slower rotation\n      \n      // Replace gravity with upward drift for some particles\n      burst.upwardDrift = Math.random() * 0.05;\n      \n      // Higher damping for more elegant movement\n      burst.damping = 0.97 + Math.random() * 0.01;\n      \n      // Add to active bursts\n      burstsRef.current.push(burst);\n    }\n  }, [enableBursts, adaptedSettings.useHighQualityRendering, getBurstParticle, burstParticleSize]);\n  \n  // Render burst particles with WebGL\n  const renderBurstsWebGL = useCallback((gl, deltaTime) => {\n    if (!enableBursts || burstsRef.current.length === 0 || !webGLProgramsRef.current.burst) return;\n    \n    const burstProgram = webGLProgramsRef.current.burst;\n    \n    // Use burst shader program\n    gl.useProgram(burstProgram.program);\n    \n    // Set resolution uniform\n    gl.uniform2f(\n      burstProgram.uniforms.resolution,\n      canvasRef.current.width,\n      canvasRef.current.height\n    );\n    \n    // Create float32 arrays to hold position, size, and color data\n    // 2 floats per position (x, y)\n    const positions = new Float32Array(burstsRef.current.length * 2);\n    // 1 float per size\n    const sizes = new Float32Array(burstsRef.current.length);\n    // 4 floats per color (r, g, b, a)\n    const colors = new Float32Array(burstsRef.current.length * 4);\n    \n    // Process each burst particle and update its data\n    for (let i = 0; i < burstsRef.current.length; i++) {\n      const burst = burstsRef.current[i];\n      \n      // Update position\n      burst.x += burst.vx * (deltaTime / 16);\n      burst.y += burst.vy * (deltaTime / 16);\n      \n      // Apply gravity if present\n      if (burst.gravity) {\n        burst.vy += burst.gravity * (deltaTime / 16);\n      }\n      \n      // Apply damping to velocity\n      burst.vx *= burst.damping;\n      burst.vy *= burst.damping;\n      \n      // Update rotation\n      burst.rotation += burst.rotationSpeed * (deltaTime / 16);\n      \n      // Reduce life\n      burst.life -= burst.decay * (deltaTime / 16);\n      \n      // Map burst data to arrays\n      const posIndex = i * 2;\n      positions[posIndex] = burst.x;\n      positions[posIndex + 1] = burst.y;\n      \n      sizes[i] = burst.size * Math.pow(burst.life, 0.7) * dimensions.pixelRatio;\n      \n      // Parse color components from rgba string\n      // This is a simplified placeholder - you'd need proper color parsing\n      const colorIndex = i * 4;\n      colors[colorIndex] = 1.0;     // r\n      colors[colorIndex + 1] = 0.9; // g\n      colors[colorIndex + 2] = 0.7; // b\n      colors[colorIndex + 3] = burst.life * 0.7; // a\n    }\n    \n    // Create and bind position buffer\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(burstProgram.attributes.position);\n    gl.vertexAttribPointer(burstProgram.attributes.position, 2, gl.FLOAT, false, 0, 0);\n    \n    // Create and bind size buffer\n    const sizeBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, sizes, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(burstProgram.attributes.size);\n    gl.vertexAttribPointer(burstProgram.attributes.size, 1, gl.FLOAT, false, 0, 0);\n    \n    // Create and bind color buffer\n    const colorBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(burstProgram.attributes.color);\n    gl.vertexAttribPointer(burstProgram.attributes.color, 4, gl.FLOAT, false, 0, 0);\n    \n    // Draw points\n    gl.drawArrays(gl.POINTS, 0, burstsRef.current.length);\n    \n    // Clean up\n    gl.disableVertexAttribArray(burstProgram.attributes.position);\n    gl.disableVertexAttribArray(burstProgram.attributes.size);\n    gl.disableVertexAttribArray(burstProgram.attributes.color);\n    gl.deleteBuffer(positionBuffer);\n    gl.deleteBuffer(sizeBuffer);\n    gl.deleteBuffer(colorBuffer);\n    \n    // Filter out dead particles\n    let j = 0;\n    for (let i = 0; i < burstsRef.current.length; i++) {\n      const burst = burstsRef.current[i];\n      if (burst.life > 0) {\n        // Keep alive particles, compact array\n        if (i !== j) {\n          burstsRef.current[j] = burst;\n        }\n        j++;\n      } else {\n        // Return to object pool\n        objectPoolsRef.current.bursts.push(burst);\n      }\n    }\n    \n    // Truncate array to remove dead particles\n    if (j < burstsRef.current.length) {\n      burstsRef.current.length = j;\n    }\n  }, [enableBursts, dimensions.pixelRatio]);\n  \n  // Render burst particles with Canvas 2D\n  const renderBursts2D = useCallback((ctx, deltaTime) => {\n    if (!enableBursts || burstsRef.current.length === 0) return;\n    \n    // Process and render each burst particle\n    let j = 0;\n    for (let i = 0; i < burstsRef.current.length; i++) {\n      const burst = burstsRef.current[i];\n      \n      // Update position with more ethereal, drifting movement\n      burst.x += burst.vx * (deltaTime / 16);\n      burst.y += burst.vy * (deltaTime / 16);\n      \n      // Apply slight upward drift instead of gravity for ethereal effect\n      burst.vy -= (burst.upwardDrift || 0.01) * (deltaTime / 16);\n      \n      // Apply stronger damping for elegant fade-out\n      burst.vx *= burst.damping;\n      burst.vy *= burst.damping;\n      \n      // Update rotation more subtly\n      if (burst.rotation !== undefined) {\n        burst.rotation += (burst.rotationSpeed || 0.01) * (deltaTime / 16);\n      }\n      \n      // Reduce life\n      burst.life -= burst.decay * (deltaTime / 16);\n      \n      // Keep alive particles\n      if (burst.life > 0) {\n        // Draw particle\n        ctx.save();\n        \n        // Calculate fade color - transition from gold to silver\n        const fadeProgress = 1 - burst.life;\n        \n        // High-quality rendering with ethereal glow effects\n        if (adaptedSettings.useHighQualityRendering) {\n          // Add shadow for glow effect - more pronounced for fantasy aesthetic\n          if (adaptedSettings.useGlow) {\n            // Transition from golden to silver glow\n            const glowColor = burst.initialColor || glowColor;\n            ctx.shadowColor = glowColor;\n            ctx.shadowBlur = burst.size * (2.5 + fadeProgress) * burst.life;\n          }\n          \n          // Create elongated, wispy particles that stretch as they move\n          const baseLength = burst.size * (1 + fadeProgress * 2);\n          const trailLength = baseLength * 2.5;\n          \n          // Calculate the particle's movement direction\n          const angle = Math.atan2(burst.vy, burst.vx);\n          \n          // Draw wispy, ember-like trail\n          ctx.translate(burst.x, burst.y);\n          ctx.rotate(angle + (burst.rotation || 0));\n          \n          // Create gradient for ember trail - gold to silver transition\n          const gradient = ctx.createLinearGradient(0, 0, -trailLength, 0);\n          \n          // Determine colors based on life cycle\n          // Start with golden/ember colors, fade to silver/ash\n          const startOpacity = burst.life * 0.8;\n          const endOpacity = burst.life * 0.1;\n          \n          // Gold to silver transition\n          const startColor = getCachedColor(burst.color || 'rgba(255, 215, 0, 1)', startOpacity);\n          const midColor = getCachedColor('rgba(232, 224, 185, 1)', startOpacity * 0.6);\n          const endColor = getCachedColor('rgba(192, 192, 192, 1)', endOpacity);\n          \n          gradient.addColorStop(0, startColor);\n          gradient.addColorStop(0.4, midColor);\n          gradient.addColorStop(1, endColor);\n          \n          // Draw ember trail as tapered shape\n          ctx.beginPath();\n          \n          // Ember head (slightly wider)\n          const headWidth = baseLength * 0.3;\n          ctx.moveTo(0, headWidth);\n          \n          // Curved trail sides\n          ctx.quadraticCurveTo(-trailLength/2, headWidth * 0.8, -trailLength, 0);\n          ctx.quadraticCurveTo(-trailLength/2, -headWidth * 0.8, 0, -headWidth);\n          \n          ctx.closePath();\n          ctx.fillStyle = gradient;\n          ctx.fill();\n          \n          // Add small ember core with brighter glow\n          const coreSize = baseLength * 0.4;\n          ctx.beginPath();\n          ctx.arc(0, 0, coreSize, 0, Math.PI * 2);\n          \n          // Core gradient - brighter center\n          const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, coreSize);\n          coreGradient.addColorStop(0, getCachedColor('rgba(255, 255, 220, 1)', burst.life));\n          coreGradient.addColorStop(0.5, getCachedColor(burst.color || 'rgba(255, 215, 0, 1)', burst.life * 0.9));\n          coreGradient.addColorStop(1, getCachedColor(burst.color || 'rgba(255, 215, 0, 1)', burst.life * 0.4));\n          \n          ctx.fillStyle = coreGradient;\n          ctx.fill();\n        } else {\n          // Simpler rendering for lower-end devices - still elegant\n          const angle = Math.atan2(burst.vy, burst.vx);\n          \n          // Simple elongated particle\n          ctx.translate(burst.x, burst.y);\n          ctx.rotate(angle);\n          \n          // Simple gradient\n          const simpleGradient = ctx.createLinearGradient(0, 0, -burst.size * 3 * burst.life, 0);\n          simpleGradient.addColorStop(0, getCachedColor(burst.color || glowColor, burst.life * 0.8));\n          simpleGradient.addColorStop(1, getCachedColor('rgba(192, 192, 192, 1)', burst.life * 0.2));\n          \n          // Draw teardrop shape\n          ctx.beginPath();\n          ctx.arc(0, 0, burst.size * burst.life, 0, Math.PI, true);\n          ctx.lineTo(-burst.size * 3 * burst.life, 0);\n          ctx.closePath();\n          \n          ctx.fillStyle = simpleGradient;\n          ctx.fill();\n        }\n        \n        ctx.restore();\n        \n        // Compact alive particles\n        if (i !== j) {\n          burstsRef.current[j] = burst;\n        }\n        j++;\n      } else {\n        // Return to object pool\n        objectPoolsRef.current.bursts.push(burst);\n      }\n    }\n    \n    // Truncate array to remove dead particles\n    if (j < burstsRef.current.length) {\n      burstsRef.current.length = j;\n    }\n  }, [enableBursts, adaptedSettings.useHighQualityRendering, adaptedSettings.useGlow, getCachedColor, glowColor]);\n  \n  // 2D Canvas rendering method for meteors\n  const renderMeteors2D = useCallback((ctx, parallaxOffset, timestamp) => {\n    // Process and render each meteor\n    meteorsRef.current.forEach(meteor => {\n      // Calculate opacity based on progress\n      let currentOpacity = meteor.opacity;\n      if (meteor.progress > meteor.fadeThreshold) {\n        const fadeProgress = (meteor.progress - meteor.fadeThreshold) / (1 - meteor.fadeThreshold);\n        currentOpacity = meteor.opacity * (1 - fadeProgress);\n      }\n      \n      // Apply pulse effect\n      const timeFactor = timestamp * 0.001;\n      const pulseEffect = Math.sin(timeFactor * meteor.pulseSpeed + meteor.pulsePhase) * 0.2 + 0.8;\n      \n      // Parallax offset adjustment\n      const adjustY = enableParallax ? parallaxOffset * (meteor.size / meteorMaxSize) : 0;\n      \n      // Check if we should create a burst effect\n      if (meteor.hasBurst && !meteor.burstTriggered && meteor.progress >= meteor.burstThreshold) {\n        meteor.burstTriggered = true;\n        const burstPosition = meteor.positions[0];\n        \n        // Get velocity at burst point for influence on particles\n        const velocityPoint = { x: 0, y: 0 };\n        getPathVelocity(meteor.progress, meteor.path, velocityPoint);\n        \n        // Scale velocity for better visual effect\n        velocityPoint.x *= 0.8;\n        velocityPoint.y *= 0.8;\n        \n        // Create burst with velocity influence\n        createBurst(\n          burstPosition.x,\n          burstPosition.y + adjustY,\n          meteor.burstSize,\n          meteor.burstColors,\n          meteor.burstParticles,\n          velocityPoint\n        );\n      }\n      \n      // Optimized rendering approach\n      if (adaptedSettings.useHighQualityRendering) {\n        // High-quality rendering with shadows\n        // Set shadow for glow effect if enabled\n        if (adaptedSettings.useGlow) {\n          ctx.shadowColor = glowColor;\n          ctx.shadowBlur = meteor.size * 3 * pulseEffect;\n        }\n        \n        // Draw trail segments\n        ctx.lineCap = 'round';\n        \n        for (let i = meteor.positions.length - 2; i >= 0; i--) {\n          const pos1 = meteor.positions[i];\n          const pos2 = meteor.positions[i + 1];\n          \n          if (!pos1 || !pos2) continue;\n          \n          // Calculate segment opacity (decreases along the trail)\n          const segmentOpacity = currentOpacity * (1 - i / meteor.positions.length) * pulseEffect;\n          \n          // Skip if nearly invisible\n          if (segmentOpacity < 0.02) continue;\n          \n          // Calculate segment width (decreases along the trail)\n          const segmentWidth = meteor.size * (1 - i / meteor.positions.length * 0.7);\n          \n          // Draw line segment\n          ctx.beginPath();\n          ctx.moveTo(pos1.x, pos1.y + adjustY);\n          ctx.lineTo(pos2.x, pos2.y + adjustY);\n          \n          // Set line style\n          ctx.lineWidth = segmentWidth;\n          ctx.strokeStyle = getCachedColor(trailColor, segmentOpacity);\n          ctx.stroke();\n        }\n        \n        // Draw meteor head\n        if (meteor.positions[0]) {\n          const headPos = meteor.positions[0];\n          \n          // Set shadow for head\n          if (adaptedSettings.useShadow) {\n            ctx.shadowColor = glowColor;\n            ctx.shadowBlur = meteor.size * 5 * pulseEffect;\n          }\n          \n          // Draw outer glow\n          ctx.beginPath();\n          ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 1.5, 0, Math.PI * 2);\n          ctx.fillStyle = getCachedColor(glowColor, currentOpacity * 0.7 * pulseEffect);\n          ctx.fill();\n          \n          // Draw inner core\n          ctx.beginPath();\n          ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 0.7, 0, Math.PI * 2);\n          ctx.fillStyle = getCachedColor(coreColor, currentOpacity * pulseEffect);\n          ctx.fill();\n        }\n      } else {\n        // Performance-optimized rendering for lower-end devices\n        // Draw simplified trail\n        ctx.beginPath();\n        const headPos = meteor.positions[0];\n        if (!headPos) return;\n        \n        ctx.moveTo(headPos.x, headPos.y + adjustY);\n        \n        for (let i = 1; i < meteor.positions.length; i += 2) {\n          const pos = meteor.positions[i];\n          if (!pos) continue;\n          ctx.lineTo(pos.x, pos.y + adjustY);\n        }\n        \n        // Gradient trail\n        const gradient = ctx.createLinearGradient(\n          headPos.x, headPos.y + adjustY,\n          meteor.positions[meteor.positions.length - 1].x,\n          meteor.positions[meteor.positions.length - 1].y + adjustY\n        );\n        \n        gradient.addColorStop(0, getCachedColor(coreColor, currentOpacity * pulseEffect));\n        gradient.addColorStop(0.3, getCachedColor(glowColor, currentOpacity * 0.7 * pulseEffect));\n        gradient.addColorStop(1, getCachedColor(trailColor, 0));\n        \n        ctx.strokeStyle = gradient;\n        ctx.lineWidth = meteor.size;\n        ctx.lineCap = 'round';\n        ctx.stroke();\n        \n        // Simple head\n        ctx.beginPath();\n        ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 0.7, 0, Math.PI * 2);\n        ctx.fillStyle = getCachedColor(coreColor, currentOpacity * pulseEffect);\n        ctx.fill();\n      }\n    });\n  }, [\n    adaptedSettings.useHighQualityRendering,\n    adaptedSettings.useGlow,\n    adaptedSettings.useShadow,\n    enableParallax,\n    meteorMaxSize,\n    glowColor,\n    trailColor,\n    coreColor,\n    getCachedColor,\n    createBurst,\n    getPathVelocity\n  ]);\n  \n  // WebGL rendering method\n  const renderMeteorsWebGL = useCallback((gl, timestamp) => {\n    // This is a simplified placeholder for WebGL rendering\n    // A full implementation would use the shaders and buffers set up earlier\n    \n    if (!gl || !webGLProgramsRef.current.meteor) return;\n    \n    // Clear canvas\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    \n    // Use meteor shader program\n    const meteorProgram = webGLProgramsRef.current.meteor;\n    gl.useProgram(meteorProgram.program);\n    \n    // Set uniforms\n    gl.uniform2f(\n      meteorProgram.uniforms.resolution,\n      canvasRef.current.width,\n      canvasRef.current.height\n    );\n    \n    // This is where we would bind vertex buffers and render particles\n    // For a real implementation, you would:\n    // 1. Update vertex buffer with current meteor positions\n    // 2. Set attributes for position, size, color\n    // 3. Draw using gl.POINTS or other appropriate primitives\n    \n    // Check for burst triggers in WebGL mode too\n    meteorsRef.current.forEach(meteor => {\n      if (meteor.hasBurst && !meteor.burstTriggered && meteor.progress >= meteor.burstThreshold) {\n        meteor.burstTriggered = true;\n        const burstPosition = meteor.positions[0];\n        \n        // Get velocity at burst point for influence on particles\n        const velocityPoint = { x: 0, y: 0 };\n        getPathVelocity(meteor.progress, meteor.path, velocityPoint);\n        \n        // Create burst with velocity influence\n        // This will add particles to be rendered by renderBurstsWebGL\n        createBurst(\n          burstPosition.x,\n          burstPosition.y,\n          meteor.burstSize,\n          meteor.burstColors,\n          meteor.burstParticles,\n          velocityPoint\n        );\n      }\n    });\n    \n  }, [createBurst, getPathVelocity]);\n  \n  // Update meteor positions\n  const updateMeteors = useCallback((deltaTime) => {\n    // Process meteors without destructuring unused width/height\n    for (let i = meteorsRef.current.length - 1; i >= 0; i--) {\n      const meteor = meteorsRef.current[i];\n      \n      // Update progress based on speed and delta time\n      meteor.progress += meteor.speed * (deltaTime / 1000);\n      \n      // Check if meteor has completed its path\n      if (meteor.progress >= 1) {\n        // Return to object pool\n        meteor.active = false;\n        objectPoolsRef.current.meteors.push(meteor);\n        meteorsRef.current.splice(i, 1);\n        continue;\n      }\n      \n      // Calculate current position along the path\n      const currentPos = getPathPoint(Math.min(1, meteor.progress), meteor.path, pointCache.current);\n      \n      // Update position history (for trail) using optimized array management\n      // Shift positions array - this is more efficient than splice/unshift for small arrays\n      for (let j = meteor.positions.length - 1; j > 0; j--) {\n        const current = meteor.positions[j];\n        const prev = meteor.positions[j - 1];\n        \n        current.x = prev.x;\n        current.y = prev.y;\n      }\n      \n      // Update head position\n      meteor.positions[0].x = currentPos.x;\n      meteor.positions[0].y = currentPos.y;\n    }\n    \n    // Spawn new meteors if needed\n    const now = performance.now();\n    const spawnNeeded = meteorsRef.current.length < adaptedSettings.meteorDensity;\n    const canSpawnNow = !staggered || now >= nextSpawnTimeRef.current;\n    \n    if (spawnNeeded && canSpawnNow) {\n      const newMeteor = initializeMeteor();\n      if (newMeteor) {\n        meteorsRef.current.push(newMeteor);\n        \n        // Set next spawn time if staggering is enabled\n        if (staggered) {\n          const delay = Math.random() * (maxStaggerDelay - minStaggerDelay) + minStaggerDelay;\n          nextSpawnTimeRef.current = now + delay;\n        }\n      }\n    }\n  // Dependencies for updateMeteors\n  }, [\n    adaptedSettings.meteorDensity,\n    staggered,\n    minStaggerDelay,\n    maxStaggerDelay,\n    initializeMeteor,\n    getPathPoint,\n    pointCache\n  ]);\n  \n  // FPS limiter for consistent animation speed\n  const fpsLimiter = useCallback((timestamp, callback) => {\n    // Skip animation if hidden, inactive, or reduced motion\n    if (!isVisible || !active || (respectReducedMotion && prefersReducedMotion) || document.hidden) {\n      animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n      return;\n    }\n    \n    const targetFrameTime = 1000 / maxFPS;\n    const elapsed = timestamp - lastTimestampRef.current;\n    \n    if (elapsed >= targetFrameTime || lastTimestampRef.current === 0) {\n      // Calculate correct delta\n      const delta = lastTimestampRef.current === 0 ? 16 : elapsed;\n      \n      // Update timestamp, limiting delta to avoid jumps after inactivity\n      lastTimestampRef.current = timestamp - (elapsed % targetFrameTime);\n      \n      // Run animation callback with capped delta time\n      callback(Math.min(delta, 50));\n      \n      // FPS tracking for debug and adaptive quality\n      frameCountRef.current++;\n      if (timestamp - fpsTimestampRef.current >= 1000) {\n        currentFpsRef.current = frameCountRef.current;\n        frameCountRef.current = 0;\n        fpsTimestampRef.current = timestamp;\n        \n        // Log FPS in debug mode\n        if (debug) {\n          console.log(`MeteorShower FPS: ${currentFpsRef.current}, Quality: ${qualityFactor.toFixed(2)}`);\n        }\n        \n        // Dynamic quality adjustment based on performance\n        if (adaptiveQuality && currentFpsRef.current < maxFPS * 0.7) {\n          // If FPS is below 70% of target, reduce quality\n          setQualityFactor(prev => Math.max(0.4, prev * 0.9));\n        } else if (adaptiveQuality && currentFpsRef.current >= maxFPS * 0.95 && qualityFactor < 1) {\n          // If FPS is near target and quality is reduced, gradually increase\n          setQualityFactor(prev => Math.min(1, prev * 1.05));\n        }\n      }\n    }\n    \n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n  }, [\n    isVisible,\n    active,\n    respectReducedMotion,\n    prefersReducedMotion,\n    maxFPS,\n    debug,\n    adaptiveQuality,\n    qualityFactor\n  ]);\n  \n  // Main animation handler\n  const handleAnimation = useCallback((deltaTime) => {\n    // Skip if component is not ready\n    if (!canvasRef.current || !isInitialized) return;\n    \n    const now = performance.now();\n    \n    // Calculate parallax offset if enabled\n    let parallaxOffset = 0;\n    if (enableParallax) {\n      parallaxOffset = scrollPositionRef.current * parallaxIntensity;\n    }\n    \n    // Update meteor positions\n    updateMeteors(deltaTime);\n    \n    // Render based on selected mode\n    if (actualRenderingMode === 'webgl' && webGLRef.current) {\n      // WebGL rendering path\n      renderMeteorsWebGL(webGLRef.current, now);\n      \n      // Render burst particles with WebGL\n      if (enableBursts) {\n        renderBurstsWebGL(webGLRef.current, deltaTime);\n      }\n    } else {\n      // Canvas 2D rendering path\n      const ctx = ctxRef.current;\n      if (!ctx) return;\n      \n      // Clear canvas with optimized clear (only clear used area)\n      ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n      \n      // Render meteors\n      renderMeteors2D(ctx, parallaxOffset, now);\n      \n      // Render burst particles\n      if (enableBursts) {\n        renderBursts2D(ctx, deltaTime);\n      }\n      \n      // Debug visualization\n      if (debug) {\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n        ctx.font = '12px monospace';\n        ctx.fillText(`FPS: ${currentFpsRef.current}`, 10, 20);\n        ctx.fillText(`Meteors: ${meteorsRef.current.length}/${adaptedSettings.meteorDensity}`, 10, 40);\n        ctx.fillText(`Quality: ${qualityFactor.toFixed(2)}`, 10, 60);\n        ctx.fillText(`Rendering: ${actualRenderingMode}`, 10, 80);\n        \n        if (enableBursts) {\n          ctx.fillText(`Bursts: ${burstsRef.current.length}`, 10, 100);\n          ctx.fillText(`Last Burst: ${lastBurstCountRef.current}`, 10, 120);\n        }\n      }\n    }\n  }, [\n    isInitialized,\n    dimensions,\n    adaptedSettings.meteorDensity,\n    enableParallax,\n    parallaxIntensity,\n    actualRenderingMode,\n    debug,\n    updateMeteors,\n    renderMeteors2D,\n    renderMeteorsWebGL,\n    enableBursts,\n    renderBursts2D,\n    renderBurstsWebGL,\n    qualityFactor\n  ]);\n  \n  // Main animation loop\n  useEffect(() => {\n    if (!active || !isInitialized || !dimensions.width || !dimensions.height) {\n      return;\n    }\n    \n    // Start animation with FPS limiter\n    fpsTimestampRef.current = performance.now();\n    frameCountRef.current = 0;\n    lastTimestampRef.current = 0;\n    \n    animationFrameRef.current = requestAnimationFrame(timestamp => {\n      fpsLimiter(timestamp, handleAnimation);\n    });\n    \n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [\n    active,\n    isInitialized,\n    dimensions,\n    fpsLimiter,\n    handleAnimation\n  ]);\n  \n  return (\n    <div \n      ref={containerRef}\n      style={{ \n        position: 'absolute',\n        top: 0, \n        left: 0, \n        width: '100%', \n        height: height,\n        overflow: 'hidden', \n        pointerEvents: 'none', \n        zIndex: zIndex,\n        // Hardware acceleration\n        backfaceVisibility: 'hidden',\n        transform: 'translateZ(0)',\n        willChange: 'transform'\n      }}\n      aria-hidden=\"true\"\n    >\n      <canvas \n        ref={canvasRef} \n        style={{ \n          position: 'absolute', \n          top: 0, \n          left: 0, \n          width: '100%', \n          height: '100%',\n          // Additional rendering optimizations\n          imageRendering: 'high-quality',\n          // Hardware acceleration\n          backfaceVisibility: 'hidden',\n          transform: 'translateZ(0)',\n          willChange: 'transform',\n          // Ensures proper subpixel rendering\n          filter: 'none'\n        }} \n      />\n    </div>\n  );\n};\n\n/**\n * GoldenMeteorShower Component\n * \n * A preset version of the MeteorShower with a golden/amber color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const GoldenMeteorShower = (props) => {\n  const goldenPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 245, 158, 0.9)',\n    trailColor: 'rgba(207, 181, 59, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 200,\n    maxStaggerDelay: 2000,\n    enableBursts: true,\n    burstProbability: 0.4,\n    burstParticleSize: 1.8,\n    burstParticleCount: 14\n  };\n  \n  return <MeteorShower {...goldenPreset} {...props} />;\n};\n\n/**\n * CelestialMeteorShower Component\n * \n * A preset version of the MeteorShower with a bluish-purple color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const CelestialMeteorShower = (props) => {\n  const celestialPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(220, 225, 255, 0.9)',\n    trailColor: 'rgba(150, 160, 255, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 300,\n    maxStaggerDelay: 1800,\n    enableBursts: true,\n    burstProbability: 0.35\n  };\n  \n  return <MeteorShower {...celestialPreset} {...props} />;\n};\n\n/**\n * RubyMeteorShower Component\n * \n * A preset version of the MeteorShower with a red color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const RubyMeteorShower = (props) => {\n  const rubyPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 200, 200, 0.9)',\n    trailColor: 'rgba(220, 100, 100, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 350,\n    maxStaggerDelay: 2200,\n    enableBursts: true,\n    burstProbability: 0.45\n  };\n  \n  return <MeteorShower {...rubyPreset} {...props} />;\n};\n\n/**\n * TopMeteorShower Component\n * \n * A preset version of the MeteorShower with meteors falling from the top of the screen\n * at a consistent 30-degree angle, distributed with emphasis on left and center areas.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const TopMeteorShower = (props) => {\n  const topPreset = {\n    mode: 'linear',\n    direction: 'top',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.12,\n    trailLength: 200,\n    trailSegments: 25,\n    journeyCompletion: 0.95,\n    staggered: true,\n    minStaggerDelay: 100,\n    maxStaggerDelay: 1000,\n    enableBursts: true,\n    burstProbability: 0.5,\n    burstParticleCount: 15\n  };\n  \n  return <MeteorShower {...topPreset} {...props} />;\n};\n\nexport default MeteorShower;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}