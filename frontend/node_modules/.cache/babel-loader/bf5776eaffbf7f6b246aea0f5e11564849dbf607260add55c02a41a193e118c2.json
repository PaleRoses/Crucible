{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/MeteorShower.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\n\n/**\n * MeteorShower Component - Enhanced Version\n * \n * Creates an animated meteor shower effect where meteors arc across the sky\n * with comet-like trails and fade away naturally.\n * Features staggered appearance and configurable journey completion.\n * \n * @param {Object} props - Component props\n * @param {string|number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=5] - Z-index for the container\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.meteorDensity=15] - Number of meteors to maintain on screen\n * @param {number} [props.meteorMinSize=1] - Minimum size of meteors\n * @param {number} [props.meteorMaxSize=3] - Maximum size of meteors\n * @param {number} [props.meteorSpeed=0.08] - Base speed of meteors\n * @param {number} [props.trailLength=180] - Length of meteor trails\n * @param {number} [props.trailSegments=20] - Number of segments in each trail\n * @param {string} [props.coreColor='rgba(255, 255, 255, 1)'] - Core color for meteors\n * @param {string} [props.glowColor='rgba(255, 253, 227, 0.9)'] - Glow color for meteors\n * @param {string} [props.trailColor='rgba(191, 173, 127, 0.8)'] - Trail color for meteors\n * @param {boolean} [props.enableParallax=false] - Enable parallax effect on scroll\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of parallax effect\n * @param {boolean} [props.staggered=true] - Enable staggered meteor appearance\n * @param {number} [props.minStaggerDelay=200] - Minimum delay between meteor spawns (ms)\n * @param {number} [props.maxStaggerDelay=2000] - Maximum delay between meteor spawns (ms)\n * @param {number} [props.journeyCompletion=0.9] - When meteors complete their journey (0-1, where 1 is the container height)\n * @param {boolean} [props.debug=false] - Enable debug visualization\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MeteorShower = ({\n  height = '100vh',\n  zIndex = 5,\n  active = true,\n  meteorDensity = 15,\n  meteorMinSize = 1,\n  meteorMaxSize = 3,\n  meteorSpeed = 0.08,\n  trailLength = 180,\n  trailSegments = 20,\n  coreColor = 'rgba(255, 255, 255, 1)',\n  glowColor = 'rgba(255, 253, 227, 0.9)',\n  trailColor = 'rgba(191, 173, 127, 0.8)',\n  enableParallax = false,\n  parallaxIntensity = 0.2,\n  staggered = true,\n  minStaggerDelay = 200,\n  maxStaggerDelay = 2000,\n  journeyCompletion = 0.9,\n  // Default: complete at 90% of container height\n  debug = false\n}) => {\n  _s();\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const meteorsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n  const nextSpawnTimeRef = useRef(0);\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0\n  });\n  const [isInitialized, setIsInitialized] = useState(false);\n\n  // Calculate arc path parameters for a meteor\n  const calculateArcPath = (width, height) => {\n    // Start point: somewhere along the top of the canvas with randomization\n    const startX = Math.random() * width * 1.5 - width * 0.25;\n\n    // Control how far meteors can start from outside the visible area\n    const startY = Math.random() * -100 - 50;\n\n    // Randomize arc curvature and direction\n    const curveDirection = Math.random() > 0.5 ? 1 : -1;\n    const curveIntensity = Math.random() * 0.4 + 0.2;\n\n    // Calculate control points for quadratic path\n    // End point: adjusted to complete journey according to journeyCompletion parameter\n    const endX = startX + curveDirection * width * curveIntensity;\n    const endY = height * journeyCompletion;\n\n    // Control point: creates the arc shape\n    const controlX = (startX + endX) / 2 + curveDirection * width * curveIntensity;\n    const controlY = (startY + endY) * 0.5;\n    return {\n      start: {\n        x: startX,\n        y: startY\n      },\n      control: {\n        x: controlX,\n        y: controlY\n      },\n      end: {\n        x: endX,\n        y: endY\n      }\n    };\n  };\n\n  // Initialize a new meteor\n  const initializeMeteor = () => {\n    const width = dimensions.width;\n    const height = dimensions.height;\n    if (!width || !height) return null;\n\n    // Calculate arc path\n    const path = calculateArcPath(width, height);\n\n    // Randomize meteor properties\n    const baseSpeed = meteorSpeed * (Math.random() * 0.5 + 0.75);\n    return {\n      path,\n      progress: 0,\n      size: Math.random() * (meteorMaxSize - meteorMinSize) + meteorMinSize,\n      speed: baseSpeed,\n      active: true,\n      positions: new Array(trailSegments).fill({\n        x: path.start.x,\n        y: path.start.y\n      }),\n      opacity: Math.random() * 0.3 + 0.7,\n      fadeThreshold: 0.7 + Math.random() * 0.2,\n      // When to start fading (70-90% of journey)\n      pulsePhase: Math.random() * Math.PI * 2,\n      pulseSpeed: Math.random() * 0.01 + 0.005\n    };\n  };\n\n  // Calculate position along a quadratic bezier curve\n  const getQuadraticBezierPoint = (t, p0, p1, p2) => {\n    const x = Math.pow(1 - t, 2) * p0.x + 2 * (1 - t) * t * p1.x + Math.pow(t, 2) * p2.x;\n    const y = Math.pow(1 - t, 2) * p0.y + 2 * (1 - t) * t * p1.y + Math.pow(t, 2) * p2.y;\n    return {\n      x,\n      y\n    };\n  };\n\n  // Update canvas dimensions on resize\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (canvasRef.current && containerRef.current) {\n        const container = containerRef.current;\n        const rect = container.getBoundingClientRect();\n        const width = rect.width;\n        const containerHeight = typeof height === 'string' && height.endsWith('vh') ? parseInt(height, 10) / 100 * window.innerHeight : parseInt(height, 10) || window.innerHeight;\n        if (debug) {\n          console.log('Setting canvas dimensions:', width, containerHeight);\n        }\n        setDimensions({\n          width,\n          height: containerHeight\n        });\n        canvasRef.current.width = width;\n        canvasRef.current.height = containerHeight;\n        setIsInitialized(true);\n      }\n    };\n    setTimeout(updateDimensions, 100);\n    window.addEventListener('resize', updateDimensions);\n    return () => {\n      window.removeEventListener('resize', updateDimensions);\n    };\n  }, [height, debug]);\n\n  // Handle parallax effect on scroll if enabled\n  useEffect(() => {\n    if (!enableParallax) return;\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    window.addEventListener('scroll', handleScroll);\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [enableParallax]);\n\n  // Main animation loop\n  useEffect(() => {\n    if (!active || !dimensions.width || !dimensions.height || !isInitialized) {\n      if (debug) {\n        console.log('Animation not starting. Active:', active, 'Dimensions:', dimensions, 'Initialized:', isInitialized);\n      }\n      return;\n    }\n    if (debug) {\n      console.log('Starting animation with dimensions:', dimensions);\n    }\n\n    // Animation function\n    const animate = timestamp => {\n      if (!canvasRef.current) return;\n      const ctx = canvasRef.current.getContext('2d');\n      const width = dimensions.width;\n      const height = dimensions.height;\n\n      // Initialize lastTimestamp on first run\n      if (lastTimestampRef.current === 0) {\n        lastTimestampRef.current = timestamp;\n        nextSpawnTimeRef.current = timestamp;\n      }\n\n      // Calculate delta time (capped to prevent jumps after tab switching)\n      const deltaTime = Math.min(timestamp - lastTimestampRef.current, 50);\n      lastTimestampRef.current = timestamp;\n\n      // Clear canvas\n      ctx.clearRect(0, 0, width, height);\n\n      // Debug mode - draw canvas bounds\n      if (debug) {\n        ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n        ctx.lineWidth = 2;\n        ctx.strokeRect(0, 0, width, height);\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n        ctx.font = '12px monospace';\n        ctx.fillText(`Canvas: ${width}Ã—${height}`, 10, 20);\n        ctx.fillText(`Meteors: ${meteorsRef.current.length}/${meteorDensity}`, 10, 40);\n        ctx.fillText(`Journey Completion: ${journeyCompletion * 100}%`, 10, 60);\n        if (staggered) {\n          ctx.fillText(`Next Spawn: ${Math.max(0, (nextSpawnTimeRef.current - timestamp) / 1000).toFixed(2)}s`, 10, 80);\n        }\n      }\n\n      // Apply parallax offset\n      let parallaxOffset = 0;\n      if (enableParallax) {\n        parallaxOffset = scrollPositionRef.current * parallaxIntensity;\n      }\n\n      // Spawn new meteors if needed, with staggering if enabled\n      if (meteorsRef.current.length < meteorDensity) {\n        const canSpawnNow = !staggered || timestamp >= nextSpawnTimeRef.current;\n        if (canSpawnNow) {\n          const newMeteor = initializeMeteor();\n          if (newMeteor) {\n            meteorsRef.current.push(newMeteor);\n\n            // If staggering is enabled, set the next spawn time\n            if (staggered) {\n              const delay = Math.random() * (maxStaggerDelay - minStaggerDelay) + minStaggerDelay;\n              nextSpawnTimeRef.current = timestamp + delay;\n            }\n          }\n        }\n      }\n\n      // Update and draw meteors\n      meteorsRef.current = meteorsRef.current.filter(meteor => {\n        // Skip if not active\n        if (!meteor.active) return false;\n\n        // Update progress based on speed and delta time\n        meteor.progress += meteor.speed * (deltaTime / 1000);\n\n        // Calculate current position along the quadratic bezier path\n        const currentPos = getQuadraticBezierPoint(Math.min(1, meteor.progress), meteor.path.start, meteor.path.control, meteor.path.end);\n\n        // Update position history (for trail)\n        meteor.positions.unshift({\n          x: currentPos.x,\n          y: currentPos.y\n        });\n        meteor.positions = meteor.positions.slice(0, trailSegments);\n\n        // Check if meteor has completed its path\n        if (meteor.progress >= 1) {\n          return false;\n        }\n\n        // Calculate opacity based on progress\n        // Start fading out after reaching the fadeThreshold\n        let currentOpacity = meteor.opacity;\n        if (meteor.progress > meteor.fadeThreshold) {\n          // Map progress from fadeThreshold-1.0 to 1.0-0.0 for opacity\n          const fadeProgress = (meteor.progress - meteor.fadeThreshold) / (1 - meteor.fadeThreshold);\n          currentOpacity = meteor.opacity * (1 - fadeProgress);\n        }\n\n        // Apply pulse/flicker effect\n        const timeFactor = timestamp * 0.001;\n        const pulseEffect = Math.sin(timeFactor * meteor.pulseSpeed + meteor.pulsePhase) * 0.2 + 0.8;\n\n        // Adjust for parallax if enabled\n        const adjustY = enableParallax ? parallaxOffset * (meteor.size / meteorMaxSize) : 0;\n\n        // Draw trail segments\n        for (let i = 0; i < meteor.positions.length - 1; i++) {\n          if (!meteor.positions[i] || !meteor.positions[i + 1]) continue;\n\n          // Calculate segment opacity (decreases along the trail)\n          const segmentOpacity = currentOpacity * (1 - i / meteor.positions.length) * pulseEffect;\n\n          // Skip if nearly invisible\n          if (segmentOpacity < 0.02) continue;\n\n          // Calculate segment width (decreases along the trail)\n          const segmentWidth = meteor.size * (1 - i / meteor.positions.length * 0.7);\n\n          // Set shadow/glow effect\n          ctx.shadowColor = glowColor;\n          ctx.shadowBlur = meteor.size * 3 * pulseEffect;\n\n          // Draw line segment\n          ctx.beginPath();\n          ctx.moveTo(meteor.positions[i].x, meteor.positions[i].y + adjustY);\n          ctx.lineTo(meteor.positions[i + 1].x, meteor.positions[i + 1].y + adjustY);\n\n          // Set line style\n          ctx.lineCap = 'round';\n          ctx.lineWidth = segmentWidth;\n          ctx.strokeStyle = trailColor.replace(/[\\d.]+\\)$/, segmentOpacity + ')');\n          ctx.stroke();\n        }\n\n        // Draw meteor head (brightest part)\n        if (meteor.positions[0]) {\n          // Set shadow/glow for head\n          ctx.shadowColor = glowColor;\n          ctx.shadowBlur = meteor.size * 5 * pulseEffect;\n\n          // Draw outer glow\n          ctx.beginPath();\n          ctx.arc(meteor.positions[0].x, meteor.positions[0].y + adjustY, meteor.size * 1.5, 0, Math.PI * 2);\n          ctx.fillStyle = glowColor.replace(/[\\d.]+\\)$/, currentOpacity * 0.7 * pulseEffect + ')');\n          ctx.fill();\n\n          // Draw inner core\n          ctx.beginPath();\n          ctx.arc(meteor.positions[0].x, meteor.positions[0].y + adjustY, meteor.size * 0.7, 0, Math.PI * 2);\n          ctx.fillStyle = coreColor.replace(/[\\d.]+\\)$/, currentOpacity * pulseEffect + ')');\n          ctx.fill();\n        }\n        return true;\n      });\n\n      // Continue animation\n      animationFrameRef.current = requestAnimationFrame(animate);\n    };\n\n    // Start animation\n    animationFrameRef.current = requestAnimationFrame(animate);\n\n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [active, isInitialized, dimensions, meteorDensity, meteorMinSize, meteorMaxSize, meteorSpeed, trailLength, trailSegments, coreColor, glowColor, trailColor, enableParallax, parallaxIntensity, staggered, minStaggerDelay, maxStaggerDelay, journeyCompletion, debug]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: height,\n      overflow: 'hidden',\n      pointerEvents: 'none',\n      zIndex: zIndex\n    },\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 384,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 371,\n    columnNumber: 5\n  }, this);\n};\n\n/**\n * GoldenMeteorShower Component\n * \n * A preset version of the MeteorShower with a golden/amber color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_s(MeteorShower, \"tVcPdlpBSxjRrNNxm2kmJIL72xA=\");\n_c = MeteorShower;\nexport const GoldenMeteorShower = props => {\n  const goldenPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 253, 227, 0.9)',\n    trailColor: 'rgba(191, 173, 127, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 200,\n    maxStaggerDelay: 2000\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...goldenPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 421,\n    columnNumber: 10\n  }, this);\n};\n\n/**\n * CelestialMeteorShower Component\n * \n * A preset version of the MeteorShower with a bluish-purple color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c2 = GoldenMeteorShower;\nexport const CelestialMeteorShower = props => {\n  const celestialPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(220, 225, 255, 0.9)',\n    trailColor: 'rgba(150, 160, 255, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 300,\n    maxStaggerDelay: 1800\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...celestialPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 447,\n    columnNumber: 10\n  }, this);\n};\n\n/**\n * EmeraldMeteorShower Component\n * \n * A preset version of the MeteorShower with a green color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c3 = CelestialMeteorShower;\nexport const EmeraldMeteorShower = props => {\n  const emeraldPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(215, 255, 230, 0.9)',\n    trailColor: 'rgba(100, 220, 150, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 250,\n    maxStaggerDelay: 1500\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...emeraldPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 473,\n    columnNumber: 10\n  }, this);\n};\n\n/**\n * RubyMeteorShower Component\n * \n * A preset version of the MeteorShower with a red color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c4 = EmeraldMeteorShower;\nexport const RubyMeteorShower = props => {\n  const rubyPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 200, 200, 0.9)',\n    trailColor: 'rgba(220, 100, 100, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 350,\n    maxStaggerDelay: 2200\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...rubyPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 499,\n    columnNumber: 10\n  }, this);\n};\n_c5 = RubyMeteorShower;\nexport default MeteorShower;\nvar _c, _c2, _c3, _c4, _c5;\n$RefreshReg$(_c, \"MeteorShower\");\n$RefreshReg$(_c2, \"GoldenMeteorShower\");\n$RefreshReg$(_c3, \"CelestialMeteorShower\");\n$RefreshReg$(_c4, \"EmeraldMeteorShower\");\n$RefreshReg$(_c5, \"RubyMeteorShower\");","map":{"version":3,"names":["React","useState","useEffect","useRef","jsxDEV","_jsxDEV","MeteorShower","height","zIndex","active","meteorDensity","meteorMinSize","meteorMaxSize","meteorSpeed","trailLength","trailSegments","coreColor","glowColor","trailColor","enableParallax","parallaxIntensity","staggered","minStaggerDelay","maxStaggerDelay","journeyCompletion","debug","_s","containerRef","canvasRef","meteorsRef","animationFrameRef","lastTimestampRef","scrollPositionRef","nextSpawnTimeRef","dimensions","setDimensions","width","isInitialized","setIsInitialized","calculateArcPath","startX","Math","random","startY","curveDirection","curveIntensity","endX","endY","controlX","controlY","start","x","y","control","end","initializeMeteor","path","baseSpeed","progress","size","speed","positions","Array","fill","opacity","fadeThreshold","pulsePhase","PI","pulseSpeed","getQuadraticBezierPoint","t","p0","p1","p2","pow","updateDimensions","current","container","rect","getBoundingClientRect","containerHeight","endsWith","parseInt","window","innerHeight","console","log","setTimeout","addEventListener","removeEventListener","handleScroll","scrollY","animate","timestamp","ctx","getContext","deltaTime","min","clearRect","strokeStyle","lineWidth","strokeRect","fillStyle","font","fillText","length","max","toFixed","parallaxOffset","canSpawnNow","newMeteor","push","delay","filter","meteor","currentPos","unshift","slice","currentOpacity","fadeProgress","timeFactor","pulseEffect","sin","adjustY","i","segmentOpacity","segmentWidth","shadowColor","shadowBlur","beginPath","moveTo","lineTo","lineCap","replace","stroke","arc","requestAnimationFrame","cancelAnimationFrame","ref","style","position","top","left","overflow","pointerEvents","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","GoldenMeteorShower","props","goldenPreset","_c2","CelestialMeteorShower","celestialPreset","_c3","EmeraldMeteorShower","emeraldPreset","_c4","RubyMeteorShower","rubyPreset","_c5","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/MeteorShower.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\n\n/**\n * MeteorShower Component - Enhanced Version\n * \n * Creates an animated meteor shower effect where meteors arc across the sky\n * with comet-like trails and fade away naturally.\n * Features staggered appearance and configurable journey completion.\n * \n * @param {Object} props - Component props\n * @param {string|number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=5] - Z-index for the container\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.meteorDensity=15] - Number of meteors to maintain on screen\n * @param {number} [props.meteorMinSize=1] - Minimum size of meteors\n * @param {number} [props.meteorMaxSize=3] - Maximum size of meteors\n * @param {number} [props.meteorSpeed=0.08] - Base speed of meteors\n * @param {number} [props.trailLength=180] - Length of meteor trails\n * @param {number} [props.trailSegments=20] - Number of segments in each trail\n * @param {string} [props.coreColor='rgba(255, 255, 255, 1)'] - Core color for meteors\n * @param {string} [props.glowColor='rgba(255, 253, 227, 0.9)'] - Glow color for meteors\n * @param {string} [props.trailColor='rgba(191, 173, 127, 0.8)'] - Trail color for meteors\n * @param {boolean} [props.enableParallax=false] - Enable parallax effect on scroll\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of parallax effect\n * @param {boolean} [props.staggered=true] - Enable staggered meteor appearance\n * @param {number} [props.minStaggerDelay=200] - Minimum delay between meteor spawns (ms)\n * @param {number} [props.maxStaggerDelay=2000] - Maximum delay between meteor spawns (ms)\n * @param {number} [props.journeyCompletion=0.9] - When meteors complete their journey (0-1, where 1 is the container height)\n * @param {boolean} [props.debug=false] - Enable debug visualization\n */\nconst MeteorShower = ({\n  height = '100vh',\n  zIndex = 5,\n  active = true,\n  meteorDensity = 15,\n  meteorMinSize = 1,\n  meteorMaxSize = 3,\n  meteorSpeed = 0.08,\n  trailLength = 180,\n  trailSegments = 20,\n  coreColor = 'rgba(255, 255, 255, 1)',\n  glowColor = 'rgba(255, 253, 227, 0.9)',\n  trailColor = 'rgba(191, 173, 127, 0.8)',\n  enableParallax = false,\n  parallaxIntensity = 0.2,\n  staggered = true,\n  minStaggerDelay = 200,\n  maxStaggerDelay = 2000,\n  journeyCompletion = 0.9, // Default: complete at 90% of container height\n  debug = false\n}) => {\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const meteorsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n  const nextSpawnTimeRef = useRef(0);\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n  const [isInitialized, setIsInitialized] = useState(false);\n  \n  // Calculate arc path parameters for a meteor\n  const calculateArcPath = (width, height) => {\n    // Start point: somewhere along the top of the canvas with randomization\n    const startX = Math.random() * width * 1.5 - width * 0.25;\n    \n    // Control how far meteors can start from outside the visible area\n    const startY = Math.random() * -100 - 50;\n    \n    // Randomize arc curvature and direction\n    const curveDirection = Math.random() > 0.5 ? 1 : -1;\n    const curveIntensity = Math.random() * 0.4 + 0.2;\n    \n    // Calculate control points for quadratic path\n    // End point: adjusted to complete journey according to journeyCompletion parameter\n    const endX = startX + (curveDirection * width * curveIntensity);\n    const endY = height * journeyCompletion;\n    \n    // Control point: creates the arc shape\n    const controlX = (startX + endX) / 2 + (curveDirection * width * curveIntensity);\n    const controlY = (startY + endY) * 0.5;\n    \n    return {\n      start: { x: startX, y: startY },\n      control: { x: controlX, y: controlY },\n      end: { x: endX, y: endY }\n    };\n  };\n  \n  // Initialize a new meteor\n  const initializeMeteor = () => {\n    const width = dimensions.width;\n    const height = dimensions.height;\n    \n    if (!width || !height) return null;\n    \n    // Calculate arc path\n    const path = calculateArcPath(width, height);\n    \n    // Randomize meteor properties\n    const baseSpeed = meteorSpeed * (Math.random() * 0.5 + 0.75);\n    \n    return {\n      path,\n      progress: 0,\n      size: Math.random() * (meteorMaxSize - meteorMinSize) + meteorMinSize,\n      speed: baseSpeed,\n      active: true,\n      positions: new Array(trailSegments).fill({ x: path.start.x, y: path.start.y }),\n      opacity: Math.random() * 0.3 + 0.7,\n      fadeThreshold: 0.7 + Math.random() * 0.2, // When to start fading (70-90% of journey)\n      pulsePhase: Math.random() * Math.PI * 2,\n      pulseSpeed: Math.random() * 0.01 + 0.005\n    };\n  };\n  \n  // Calculate position along a quadratic bezier curve\n  const getQuadraticBezierPoint = (t, p0, p1, p2) => {\n    const x = Math.pow(1 - t, 2) * p0.x + 2 * (1 - t) * t * p1.x + Math.pow(t, 2) * p2.x;\n    const y = Math.pow(1 - t, 2) * p0.y + 2 * (1 - t) * t * p1.y + Math.pow(t, 2) * p2.y;\n    return { x, y };\n  };\n  \n  // Update canvas dimensions on resize\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (canvasRef.current && containerRef.current) {\n        const container = containerRef.current;\n        const rect = container.getBoundingClientRect();\n        const width = rect.width;\n        const containerHeight = typeof height === 'string' && height.endsWith('vh') \n          ? (parseInt(height, 10) / 100) * window.innerHeight\n          : parseInt(height, 10) || window.innerHeight;\n          \n        if (debug) {\n          console.log('Setting canvas dimensions:', width, containerHeight);\n        }\n        \n        setDimensions({ width, height: containerHeight });\n        canvasRef.current.width = width;\n        canvasRef.current.height = containerHeight;\n        setIsInitialized(true);\n      }\n    };\n    \n    setTimeout(updateDimensions, 100);\n    window.addEventListener('resize', updateDimensions);\n    \n    return () => {\n      window.removeEventListener('resize', updateDimensions);\n    };\n  }, [height, debug]);\n  \n  // Handle parallax effect on scroll if enabled\n  useEffect(() => {\n    if (!enableParallax) return;\n    \n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    \n    window.addEventListener('scroll', handleScroll);\n    \n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [enableParallax]);\n  \n  // Main animation loop\n  useEffect(() => {\n    if (!active || !dimensions.width || !dimensions.height || !isInitialized) {\n      if (debug) {\n        console.log('Animation not starting. Active:', active, 'Dimensions:', dimensions, 'Initialized:', isInitialized);\n      }\n      return;\n    }\n    \n    if (debug) {\n      console.log('Starting animation with dimensions:', dimensions);\n    }\n    \n    // Animation function\n    const animate = (timestamp) => {\n      if (!canvasRef.current) return;\n      \n      const ctx = canvasRef.current.getContext('2d');\n      const width = dimensions.width;\n      const height = dimensions.height;\n      \n      // Initialize lastTimestamp on first run\n      if (lastTimestampRef.current === 0) {\n        lastTimestampRef.current = timestamp;\n        nextSpawnTimeRef.current = timestamp;\n      }\n      \n      // Calculate delta time (capped to prevent jumps after tab switching)\n      const deltaTime = Math.min(timestamp - lastTimestampRef.current, 50);\n      lastTimestampRef.current = timestamp;\n      \n      // Clear canvas\n      ctx.clearRect(0, 0, width, height);\n      \n      // Debug mode - draw canvas bounds\n      if (debug) {\n        ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n        ctx.lineWidth = 2;\n        ctx.strokeRect(0, 0, width, height);\n        \n        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n        ctx.font = '12px monospace';\n        ctx.fillText(`Canvas: ${width}Ã—${height}`, 10, 20);\n        ctx.fillText(`Meteors: ${meteorsRef.current.length}/${meteorDensity}`, 10, 40);\n        ctx.fillText(`Journey Completion: ${journeyCompletion * 100}%`, 10, 60);\n        if (staggered) {\n          ctx.fillText(`Next Spawn: ${Math.max(0, (nextSpawnTimeRef.current - timestamp) / 1000).toFixed(2)}s`, 10, 80);\n        }\n      }\n      \n      // Apply parallax offset\n      let parallaxOffset = 0;\n      if (enableParallax) {\n        parallaxOffset = scrollPositionRef.current * parallaxIntensity;\n      }\n      \n      // Spawn new meteors if needed, with staggering if enabled\n      if (meteorsRef.current.length < meteorDensity) {\n        const canSpawnNow = !staggered || timestamp >= nextSpawnTimeRef.current;\n        \n        if (canSpawnNow) {\n          const newMeteor = initializeMeteor();\n          if (newMeteor) {\n            meteorsRef.current.push(newMeteor);\n            \n            // If staggering is enabled, set the next spawn time\n            if (staggered) {\n              const delay = Math.random() * (maxStaggerDelay - minStaggerDelay) + minStaggerDelay;\n              nextSpawnTimeRef.current = timestamp + delay;\n            }\n          }\n        }\n      }\n      \n      // Update and draw meteors\n      meteorsRef.current = meteorsRef.current.filter(meteor => {\n        // Skip if not active\n        if (!meteor.active) return false;\n        \n        // Update progress based on speed and delta time\n        meteor.progress += meteor.speed * (deltaTime / 1000);\n        \n        // Calculate current position along the quadratic bezier path\n        const currentPos = getQuadraticBezierPoint(\n          Math.min(1, meteor.progress),\n          meteor.path.start,\n          meteor.path.control,\n          meteor.path.end\n        );\n        \n        // Update position history (for trail)\n        meteor.positions.unshift({ x: currentPos.x, y: currentPos.y });\n        meteor.positions = meteor.positions.slice(0, trailSegments);\n        \n        // Check if meteor has completed its path\n        if (meteor.progress >= 1) {\n          return false;\n        }\n        \n        // Calculate opacity based on progress\n        // Start fading out after reaching the fadeThreshold\n        let currentOpacity = meteor.opacity;\n        if (meteor.progress > meteor.fadeThreshold) {\n          // Map progress from fadeThreshold-1.0 to 1.0-0.0 for opacity\n          const fadeProgress = (meteor.progress - meteor.fadeThreshold) / (1 - meteor.fadeThreshold);\n          currentOpacity = meteor.opacity * (1 - fadeProgress);\n        }\n        \n        // Apply pulse/flicker effect\n        const timeFactor = timestamp * 0.001;\n        const pulseEffect = Math.sin(timeFactor * meteor.pulseSpeed + meteor.pulsePhase) * 0.2 + 0.8;\n        \n        // Adjust for parallax if enabled\n        const adjustY = enableParallax ? parallaxOffset * (meteor.size / meteorMaxSize) : 0;\n        \n        // Draw trail segments\n        for (let i = 0; i < meteor.positions.length - 1; i++) {\n          if (!meteor.positions[i] || !meteor.positions[i+1]) continue;\n          \n          // Calculate segment opacity (decreases along the trail)\n          const segmentOpacity = currentOpacity * (1 - i / meteor.positions.length) * pulseEffect;\n          \n          // Skip if nearly invisible\n          if (segmentOpacity < 0.02) continue;\n          \n          // Calculate segment width (decreases along the trail)\n          const segmentWidth = meteor.size * (1 - i / meteor.positions.length * 0.7);\n          \n          // Set shadow/glow effect\n          ctx.shadowColor = glowColor;\n          ctx.shadowBlur = meteor.size * 3 * pulseEffect;\n          \n          // Draw line segment\n          ctx.beginPath();\n          ctx.moveTo(meteor.positions[i].x, meteor.positions[i].y + adjustY);\n          ctx.lineTo(meteor.positions[i+1].x, meteor.positions[i+1].y + adjustY);\n          \n          // Set line style\n          ctx.lineCap = 'round';\n          ctx.lineWidth = segmentWidth;\n          ctx.strokeStyle = trailColor.replace(/[\\d.]+\\)$/, segmentOpacity + ')');\n          ctx.stroke();\n        }\n        \n        // Draw meteor head (brightest part)\n        if (meteor.positions[0]) {\n          // Set shadow/glow for head\n          ctx.shadowColor = glowColor;\n          ctx.shadowBlur = meteor.size * 5 * pulseEffect;\n          \n          // Draw outer glow\n          ctx.beginPath();\n          ctx.arc(meteor.positions[0].x, meteor.positions[0].y + adjustY, meteor.size * 1.5, 0, Math.PI * 2);\n          ctx.fillStyle = glowColor.replace(/[\\d.]+\\)$/, currentOpacity * 0.7 * pulseEffect + ')');\n          ctx.fill();\n          \n          // Draw inner core\n          ctx.beginPath();\n          ctx.arc(meteor.positions[0].x, meteor.positions[0].y + adjustY, meteor.size * 0.7, 0, Math.PI * 2);\n          ctx.fillStyle = coreColor.replace(/[\\d.]+\\)$/, currentOpacity * pulseEffect + ')');\n          ctx.fill();\n        }\n        \n        return true;\n      });\n      \n      // Continue animation\n      animationFrameRef.current = requestAnimationFrame(animate);\n    };\n    \n    // Start animation\n    animationFrameRef.current = requestAnimationFrame(animate);\n    \n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [\n    active,\n    isInitialized,\n    dimensions,\n    meteorDensity,\n    meteorMinSize,\n    meteorMaxSize,\n    meteorSpeed,\n    trailLength,\n    trailSegments,\n    coreColor,\n    glowColor,\n    trailColor,\n    enableParallax,\n    parallaxIntensity,\n    staggered,\n    minStaggerDelay,\n    maxStaggerDelay,\n    journeyCompletion,\n    debug\n  ]);\n  \n  return (\n    <div \n      ref={containerRef}\n      style={{ \n        position: 'absolute',\n        top: 0, \n        left: 0, \n        width: '100%', \n        height: height,\n        overflow: 'hidden', \n        pointerEvents: 'none', \n        zIndex: zIndex\n      }}\n    >\n      <canvas \n        ref={canvasRef} \n        style={{ \n          position: 'absolute', \n          top: 0, \n          left: 0, \n          width: '100%', \n          height: '100%'\n        }} \n      />\n    </div>\n  );\n};\n\n/**\n * GoldenMeteorShower Component\n * \n * A preset version of the MeteorShower with a golden/amber color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const GoldenMeteorShower = (props) => {\n  const goldenPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 253, 227, 0.9)',\n    trailColor: 'rgba(191, 173, 127, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 200,\n    maxStaggerDelay: 2000,\n  };\n  \n  return <MeteorShower {...goldenPreset} {...props} />;\n};\n\n/**\n * CelestialMeteorShower Component\n * \n * A preset version of the MeteorShower with a bluish-purple color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const CelestialMeteorShower = (props) => {\n  const celestialPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(220, 225, 255, 0.9)',\n    trailColor: 'rgba(150, 160, 255, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 300,\n    maxStaggerDelay: 1800,\n  };\n  \n  return <MeteorShower {...celestialPreset} {...props} />;\n};\n\n/**\n * EmeraldMeteorShower Component\n * \n * A preset version of the MeteorShower with a green color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const EmeraldMeteorShower = (props) => {\n  const emeraldPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(215, 255, 230, 0.9)',\n    trailColor: 'rgba(100, 220, 150, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 250,\n    maxStaggerDelay: 1500,\n  };\n  \n  return <MeteorShower {...emeraldPreset} {...props} />;\n};\n\n/**\n * RubyMeteorShower Component\n * \n * A preset version of the MeteorShower with a red color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const RubyMeteorShower = (props) => {\n  const rubyPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 200, 200, 0.9)',\n    trailColor: 'rgba(220, 100, 100, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 350,\n    maxStaggerDelay: 2200,\n  };\n  \n  return <MeteorShower {...rubyPreset} {...props} />;\n};\n\nexport default MeteorShower;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}