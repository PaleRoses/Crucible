{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/layout/Background.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useCallback, useMemo } from 'react';\nimport { useScroll, useSpring } from 'framer-motion';\n\n/**\n * Background Component\n * \n * Enhanced with time-based star generation for consistent appearance\n * between page navigations and reduced storage operations.\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Background = ({\n  config = {}\n}) => {\n  _s();\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const starsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimeRef = useRef(0);\n  const lastScrollYRef = useRef(0);\n\n  // Use refs instead of state to prevent re-renders\n  const isInitializedRef = useRef(false);\n  const firstRenderCompleteRef = useRef(false);\n\n  // Store dimensions in a ref to avoid re-renders when they change\n  const dimensionsRef = useRef({\n    width: 0,\n    height: 0,\n    pixelRatio: 1\n  });\n\n  // Get scroll position using framer-motion\n  const {\n    scrollY\n  } = useScroll({\n    smooth: 0.05 // Smoother scrolling for high-framerate animations\n  });\n\n  // Use spring physics for smoother scrolling effect\n  const springScrollY = useSpring(scrollY, {\n    stiffness: 1,\n    damping: 5,\n    mass: 0.5,\n    restDelta: 0.001,\n    restSpeed: 0.001\n  });\n\n  // Track spring scrollY value without causing re-renders\n  const springScrollYRef = useRef(0);\n  useEffect(() => {\n    const unsubscribe = springScrollY.onChange(value => {\n      springScrollYRef.current = value;\n    });\n    return () => unsubscribe();\n  }, [springScrollY]);\n\n  // Configuration - wrapped in useMemo to prevent recreation on each render\n  // Merge default config with user-provided config\n  const CONFIG = useMemo(() => ({\n    // Star appearance\n    starCount: 100,\n    starSizeMin: 1.0,\n    starSizeMax: 1.9,\n    starOpacityMin: 0.2,\n    starOpacityMax: 0.55,\n    // Parallax and movement parameters\n    baseMovementSpeed: 0.00001,\n    // Reduced for slower movement\n    pulseFrequency: 0.00002,\n    // Slower pulsing\n    parallaxEnabled: true,\n    parallaxFactor: 0.2,\n    // How much stars move relative to scroll (0-1)\n\n    // Trail effect parameters\n    trailEnabled: true,\n    // Enable subtle trails\n    trailLength: 2,\n    // Very short trail length (in pixels)\n    trailOpacityFactor: 0.5,\n    // Trail opacity relative to star opacity\n\n    // Twinkling effect parameters\n    twinkleEnabled: true,\n    // Enable stars to fade in and out\n    twinkleProbability: 0.01,\n    // Probability of a star beginning to twinkle each frame\n    twinkleDuration: [2000, 4000],\n    // Min and max duration of a twinkle cycle in ms\n\n    // Random fading parameters\n    randomFadingEnabled: true,\n    // Enable random fading of stars\n    randomFadeOutProbability: 0.0003,\n    // Probability of a star randomly starting to fade out per frame\n    maxSimultaneousFading: 10,\n    // Maximum number of stars that can be fading at once\n\n    // Drifting movement parameters\n    driftEnabled: true,\n    // Enable slow drifting movement\n    driftSpeed: 0.01,\n    // Base speed of drift movement (pixels per second)\n    driftSpeedVariation: 0.005,\n    // Variation in drift speed between stars\n    directionChangeFrequency: 0.0005,\n    // Probability of changing direction each frame\n    directionChangeAmount: 0.05,\n    // How much direction can change at once (lower = smoother)\n\n    // Star regeneration parameters\n    regenerateOffscreenStars: true,\n    // Replace off-screen stars instead of wrapping\n    fadeInDuration: 2000,\n    // Duration for new stars to fade in (ms)\n    fadeOutDuration: 1500,\n    // Duration for off-screen stars to fade out (ms)\n    offscreenBuffer: 50,\n    // Distance beyond viewport to trigger regeneration (px)\n\n    // Physics parameters for bouncy effect\n    springStrength: 0.03,\n    // Higher = snappier\n    dampingFactor: 0.95,\n    // Higher = less bouncy (0-1)\n\n    // Star distribution parameters\n    verticalSpreadFactor: 3,\n    // How many screen heights to spread stars across\n    offscreenBufferFactor: 1,\n    // How many screen heights above viewport to generate stars\n\n    // Performance parameters\n    maxFPS: 60,\n    useRays: false,\n    // Disable ray rendering for performance\n\n    // Time-based parameters (new)\n    useTimeBased: true,\n    // Enable time-based seeding and animation\n    timeConsistency: 'daily',\n    // Options: 'hourly', 'daily', 'weekly', 'always'\n    preserveScrollPosition: true,\n    // Save and restore scroll position between sessions\n\n    // Session persistence\n    sessionKey: 'scrolling_star_background_config',\n    scrollPositionKey: 'scrolling_star_background_scroll',\n    // Override with user config\n    ...config\n  }), [config]);\n\n  // Warm, golden color palette - wrapped in useMemo\n  const COLORS = useMemo(() => ({\n    // Star colors\n    stars: ['rgba(255, 243, 200, alpha)',\n    // Warm yellow\n    'rgba(255, 231, 164, alpha)',\n    // Golden\n    'rgba(252, 249, 231, alpha)' // Off-white gold\n    ],\n    // Background gradient colors\n    background: {\n      topColor: 'rgb(8, 8, 12)',\n      bottomColor: 'rgb(15, 15, 20)'\n    },\n    // Override with user config if provided\n    ...(config.colors || {})\n  }), [config.colors]);\n\n  // Pre-generated color values to avoid string replacements during animation\n  const colorCache = useMemo(() => {\n    const cache = {};\n    COLORS.stars.forEach(baseColor => {\n      cache[baseColor] = {};\n      for (let opacity = 0; opacity <= 10; opacity++) {\n        const value = opacity / 10;\n        cache[baseColor][value] = baseColor.replace(/alpha\\)$/, `${value})`);\n      }\n    });\n    return cache;\n  }, [COLORS.stars]);\n\n  // Get color with opacity from cache (faster than string replacement)\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    // Round to nearest 0.1 to use cached values\n    const roundedOpacity = Math.round(safeOpacity * 10) / 10;\n    return colorCache[baseColor][roundedOpacity] || baseColor.replace(/alpha\\)$/, `${safeOpacity})`);\n  }, [colorCache]);\n\n  // Generate a seed based on the current time\n  const getTimeSeed = useCallback(() => {\n    const now = new Date();\n\n    // Create different seed values based on configuration\n    switch (CONFIG.timeConsistency) {\n      case 'hourly':\n        // Change every hour (year + month + day + hour)\n        return now.getFullYear() * 1000000 + (now.getMonth() + 1) * 10000 + now.getDate() * 100 + now.getHours();\n      case 'weekly':\n        // Change weekly (year + week number)\n        const startOfYear = new Date(now.getFullYear(), 0, 1);\n        const days = Math.floor((now - startOfYear) / (24 * 60 * 60 * 1000));\n        const weekNumber = Math.ceil(days / 7);\n        return now.getFullYear() * 100 + weekNumber;\n      case 'always':\n        // Always the same (fixed value)\n        return 42;\n      case 'daily':\n      default:\n        // Change daily (year + month + day)\n        return now.getFullYear() * 10000 + (now.getMonth() + 1) * 100 + now.getDate();\n    }\n  }, [CONFIG.timeConsistency]);\n\n  // Simple seeded random function\n  const createSeededRandom = useCallback(seed => {\n    return function () {\n      // Simple xorshift-based algorithm\n      seed = (seed ^ seed << 13) >>> 0;\n      seed = (seed ^ seed >>> 17) >>> 0;\n      seed = (seed ^ seed << 5) >>> 0;\n      return seed % 1000000 / 1000000;\n    };\n  }, []);\n\n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) return false;\n    const canvas = canvasRef.current;\n\n    // Get viewport dimensions\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const pixelRatio = window.devicePixelRatio || 1;\n\n    // Set canvas size accounting for pixel ratio\n    canvas.width = width * pixelRatio;\n    canvas.height = height * pixelRatio;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n\n    // Ensure canvas is visible with a background color\n    const ctx = canvas.getContext('2d', {\n      alpha: false\n    }); // Optimize for non-transparent canvas\n    if (ctx) {\n      ctx.fillStyle = 'rgb(15, 15, 20)';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n\n    // Update dimensions ref instead of state\n    dimensionsRef.current = {\n      width,\n      height,\n      pixelRatio\n    };\n    return true;\n  }, []);\n\n  // Generate a new star configuration with time-based seeding\n  const generateStarSeeds = useCallback(() => {\n    const {\n      width,\n      height\n    } = dimensionsRef.current;\n    if (!width || !height) return [];\n    const starSeeds = [];\n\n    // Initialize random generator - either time-based or standard\n    let random;\n    if (CONFIG.useTimeBased) {\n      // Use time-based seeding\n      const timeSeed = getTimeSeed();\n      random = createSeededRandom(timeSeed);\n    } else {\n      // Use standard random\n      random = Math.random;\n    }\n\n    // Generate consistent star seeds\n    for (let i = 0; i < CONFIG.starCount; i++) {\n      starSeeds.push({\n        xSeed: random(),\n        // Distribute stars vertically across multiple screen heights\n        // Including above the viewport for continuous scrolling effect\n        ySeed: random() * CONFIG.verticalSpreadFactor - CONFIG.offscreenBufferFactor,\n        zSeed: random() * 0.8 + 0.1,\n        sizeSeed: random(),\n        opacitySeed: random(),\n        phaseSeed: random() * Math.PI * 2,\n        speedSeed: random() * 0.2 + 0.9,\n        pulseSpeedSeed: random() * 0.002 + 0.001,\n        colorIndex: Math.floor(random() * COLORS.stars.length),\n        // Parallax factor determines how much this star moves with scrolling\n        // Deeper stars (higher z) move less for realistic parallax\n        parallaxFactorSeed: random() * 0.5 + 0.1,\n        // Drift movement properties\n        driftDirectionXSeed: random() * 2 - 1,\n        driftDirectionYSeed: random() * 2 - 1,\n        driftSpeedSeed: random()\n      });\n    }\n    return starSeeds;\n  }, [CONFIG, COLORS.stars.length, getTimeSeed, createSeededRandom]);\n\n  // Create a new star at random position\n  const createNewStar = useCallback((offScreenStar = null) => {\n    const {\n      width,\n      height\n    } = dimensionsRef.current;\n    const star = {};\n\n    // If replacing an existing star, preserve some properties\n    if (offScreenStar) {\n      star.z = offScreenStar.z;\n      star.size = offScreenStar.size;\n      star.baseOpacity = offScreenStar.baseOpacity;\n      star.pulsePhase = Math.random() * Math.PI * 2; // New phase\n      star.color = offScreenStar.color;\n      star.parallaxFactor = offScreenStar.parallaxFactor;\n    } else {\n      // Otherwise generate new properties\n      star.z = Math.random() * 0.8 + 0.1;\n      star.size = (Math.random() * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n      star.baseOpacity = Math.random() * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n      star.pulsePhase = Math.random() * Math.PI * 2;\n      star.color = COLORS.stars[Math.floor(Math.random() * COLORS.stars.length)];\n      star.parallaxFactor = Math.random() * 0.5 * CONFIG.parallaxFactor * (1 - star.z * 0.5);\n    }\n\n    // Generate position\n    // Avoid edges by using 10% inset from the viewport dimensions\n    const edgeBuffer = Math.min(width, height) * 0.1;\n    star.x = edgeBuffer + Math.random() * (width - 2 * edgeBuffer);\n    star.baseY = edgeBuffer + Math.random() * (height - 2 * edgeBuffer);\n    star.y = star.baseY;\n    star.targetY = star.y;\n\n    // For new stars during runtime, fade them in\n    // For initial stars, start them fully visible\n    const isInitialCreation = !isInitializedRef.current;\n    if (isInitialCreation) {\n      star.opacity = star.baseOpacity;\n      star.state = 'visible';\n      star.fadeProgress = 1;\n    } else {\n      star.opacity = 0;\n      star.state = 'fading-in';\n      star.fadeProgress = 0;\n      star.fadeStart = Date.now();\n    }\n\n    // Movement properties\n    star.pulseSpeed = Math.random() * 0.002 + 0.001;\n    star.movementSpeed = (Math.random() * 0.2 + 0.9) * CONFIG.baseMovementSpeed * (1.1 - star.z);\n\n    // Drift movement properties\n    star.driftDirectionX = Math.random() * 2 - 1;\n    star.driftDirectionY = Math.random() * 2 - 1;\n    // Normalize the direction vector\n    const dirMagnitude = Math.sqrt(star.driftDirectionX ** 2 + star.driftDirectionY ** 2);\n    star.driftDirectionX /= dirMagnitude;\n    star.driftDirectionY /= dirMagnitude;\n    // Vary the drift speed between stars\n    star.driftSpeed = CONFIG.driftSpeed + (Math.random() * 2 - 1) * CONFIG.driftSpeedVariation;\n    star.directionChangeTimer = 0;\n\n    // Initialize velocity and position tracking for trails\n    star.velocity = 0;\n    star.lastX = star.x;\n    star.lastY = star.y;\n\n    // Initialize twinkling properties\n    star.twinkleState = 'visible';\n    star.twinkleProgress = 0;\n    star.twinkleDuration = Math.random() * (CONFIG.twinkleDuration[1] - CONFIG.twinkleDuration[0]) + CONFIG.twinkleDuration[0];\n\n    // Physics properties\n    star.velocity = 0;\n    return star;\n  }, [CONFIG, COLORS.stars]);\n\n  // Load or generate time-based star configuration\n  const getStarConfiguration = useCallback(() => {\n    const {\n      width,\n      height\n    } = dimensionsRef.current;\n    if (!width || !height) return {\n      starSeeds: []\n    };\n\n    // When using time-based generation, we don't need to load from storage\n    // except for the scroll position\n    if (CONFIG.useTimeBased) {\n      // Generate seeds directly from time\n      const starSeeds = generateStarSeeds();\n\n      // Try to load just the scroll position from sessionStorage\n      if (CONFIG.preserveScrollPosition) {\n        try {\n          const scrollPos = sessionStorage.getItem(CONFIG.scrollPositionKey);\n          if (scrollPos !== null) {\n            springScrollYRef.current = parseFloat(scrollPos);\n          }\n        } catch (error) {\n          console.warn('Could not load scroll position from session storage', error);\n        }\n      }\n      return {\n        starSeeds,\n        timeSeed: getTimeSeed()\n      };\n    }\n\n    // If not using time-based, fall back to original session storage approach\n    try {\n      // Try to load existing configuration from sessionStorage\n      const storedConfig = sessionStorage.getItem(CONFIG.sessionKey);\n      if (storedConfig) {\n        const parsedConfig = JSON.parse(storedConfig);\n        // Check if we have the right number of stars (config might have changed)\n        if (parsedConfig.starSeeds && parsedConfig.starSeeds.length === CONFIG.starCount) {\n          return parsedConfig;\n        }\n      }\n    } catch (error) {\n      console.warn('Could not load star configuration from session storage', error);\n    }\n\n    // Generate new configuration if none exists or if it's invalid\n    const starSeeds = generateStarSeeds();\n\n    // Store new configuration in sessionStorage (only if not using time-based)\n    if (!CONFIG.useTimeBased) {\n      const newConfig = {\n        starSeeds,\n        timestamp: Date.now()\n      };\n      try {\n        sessionStorage.setItem(CONFIG.sessionKey, JSON.stringify(newConfig));\n      } catch (error) {\n        console.warn('Could not save star configuration to session storage', error);\n      }\n    }\n    return {\n      starSeeds\n    };\n  }, [CONFIG, generateStarSeeds, getTimeSeed]);\n\n  // Save just the scroll position (for time-based mode)\n  const saveScrollPosition = useCallback(() => {\n    if (!CONFIG.preserveScrollPosition) return;\n    try {\n      sessionStorage.setItem(CONFIG.scrollPositionKey, springScrollYRef.current.toString());\n    } catch (error) {\n      console.warn('Could not save scroll position to session storage', error);\n    }\n  }, [CONFIG.preserveScrollPosition, CONFIG.scrollPositionKey]);\n\n  // Initialize stars with time-based or session-persistent configuration\n  const initializeStars = useCallback(() => {\n    const {\n      width,\n      height\n    } = dimensionsRef.current;\n    if (!width || !height) return;\n\n    // First check if we already have stars that should be preserved\n    if (starsRef.current.length > 0 && isInitializedRef.current) {\n      // Only reinitialize if screen dimensions have significantly changed\n      const existingWidth = starsRef.current[0].x / starsRef.current[0].xSeed;\n      const existingHeight = starsRef.current[0].baseY / (starsRef.current[0].ySeed + CONFIG.offscreenBufferFactor);\n      const widthChange = Math.abs(existingWidth - width) / width;\n      const heightChange = Math.abs(existingHeight - height) / height;\n\n      // If using time-based generation and the time seed hasn't changed,\n      // and dimensions haven't changed much, preserve existing stars\n      if (widthChange < 0.2 && heightChange < 0.2) {\n        // When using time-based generation, check if the seed has changed\n        if (CONFIG.useTimeBased) {\n          const currentTimeSeed = getTimeSeed();\n          const previousTimeSeed = starsRef.current.timeSeed;\n\n          // If time seed has changed, we need to regenerate\n          if (previousTimeSeed && previousTimeSeed !== currentTimeSeed) {\n            // Continue with regeneration below\n          } else {\n            // Just update target positions based on new dimensions\n            for (let i = 0; i < starsRef.current.length; i++) {\n              const star = starsRef.current[i];\n              // Scale position to new dimensions\n              star.x = star.x / existingWidth * width;\n              star.baseY = star.baseY / existingHeight * height;\n              star.y = star.baseY;\n              star.targetY = star.y;\n            }\n            return; // Keep existing stars\n          }\n        } else {\n          // Non-time-based mode, just update positions\n          for (let i = 0; i < starsRef.current.length; i++) {\n            const star = starsRef.current[i];\n            // Scale position to new dimensions\n            star.x = star.x / existingWidth * width;\n            star.baseY = star.baseY / existingHeight * height;\n            star.y = star.baseY;\n            star.targetY = star.y;\n          }\n          return; // Keep existing stars\n        }\n      }\n    }\n\n    // Get or create time-based or session-persistent configuration\n    const {\n      starSeeds,\n      timeSeed\n    } = getStarConfiguration();\n\n    // Clear existing stars\n    starsRef.current = [];\n\n    // Store time seed for future comparison\n    starsRef.current.timeSeed = timeSeed;\n\n    // Create stars using the seeds\n    for (let i = 0; i < starSeeds.length; i++) {\n      const seed = starSeeds[i];\n      const star = {};\n\n      // Store original seeds for future reference\n      star.xSeed = seed.xSeed;\n      star.ySeed = seed.ySeed;\n\n      // Position - use seeds but adapt to current screen dimensions\n      star.x = seed.xSeed * width;\n      // Initial y position - distributed vertically across multiple screen heights\n      star.baseY = (seed.ySeed + CONFIG.offscreenBufferFactor) * height;\n      star.y = star.baseY;\n      star.z = seed.zSeed; // Depth (0.1 to 0.9)\n\n      // Visual properties\n      star.size = (seed.sizeSeed * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n      star.baseOpacity = seed.opacitySeed * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n      star.opacity = star.baseOpacity; // Start fully visible\n\n      // Animation properties\n      star.pulsePhase = seed.phaseSeed;\n      star.pulseSpeed = seed.pulseSpeedSeed;\n      star.movementSpeed = seed.speedSeed * CONFIG.baseMovementSpeed * (1.1 - star.z);\n\n      // Initialize velocity and position tracking for trails\n      star.velocity = 0;\n      star.lastX = star.x;\n      star.lastY = star.y;\n\n      // Initialize twinkling properties\n      star.twinkleState = 'visible'; // 'fading-in', 'visible', 'fading-out', 'hidden'\n      star.twinkleProgress = 0;\n      star.twinkleDuration = Math.random() * (CONFIG.twinkleDuration[1] - CONFIG.twinkleDuration[0]) + CONFIG.twinkleDuration[0];\n\n      // Drift movement properties\n      star.driftDirectionX = seed.driftDirectionXSeed;\n      star.driftDirectionY = seed.driftDirectionYSeed;\n      // Normalize the direction vector\n      const dirMagnitude = Math.sqrt(star.driftDirectionX ** 2 + star.driftDirectionY ** 2) || 1;\n      star.driftDirectionX /= dirMagnitude;\n      star.driftDirectionY /= dirMagnitude;\n      // Vary the drift speed between stars\n      star.driftSpeed = CONFIG.driftSpeed + (seed.driftSpeedSeed * 2 - 1) * CONFIG.driftSpeedVariation;\n      star.directionChangeTimer = 0;\n\n      // Star state tracking\n      star.state = 'visible'; // Start visible, not fading in\n      star.fadeProgress = 1; // Fully visible\n\n      // Parallax properties (for scrolling effect)\n      // Make deeper stars (higher z) move less for realistic parallax\n      star.parallaxFactor = seed.parallaxFactorSeed * CONFIG.parallaxFactor * (1 - star.z * 0.5);\n\n      // Physics properties for bouncy effect\n      star.velocity = 0;\n      star.targetY = star.y;\n\n      // Color variation\n      star.color = COLORS.stars[seed.colorIndex];\n\n      // Store in ref\n      starsRef.current.push(star);\n    }\n  }, [CONFIG, COLORS.stars, getStarConfiguration, getTimeSeed]);\n\n  // Optimized star rendering with subtle trail effect\n  const drawStar = useCallback((ctx, star) => {\n    // Skip rendering completely invisible stars\n    if (star.opacity < 0.02) return;\n\n    // Draw subtle trail if enabled and star is moving\n    if (CONFIG.trailEnabled && (Math.abs(star.velocity) > 0.001 || Math.abs(star.lastX - star.x) > 0.1)) {\n      // Calculate trail direction based on movement\n      const trailX = star.lastX !== undefined ? star.lastX : star.x - star.velocity * 5;\n      const trailY = star.lastY !== undefined ? star.lastY : star.y - star.velocity * 5;\n\n      // Ensure the trail is very subtle\n      ctx.beginPath();\n      ctx.moveTo(star.x, star.y);\n      ctx.lineTo(trailX, trailY);\n      ctx.strokeStyle = getColor(star.color, star.opacity * CONFIG.trailOpacityFactor);\n      ctx.lineWidth = star.size * 0.6;\n      ctx.lineCap = 'round';\n      ctx.stroke();\n    }\n\n    // Store current position for next frame's trail\n    star.lastX = star.x;\n    star.lastY = star.y;\n\n    // Simplified star rendering without creating new gradients every frame\n    ctx.beginPath();\n    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n    ctx.fillStyle = getColor(star.color, star.opacity);\n    ctx.fill();\n\n    // Simplified glow effect without expensive gradient creation\n    if (star.opacity > 0.3) {\n      ctx.beginPath();\n      ctx.arc(star.x, star.y, star.size * 1.8, 0, Math.PI * 2);\n      ctx.fillStyle = getColor(star.color, star.opacity * 0.4);\n      ctx.fill();\n    }\n  }, [CONFIG.trailEnabled, CONFIG.trailOpacityFactor, getColor]);\n\n  // Check if a star is off-screen\n  const isStarOffScreen = useCallback(star => {\n    const {\n      width,\n      height\n    } = dimensionsRef.current;\n    const buffer = CONFIG.offscreenBuffer;\n    return star.x < -buffer || star.x > width + buffer || star.y < -buffer || star.y > height + buffer;\n  }, [CONFIG.offscreenBuffer]);\n\n  // Render the scene - optimized for performance\n  const renderScene = useCallback(() => {\n    if (!canvasRef.current) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d', {\n      alpha: false\n    });\n    if (!ctx) return;\n    const {\n      width,\n      height,\n      pixelRatio\n    } = dimensionsRef.current;\n\n    // Clear canvas\n    ctx.fillStyle = COLORS.background.topColor;\n    ctx.fillRect(0, 0, width * pixelRatio, height * pixelRatio);\n\n    // Apply device pixel ratio scaling only once\n    ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n\n    // Enable global composition for better glow effect\n    ctx.globalCompositeOperation = 'lighter';\n\n    // Draw stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n      drawStar(ctx, star);\n    }\n\n    // Reset global composition\n    ctx.globalCompositeOperation = 'source-over';\n  }, [COLORS.background.topColor, drawStar]);\n\n  // Update animation state - optimized for performance\n  const updateAnimation = useCallback((deltaTime, timestamp) => {\n    const currentScrollY = springScrollYRef.current;\n    lastScrollYRef.current = currentScrollY;\n\n    // Use time-appropriate timestamp for animations in time-based mode\n    let timeFactor;\n    if (CONFIG.useTimeBased) {\n      // Get current time of day (0-1 range representing entire day)\n      const now = new Date();\n      const secondsInDay = now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds();\n      const fractionOfDay = secondsInDay / 86400; // 86400 seconds in a day\n\n      // Use this for animations that should be consistent throughout the day\n      timeFactor = fractionOfDay * 100; // Scale for better animation control\n    } else {\n      // Use standard animation timestamp\n      timeFactor = timestamp * 0.001;\n    }\n    const currentTime = Date.now();\n\n    // Track stars to replace (avoid modifying array during iteration)\n    const starsToReplace = [];\n\n    // Count currently fading stars to manage random fading\n    let fadingCount = 0;\n    if (CONFIG.randomFadingEnabled) {\n      fadingCount = starsRef.current.filter(star => star.state === 'fading-out' || star.state === 'fading-in').length;\n    }\n\n    // Update stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n\n      // Handle star state transitions\n      if (star.state === 'fading-in') {\n        // Calculate progress for fade-in\n        const elapsed = currentTime - star.fadeStart;\n        star.fadeProgress = Math.min(1, elapsed / CONFIG.fadeInDuration);\n        star.opacity = star.baseOpacity * star.fadeProgress;\n\n        // Complete fade-in\n        if (star.fadeProgress >= 1) {\n          star.state = 'visible';\n          star.opacity = star.baseOpacity;\n        }\n      } else if (star.state === 'fading-out') {\n        // Calculate progress for fade-out\n        const elapsed = currentTime - star.fadeStart;\n        star.fadeProgress = Math.max(0, 1 - elapsed / CONFIG.fadeOutDuration);\n        star.opacity = star.baseOpacity * star.fadeProgress;\n\n        // Complete fade-out - mark for replacement\n        if (star.fadeProgress <= 0) {\n          starsToReplace.push(i);\n        }\n      } else {\n        // Normal visible state\n\n        // Random fading (new feature)\n        if (CONFIG.randomFadingEnabled && fadingCount < CONFIG.maxSimultaneousFading && Math.random() < CONFIG.randomFadeOutProbability * deltaTime) {\n          // Start fade-out process for random star\n          star.state = 'fading-out';\n          star.fadeStart = currentTime;\n          fadingCount++;\n          continue; // Skip the rest of the loop for this star\n        }\n\n        // Calculate parallax effect based on scroll position\n        if (CONFIG.parallaxEnabled) {\n          // Update target position based on scroll (parallax effect)\n          star.targetY = star.baseY - currentScrollY * star.parallaxFactor;\n        }\n\n        // Apply spring physics for bouncy effect\n        const displacement = star.targetY - star.y;\n        const springForce = displacement * CONFIG.springStrength;\n\n        // Update velocity with spring force\n        star.velocity += springForce;\n\n        // Apply damping to velocity\n        star.velocity *= CONFIG.dampingFactor;\n\n        // Add velocity clamping to prevent extreme bouncing\n        const maxVelocity = 1.0; // Maximum allowed velocity\n        star.velocity = Math.max(-maxVelocity, Math.min(maxVelocity, star.velocity));\n\n        // Update position based on velocity (for parallax)\n        star.y += star.velocity;\n\n        // Apply drift movement if enabled\n        if (CONFIG.driftEnabled) {\n          // Apply movement with additional smoothing to prevent jumps\n          // Calculate the intended movement\n          const dx = star.driftDirectionX * star.driftSpeed * deltaTime;\n          const dy = star.driftDirectionY * star.driftSpeed * deltaTime;\n\n          // Apply a maximum movement limit to prevent jumps\n          const maxMove = 0.5; // Maximum pixels to move per frame\n          const actualDx = Math.abs(dx) > maxMove ? Math.sign(dx) * maxMove : dx;\n          const actualDy = Math.abs(dy) > maxMove ? Math.sign(dy) * maxMove : dy;\n\n          // Move star based on limited movement\n          star.x += actualDx;\n          // Add the drift to baseY (which is the reference point for parallax)\n          star.baseY += actualDy;\n          star.targetY = star.baseY - currentScrollY * star.parallaxFactor;\n\n          // Occasionally change drift direction with smoother transitions\n          star.directionChangeTimer += deltaTime;\n          if (Math.random() < CONFIG.directionChangeFrequency * deltaTime) {\n            // Gradually change direction by adding a small random vector\n            // Use the directionChangeAmount to limit the magnitude of the change\n            const changeX = (Math.random() * 2 - 1) * CONFIG.directionChangeAmount;\n            const changeY = (Math.random() * 2 - 1) * CONFIG.directionChangeAmount;\n\n            // Apply a small percentage of the change for smoother transitions\n            star.driftDirectionX += changeX;\n            star.driftDirectionY += changeY;\n\n            // Re-normalize the direction vector with safety checks\n            const dirMagnitude = Math.sqrt(star.driftDirectionX ** 2 + star.driftDirectionY ** 2) || 1;\n\n            // Prevent jittery movement by ensuring minimum magnitude\n            if (dirMagnitude < 0.01) {\n              // If direction vector is too small, reset to a random direction\n              star.driftDirectionX = Math.random() * 2 - 1;\n              star.driftDirectionY = Math.random() * 2 - 1;\n              const newMagnitude = Math.sqrt(star.driftDirectionX ** 2 + star.driftDirectionY ** 2) || 1;\n              star.driftDirectionX /= newMagnitude;\n              star.driftDirectionY /= newMagnitude;\n            } else {\n              star.driftDirectionX /= dirMagnitude;\n              star.driftDirectionY /= dirMagnitude;\n            }\n          }\n        }\n\n        // Check if star is now off-screen\n        if (CONFIG.regenerateOffscreenStars && isStarOffScreen(star) && star.state === 'visible') {\n          // Start fade-out process\n          star.state = 'fading-out';\n          star.fadeStart = currentTime;\n        }\n\n        // Apply time-based pulsing effect\n        const pulseFactor = Math.sin(timeFactor * star.pulseSpeed + star.pulsePhase) * 0.15 + 0.85;\n        // Only apply pulsing if not in a transition state\n        if (star.state === 'visible') {\n          star.opacity = star.baseOpacity * pulseFactor;\n        }\n      }\n    }\n\n    // Replace stars that have completed fade-out (in reverse order to avoid index issues)\n    for (let i = starsToReplace.length - 1; i >= 0; i--) {\n      const index = starsToReplace[i];\n      // Create a new star to replace the off-screen one\n      const newStar = createNewStar(starsRef.current[index]);\n      // Replace the star in the array\n      starsRef.current[index] = newStar;\n    }\n\n    // For time-based mode, we don't need to frequently save configuration\n    // Just save scroll position when it changes significantly\n    if (CONFIG.preserveScrollPosition && Math.abs(currentScrollY - parseFloat(sessionStorage.getItem(CONFIG.scrollPositionKey) || '0')) > 50) {\n      saveScrollPosition();\n    }\n\n    // Only save full configuration periodically if NOT using time-based mode\n    if (!CONFIG.useTimeBased && timestamp % 3000 < 16) {\n      // Every ~3 seconds (assuming 60fps)\n      try {\n        // Convert current star configuration to seeds for storage\n        const starSeeds = starsRef.current.map(star => ({\n          xSeed: star.x / dimensionsRef.current.width,\n          ySeed: star.baseY / dimensionsRef.current.height - CONFIG.offscreenBufferFactor,\n          zSeed: star.z,\n          sizeSeed: (star.size / star.z - CONFIG.starSizeMin) / (CONFIG.starSizeMax - CONFIG.starSizeMin),\n          opacitySeed: (star.baseOpacity - CONFIG.starOpacityMin) / (CONFIG.starOpacityMax - CONFIG.starOpacityMin),\n          phaseSeed: star.pulsePhase / (Math.PI * 2),\n          speedSeed: star.movementSpeed / (CONFIG.baseMovementSpeed * (1.1 - star.z)),\n          pulseSpeedSeed: (star.pulseSpeed - 0.001) / 0.002,\n          colorIndex: COLORS.stars.indexOf(star.color),\n          parallaxFactorSeed: star.parallaxFactor / (CONFIG.parallaxFactor * (1 - star.z * 0.5)),\n          driftDirectionXSeed: star.driftDirectionX,\n          driftDirectionYSeed: star.driftDirectionY,\n          driftSpeedSeed: (star.driftSpeed - CONFIG.driftSpeed + CONFIG.driftSpeedVariation) / (2 * CONFIG.driftSpeedVariation)\n        }));\n        sessionStorage.setItem(CONFIG.sessionKey, JSON.stringify({\n          starSeeds,\n          timestamp: Date.now()\n        }));\n      } catch (error) {\n        console.warn('Could not save star configuration to session storage', error);\n      }\n    }\n  }, [CONFIG, isStarOffScreen, createNewStar, COLORS.stars, saveScrollPosition]);\n\n  // Define the animation loop function, using time-based approach as appropriate\n  const animate = useCallback(function animationLoop(timestamp) {\n    if (!isInitializedRef.current) {\n      animationFrameRef.current = requestAnimationFrame(animationLoop);\n      return;\n    }\n\n    // Limit FPS\n    const minFrameTime = 1000 / CONFIG.maxFPS;\n    const elapsed = timestamp - (lastTimeRef.current || 0);\n    if (elapsed < minFrameTime) {\n      animationFrameRef.current = requestAnimationFrame(animationLoop);\n      return;\n    }\n\n    // Calculate delta time with cap to prevent large jumps\n    const deltaTime = lastTimeRef.current ? Math.min(elapsed, 50) : 16;\n    lastTimeRef.current = timestamp;\n\n    // For time-based mode, we can optionally use a time-derived timestamp\n    // This ensures animations are consistent based on time of day\n    if (CONFIG.useTimeBased) {\n      // Get current minute of the day (0-1440)\n      const now = new Date();\n      const minuteOfDay = now.getHours() * 60 + now.getMinutes();\n\n      // Create a timestamp that increments more slowly\n      // This makes animations more consistent across page loads\n      const timeBasedTimestamp = minuteOfDay * 1000;\n\n      // Use this time-based timestamp for animations\n      updateAnimation(deltaTime, timeBasedTimestamp);\n    } else {\n      // Standard animation using browser timestamp\n      updateAnimation(deltaTime, timestamp);\n    }\n\n    // Render scene\n    renderScene();\n\n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(animationLoop);\n  }, [CONFIG.maxFPS, CONFIG.useTimeBased, updateAnimation, renderScene]);\n\n  // Comprehensive initialization and resize handling\n  useEffect(() => {\n    // One-time initialization function\n    const initialize = () => {\n      if (setupCanvas()) {\n        // Create stars only after canvas is ready\n        initializeStars();\n        // Mark as initialized but don't trigger re-render\n        isInitializedRef.current = true;\n        // Start animation only after everything is ready\n        animationFrameRef.current = requestAnimationFrame(animate);\n      }\n    };\n\n    // Handle resize events\n    const handleResize = () => {\n      // Only re-initialize if already initialized\n      if (isInitializedRef.current) {\n        setupCanvas();\n        initializeStars();\n      }\n    };\n\n    // Save scroll position on page visibility change (page navigation)\n    const handleVisibilityChange = () => {\n      if (document.visibilityState === 'hidden' && CONFIG.preserveScrollPosition) {\n        saveScrollPosition();\n      }\n    };\n\n    // Save scroll position before unload (page refresh/close)\n    const handleBeforeUnload = () => {\n      if (CONFIG.preserveScrollPosition) {\n        saveScrollPosition();\n      }\n    };\n\n    // Add event listeners\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    window.addEventListener('beforeunload', handleBeforeUnload);\n\n    // Throttle resize events\n    let resizeTimer;\n    const throttledResize = () => {\n      if (!resizeTimer) {\n        resizeTimer = setTimeout(() => {\n          resizeTimer = null;\n          handleResize();\n        }, 200); // 200ms throttle\n      }\n    };\n\n    // Add resize listener\n    window.addEventListener('resize', throttledResize);\n\n    // Run initialization after first render is complete\n    // This prevents the \"double load\" effect\n    requestAnimationFrame(() => {\n      firstRenderCompleteRef.current = true;\n      initialize();\n    });\n\n    // Cleanup\n    return () => {\n      window.removeEventListener('resize', throttledResize);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n      if (resizeTimer) clearTimeout(resizeTimer);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      // Save scroll position on unmount\n      if (CONFIG.preserveScrollPosition) {\n        saveScrollPosition();\n      }\n    };\n  }, [CONFIG.preserveScrollPosition, setupCanvas, initializeStars, animate, saveScrollPosition]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      width: '100vw',\n      height: '100vh',\n      overflow: 'hidden',\n      zIndex: -1,\n      pointerEvents: 'none'\n    },\n    \"aria-hidden\": \"true\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 975,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 961,\n    columnNumber: 5\n  }, this);\n};\n_s(Background, \"tjftF3/ZrhFZzCb8SeQtEe3LBoI=\", false, function () {\n  return [useScroll, useSpring];\n});\n_c = Background;\nexport default Background;\nvar _c;\n$RefreshReg$(_c, \"Background\");","map":{"version":3,"names":["React","useRef","useEffect","useCallback","useMemo","useScroll","useSpring","jsxDEV","_jsxDEV","Background","config","_s","containerRef","canvasRef","starsRef","animationFrameRef","lastTimeRef","lastScrollYRef","isInitializedRef","firstRenderCompleteRef","dimensionsRef","width","height","pixelRatio","scrollY","smooth","springScrollY","stiffness","damping","mass","restDelta","restSpeed","springScrollYRef","unsubscribe","onChange","value","current","CONFIG","starCount","starSizeMin","starSizeMax","starOpacityMin","starOpacityMax","baseMovementSpeed","pulseFrequency","parallaxEnabled","parallaxFactor","trailEnabled","trailLength","trailOpacityFactor","twinkleEnabled","twinkleProbability","twinkleDuration","randomFadingEnabled","randomFadeOutProbability","maxSimultaneousFading","driftEnabled","driftSpeed","driftSpeedVariation","directionChangeFrequency","directionChangeAmount","regenerateOffscreenStars","fadeInDuration","fadeOutDuration","offscreenBuffer","springStrength","dampingFactor","verticalSpreadFactor","offscreenBufferFactor","maxFPS","useRays","useTimeBased","timeConsistency","preserveScrollPosition","sessionKey","scrollPositionKey","COLORS","stars","background","topColor","bottomColor","colors","colorCache","cache","forEach","baseColor","opacity","replace","getColor","safeOpacity","Math","max","min","roundedOpacity","round","getTimeSeed","now","Date","getFullYear","getMonth","getDate","getHours","startOfYear","days","floor","weekNumber","ceil","createSeededRandom","seed","setupCanvas","canvas","window","innerWidth","innerHeight","devicePixelRatio","style","ctx","getContext","alpha","fillStyle","fillRect","generateStarSeeds","starSeeds","random","timeSeed","i","push","xSeed","ySeed","zSeed","sizeSeed","opacitySeed","phaseSeed","PI","speedSeed","pulseSpeedSeed","colorIndex","length","parallaxFactorSeed","driftDirectionXSeed","driftDirectionYSeed","driftSpeedSeed","createNewStar","offScreenStar","star","z","size","baseOpacity","pulsePhase","color","edgeBuffer","x","baseY","y","targetY","isInitialCreation","state","fadeProgress","fadeStart","pulseSpeed","movementSpeed","driftDirectionX","driftDirectionY","dirMagnitude","sqrt","directionChangeTimer","velocity","lastX","lastY","twinkleState","twinkleProgress","getStarConfiguration","scrollPos","sessionStorage","getItem","parseFloat","error","console","warn","storedConfig","parsedConfig","JSON","parse","newConfig","timestamp","setItem","stringify","saveScrollPosition","toString","initializeStars","existingWidth","existingHeight","widthChange","abs","heightChange","currentTimeSeed","previousTimeSeed","drawStar","trailX","undefined","trailY","beginPath","moveTo","lineTo","strokeStyle","lineWidth","lineCap","stroke","arc","fill","isStarOffScreen","buffer","renderScene","setTransform","globalCompositeOperation","updateAnimation","deltaTime","currentScrollY","timeFactor","secondsInDay","getMinutes","getSeconds","fractionOfDay","currentTime","starsToReplace","fadingCount","filter","elapsed","displacement","springForce","maxVelocity","dx","dy","maxMove","actualDx","sign","actualDy","changeX","changeY","newMagnitude","pulseFactor","sin","index","newStar","map","indexOf","animate","animationLoop","requestAnimationFrame","minFrameTime","minuteOfDay","timeBasedTimestamp","initialize","handleResize","handleVisibilityChange","document","visibilityState","handleBeforeUnload","addEventListener","resizeTimer","throttledResize","setTimeout","removeEventListener","clearTimeout","cancelAnimationFrame","ref","position","top","left","overflow","zIndex","pointerEvents","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/layout/Background.jsx"],"sourcesContent":["import React, { useRef, useEffect, useCallback, useMemo } from 'react';\nimport { useScroll, useSpring } from 'framer-motion';\n\n/**\n * Background Component\n * \n * Enhanced with time-based star generation for consistent appearance\n * between page navigations and reduced storage operations.\n */\nconst Background = ({ config = {} }) => {\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const starsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimeRef = useRef(0);\n  const lastScrollYRef = useRef(0);\n  \n  // Use refs instead of state to prevent re-renders\n  const isInitializedRef = useRef(false);\n  const firstRenderCompleteRef = useRef(false);\n  \n  // Store dimensions in a ref to avoid re-renders when they change\n  const dimensionsRef = useRef({ width: 0, height: 0, pixelRatio: 1 });\n  \n  // Get scroll position using framer-motion\n  const { scrollY } = useScroll({\n    smooth: 0.05  // Smoother scrolling for high-framerate animations\n  });\n  \n  // Use spring physics for smoother scrolling effect\n  const springScrollY = useSpring(scrollY, {\n    stiffness: 1,\n    damping: 5,\n    mass: 0.5,\n    restDelta: 0.001,\n    restSpeed: 0.001\n  });\n  \n  // Track spring scrollY value without causing re-renders\n  const springScrollYRef = useRef(0);\n  useEffect(() => {\n    const unsubscribe = springScrollY.onChange(value => {\n      springScrollYRef.current = value;\n    });\n    return () => unsubscribe();\n  }, [springScrollY]);\n  \n  // Configuration - wrapped in useMemo to prevent recreation on each render\n  // Merge default config with user-provided config\n  const CONFIG = useMemo(() => ({\n    // Star appearance\n    starCount: 100,\n    starSizeMin: 1.0,\n    starSizeMax: 1.9,\n    starOpacityMin: 0.2,\n    starOpacityMax: 0.55,\n    \n    // Parallax and movement parameters\n    baseMovementSpeed: 0.00001,  // Reduced for slower movement\n    pulseFrequency: 0.00002,     // Slower pulsing\n    parallaxEnabled: true,\n    parallaxFactor: 0.2,  // How much stars move relative to scroll (0-1)\n    \n    // Trail effect parameters\n    trailEnabled: true,          // Enable subtle trails\n    trailLength: 2,              // Very short trail length (in pixels)\n    trailOpacityFactor: 0.5,     // Trail opacity relative to star opacity\n    \n    // Twinkling effect parameters\n    twinkleEnabled: true,        // Enable stars to fade in and out\n    twinkleProbability: 0.01,    // Probability of a star beginning to twinkle each frame\n    twinkleDuration: [2000, 4000], // Min and max duration of a twinkle cycle in ms\n    \n    // Random fading parameters\n    randomFadingEnabled: true,    // Enable random fading of stars\n    randomFadeOutProbability: 0.0003, // Probability of a star randomly starting to fade out per frame\n    maxSimultaneousFading: 10,    // Maximum number of stars that can be fading at once\n    \n    // Drifting movement parameters\n    driftEnabled: true,            // Enable slow drifting movement\n    driftSpeed: 0.01,              // Base speed of drift movement (pixels per second)\n    driftSpeedVariation: 0.005,    // Variation in drift speed between stars\n    directionChangeFrequency: 0.0005, // Probability of changing direction each frame\n    directionChangeAmount: 0.05,   // How much direction can change at once (lower = smoother)\n    \n    // Star regeneration parameters\n    regenerateOffscreenStars: true, // Replace off-screen stars instead of wrapping\n    fadeInDuration: 2000,          // Duration for new stars to fade in (ms)\n    fadeOutDuration: 1500,         // Duration for off-screen stars to fade out (ms)\n    offscreenBuffer: 50,           // Distance beyond viewport to trigger regeneration (px)\n    \n    // Physics parameters for bouncy effect\n    springStrength: 0.03,  // Higher = snappier\n    dampingFactor: 0.95,    // Higher = less bouncy (0-1)\n    \n    // Star distribution parameters\n    verticalSpreadFactor: 3,  // How many screen heights to spread stars across\n    offscreenBufferFactor: 1, // How many screen heights above viewport to generate stars\n    \n    // Performance parameters\n    maxFPS: 60,\n    useRays: false,  // Disable ray rendering for performance\n    \n    // Time-based parameters (new)\n    useTimeBased: true,            // Enable time-based seeding and animation\n    timeConsistency: 'daily',      // Options: 'hourly', 'daily', 'weekly', 'always'\n    preserveScrollPosition: true,  // Save and restore scroll position between sessions\n    \n    // Session persistence\n    sessionKey: 'scrolling_star_background_config',\n    scrollPositionKey: 'scrolling_star_background_scroll',\n    \n    // Override with user config\n    ...config\n  }), [config]);\n  \n  // Warm, golden color palette - wrapped in useMemo\n  const COLORS = useMemo(() => ({\n    // Star colors\n    stars: [\n      'rgba(255, 243, 200, alpha)', // Warm yellow\n      'rgba(255, 231, 164, alpha)', // Golden\n      'rgba(252, 249, 231, alpha)'  // Off-white gold\n    ],\n    \n    // Background gradient colors\n    background: {\n      topColor: 'rgb(8, 8, 12)',\n      bottomColor: 'rgb(15, 15, 20)'\n    },\n    \n    // Override with user config if provided\n    ...(config.colors || {})\n  }), [config.colors]);\n  \n  // Pre-generated color values to avoid string replacements during animation\n  const colorCache = useMemo(() => {\n    const cache = {};\n    COLORS.stars.forEach(baseColor => {\n      cache[baseColor] = {};\n      for (let opacity = 0; opacity <= 10; opacity++) {\n        const value = opacity / 10;\n        cache[baseColor][value] = baseColor.replace(/alpha\\)$/, `${value})`);\n      }\n    });\n    return cache;\n  }, [COLORS.stars]);\n  \n  // Get color with opacity from cache (faster than string replacement)\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    // Round to nearest 0.1 to use cached values\n    const roundedOpacity = Math.round(safeOpacity * 10) / 10;\n    return colorCache[baseColor][roundedOpacity] || baseColor.replace(/alpha\\)$/, `${safeOpacity})`);\n  }, [colorCache]);\n  \n  // Generate a seed based on the current time\n  const getTimeSeed = useCallback(() => {\n    const now = new Date();\n    \n    // Create different seed values based on configuration\n    switch(CONFIG.timeConsistency) {\n      case 'hourly':\n        // Change every hour (year + month + day + hour)\n        return now.getFullYear() * 1000000 + (now.getMonth() + 1) * 10000 + \n               now.getDate() * 100 + now.getHours();\n      case 'weekly':\n        // Change weekly (year + week number)\n        const startOfYear = new Date(now.getFullYear(), 0, 1);\n        const days = Math.floor((now - startOfYear) / (24 * 60 * 60 * 1000));\n        const weekNumber = Math.ceil(days / 7);\n        return now.getFullYear() * 100 + weekNumber;\n      case 'always':\n        // Always the same (fixed value)\n        return 42;\n      case 'daily':\n      default:\n        // Change daily (year + month + day)\n        return now.getFullYear() * 10000 + (now.getMonth() + 1) * 100 + now.getDate();\n    }\n  }, [CONFIG.timeConsistency]);\n  \n  // Simple seeded random function\n  const createSeededRandom = useCallback((seed) => {\n    return function() {\n      // Simple xorshift-based algorithm\n      seed = (seed ^ (seed << 13)) >>> 0;\n      seed = (seed ^ (seed >>> 17)) >>> 0;\n      seed = (seed ^ (seed << 5)) >>> 0;\n      return (seed % 1000000) / 1000000;\n    };\n  }, []);\n  \n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) return false;\n    \n    const canvas = canvasRef.current;\n    \n    // Get viewport dimensions\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const pixelRatio = window.devicePixelRatio || 1;\n    \n    // Set canvas size accounting for pixel ratio\n    canvas.width = width * pixelRatio;\n    canvas.height = height * pixelRatio;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n    \n    // Ensure canvas is visible with a background color\n    const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for non-transparent canvas\n    if (ctx) {\n      ctx.fillStyle = 'rgb(15, 15, 20)';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    \n    // Update dimensions ref instead of state\n    dimensionsRef.current = { width, height, pixelRatio };\n    \n    return true;\n  }, []);\n  \n  // Generate a new star configuration with time-based seeding\n  const generateStarSeeds = useCallback(() => {\n    const { width, height } = dimensionsRef.current;\n    if (!width || !height) return [];\n    \n    const starSeeds = [];\n    \n    // Initialize random generator - either time-based or standard\n    let random;\n    \n    if (CONFIG.useTimeBased) {\n      // Use time-based seeding\n      const timeSeed = getTimeSeed();\n      random = createSeededRandom(timeSeed);\n    } else {\n      // Use standard random\n      random = Math.random;\n    }\n    \n    // Generate consistent star seeds\n    for (let i = 0; i < CONFIG.starCount; i++) {\n      starSeeds.push({\n        xSeed: random(),\n        // Distribute stars vertically across multiple screen heights\n        // Including above the viewport for continuous scrolling effect\n        ySeed: random() * CONFIG.verticalSpreadFactor - CONFIG.offscreenBufferFactor,\n        zSeed: random() * 0.8 + 0.1,\n        sizeSeed: random(),\n        opacitySeed: random(),\n        phaseSeed: random() * Math.PI * 2,\n        speedSeed: random() * 0.2 + 0.9,\n        pulseSpeedSeed: random() * 0.002 + 0.001,\n        colorIndex: Math.floor(random() * COLORS.stars.length),\n        // Parallax factor determines how much this star moves with scrolling\n        // Deeper stars (higher z) move less for realistic parallax\n        parallaxFactorSeed: random() * 0.5 + 0.1,\n        // Drift movement properties\n        driftDirectionXSeed: random() * 2 - 1,\n        driftDirectionYSeed: random() * 2 - 1,\n        driftSpeedSeed: random()\n      });\n    }\n    \n    return starSeeds;\n  }, [CONFIG, COLORS.stars.length, getTimeSeed, createSeededRandom]);\n  \n  // Create a new star at random position\n  const createNewStar = useCallback((offScreenStar = null) => {\n    const { width, height } = dimensionsRef.current;\n    const star = {};\n    \n    // If replacing an existing star, preserve some properties\n    if (offScreenStar) {\n      star.z = offScreenStar.z;\n      star.size = offScreenStar.size;\n      star.baseOpacity = offScreenStar.baseOpacity;\n      star.pulsePhase = Math.random() * Math.PI * 2; // New phase\n      star.color = offScreenStar.color;\n      star.parallaxFactor = offScreenStar.parallaxFactor;\n    } else {\n      // Otherwise generate new properties\n      star.z = Math.random() * 0.8 + 0.1;\n      star.size = (Math.random() * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n      star.baseOpacity = Math.random() * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n      star.pulsePhase = Math.random() * Math.PI * 2;\n      star.color = COLORS.stars[Math.floor(Math.random() * COLORS.stars.length)];\n      star.parallaxFactor = Math.random() * 0.5 * CONFIG.parallaxFactor * (1 - star.z * 0.5);\n    }\n    \n    // Generate position\n    // Avoid edges by using 10% inset from the viewport dimensions\n    const edgeBuffer = Math.min(width, height) * 0.1;\n    star.x = edgeBuffer + Math.random() * (width - 2 * edgeBuffer);\n    star.baseY = edgeBuffer + Math.random() * (height - 2 * edgeBuffer);\n    star.y = star.baseY;\n    star.targetY = star.y;\n    \n    // For new stars during runtime, fade them in\n    // For initial stars, start them fully visible\n    const isInitialCreation = !isInitializedRef.current;\n    if (isInitialCreation) {\n      star.opacity = star.baseOpacity;\n      star.state = 'visible';\n      star.fadeProgress = 1;\n    } else {\n      star.opacity = 0;\n      star.state = 'fading-in';\n      star.fadeProgress = 0;\n      star.fadeStart = Date.now();\n    }\n    \n    // Movement properties\n    star.pulseSpeed = Math.random() * 0.002 + 0.001;\n    star.movementSpeed = (Math.random() * 0.2 + 0.9) * CONFIG.baseMovementSpeed * (1.1 - star.z);\n    \n    // Drift movement properties\n    star.driftDirectionX = Math.random() * 2 - 1;\n    star.driftDirectionY = Math.random() * 2 - 1;\n    // Normalize the direction vector\n    const dirMagnitude = Math.sqrt(star.driftDirectionX ** 2 + star.driftDirectionY ** 2);\n    star.driftDirectionX /= dirMagnitude;\n    star.driftDirectionY /= dirMagnitude;\n    // Vary the drift speed between stars\n    star.driftSpeed = CONFIG.driftSpeed + (Math.random() * 2 - 1) * CONFIG.driftSpeedVariation;\n    star.directionChangeTimer = 0;\n    \n    // Initialize velocity and position tracking for trails\n    star.velocity = 0;\n    star.lastX = star.x;\n    star.lastY = star.y;\n    \n    // Initialize twinkling properties\n    star.twinkleState = 'visible';\n    star.twinkleProgress = 0;\n    star.twinkleDuration = Math.random() * \n      (CONFIG.twinkleDuration[1] - CONFIG.twinkleDuration[0]) + \n      CONFIG.twinkleDuration[0];\n    \n    // Physics properties\n    star.velocity = 0;\n    \n    return star;\n  }, [CONFIG, COLORS.stars]);\n  \n  // Load or generate time-based star configuration\n  const getStarConfiguration = useCallback(() => {\n    const { width, height } = dimensionsRef.current;\n    if (!width || !height) return { starSeeds: [] };\n    \n    // When using time-based generation, we don't need to load from storage\n    // except for the scroll position\n    if (CONFIG.useTimeBased) {\n      // Generate seeds directly from time\n      const starSeeds = generateStarSeeds();\n      \n      // Try to load just the scroll position from sessionStorage\n      if (CONFIG.preserveScrollPosition) {\n        try {\n          const scrollPos = sessionStorage.getItem(CONFIG.scrollPositionKey);\n          if (scrollPos !== null) {\n            springScrollYRef.current = parseFloat(scrollPos);\n          }\n        } catch (error) {\n          console.warn('Could not load scroll position from session storage', error);\n        }\n      }\n      \n      return { starSeeds, timeSeed: getTimeSeed() };\n    }\n    \n    // If not using time-based, fall back to original session storage approach\n    try {\n      // Try to load existing configuration from sessionStorage\n      const storedConfig = sessionStorage.getItem(CONFIG.sessionKey);\n      \n      if (storedConfig) {\n        const parsedConfig = JSON.parse(storedConfig);\n        // Check if we have the right number of stars (config might have changed)\n        if (parsedConfig.starSeeds && parsedConfig.starSeeds.length === CONFIG.starCount) {\n          return parsedConfig;\n        }\n      }\n    } catch (error) {\n      console.warn('Could not load star configuration from session storage', error);\n    }\n    \n    // Generate new configuration if none exists or if it's invalid\n    const starSeeds = generateStarSeeds();\n    \n    // Store new configuration in sessionStorage (only if not using time-based)\n    if (!CONFIG.useTimeBased) {\n      const newConfig = { starSeeds, timestamp: Date.now() };\n      try {\n        sessionStorage.setItem(CONFIG.sessionKey, JSON.stringify(newConfig));\n      } catch (error) {\n        console.warn('Could not save star configuration to session storage', error);\n      }\n    }\n    \n    return { starSeeds };\n  }, [CONFIG, generateStarSeeds, getTimeSeed]);\n  \n  // Save just the scroll position (for time-based mode)\n  const saveScrollPosition = useCallback(() => {\n    if (!CONFIG.preserveScrollPosition) return;\n    \n    try {\n      sessionStorage.setItem(CONFIG.scrollPositionKey, springScrollYRef.current.toString());\n    } catch (error) {\n      console.warn('Could not save scroll position to session storage', error);\n    }\n  }, [CONFIG.preserveScrollPosition, CONFIG.scrollPositionKey]);\n  \n  // Initialize stars with time-based or session-persistent configuration\n  const initializeStars = useCallback(() => {\n    const { width, height } = dimensionsRef.current;\n    if (!width || !height) return;\n    \n    // First check if we already have stars that should be preserved\n    if (starsRef.current.length > 0 && isInitializedRef.current) {\n      // Only reinitialize if screen dimensions have significantly changed\n      const existingWidth = starsRef.current[0].x / starsRef.current[0].xSeed;\n      const existingHeight = starsRef.current[0].baseY / (starsRef.current[0].ySeed + CONFIG.offscreenBufferFactor);\n      \n      const widthChange = Math.abs(existingWidth - width) / width;\n      const heightChange = Math.abs(existingHeight - height) / height;\n      \n      // If using time-based generation and the time seed hasn't changed,\n      // and dimensions haven't changed much, preserve existing stars\n      if (widthChange < 0.2 && heightChange < 0.2) {\n        // When using time-based generation, check if the seed has changed\n        if (CONFIG.useTimeBased) {\n          const currentTimeSeed = getTimeSeed();\n          const previousTimeSeed = starsRef.current.timeSeed;\n          \n          // If time seed has changed, we need to regenerate\n          if (previousTimeSeed && previousTimeSeed !== currentTimeSeed) {\n            // Continue with regeneration below\n          } else {\n            // Just update target positions based on new dimensions\n            for (let i = 0; i < starsRef.current.length; i++) {\n              const star = starsRef.current[i];\n              // Scale position to new dimensions\n              star.x = (star.x / existingWidth) * width;\n              star.baseY = (star.baseY / existingHeight) * height;\n              star.y = star.baseY;\n              star.targetY = star.y;\n            }\n            return; // Keep existing stars\n          }\n        } else {\n          // Non-time-based mode, just update positions\n          for (let i = 0; i < starsRef.current.length; i++) {\n            const star = starsRef.current[i];\n            // Scale position to new dimensions\n            star.x = (star.x / existingWidth) * width;\n            star.baseY = (star.baseY / existingHeight) * height;\n            star.y = star.baseY;\n            star.targetY = star.y;\n          }\n          return; // Keep existing stars\n        }\n      }\n    }\n    \n    // Get or create time-based or session-persistent configuration\n    const { starSeeds, timeSeed } = getStarConfiguration();\n    \n    // Clear existing stars\n    starsRef.current = [];\n    \n    // Store time seed for future comparison\n    starsRef.current.timeSeed = timeSeed;\n    \n    // Create stars using the seeds\n    for (let i = 0; i < starSeeds.length; i++) {\n      const seed = starSeeds[i];\n      const star = {};\n      \n      // Store original seeds for future reference\n      star.xSeed = seed.xSeed;\n      star.ySeed = seed.ySeed;\n      \n      // Position - use seeds but adapt to current screen dimensions\n      star.x = seed.xSeed * width;\n      // Initial y position - distributed vertically across multiple screen heights\n      star.baseY = (seed.ySeed + CONFIG.offscreenBufferFactor) * height;\n      star.y = star.baseY;\n      star.z = seed.zSeed; // Depth (0.1 to 0.9)\n      \n      // Visual properties\n      star.size = (seed.sizeSeed * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n      star.baseOpacity = seed.opacitySeed * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n      star.opacity = star.baseOpacity; // Start fully visible\n      \n      // Animation properties\n      star.pulsePhase = seed.phaseSeed;\n      star.pulseSpeed = seed.pulseSpeedSeed;\n      star.movementSpeed = seed.speedSeed * CONFIG.baseMovementSpeed * (1.1 - star.z);\n      \n      // Initialize velocity and position tracking for trails\n      star.velocity = 0;\n      star.lastX = star.x;\n      star.lastY = star.y;\n      \n      // Initialize twinkling properties\n      star.twinkleState = 'visible'; // 'fading-in', 'visible', 'fading-out', 'hidden'\n      star.twinkleProgress = 0;\n      star.twinkleDuration = Math.random() * \n        (CONFIG.twinkleDuration[1] - CONFIG.twinkleDuration[0]) + \n        CONFIG.twinkleDuration[0];\n      \n      // Drift movement properties\n      star.driftDirectionX = seed.driftDirectionXSeed;\n      star.driftDirectionY = seed.driftDirectionYSeed;\n      // Normalize the direction vector\n      const dirMagnitude = Math.sqrt(star.driftDirectionX ** 2 + star.driftDirectionY ** 2) || 1;\n      star.driftDirectionX /= dirMagnitude;\n      star.driftDirectionY /= dirMagnitude;\n      // Vary the drift speed between stars\n      star.driftSpeed = CONFIG.driftSpeed + (seed.driftSpeedSeed * 2 - 1) * CONFIG.driftSpeedVariation;\n      star.directionChangeTimer = 0;\n      \n      // Star state tracking\n      star.state = 'visible'; // Start visible, not fading in\n      star.fadeProgress = 1; // Fully visible\n      \n      // Parallax properties (for scrolling effect)\n      // Make deeper stars (higher z) move less for realistic parallax\n      star.parallaxFactor = seed.parallaxFactorSeed * CONFIG.parallaxFactor * (1 - star.z * 0.5);\n      \n      // Physics properties for bouncy effect\n      star.velocity = 0;\n      star.targetY = star.y;\n      \n      // Color variation\n      star.color = COLORS.stars[seed.colorIndex];\n      \n      // Store in ref\n      starsRef.current.push(star);\n    }\n  }, [CONFIG, COLORS.stars, getStarConfiguration, getTimeSeed]);\n  \n  // Optimized star rendering with subtle trail effect\n  const drawStar = useCallback((ctx, star) => {\n    // Skip rendering completely invisible stars\n    if (star.opacity < 0.02) return;\n    \n    // Draw subtle trail if enabled and star is moving\n    if (CONFIG.trailEnabled && (Math.abs(star.velocity) > 0.001 || Math.abs(star.lastX - star.x) > 0.1)) {\n      // Calculate trail direction based on movement\n      const trailX = star.lastX !== undefined ? star.lastX : star.x - star.velocity * 5;\n      const trailY = star.lastY !== undefined ? star.lastY : star.y - star.velocity * 5;\n      \n      // Ensure the trail is very subtle\n      ctx.beginPath();\n      ctx.moveTo(star.x, star.y);\n      ctx.lineTo(trailX, trailY);\n      ctx.strokeStyle = getColor(star.color, star.opacity * CONFIG.trailOpacityFactor);\n      ctx.lineWidth = star.size * 0.6;\n      ctx.lineCap = 'round';\n      ctx.stroke();\n    }\n    \n    // Store current position for next frame's trail\n    star.lastX = star.x;\n    star.lastY = star.y;\n    \n    // Simplified star rendering without creating new gradients every frame\n    ctx.beginPath();\n    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n    ctx.fillStyle = getColor(star.color, star.opacity);\n    ctx.fill();\n    \n    // Simplified glow effect without expensive gradient creation\n    if (star.opacity > 0.3) {\n      ctx.beginPath();\n      ctx.arc(star.x, star.y, star.size * 1.8, 0, Math.PI * 2);\n      ctx.fillStyle = getColor(star.color, star.opacity * 0.4);\n      ctx.fill();\n    }\n  }, [CONFIG.trailEnabled, CONFIG.trailOpacityFactor, getColor]);\n  \n  // Check if a star is off-screen\n  const isStarOffScreen = useCallback((star) => {\n    const { width, height } = dimensionsRef.current;\n    const buffer = CONFIG.offscreenBuffer;\n    \n    return (\n      star.x < -buffer ||\n      star.x > width + buffer ||\n      star.y < -buffer ||\n      star.y > height + buffer\n    );\n  }, [CONFIG.offscreenBuffer]);\n  \n  // Render the scene - optimized for performance\n  const renderScene = useCallback(() => {\n    if (!canvasRef.current) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d', { alpha: false });\n    \n    if (!ctx) return;\n    \n    const { width, height, pixelRatio } = dimensionsRef.current;\n    \n    // Clear canvas\n    ctx.fillStyle = COLORS.background.topColor;\n    ctx.fillRect(0, 0, width * pixelRatio, height * pixelRatio);\n    \n    // Apply device pixel ratio scaling only once\n    ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    \n    // Enable global composition for better glow effect\n    ctx.globalCompositeOperation = 'lighter';\n    \n    // Draw stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n      drawStar(ctx, star);\n    }\n    \n    // Reset global composition\n    ctx.globalCompositeOperation = 'source-over';\n  }, [COLORS.background.topColor, drawStar]);\n  \n  // Update animation state - optimized for performance\n  const updateAnimation = useCallback((deltaTime, timestamp) => {\n    const currentScrollY = springScrollYRef.current;\n    lastScrollYRef.current = currentScrollY;\n    \n    // Use time-appropriate timestamp for animations in time-based mode\n    let timeFactor;\n    \n    if (CONFIG.useTimeBased) {\n      // Get current time of day (0-1 range representing entire day)\n      const now = new Date();\n      const secondsInDay = now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds();\n      const fractionOfDay = secondsInDay / 86400; // 86400 seconds in a day\n      \n      // Use this for animations that should be consistent throughout the day\n      timeFactor = fractionOfDay * 100; // Scale for better animation control\n    } else {\n      // Use standard animation timestamp\n      timeFactor = timestamp * 0.001;\n    }\n    \n    const currentTime = Date.now();\n    \n    // Track stars to replace (avoid modifying array during iteration)\n    const starsToReplace = [];\n    \n    // Count currently fading stars to manage random fading\n    let fadingCount = 0;\n    if (CONFIG.randomFadingEnabled) {\n      fadingCount = starsRef.current.filter(star => star.state === 'fading-out' || star.state === 'fading-in').length;\n    }\n    \n    // Update stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n      \n      // Handle star state transitions\n      if (star.state === 'fading-in') {\n        // Calculate progress for fade-in\n        const elapsed = currentTime - star.fadeStart;\n        star.fadeProgress = Math.min(1, elapsed / CONFIG.fadeInDuration);\n        star.opacity = star.baseOpacity * star.fadeProgress;\n        \n        // Complete fade-in\n        if (star.fadeProgress >= 1) {\n          star.state = 'visible';\n          star.opacity = star.baseOpacity;\n        }\n      } else if (star.state === 'fading-out') {\n        // Calculate progress for fade-out\n        const elapsed = currentTime - star.fadeStart;\n        star.fadeProgress = Math.max(0, 1 - (elapsed / CONFIG.fadeOutDuration));\n        star.opacity = star.baseOpacity * star.fadeProgress;\n        \n        // Complete fade-out - mark for replacement\n        if (star.fadeProgress <= 0) {\n          starsToReplace.push(i);\n        }\n      } else {\n        // Normal visible state\n        \n        // Random fading (new feature)\n        if (CONFIG.randomFadingEnabled && \n            fadingCount < CONFIG.maxSimultaneousFading && \n            Math.random() < CONFIG.randomFadeOutProbability * deltaTime) {\n          // Start fade-out process for random star\n          star.state = 'fading-out';\n          star.fadeStart = currentTime;\n          fadingCount++;\n          continue; // Skip the rest of the loop for this star\n        }\n        \n        // Calculate parallax effect based on scroll position\n        if (CONFIG.parallaxEnabled) {\n          // Update target position based on scroll (parallax effect)\n          star.targetY = star.baseY - (currentScrollY * star.parallaxFactor);\n        }\n        \n        // Apply spring physics for bouncy effect\n        const displacement = star.targetY - star.y;\n        const springForce = displacement * CONFIG.springStrength;\n        \n        // Update velocity with spring force\n        star.velocity += springForce;\n        \n        // Apply damping to velocity\n        star.velocity *= CONFIG.dampingFactor;\n        \n        // Add velocity clamping to prevent extreme bouncing\n        const maxVelocity = 1.0; // Maximum allowed velocity\n        star.velocity = Math.max(-maxVelocity, Math.min(maxVelocity, star.velocity));\n        \n        // Update position based on velocity (for parallax)\n        star.y += star.velocity;\n        \n        // Apply drift movement if enabled\n        if (CONFIG.driftEnabled) {\n          // Apply movement with additional smoothing to prevent jumps\n          // Calculate the intended movement\n          const dx = star.driftDirectionX * star.driftSpeed * deltaTime;\n          const dy = star.driftDirectionY * star.driftSpeed * deltaTime;\n          \n          // Apply a maximum movement limit to prevent jumps\n          const maxMove = 0.5; // Maximum pixels to move per frame\n          const actualDx = Math.abs(dx) > maxMove ? Math.sign(dx) * maxMove : dx;\n          const actualDy = Math.abs(dy) > maxMove ? Math.sign(dy) * maxMove : dy;\n          \n          // Move star based on limited movement\n          star.x += actualDx;\n          // Add the drift to baseY (which is the reference point for parallax)\n          star.baseY += actualDy;\n          star.targetY = star.baseY - (currentScrollY * star.parallaxFactor);\n          \n          // Occasionally change drift direction with smoother transitions\n          star.directionChangeTimer += deltaTime;\n          if (Math.random() < CONFIG.directionChangeFrequency * deltaTime) {\n            // Gradually change direction by adding a small random vector\n            // Use the directionChangeAmount to limit the magnitude of the change\n            const changeX = (Math.random() * 2 - 1) * CONFIG.directionChangeAmount;\n            const changeY = (Math.random() * 2 - 1) * CONFIG.directionChangeAmount;\n            \n            // Apply a small percentage of the change for smoother transitions\n            star.driftDirectionX += changeX;\n            star.driftDirectionY += changeY;\n            \n            // Re-normalize the direction vector with safety checks\n            const dirMagnitude = Math.sqrt(star.driftDirectionX ** 2 + star.driftDirectionY ** 2) || 1;\n            \n            // Prevent jittery movement by ensuring minimum magnitude\n            if (dirMagnitude < 0.01) {\n              // If direction vector is too small, reset to a random direction\n              star.driftDirectionX = Math.random() * 2 - 1;\n              star.driftDirectionY = Math.random() * 2 - 1;\n              const newMagnitude = Math.sqrt(star.driftDirectionX ** 2 + star.driftDirectionY ** 2) || 1;\n              star.driftDirectionX /= newMagnitude;\n              star.driftDirectionY /= newMagnitude;\n            } else {\n              star.driftDirectionX /= dirMagnitude;\n              star.driftDirectionY /= dirMagnitude;\n            }\n          }\n        }\n        \n        // Check if star is now off-screen\n        if (CONFIG.regenerateOffscreenStars && isStarOffScreen(star) && star.state === 'visible') {\n          // Start fade-out process\n          star.state = 'fading-out';\n          star.fadeStart = currentTime;\n        }\n        \n        // Apply time-based pulsing effect\n        const pulseFactor = Math.sin(timeFactor * star.pulseSpeed + star.pulsePhase) * 0.15 + 0.85;\n        // Only apply pulsing if not in a transition state\n        if (star.state === 'visible') {\n          star.opacity = star.baseOpacity * pulseFactor;\n        }\n      }\n    }\n    \n    // Replace stars that have completed fade-out (in reverse order to avoid index issues)\n    for (let i = starsToReplace.length - 1; i >= 0; i--) {\n      const index = starsToReplace[i];\n      // Create a new star to replace the off-screen one\n      const newStar = createNewStar(starsRef.current[index]);\n      // Replace the star in the array\n      starsRef.current[index] = newStar;\n    }\n    \n    // For time-based mode, we don't need to frequently save configuration\n    // Just save scroll position when it changes significantly\n    if (CONFIG.preserveScrollPosition && \n        Math.abs(currentScrollY - parseFloat(sessionStorage.getItem(CONFIG.scrollPositionKey) || '0')) > 50) {\n      saveScrollPosition();\n    }\n    \n    // Only save full configuration periodically if NOT using time-based mode\n    if (!CONFIG.useTimeBased && timestamp % 3000 < 16) { // Every ~3 seconds (assuming 60fps)\n      try {\n        // Convert current star configuration to seeds for storage\n        const starSeeds = starsRef.current.map(star => ({\n          xSeed: star.x / dimensionsRef.current.width,\n          ySeed: (star.baseY / dimensionsRef.current.height) - CONFIG.offscreenBufferFactor,\n          zSeed: star.z,\n          sizeSeed: (star.size / star.z - CONFIG.starSizeMin) / (CONFIG.starSizeMax - CONFIG.starSizeMin),\n          opacitySeed: (star.baseOpacity - CONFIG.starOpacityMin) / (CONFIG.starOpacityMax - CONFIG.starOpacityMin),\n          phaseSeed: star.pulsePhase / (Math.PI * 2),\n          speedSeed: star.movementSpeed / (CONFIG.baseMovementSpeed * (1.1 - star.z)),\n          pulseSpeedSeed: (star.pulseSpeed - 0.001) / 0.002,\n          colorIndex: COLORS.stars.indexOf(star.color),\n          parallaxFactorSeed: star.parallaxFactor / (CONFIG.parallaxFactor * (1 - star.z * 0.5)),\n          driftDirectionXSeed: star.driftDirectionX,\n          driftDirectionYSeed: star.driftDirectionY,\n          driftSpeedSeed: (star.driftSpeed - CONFIG.driftSpeed + CONFIG.driftSpeedVariation) / (2 * CONFIG.driftSpeedVariation)\n        }));\n        \n        sessionStorage.setItem(CONFIG.sessionKey, JSON.stringify({\n          starSeeds,\n          timestamp: Date.now()\n        }));\n      } catch (error) {\n        console.warn('Could not save star configuration to session storage', error);\n      }\n    }\n  }, [CONFIG, isStarOffScreen, createNewStar, COLORS.stars, saveScrollPosition]);\n  \n  // Define the animation loop function, using time-based approach as appropriate\n  const animate = useCallback(function animationLoop(timestamp) {\n    if (!isInitializedRef.current) {\n      animationFrameRef.current = requestAnimationFrame(animationLoop);\n      return;\n    }\n    \n    // Limit FPS\n    const minFrameTime = 1000 / CONFIG.maxFPS;\n    const elapsed = timestamp - (lastTimeRef.current || 0);\n    \n    if (elapsed < minFrameTime) {\n      animationFrameRef.current = requestAnimationFrame(animationLoop);\n      return;\n    }\n    \n    // Calculate delta time with cap to prevent large jumps\n    const deltaTime = lastTimeRef.current ? Math.min(elapsed, 50) : 16;\n    lastTimeRef.current = timestamp;\n    \n    // For time-based mode, we can optionally use a time-derived timestamp\n    // This ensures animations are consistent based on time of day\n    if (CONFIG.useTimeBased) {\n      // Get current minute of the day (0-1440)\n      const now = new Date();\n      const minuteOfDay = now.getHours() * 60 + now.getMinutes();\n      \n      // Create a timestamp that increments more slowly\n      // This makes animations more consistent across page loads\n      const timeBasedTimestamp = minuteOfDay * 1000;\n      \n      // Use this time-based timestamp for animations\n      updateAnimation(deltaTime, timeBasedTimestamp);\n    } else {\n      // Standard animation using browser timestamp\n      updateAnimation(deltaTime, timestamp);\n    }\n    \n    // Render scene\n    renderScene();\n    \n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(animationLoop);\n  }, [CONFIG.maxFPS, CONFIG.useTimeBased, updateAnimation, renderScene]);\n  \n  // Comprehensive initialization and resize handling\n  useEffect(() => {\n    // One-time initialization function\n    const initialize = () => {\n      if (setupCanvas()) {\n        // Create stars only after canvas is ready\n        initializeStars();\n        // Mark as initialized but don't trigger re-render\n        isInitializedRef.current = true;\n        // Start animation only after everything is ready\n        animationFrameRef.current = requestAnimationFrame(animate);\n      }\n    };\n    \n    // Handle resize events\n    const handleResize = () => {\n      // Only re-initialize if already initialized\n      if (isInitializedRef.current) {\n        setupCanvas();\n        initializeStars();\n      }\n    };\n    \n    // Save scroll position on page visibility change (page navigation)\n    const handleVisibilityChange = () => {\n      if (document.visibilityState === 'hidden' && CONFIG.preserveScrollPosition) {\n        saveScrollPosition();\n      }\n    };\n    \n    // Save scroll position before unload (page refresh/close)\n    const handleBeforeUnload = () => {\n      if (CONFIG.preserveScrollPosition) {\n        saveScrollPosition();\n      }\n    };\n    \n    // Add event listeners\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    window.addEventListener('beforeunload', handleBeforeUnload);\n    \n    // Throttle resize events\n    let resizeTimer;\n    const throttledResize = () => {\n      if (!resizeTimer) {\n        resizeTimer = setTimeout(() => {\n          resizeTimer = null;\n          handleResize();\n        }, 200); // 200ms throttle\n      }\n    };\n    \n    // Add resize listener\n    window.addEventListener('resize', throttledResize);\n    \n    // Run initialization after first render is complete\n    // This prevents the \"double load\" effect\n    requestAnimationFrame(() => {\n      firstRenderCompleteRef.current = true;\n      initialize();\n    });\n    \n    // Cleanup\n    return () => {\n      window.removeEventListener('resize', throttledResize);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n      if (resizeTimer) clearTimeout(resizeTimer);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      // Save scroll position on unmount\n      if (CONFIG.preserveScrollPosition) {\n        saveScrollPosition();\n      }\n    };\n  }, [CONFIG.preserveScrollPosition, setupCanvas, initializeStars, animate, saveScrollPosition]);\n  \n  return (\n    <div\n      ref={containerRef}\n      style={{\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        width: '100vw',\n        height: '100vh',\n        overflow: 'hidden',\n        zIndex: -1,\n        pointerEvents: 'none'\n      }}\n      aria-hidden=\"true\"\n    >\n      <canvas\n        ref={canvasRef}\n        style={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%'\n        }}\n      />\n    </div>\n  );\n};\n\nexport default Background;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}