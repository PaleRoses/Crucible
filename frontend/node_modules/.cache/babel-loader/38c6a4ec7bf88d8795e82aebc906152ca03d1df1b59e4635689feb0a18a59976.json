{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/effects/scrollingeffects/SlidingBackground.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\n\n/**\n * SlidingBackground Component\n * \n * A smooth, high-quality background component with painterly fade effects and \n * fluid parallax scrolling that properly handles high-resolution images.\n * \n * @param {Object} props - Component props\n * @param {string} props.image - URL of the background image\n * @param {string} [props.position='top'] - Position of the focused area ('top', 'middle', 'bottom')\n * @param {string|number} [props.height='33vh'] - Height of the component\n * @param {number} [props.parallaxFactor=0.4] - How much the image moves relative to scroll (lower = smoother)\n * @param {string} [props.backgroundColor='#000'] - Background color\n * @param {number} [props.zIndex=0] - z-index of the component\n * @param {number} [props.fadeSize=0.4] - Size of the fade effect (0-1)\n * @param {number} [props.opacity=1] - Overall opacity of the component\n * @param {React.ReactNode} [props.children] - Content to render on top of the background\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SlidingBackground = ({\n  image,\n  position = 'top',\n  height = '33vh',\n  parallaxFactor = 0.4,\n  backgroundColor = '#000',\n  zIndex = 0,\n  fadeSize = 0.4,\n  opacity = 1,\n  children\n}) => {\n  _s();\n  // Refs\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const imageRef = useRef(null);\n  const rafRef = useRef(null);\n  const targetScrollY = useRef(0);\n  const currentScrollY = useRef(0);\n\n  // State\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0\n  });\n  const [isImageLoaded, setIsImageLoaded] = useState(false);\n  const [imageAspect, setImageAspect] = useState(0);\n\n  // Helper function to convert color to rgba with opacity\n  const withOpacity = useCallback((color, opacity) => {\n    // Handle hex colors\n    if (color.startsWith('#')) {\n      // Convert hex to rgb\n      let r = 0,\n        g = 0,\n        b = 0;\n\n      // Handle #RGB format\n      if (color.length === 4) {\n        r = parseInt(color[1] + color[1], 16);\n        g = parseInt(color[2] + color[2], 16);\n        b = parseInt(color[3] + color[3], 16);\n      }\n      // Handle #RRGGBB format\n      else if (color.length === 7) {\n        r = parseInt(color.substring(1, 3), 16);\n        g = parseInt(color.substring(3, 5), 16);\n        b = parseInt(color.substring(5, 7), 16);\n      }\n      return `rgba(${r}, ${g}, ${b}, ${opacity})`;\n    }\n\n    // Handle rgb/rgba colors\n    if (color.startsWith('rgb')) {\n      // If already rgba, replace the opacity\n      if (color.startsWith('rgba')) {\n        return color.replace(/rgba\\((.+?),\\s*[\\d.]+\\)/, `rgba($1, ${opacity})`);\n      }\n      // Convert rgb to rgba\n      return color.replace(/rgb\\((.+?)\\)/, `rgba($1, ${opacity})`);\n    }\n\n    // Handle named colors by using a semi-transparent black as fallback\n    return `rgba(0, 0, 0, ${opacity})`;\n  }, []);\n\n  // Painterly noise texture function (creates organic texture)\n  const addPainterlyNoise = useCallback((x, y, intensity = 0.15) => {\n    // Use Perlin-like noise approximation for a more organic feel\n    const noise = Math.sin(x * 0.01) * Math.sin(y * 0.01) * Math.sin(x * 0.02 + y * 0.03) * Math.sin(y * 0.02 + x * 0.01);\n    return noise * intensity;\n  }, []);\n\n  // Calculate dimensions for the image and canvas\n  const calculateDimensions = useCallback(() => {\n    if (!containerRef.current) return;\n    const rect = containerRef.current.getBoundingClientRect();\n    setDimensions({\n      width: rect.width,\n      height: rect.height\n    });\n  }, []);\n\n  // Render the canvas with painterly effects\n  const renderCanvas = useCallback(() => {\n    if (!canvasRef.current || !imageRef.current || !dimensions.width || !dimensions.height) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const devicePixelRatio = window.devicePixelRatio || 1;\n\n    // Calculate the rendering context size (accounting for DPR)\n    const renderWidth = dimensions.width;\n    const renderHeight = dimensions.height;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, renderWidth, renderHeight);\n\n    // Calculate parallax offset based on current interpolated scroll position\n    const parallaxOffset = currentScrollY.current * parallaxFactor;\n\n    // Calculate image dimensions to maintain aspect ratio\n    const canvasAspect = renderWidth / renderHeight;\n    let drawWidth, drawHeight, offsetX, offsetY;\n\n    // Ensure image covers the entire canvas with some overflow for parallax\n    if (imageAspect > canvasAspect) {\n      // Image is wider than canvas (relative to height)\n      drawHeight = renderHeight * 1.1; // Add 10% to allow for parallax movement\n      drawWidth = drawHeight * imageAspect;\n      offsetX = (renderWidth - drawWidth) / 2;\n      offsetY = 0;\n    } else {\n      // Image is taller than canvas (relative to width)\n      drawWidth = renderWidth * 1.1; // Add 10% to allow for parallax movement\n      drawHeight = drawWidth / imageAspect;\n      offsetX = 0;\n      offsetY = (renderHeight - drawHeight) / 2;\n    }\n\n    // Adjust based on position setting\n    if (position === 'top') {\n      offsetY = 0;\n    } else if (position === 'bottom') {\n      offsetY = renderHeight - drawHeight;\n    } else if (position === 'middle') {\n      offsetY = (renderHeight - drawHeight) / 2;\n    }\n\n    // Apply parallax offset\n    offsetY += parallaxOffset;\n\n    // Global opacity\n    ctx.globalAlpha = opacity;\n\n    // Draw the image\n    ctx.drawImage(imageRef.current, offsetX, offsetY, drawWidth, drawHeight);\n\n    // Painterly fade effects\n    const fadeTopHeight = Math.floor(renderHeight * fadeSize);\n    const fadeBottomHeight = Math.floor(renderHeight * fadeSize);\n    const shouldFadeTop = position === 'bottom' || position === 'middle';\n    const shouldFadeBottom = position === 'top' || position === 'middle';\n\n    // Top fade with painterly effect\n    if (shouldFadeTop) {\n      // Create a canvas pattern for painterly texture\n      const patternCanvas = document.createElement('canvas');\n      const patternSize = 256;\n      patternCanvas.width = patternSize;\n      patternCanvas.height = patternSize;\n      const patternCtx = patternCanvas.getContext('2d');\n\n      // Create textured gradient\n      const patternGradient = patternCtx.createLinearGradient(0, 0, 0, patternSize);\n      patternGradient.addColorStop(0, backgroundColor);\n      patternGradient.addColorStop(0.65, withOpacity(backgroundColor, 0.7));\n      patternGradient.addColorStop(0.85, withOpacity(backgroundColor, 0.3));\n      patternGradient.addColorStop(1, withOpacity(backgroundColor, 0));\n\n      // Add texture\n      patternCtx.fillStyle = patternGradient;\n      patternCtx.fillRect(0, 0, patternSize, patternSize);\n\n      // Add noise to the pattern\n      const patternData = patternCtx.getImageData(0, 0, patternSize, patternSize);\n      const pixels = patternData.data;\n      for (let y = 0; y < patternSize; y++) {\n        for (let x = 0; x < patternSize; x++) {\n          // Increase noise toward the bottom (where transparency begins)\n          const noiseIntensity = 0.1 + y / patternSize * 0.2;\n          const noise = addPainterlyNoise(x, y, noiseIntensity);\n          const idx = (y * patternSize + x) * 4;\n          const alpha = pixels[idx + 3];\n\n          // Only modify partially transparent pixels for better edge effect\n          if (alpha > 0 && alpha < 255) {\n            pixels[idx + 3] = Math.max(0, Math.min(255, alpha + noise * 40));\n          }\n        }\n      }\n      patternCtx.putImageData(patternData, 0, 0);\n\n      // Create brush stroke effect at the bottom edge\n      patternCtx.globalCompositeOperation = 'destination-out';\n\n      // Draw some random \"brush strokes\" at the bottom\n      const strokeCount = 8;\n      for (let i = 0; i < strokeCount; i++) {\n        const x = patternSize / strokeCount * i + Math.random() * 20 - 10;\n        const y = patternSize * 0.8 + Math.random() * 20;\n        const width = patternSize / strokeCount * 1.2;\n        const height = Math.random() * 30 + 20;\n        patternCtx.beginPath();\n        patternCtx.ellipse(x, y, width / 2, height / 2, 0, 0, Math.PI * 2);\n        patternCtx.fill();\n      }\n\n      // Apply the pattern to the main canvas\n      const pattern = ctx.createPattern(patternCanvas, 'repeat-x');\n      ctx.save();\n\n      // Scale the pattern to fit the fade area\n      const scaleY = fadeTopHeight / patternSize;\n      ctx.translate(0, 0);\n      ctx.scale(1, scaleY);\n      ctx.fillStyle = pattern;\n      ctx.fillRect(0, 0, renderWidth, fadeTopHeight / scaleY);\n      ctx.restore();\n    }\n\n    // Bottom fade with painterly effect\n    if (shouldFadeBottom) {\n      const startY = renderHeight - fadeBottomHeight;\n\n      // Create a canvas pattern for painterly texture\n      const patternCanvas = document.createElement('canvas');\n      const patternSize = 256;\n      patternCanvas.width = patternSize;\n      patternCanvas.height = patternSize;\n      const patternCtx = patternCanvas.getContext('2d');\n\n      // Create textured gradient\n      const patternGradient = patternCtx.createLinearGradient(0, 0, 0, patternSize);\n      patternGradient.addColorStop(0, withOpacity(backgroundColor, 0));\n      patternGradient.addColorStop(0.15, withOpacity(backgroundColor, 0.3));\n      patternGradient.addColorStop(0.35, withOpacity(backgroundColor, 0.7));\n      patternGradient.addColorStop(1, backgroundColor);\n\n      // Add texture\n      patternCtx.fillStyle = patternGradient;\n      patternCtx.fillRect(0, 0, patternSize, patternSize);\n\n      // Add noise to the pattern\n      const patternData = patternCtx.getImageData(0, 0, patternSize, patternSize);\n      const pixels = patternData.data;\n      for (let y = 0; y < patternSize; y++) {\n        for (let x = 0; x < patternSize; x++) {\n          // Increase noise at the top (where transparency begins)\n          const noiseIntensity = 0.2 - y / patternSize * 0.15;\n          const noise = addPainterlyNoise(x, y, noiseIntensity);\n          const idx = (y * patternSize + x) * 4;\n          const alpha = pixels[idx + 3];\n\n          // Only modify partially transparent pixels for better edge effect\n          if (alpha > 0 && alpha < 255) {\n            pixels[idx + 3] = Math.max(0, Math.min(255, alpha + noise * 40));\n          }\n        }\n      }\n      patternCtx.putImageData(patternData, 0, 0);\n\n      // Create brush stroke effect at the top edge\n      patternCtx.globalCompositeOperation = 'destination-out';\n\n      // Draw some random \"brush strokes\" at the top\n      const strokeCount = 8;\n      for (let i = 0; i < strokeCount; i++) {\n        const x = patternSize / strokeCount * i + Math.random() * 20 - 10;\n        const y = patternSize * 0.2 - Math.random() * 10;\n        const width = patternSize / strokeCount * 1.2;\n        const height = Math.random() * 25 + 15;\n        patternCtx.beginPath();\n        patternCtx.ellipse(x, y, width / 2, height / 2, 0, 0, Math.PI * 2);\n        patternCtx.fill();\n      }\n\n      // Apply the pattern to the main canvas\n      const pattern = ctx.createPattern(patternCanvas, 'repeat-x');\n      ctx.save();\n\n      // Scale the pattern to fit the fade area\n      const scaleY = fadeBottomHeight / patternSize;\n      ctx.translate(0, startY);\n      ctx.scale(1, scaleY);\n      ctx.fillStyle = pattern;\n      ctx.fillRect(0, 0, renderWidth, patternSize);\n      ctx.restore();\n    }\n  }, [dimensions, parallaxFactor, position, backgroundColor, opacity, fadeSize, imageAspect, withOpacity, addPainterlyNoise]);\n\n  // Smooth scroll animation using easing\n  const animateScroll = useCallback(() => {\n    // LERP (Linear Interpolation) for smooth transitions\n    const ease = 0.08; // Lower = smoother but slower\n\n    // Calculate new position with easing\n    const delta = targetScrollY.current - currentScrollY.current;\n    currentScrollY.current += delta * ease;\n\n    // Only render if changed enough to be visible\n    if (Math.abs(delta) > 0.1) {\n      renderCanvas();\n      rafRef.current = requestAnimationFrame(animateScroll);\n    } else {\n      // Snap to target when very close to avoid tiny movements\n      currentScrollY.current = targetScrollY.current;\n      renderCanvas();\n    }\n  }, [renderCanvas]);\n\n  // Load high-quality image with proper handling\n  useEffect(() => {\n    const img = new Image();\n    img.crossOrigin = \"Anonymous\";\n    img.onload = () => {\n      imageRef.current = img;\n      setImageAspect(img.width / img.height);\n      setIsImageLoaded(true);\n    };\n    img.onerror = err => {\n      console.error(\"Failed to load image:\", err);\n    };\n    img.src = image;\n    return () => {\n      img.onload = null;\n      img.onerror = null;\n    };\n  }, [image]);\n\n  // Set up canvas dimensions and handle resize\n  useEffect(() => {\n    calculateDimensions();\n    const handleResize = () => {\n      calculateDimensions();\n\n      // Immediately render after resize to prevent flickering\n      if (isImageLoaded) {\n        renderCanvas();\n      }\n    };\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, [calculateDimensions, isImageLoaded, renderCanvas]);\n\n  // Update canvas based on current dimensions\n  useEffect(() => {\n    if (canvasRef.current && dimensions.width && dimensions.height) {\n      const canvas = canvasRef.current;\n      const dpr = window.devicePixelRatio || 1;\n\n      // Set display size\n      canvas.style.width = `${dimensions.width}px`;\n      canvas.style.height = `${dimensions.height}px`;\n\n      // Set actual size with high DPR for retina displays\n      canvas.width = dimensions.width * dpr;\n      canvas.height = dimensions.height * dpr;\n\n      // Scale all drawing operations for high DPR\n      const ctx = canvas.getContext('2d');\n      ctx.scale(dpr, dpr);\n    }\n  }, [dimensions]);\n\n  // Scroll event handler using requestAnimationFrame for performance\n  useEffect(() => {\n    const handleScroll = () => {\n      targetScrollY.current = window.scrollY;\n\n      // Only start animation if we're not already animating\n      if (!rafRef.current) {\n        rafRef.current = requestAnimationFrame(animateScroll);\n      }\n    };\n    window.addEventListener('scroll', handleScroll, {\n      passive: true\n    });\n\n    // Initialize animation\n    targetScrollY.current = window.scrollY;\n    currentScrollY.current = window.scrollY;\n\n    // Initial render\n    if (isImageLoaded) {\n      renderCanvas();\n    }\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n      if (rafRef.current) {\n        cancelAnimationFrame(rafRef.current);\n        rafRef.current = null;\n      }\n    };\n  }, [animateScroll, renderCanvas, isImageLoaded]);\n\n  // Re-render when image loads\n  useEffect(() => {\n    if (isImageLoaded) {\n      renderCanvas();\n    }\n  }, [isImageLoaded, renderCanvas]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'relative',\n      width: '100%',\n      height,\n      overflow: 'hidden',\n      zIndex,\n      backgroundColor\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        display: isImageLoaded ? 'block' : 'none'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 438,\n      columnNumber: 7\n    }, this), !isImageLoaded && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        backgroundColor\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 452,\n      columnNumber: 9\n    }, this), children && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: 'relative',\n        zIndex: 1,\n        width: '100%',\n        height: '100%'\n      },\n      children: children\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 466,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 427,\n    columnNumber: 5\n  }, this);\n};\n_s(SlidingBackground, \"A+OsoUihjZRx19z3sdac7Ym0XXM=\");\n_c = SlidingBackground;\nexport default SlidingBackground;\nvar _c;\n$RefreshReg$(_c, \"SlidingBackground\");","map":{"version":3,"names":["React","useRef","useEffect","useState","useCallback","jsxDEV","_jsxDEV","SlidingBackground","image","position","height","parallaxFactor","backgroundColor","zIndex","fadeSize","opacity","children","_s","containerRef","canvasRef","imageRef","rafRef","targetScrollY","currentScrollY","dimensions","setDimensions","width","isImageLoaded","setIsImageLoaded","imageAspect","setImageAspect","withOpacity","color","startsWith","r","g","b","length","parseInt","substring","replace","addPainterlyNoise","x","y","intensity","noise","Math","sin","calculateDimensions","current","rect","getBoundingClientRect","renderCanvas","canvas","ctx","getContext","devicePixelRatio","window","renderWidth","renderHeight","clearRect","parallaxOffset","canvasAspect","drawWidth","drawHeight","offsetX","offsetY","globalAlpha","drawImage","fadeTopHeight","floor","fadeBottomHeight","shouldFadeTop","shouldFadeBottom","patternCanvas","document","createElement","patternSize","patternCtx","patternGradient","createLinearGradient","addColorStop","fillStyle","fillRect","patternData","getImageData","pixels","data","noiseIntensity","idx","alpha","max","min","putImageData","globalCompositeOperation","strokeCount","i","random","beginPath","ellipse","PI","fill","pattern","createPattern","save","scaleY","translate","scale","restore","startY","animateScroll","ease","delta","abs","requestAnimationFrame","img","Image","crossOrigin","onload","onerror","err","console","error","src","handleResize","addEventListener","removeEventListener","dpr","style","handleScroll","scrollY","passive","cancelAnimationFrame","ref","overflow","top","left","display","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/effects/scrollingeffects/SlidingBackground.jsx"],"sourcesContent":["import React, { useRef, useEffect, useState, useCallback } from 'react';\n\n/**\n * SlidingBackground Component\n * \n * A smooth, high-quality background component with painterly fade effects and \n * fluid parallax scrolling that properly handles high-resolution images.\n * \n * @param {Object} props - Component props\n * @param {string} props.image - URL of the background image\n * @param {string} [props.position='top'] - Position of the focused area ('top', 'middle', 'bottom')\n * @param {string|number} [props.height='33vh'] - Height of the component\n * @param {number} [props.parallaxFactor=0.4] - How much the image moves relative to scroll (lower = smoother)\n * @param {string} [props.backgroundColor='#000'] - Background color\n * @param {number} [props.zIndex=0] - z-index of the component\n * @param {number} [props.fadeSize=0.4] - Size of the fade effect (0-1)\n * @param {number} [props.opacity=1] - Overall opacity of the component\n * @param {React.ReactNode} [props.children] - Content to render on top of the background\n */\nconst SlidingBackground = ({\n  image,\n  position = 'top',\n  height = '33vh',\n  parallaxFactor = 0.4,\n  backgroundColor = '#000',\n  zIndex = 0,\n  fadeSize = 0.4,\n  opacity = 1,\n  children\n}) => {\n  // Refs\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const imageRef = useRef(null);\n  const rafRef = useRef(null);\n  const targetScrollY = useRef(0);\n  const currentScrollY = useRef(0);\n  \n  // State\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n  const [isImageLoaded, setIsImageLoaded] = useState(false);\n  const [imageAspect, setImageAspect] = useState(0);\n  \n  // Helper function to convert color to rgba with opacity\n  const withOpacity = useCallback((color, opacity) => {\n    // Handle hex colors\n    if (color.startsWith('#')) {\n      // Convert hex to rgb\n      let r = 0, g = 0, b = 0;\n      \n      // Handle #RGB format\n      if (color.length === 4) {\n        r = parseInt(color[1] + color[1], 16);\n        g = parseInt(color[2] + color[2], 16);\n        b = parseInt(color[3] + color[3], 16);\n      } \n      // Handle #RRGGBB format\n      else if (color.length === 7) {\n        r = parseInt(color.substring(1, 3), 16);\n        g = parseInt(color.substring(3, 5), 16);\n        b = parseInt(color.substring(5, 7), 16);\n      }\n      \n      return `rgba(${r}, ${g}, ${b}, ${opacity})`;\n    }\n    \n    // Handle rgb/rgba colors\n    if (color.startsWith('rgb')) {\n      // If already rgba, replace the opacity\n      if (color.startsWith('rgba')) {\n        return color.replace(/rgba\\((.+?),\\s*[\\d.]+\\)/, `rgba($1, ${opacity})`);\n      }\n      // Convert rgb to rgba\n      return color.replace(/rgb\\((.+?)\\)/, `rgba($1, ${opacity})`);\n    }\n    \n    // Handle named colors by using a semi-transparent black as fallback\n    return `rgba(0, 0, 0, ${opacity})`;\n  }, []);\n  \n  // Painterly noise texture function (creates organic texture)\n  const addPainterlyNoise = useCallback((x, y, intensity = 0.15) => {\n    // Use Perlin-like noise approximation for a more organic feel\n    const noise = Math.sin(x * 0.01) * Math.sin(y * 0.01) * \n                 Math.sin(x * 0.02 + y * 0.03) * Math.sin(y * 0.02 + x * 0.01);\n    return noise * intensity;\n  }, []);\n  \n  // Calculate dimensions for the image and canvas\n  const calculateDimensions = useCallback(() => {\n    if (!containerRef.current) return;\n    \n    const rect = containerRef.current.getBoundingClientRect();\n    setDimensions({\n      width: rect.width,\n      height: rect.height\n    });\n  }, []);\n  \n  // Render the canvas with painterly effects\n  const renderCanvas = useCallback(() => {\n    if (!canvasRef.current || !imageRef.current || !dimensions.width || !dimensions.height) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const devicePixelRatio = window.devicePixelRatio || 1;\n    \n    // Calculate the rendering context size (accounting for DPR)\n    const renderWidth = dimensions.width;\n    const renderHeight = dimensions.height;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, renderWidth, renderHeight);\n    \n    // Calculate parallax offset based on current interpolated scroll position\n    const parallaxOffset = currentScrollY.current * parallaxFactor;\n    \n    // Calculate image dimensions to maintain aspect ratio\n    const canvasAspect = renderWidth / renderHeight;\n    let drawWidth, drawHeight, offsetX, offsetY;\n    \n    // Ensure image covers the entire canvas with some overflow for parallax\n    if (imageAspect > canvasAspect) {\n      // Image is wider than canvas (relative to height)\n      drawHeight = renderHeight * 1.1; // Add 10% to allow for parallax movement\n      drawWidth = drawHeight * imageAspect;\n      offsetX = (renderWidth - drawWidth) / 2;\n      offsetY = 0;\n    } else {\n      // Image is taller than canvas (relative to width)\n      drawWidth = renderWidth * 1.1; // Add 10% to allow for parallax movement\n      drawHeight = drawWidth / imageAspect;\n      offsetX = 0;\n      offsetY = (renderHeight - drawHeight) / 2;\n    }\n    \n    // Adjust based on position setting\n    if (position === 'top') {\n      offsetY = 0;\n    } else if (position === 'bottom') {\n      offsetY = renderHeight - drawHeight;\n    } else if (position === 'middle') {\n      offsetY = (renderHeight - drawHeight) / 2;\n    }\n    \n    // Apply parallax offset\n    offsetY += parallaxOffset;\n    \n    // Global opacity\n    ctx.globalAlpha = opacity;\n    \n    // Draw the image\n    ctx.drawImage(imageRef.current, offsetX, offsetY, drawWidth, drawHeight);\n    \n    // Painterly fade effects\n    const fadeTopHeight = Math.floor(renderHeight * fadeSize);\n    const fadeBottomHeight = Math.floor(renderHeight * fadeSize);\n    const shouldFadeTop = position === 'bottom' || position === 'middle';\n    const shouldFadeBottom = position === 'top' || position === 'middle';\n    \n    // Top fade with painterly effect\n    if (shouldFadeTop) {\n      // Create a canvas pattern for painterly texture\n      const patternCanvas = document.createElement('canvas');\n      const patternSize = 256;\n      patternCanvas.width = patternSize;\n      patternCanvas.height = patternSize;\n      const patternCtx = patternCanvas.getContext('2d');\n      \n      // Create textured gradient\n      const patternGradient = patternCtx.createLinearGradient(0, 0, 0, patternSize);\n      patternGradient.addColorStop(0, backgroundColor);\n      patternGradient.addColorStop(0.65, withOpacity(backgroundColor, 0.7));\n      patternGradient.addColorStop(0.85, withOpacity(backgroundColor, 0.3));\n      patternGradient.addColorStop(1, withOpacity(backgroundColor, 0));\n      \n      // Add texture\n      patternCtx.fillStyle = patternGradient;\n      patternCtx.fillRect(0, 0, patternSize, patternSize);\n      \n      // Add noise to the pattern\n      const patternData = patternCtx.getImageData(0, 0, patternSize, patternSize);\n      const pixels = patternData.data;\n      \n      for (let y = 0; y < patternSize; y++) {\n        for (let x = 0; x < patternSize; x++) {\n          // Increase noise toward the bottom (where transparency begins)\n          const noiseIntensity = 0.1 + (y / patternSize) * 0.2;\n          const noise = addPainterlyNoise(x, y, noiseIntensity);\n          \n          const idx = (y * patternSize + x) * 4;\n          const alpha = pixels[idx + 3];\n          \n          // Only modify partially transparent pixels for better edge effect\n          if (alpha > 0 && alpha < 255) {\n            pixels[idx + 3] = Math.max(0, Math.min(255, alpha + noise * 40));\n          }\n        }\n      }\n      \n      patternCtx.putImageData(patternData, 0, 0);\n      \n      // Create brush stroke effect at the bottom edge\n      patternCtx.globalCompositeOperation = 'destination-out';\n      \n      // Draw some random \"brush strokes\" at the bottom\n      const strokeCount = 8;\n      for (let i = 0; i < strokeCount; i++) {\n        const x = (patternSize / strokeCount) * i + Math.random() * 20 - 10;\n        const y = patternSize * 0.8 + Math.random() * 20;\n        const width = patternSize / strokeCount * 1.2;\n        const height = Math.random() * 30 + 20;\n        \n        patternCtx.beginPath();\n        patternCtx.ellipse(x, y, width/2, height/2, 0, 0, Math.PI * 2);\n        patternCtx.fill();\n      }\n      \n      // Apply the pattern to the main canvas\n      const pattern = ctx.createPattern(patternCanvas, 'repeat-x');\n      ctx.save();\n      \n      // Scale the pattern to fit the fade area\n      const scaleY = fadeTopHeight / patternSize;\n      ctx.translate(0, 0);\n      ctx.scale(1, scaleY);\n      ctx.fillStyle = pattern;\n      ctx.fillRect(0, 0, renderWidth, fadeTopHeight / scaleY);\n      \n      ctx.restore();\n    }\n    \n    // Bottom fade with painterly effect\n    if (shouldFadeBottom) {\n      const startY = renderHeight - fadeBottomHeight;\n      \n      // Create a canvas pattern for painterly texture\n      const patternCanvas = document.createElement('canvas');\n      const patternSize = 256;\n      patternCanvas.width = patternSize;\n      patternCanvas.height = patternSize;\n      const patternCtx = patternCanvas.getContext('2d');\n      \n      // Create textured gradient\n      const patternGradient = patternCtx.createLinearGradient(0, 0, 0, patternSize);\n      patternGradient.addColorStop(0, withOpacity(backgroundColor, 0));\n      patternGradient.addColorStop(0.15, withOpacity(backgroundColor, 0.3));\n      patternGradient.addColorStop(0.35, withOpacity(backgroundColor, 0.7));\n      patternGradient.addColorStop(1, backgroundColor);\n      \n      // Add texture\n      patternCtx.fillStyle = patternGradient;\n      patternCtx.fillRect(0, 0, patternSize, patternSize);\n      \n      // Add noise to the pattern\n      const patternData = patternCtx.getImageData(0, 0, patternSize, patternSize);\n      const pixels = patternData.data;\n      \n      for (let y = 0; y < patternSize; y++) {\n        for (let x = 0; x < patternSize; x++) {\n          // Increase noise at the top (where transparency begins)\n          const noiseIntensity = 0.2 - (y / patternSize) * 0.15;\n          const noise = addPainterlyNoise(x, y, noiseIntensity);\n          \n          const idx = (y * patternSize + x) * 4;\n          const alpha = pixels[idx + 3];\n          \n          // Only modify partially transparent pixels for better edge effect\n          if (alpha > 0 && alpha < 255) {\n            pixels[idx + 3] = Math.max(0, Math.min(255, alpha + noise * 40));\n          }\n        }\n      }\n      \n      patternCtx.putImageData(patternData, 0, 0);\n      \n      // Create brush stroke effect at the top edge\n      patternCtx.globalCompositeOperation = 'destination-out';\n      \n      // Draw some random \"brush strokes\" at the top\n      const strokeCount = 8;\n      for (let i = 0; i < strokeCount; i++) {\n        const x = (patternSize / strokeCount) * i + Math.random() * 20 - 10;\n        const y = patternSize * 0.2 - Math.random() * 10;\n        const width = patternSize / strokeCount * 1.2;\n        const height = Math.random() * 25 + 15;\n        \n        patternCtx.beginPath();\n        patternCtx.ellipse(x, y, width/2, height/2, 0, 0, Math.PI * 2);\n        patternCtx.fill();\n      }\n      \n      // Apply the pattern to the main canvas\n      const pattern = ctx.createPattern(patternCanvas, 'repeat-x');\n      ctx.save();\n      \n      // Scale the pattern to fit the fade area\n      const scaleY = fadeBottomHeight / patternSize;\n      ctx.translate(0, startY);\n      ctx.scale(1, scaleY);\n      ctx.fillStyle = pattern;\n      ctx.fillRect(0, 0, renderWidth, patternSize);\n      \n      ctx.restore();\n    }\n  }, [dimensions, parallaxFactor, position, backgroundColor, opacity, fadeSize, imageAspect, withOpacity, addPainterlyNoise]);\n  \n  // Smooth scroll animation using easing\n  const animateScroll = useCallback(() => {\n    // LERP (Linear Interpolation) for smooth transitions\n    const ease = 0.08; // Lower = smoother but slower\n    \n    // Calculate new position with easing\n    const delta = targetScrollY.current - currentScrollY.current;\n    currentScrollY.current += delta * ease;\n    \n    // Only render if changed enough to be visible\n    if (Math.abs(delta) > 0.1) {\n      renderCanvas();\n      rafRef.current = requestAnimationFrame(animateScroll);\n    } else {\n      // Snap to target when very close to avoid tiny movements\n      currentScrollY.current = targetScrollY.current;\n      renderCanvas();\n    }\n  }, [renderCanvas]);\n  \n  // Load high-quality image with proper handling\n  useEffect(() => {\n    const img = new Image();\n    img.crossOrigin = \"Anonymous\";\n    \n    img.onload = () => {\n      imageRef.current = img;\n      setImageAspect(img.width / img.height);\n      setIsImageLoaded(true);\n    };\n    \n    img.onerror = (err) => {\n      console.error(\"Failed to load image:\", err);\n    };\n    \n    img.src = image;\n    \n    return () => {\n      img.onload = null;\n      img.onerror = null;\n    };\n  }, [image]);\n  \n  // Set up canvas dimensions and handle resize\n  useEffect(() => {\n    calculateDimensions();\n    \n    const handleResize = () => {\n      calculateDimensions();\n      \n      // Immediately render after resize to prevent flickering\n      if (isImageLoaded) {\n        renderCanvas();\n      }\n    };\n    \n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, [calculateDimensions, isImageLoaded, renderCanvas]);\n  \n  // Update canvas based on current dimensions\n  useEffect(() => {\n    if (canvasRef.current && dimensions.width && dimensions.height) {\n      const canvas = canvasRef.current;\n      const dpr = window.devicePixelRatio || 1;\n      \n      // Set display size\n      canvas.style.width = `${dimensions.width}px`;\n      canvas.style.height = `${dimensions.height}px`;\n      \n      // Set actual size with high DPR for retina displays\n      canvas.width = dimensions.width * dpr;\n      canvas.height = dimensions.height * dpr;\n      \n      // Scale all drawing operations for high DPR\n      const ctx = canvas.getContext('2d');\n      ctx.scale(dpr, dpr);\n    }\n  }, [dimensions]);\n  \n  // Scroll event handler using requestAnimationFrame for performance\n  useEffect(() => {\n    const handleScroll = () => {\n      targetScrollY.current = window.scrollY;\n      \n      // Only start animation if we're not already animating\n      if (!rafRef.current) {\n        rafRef.current = requestAnimationFrame(animateScroll);\n      }\n    };\n    \n    window.addEventListener('scroll', handleScroll, { passive: true });\n    \n    // Initialize animation\n    targetScrollY.current = window.scrollY;\n    currentScrollY.current = window.scrollY;\n    \n    // Initial render\n    if (isImageLoaded) {\n      renderCanvas();\n    }\n    \n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n      if (rafRef.current) {\n        cancelAnimationFrame(rafRef.current);\n        rafRef.current = null;\n      }\n    };\n  }, [animateScroll, renderCanvas, isImageLoaded]);\n  \n  // Re-render when image loads\n  useEffect(() => {\n    if (isImageLoaded) {\n      renderCanvas();\n    }\n  }, [isImageLoaded, renderCanvas]);\n  \n  return (\n    <div\n      ref={containerRef}\n      style={{\n        position: 'relative',\n        width: '100%',\n        height,\n        overflow: 'hidden',\n        zIndex,\n        backgroundColor\n      }}\n    >\n      <canvas\n        ref={canvasRef}\n        style={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%',\n          display: isImageLoaded ? 'block' : 'none'\n        }}\n      />\n      \n      {/* Loading state */}\n      {!isImageLoaded && (\n        <div\n          style={{\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            width: '100%',\n            height: '100%',\n            backgroundColor\n          }}\n        />\n      )}\n      \n      {/* Content container */}\n      {children && (\n        <div\n          style={{\n            position: 'relative',\n            zIndex: 1,\n            width: '100%',\n            height: '100%'\n          }}\n        >\n          {children}\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default SlidingBackground;"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,MAAM,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,WAAW,QAAQ,OAAO;;AAEvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhBA,SAAAC,MAAA,IAAAC,OAAA;AAiBA,MAAMC,iBAAiB,GAAGA,CAAC;EACzBC,KAAK;EACLC,QAAQ,GAAG,KAAK;EAChBC,MAAM,GAAG,MAAM;EACfC,cAAc,GAAG,GAAG;EACpBC,eAAe,GAAG,MAAM;EACxBC,MAAM,GAAG,CAAC;EACVC,QAAQ,GAAG,GAAG;EACdC,OAAO,GAAG,CAAC;EACXC;AACF,CAAC,KAAK;EAAAC,EAAA;EACJ;EACA,MAAMC,YAAY,GAAGjB,MAAM,CAAC,IAAI,CAAC;EACjC,MAAMkB,SAAS,GAAGlB,MAAM,CAAC,IAAI,CAAC;EAC9B,MAAMmB,QAAQ,GAAGnB,MAAM,CAAC,IAAI,CAAC;EAC7B,MAAMoB,MAAM,GAAGpB,MAAM,CAAC,IAAI,CAAC;EAC3B,MAAMqB,aAAa,GAAGrB,MAAM,CAAC,CAAC,CAAC;EAC/B,MAAMsB,cAAc,GAAGtB,MAAM,CAAC,CAAC,CAAC;;EAEhC;EACA,MAAM,CAACuB,UAAU,EAAEC,aAAa,CAAC,GAAGtB,QAAQ,CAAC;IAAEuB,KAAK,EAAE,CAAC;IAAEhB,MAAM,EAAE;EAAE,CAAC,CAAC;EACrE,MAAM,CAACiB,aAAa,EAAEC,gBAAgB,CAAC,GAAGzB,QAAQ,CAAC,KAAK,CAAC;EACzD,MAAM,CAAC0B,WAAW,EAAEC,cAAc,CAAC,GAAG3B,QAAQ,CAAC,CAAC,CAAC;;EAEjD;EACA,MAAM4B,WAAW,GAAG3B,WAAW,CAAC,CAAC4B,KAAK,EAAEjB,OAAO,KAAK;IAClD;IACA,IAAIiB,KAAK,CAACC,UAAU,CAAC,GAAG,CAAC,EAAE;MACzB;MACA,IAAIC,CAAC,GAAG,CAAC;QAAEC,CAAC,GAAG,CAAC;QAAEC,CAAC,GAAG,CAAC;;MAEvB;MACA,IAAIJ,KAAK,CAACK,MAAM,KAAK,CAAC,EAAE;QACtBH,CAAC,GAAGI,QAAQ,CAACN,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;QACrCG,CAAC,GAAGG,QAAQ,CAACN,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;QACrCI,CAAC,GAAGE,QAAQ,CAACN,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;MACvC;MACA;MAAA,KACK,IAAIA,KAAK,CAACK,MAAM,KAAK,CAAC,EAAE;QAC3BH,CAAC,GAAGI,QAAQ,CAACN,KAAK,CAACO,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC;QACvCJ,CAAC,GAAGG,QAAQ,CAACN,KAAK,CAACO,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC;QACvCH,CAAC,GAAGE,QAAQ,CAACN,KAAK,CAACO,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC;MACzC;MAEA,OAAO,QAAQL,CAAC,KAAKC,CAAC,KAAKC,CAAC,KAAKrB,OAAO,GAAG;IAC7C;;IAEA;IACA,IAAIiB,KAAK,CAACC,UAAU,CAAC,KAAK,CAAC,EAAE;MAC3B;MACA,IAAID,KAAK,CAACC,UAAU,CAAC,MAAM,CAAC,EAAE;QAC5B,OAAOD,KAAK,CAACQ,OAAO,CAAC,yBAAyB,EAAE,YAAYzB,OAAO,GAAG,CAAC;MACzE;MACA;MACA,OAAOiB,KAAK,CAACQ,OAAO,CAAC,cAAc,EAAE,YAAYzB,OAAO,GAAG,CAAC;IAC9D;;IAEA;IACA,OAAO,iBAAiBA,OAAO,GAAG;EACpC,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAM0B,iBAAiB,GAAGrC,WAAW,CAAC,CAACsC,CAAC,EAAEC,CAAC,EAAEC,SAAS,GAAG,IAAI,KAAK;IAChE;IACA,MAAMC,KAAK,GAAGC,IAAI,CAACC,GAAG,CAACL,CAAC,GAAG,IAAI,CAAC,GAAGI,IAAI,CAACC,GAAG,CAACJ,CAAC,GAAG,IAAI,CAAC,GACxCG,IAAI,CAACC,GAAG,CAACL,CAAC,GAAG,IAAI,GAAGC,CAAC,GAAG,IAAI,CAAC,GAAGG,IAAI,CAACC,GAAG,CAACJ,CAAC,GAAG,IAAI,GAAGD,CAAC,GAAG,IAAI,CAAC;IAC1E,OAAOG,KAAK,GAAGD,SAAS;EAC1B,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAMI,mBAAmB,GAAG5C,WAAW,CAAC,MAAM;IAC5C,IAAI,CAACc,YAAY,CAAC+B,OAAO,EAAE;IAE3B,MAAMC,IAAI,GAAGhC,YAAY,CAAC+B,OAAO,CAACE,qBAAqB,CAAC,CAAC;IACzD1B,aAAa,CAAC;MACZC,KAAK,EAAEwB,IAAI,CAACxB,KAAK;MACjBhB,MAAM,EAAEwC,IAAI,CAACxC;IACf,CAAC,CAAC;EACJ,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAM0C,YAAY,GAAGhD,WAAW,CAAC,MAAM;IACrC,IAAI,CAACe,SAAS,CAAC8B,OAAO,IAAI,CAAC7B,QAAQ,CAAC6B,OAAO,IAAI,CAACzB,UAAU,CAACE,KAAK,IAAI,CAACF,UAAU,CAACd,MAAM,EAAE;IAExF,MAAM2C,MAAM,GAAGlC,SAAS,CAAC8B,OAAO;IAChC,MAAMK,GAAG,GAAGD,MAAM,CAACE,UAAU,CAAC,IAAI,CAAC;IACnC,MAAMC,gBAAgB,GAAGC,MAAM,CAACD,gBAAgB,IAAI,CAAC;;IAErD;IACA,MAAME,WAAW,GAAGlC,UAAU,CAACE,KAAK;IACpC,MAAMiC,YAAY,GAAGnC,UAAU,CAACd,MAAM;;IAEtC;IACA4C,GAAG,CAACM,SAAS,CAAC,CAAC,EAAE,CAAC,EAAEF,WAAW,EAAEC,YAAY,CAAC;;IAE9C;IACA,MAAME,cAAc,GAAGtC,cAAc,CAAC0B,OAAO,GAAGtC,cAAc;;IAE9D;IACA,MAAMmD,YAAY,GAAGJ,WAAW,GAAGC,YAAY;IAC/C,IAAII,SAAS,EAAEC,UAAU,EAAEC,OAAO,EAAEC,OAAO;;IAE3C;IACA,IAAIrC,WAAW,GAAGiC,YAAY,EAAE;MAC9B;MACAE,UAAU,GAAGL,YAAY,GAAG,GAAG,CAAC,CAAC;MACjCI,SAAS,GAAGC,UAAU,GAAGnC,WAAW;MACpCoC,OAAO,GAAG,CAACP,WAAW,GAAGK,SAAS,IAAI,CAAC;MACvCG,OAAO,GAAG,CAAC;IACb,CAAC,MAAM;MACL;MACAH,SAAS,GAAGL,WAAW,GAAG,GAAG,CAAC,CAAC;MAC/BM,UAAU,GAAGD,SAAS,GAAGlC,WAAW;MACpCoC,OAAO,GAAG,CAAC;MACXC,OAAO,GAAG,CAACP,YAAY,GAAGK,UAAU,IAAI,CAAC;IAC3C;;IAEA;IACA,IAAIvD,QAAQ,KAAK,KAAK,EAAE;MACtByD,OAAO,GAAG,CAAC;IACb,CAAC,MAAM,IAAIzD,QAAQ,KAAK,QAAQ,EAAE;MAChCyD,OAAO,GAAGP,YAAY,GAAGK,UAAU;IACrC,CAAC,MAAM,IAAIvD,QAAQ,KAAK,QAAQ,EAAE;MAChCyD,OAAO,GAAG,CAACP,YAAY,GAAGK,UAAU,IAAI,CAAC;IAC3C;;IAEA;IACAE,OAAO,IAAIL,cAAc;;IAEzB;IACAP,GAAG,CAACa,WAAW,GAAGpD,OAAO;;IAEzB;IACAuC,GAAG,CAACc,SAAS,CAAChD,QAAQ,CAAC6B,OAAO,EAAEgB,OAAO,EAAEC,OAAO,EAAEH,SAAS,EAAEC,UAAU,CAAC;;IAExE;IACA,MAAMK,aAAa,GAAGvB,IAAI,CAACwB,KAAK,CAACX,YAAY,GAAG7C,QAAQ,CAAC;IACzD,MAAMyD,gBAAgB,GAAGzB,IAAI,CAACwB,KAAK,CAACX,YAAY,GAAG7C,QAAQ,CAAC;IAC5D,MAAM0D,aAAa,GAAG/D,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,KAAK,QAAQ;IACpE,MAAMgE,gBAAgB,GAAGhE,QAAQ,KAAK,KAAK,IAAIA,QAAQ,KAAK,QAAQ;;IAEpE;IACA,IAAI+D,aAAa,EAAE;MACjB;MACA,MAAME,aAAa,GAAGC,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;MACtD,MAAMC,WAAW,GAAG,GAAG;MACvBH,aAAa,CAAChD,KAAK,GAAGmD,WAAW;MACjCH,aAAa,CAAChE,MAAM,GAAGmE,WAAW;MAClC,MAAMC,UAAU,GAAGJ,aAAa,CAACnB,UAAU,CAAC,IAAI,CAAC;;MAEjD;MACA,MAAMwB,eAAe,GAAGD,UAAU,CAACE,oBAAoB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAEH,WAAW,CAAC;MAC7EE,eAAe,CAACE,YAAY,CAAC,CAAC,EAAErE,eAAe,CAAC;MAChDmE,eAAe,CAACE,YAAY,CAAC,IAAI,EAAElD,WAAW,CAACnB,eAAe,EAAE,GAAG,CAAC,CAAC;MACrEmE,eAAe,CAACE,YAAY,CAAC,IAAI,EAAElD,WAAW,CAACnB,eAAe,EAAE,GAAG,CAAC,CAAC;MACrEmE,eAAe,CAACE,YAAY,CAAC,CAAC,EAAElD,WAAW,CAACnB,eAAe,EAAE,CAAC,CAAC,CAAC;;MAEhE;MACAkE,UAAU,CAACI,SAAS,GAAGH,eAAe;MACtCD,UAAU,CAACK,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEN,WAAW,EAAEA,WAAW,CAAC;;MAEnD;MACA,MAAMO,WAAW,GAAGN,UAAU,CAACO,YAAY,CAAC,CAAC,EAAE,CAAC,EAAER,WAAW,EAAEA,WAAW,CAAC;MAC3E,MAAMS,MAAM,GAAGF,WAAW,CAACG,IAAI;MAE/B,KAAK,IAAI5C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkC,WAAW,EAAElC,CAAC,EAAE,EAAE;QACpC,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmC,WAAW,EAAEnC,CAAC,EAAE,EAAE;UACpC;UACA,MAAM8C,cAAc,GAAG,GAAG,GAAI7C,CAAC,GAAGkC,WAAW,GAAI,GAAG;UACpD,MAAMhC,KAAK,GAAGJ,iBAAiB,CAACC,CAAC,EAAEC,CAAC,EAAE6C,cAAc,CAAC;UAErD,MAAMC,GAAG,GAAG,CAAC9C,CAAC,GAAGkC,WAAW,GAAGnC,CAAC,IAAI,CAAC;UACrC,MAAMgD,KAAK,GAAGJ,MAAM,CAACG,GAAG,GAAG,CAAC,CAAC;;UAE7B;UACA,IAAIC,KAAK,GAAG,CAAC,IAAIA,KAAK,GAAG,GAAG,EAAE;YAC5BJ,MAAM,CAACG,GAAG,GAAG,CAAC,CAAC,GAAG3C,IAAI,CAAC6C,GAAG,CAAC,CAAC,EAAE7C,IAAI,CAAC8C,GAAG,CAAC,GAAG,EAAEF,KAAK,GAAG7C,KAAK,GAAG,EAAE,CAAC,CAAC;UAClE;QACF;MACF;MAEAiC,UAAU,CAACe,YAAY,CAACT,WAAW,EAAE,CAAC,EAAE,CAAC,CAAC;;MAE1C;MACAN,UAAU,CAACgB,wBAAwB,GAAG,iBAAiB;;MAEvD;MACA,MAAMC,WAAW,GAAG,CAAC;MACrB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,WAAW,EAAEC,CAAC,EAAE,EAAE;QACpC,MAAMtD,CAAC,GAAImC,WAAW,GAAGkB,WAAW,GAAIC,CAAC,GAAGlD,IAAI,CAACmD,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE;QACnE,MAAMtD,CAAC,GAAGkC,WAAW,GAAG,GAAG,GAAG/B,IAAI,CAACmD,MAAM,CAAC,CAAC,GAAG,EAAE;QAChD,MAAMvE,KAAK,GAAGmD,WAAW,GAAGkB,WAAW,GAAG,GAAG;QAC7C,MAAMrF,MAAM,GAAGoC,IAAI,CAACmD,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE;QAEtCnB,UAAU,CAACoB,SAAS,CAAC,CAAC;QACtBpB,UAAU,CAACqB,OAAO,CAACzD,CAAC,EAAEC,CAAC,EAAEjB,KAAK,GAAC,CAAC,EAAEhB,MAAM,GAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAEoC,IAAI,CAACsD,EAAE,GAAG,CAAC,CAAC;QAC9DtB,UAAU,CAACuB,IAAI,CAAC,CAAC;MACnB;;MAEA;MACA,MAAMC,OAAO,GAAGhD,GAAG,CAACiD,aAAa,CAAC7B,aAAa,EAAE,UAAU,CAAC;MAC5DpB,GAAG,CAACkD,IAAI,CAAC,CAAC;;MAEV;MACA,MAAMC,MAAM,GAAGpC,aAAa,GAAGQ,WAAW;MAC1CvB,GAAG,CAACoD,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC;MACnBpD,GAAG,CAACqD,KAAK,CAAC,CAAC,EAAEF,MAAM,CAAC;MACpBnD,GAAG,CAAC4B,SAAS,GAAGoB,OAAO;MACvBhD,GAAG,CAAC6B,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEzB,WAAW,EAAEW,aAAa,GAAGoC,MAAM,CAAC;MAEvDnD,GAAG,CAACsD,OAAO,CAAC,CAAC;IACf;;IAEA;IACA,IAAInC,gBAAgB,EAAE;MACpB,MAAMoC,MAAM,GAAGlD,YAAY,GAAGY,gBAAgB;;MAE9C;MACA,MAAMG,aAAa,GAAGC,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;MACtD,MAAMC,WAAW,GAAG,GAAG;MACvBH,aAAa,CAAChD,KAAK,GAAGmD,WAAW;MACjCH,aAAa,CAAChE,MAAM,GAAGmE,WAAW;MAClC,MAAMC,UAAU,GAAGJ,aAAa,CAACnB,UAAU,CAAC,IAAI,CAAC;;MAEjD;MACA,MAAMwB,eAAe,GAAGD,UAAU,CAACE,oBAAoB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAEH,WAAW,CAAC;MAC7EE,eAAe,CAACE,YAAY,CAAC,CAAC,EAAElD,WAAW,CAACnB,eAAe,EAAE,CAAC,CAAC,CAAC;MAChEmE,eAAe,CAACE,YAAY,CAAC,IAAI,EAAElD,WAAW,CAACnB,eAAe,EAAE,GAAG,CAAC,CAAC;MACrEmE,eAAe,CAACE,YAAY,CAAC,IAAI,EAAElD,WAAW,CAACnB,eAAe,EAAE,GAAG,CAAC,CAAC;MACrEmE,eAAe,CAACE,YAAY,CAAC,CAAC,EAAErE,eAAe,CAAC;;MAEhD;MACAkE,UAAU,CAACI,SAAS,GAAGH,eAAe;MACtCD,UAAU,CAACK,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEN,WAAW,EAAEA,WAAW,CAAC;;MAEnD;MACA,MAAMO,WAAW,GAAGN,UAAU,CAACO,YAAY,CAAC,CAAC,EAAE,CAAC,EAAER,WAAW,EAAEA,WAAW,CAAC;MAC3E,MAAMS,MAAM,GAAGF,WAAW,CAACG,IAAI;MAE/B,KAAK,IAAI5C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkC,WAAW,EAAElC,CAAC,EAAE,EAAE;QACpC,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmC,WAAW,EAAEnC,CAAC,EAAE,EAAE;UACpC;UACA,MAAM8C,cAAc,GAAG,GAAG,GAAI7C,CAAC,GAAGkC,WAAW,GAAI,IAAI;UACrD,MAAMhC,KAAK,GAAGJ,iBAAiB,CAACC,CAAC,EAAEC,CAAC,EAAE6C,cAAc,CAAC;UAErD,MAAMC,GAAG,GAAG,CAAC9C,CAAC,GAAGkC,WAAW,GAAGnC,CAAC,IAAI,CAAC;UACrC,MAAMgD,KAAK,GAAGJ,MAAM,CAACG,GAAG,GAAG,CAAC,CAAC;;UAE7B;UACA,IAAIC,KAAK,GAAG,CAAC,IAAIA,KAAK,GAAG,GAAG,EAAE;YAC5BJ,MAAM,CAACG,GAAG,GAAG,CAAC,CAAC,GAAG3C,IAAI,CAAC6C,GAAG,CAAC,CAAC,EAAE7C,IAAI,CAAC8C,GAAG,CAAC,GAAG,EAAEF,KAAK,GAAG7C,KAAK,GAAG,EAAE,CAAC,CAAC;UAClE;QACF;MACF;MAEAiC,UAAU,CAACe,YAAY,CAACT,WAAW,EAAE,CAAC,EAAE,CAAC,CAAC;;MAE1C;MACAN,UAAU,CAACgB,wBAAwB,GAAG,iBAAiB;;MAEvD;MACA,MAAMC,WAAW,GAAG,CAAC;MACrB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,WAAW,EAAEC,CAAC,EAAE,EAAE;QACpC,MAAMtD,CAAC,GAAImC,WAAW,GAAGkB,WAAW,GAAIC,CAAC,GAAGlD,IAAI,CAACmD,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE;QACnE,MAAMtD,CAAC,GAAGkC,WAAW,GAAG,GAAG,GAAG/B,IAAI,CAACmD,MAAM,CAAC,CAAC,GAAG,EAAE;QAChD,MAAMvE,KAAK,GAAGmD,WAAW,GAAGkB,WAAW,GAAG,GAAG;QAC7C,MAAMrF,MAAM,GAAGoC,IAAI,CAACmD,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE;QAEtCnB,UAAU,CAACoB,SAAS,CAAC,CAAC;QACtBpB,UAAU,CAACqB,OAAO,CAACzD,CAAC,EAAEC,CAAC,EAAEjB,KAAK,GAAC,CAAC,EAAEhB,MAAM,GAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAEoC,IAAI,CAACsD,EAAE,GAAG,CAAC,CAAC;QAC9DtB,UAAU,CAACuB,IAAI,CAAC,CAAC;MACnB;;MAEA;MACA,MAAMC,OAAO,GAAGhD,GAAG,CAACiD,aAAa,CAAC7B,aAAa,EAAE,UAAU,CAAC;MAC5DpB,GAAG,CAACkD,IAAI,CAAC,CAAC;;MAEV;MACA,MAAMC,MAAM,GAAGlC,gBAAgB,GAAGM,WAAW;MAC7CvB,GAAG,CAACoD,SAAS,CAAC,CAAC,EAAEG,MAAM,CAAC;MACxBvD,GAAG,CAACqD,KAAK,CAAC,CAAC,EAAEF,MAAM,CAAC;MACpBnD,GAAG,CAAC4B,SAAS,GAAGoB,OAAO;MACvBhD,GAAG,CAAC6B,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEzB,WAAW,EAAEmB,WAAW,CAAC;MAE5CvB,GAAG,CAACsD,OAAO,CAAC,CAAC;IACf;EACF,CAAC,EAAE,CAACpF,UAAU,EAAEb,cAAc,EAAEF,QAAQ,EAAEG,eAAe,EAAEG,OAAO,EAAED,QAAQ,EAAEe,WAAW,EAAEE,WAAW,EAAEU,iBAAiB,CAAC,CAAC;;EAE3H;EACA,MAAMqE,aAAa,GAAG1G,WAAW,CAAC,MAAM;IACtC;IACA,MAAM2G,IAAI,GAAG,IAAI,CAAC,CAAC;;IAEnB;IACA,MAAMC,KAAK,GAAG1F,aAAa,CAAC2B,OAAO,GAAG1B,cAAc,CAAC0B,OAAO;IAC5D1B,cAAc,CAAC0B,OAAO,IAAI+D,KAAK,GAAGD,IAAI;;IAEtC;IACA,IAAIjE,IAAI,CAACmE,GAAG,CAACD,KAAK,CAAC,GAAG,GAAG,EAAE;MACzB5D,YAAY,CAAC,CAAC;MACd/B,MAAM,CAAC4B,OAAO,GAAGiE,qBAAqB,CAACJ,aAAa,CAAC;IACvD,CAAC,MAAM;MACL;MACAvF,cAAc,CAAC0B,OAAO,GAAG3B,aAAa,CAAC2B,OAAO;MAC9CG,YAAY,CAAC,CAAC;IAChB;EACF,CAAC,EAAE,CAACA,YAAY,CAAC,CAAC;;EAElB;EACAlD,SAAS,CAAC,MAAM;IACd,MAAMiH,GAAG,GAAG,IAAIC,KAAK,CAAC,CAAC;IACvBD,GAAG,CAACE,WAAW,GAAG,WAAW;IAE7BF,GAAG,CAACG,MAAM,GAAG,MAAM;MACjBlG,QAAQ,CAAC6B,OAAO,GAAGkE,GAAG;MACtBrF,cAAc,CAACqF,GAAG,CAACzF,KAAK,GAAGyF,GAAG,CAACzG,MAAM,CAAC;MACtCkB,gBAAgB,CAAC,IAAI,CAAC;IACxB,CAAC;IAEDuF,GAAG,CAACI,OAAO,GAAIC,GAAG,IAAK;MACrBC,OAAO,CAACC,KAAK,CAAC,uBAAuB,EAAEF,GAAG,CAAC;IAC7C,CAAC;IAEDL,GAAG,CAACQ,GAAG,GAAGnH,KAAK;IAEf,OAAO,MAAM;MACX2G,GAAG,CAACG,MAAM,GAAG,IAAI;MACjBH,GAAG,CAACI,OAAO,GAAG,IAAI;IACpB,CAAC;EACH,CAAC,EAAE,CAAC/G,KAAK,CAAC,CAAC;;EAEX;EACAN,SAAS,CAAC,MAAM;IACd8C,mBAAmB,CAAC,CAAC;IAErB,MAAM4E,YAAY,GAAGA,CAAA,KAAM;MACzB5E,mBAAmB,CAAC,CAAC;;MAErB;MACA,IAAIrB,aAAa,EAAE;QACjByB,YAAY,CAAC,CAAC;MAChB;IACF,CAAC;IAEDK,MAAM,CAACoE,gBAAgB,CAAC,QAAQ,EAAED,YAAY,CAAC;IAC/C,OAAO,MAAMnE,MAAM,CAACqE,mBAAmB,CAAC,QAAQ,EAAEF,YAAY,CAAC;EACjE,CAAC,EAAE,CAAC5E,mBAAmB,EAAErB,aAAa,EAAEyB,YAAY,CAAC,CAAC;;EAEtD;EACAlD,SAAS,CAAC,MAAM;IACd,IAAIiB,SAAS,CAAC8B,OAAO,IAAIzB,UAAU,CAACE,KAAK,IAAIF,UAAU,CAACd,MAAM,EAAE;MAC9D,MAAM2C,MAAM,GAAGlC,SAAS,CAAC8B,OAAO;MAChC,MAAM8E,GAAG,GAAGtE,MAAM,CAACD,gBAAgB,IAAI,CAAC;;MAExC;MACAH,MAAM,CAAC2E,KAAK,CAACtG,KAAK,GAAG,GAAGF,UAAU,CAACE,KAAK,IAAI;MAC5C2B,MAAM,CAAC2E,KAAK,CAACtH,MAAM,GAAG,GAAGc,UAAU,CAACd,MAAM,IAAI;;MAE9C;MACA2C,MAAM,CAAC3B,KAAK,GAAGF,UAAU,CAACE,KAAK,GAAGqG,GAAG;MACrC1E,MAAM,CAAC3C,MAAM,GAAGc,UAAU,CAACd,MAAM,GAAGqH,GAAG;;MAEvC;MACA,MAAMzE,GAAG,GAAGD,MAAM,CAACE,UAAU,CAAC,IAAI,CAAC;MACnCD,GAAG,CAACqD,KAAK,CAACoB,GAAG,EAAEA,GAAG,CAAC;IACrB;EACF,CAAC,EAAE,CAACvG,UAAU,CAAC,CAAC;;EAEhB;EACAtB,SAAS,CAAC,MAAM;IACd,MAAM+H,YAAY,GAAGA,CAAA,KAAM;MACzB3G,aAAa,CAAC2B,OAAO,GAAGQ,MAAM,CAACyE,OAAO;;MAEtC;MACA,IAAI,CAAC7G,MAAM,CAAC4B,OAAO,EAAE;QACnB5B,MAAM,CAAC4B,OAAO,GAAGiE,qBAAqB,CAACJ,aAAa,CAAC;MACvD;IACF,CAAC;IAEDrD,MAAM,CAACoE,gBAAgB,CAAC,QAAQ,EAAEI,YAAY,EAAE;MAAEE,OAAO,EAAE;IAAK,CAAC,CAAC;;IAElE;IACA7G,aAAa,CAAC2B,OAAO,GAAGQ,MAAM,CAACyE,OAAO;IACtC3G,cAAc,CAAC0B,OAAO,GAAGQ,MAAM,CAACyE,OAAO;;IAEvC;IACA,IAAIvG,aAAa,EAAE;MACjByB,YAAY,CAAC,CAAC;IAChB;IAEA,OAAO,MAAM;MACXK,MAAM,CAACqE,mBAAmB,CAAC,QAAQ,EAAEG,YAAY,CAAC;MAClD,IAAI5G,MAAM,CAAC4B,OAAO,EAAE;QAClBmF,oBAAoB,CAAC/G,MAAM,CAAC4B,OAAO,CAAC;QACpC5B,MAAM,CAAC4B,OAAO,GAAG,IAAI;MACvB;IACF,CAAC;EACH,CAAC,EAAE,CAAC6D,aAAa,EAAE1D,YAAY,EAAEzB,aAAa,CAAC,CAAC;;EAEhD;EACAzB,SAAS,CAAC,MAAM;IACd,IAAIyB,aAAa,EAAE;MACjByB,YAAY,CAAC,CAAC;IAChB;EACF,CAAC,EAAE,CAACzB,aAAa,EAAEyB,YAAY,CAAC,CAAC;EAEjC,oBACE9C,OAAA;IACE+H,GAAG,EAAEnH,YAAa;IAClB8G,KAAK,EAAE;MACLvH,QAAQ,EAAE,UAAU;MACpBiB,KAAK,EAAE,MAAM;MACbhB,MAAM;MACN4H,QAAQ,EAAE,QAAQ;MAClBzH,MAAM;MACND;IACF,CAAE;IAAAI,QAAA,gBAEFV,OAAA;MACE+H,GAAG,EAAElH,SAAU;MACf6G,KAAK,EAAE;QACLvH,QAAQ,EAAE,UAAU;QACpB8H,GAAG,EAAE,CAAC;QACNC,IAAI,EAAE,CAAC;QACP9G,KAAK,EAAE,MAAM;QACbhB,MAAM,EAAE,MAAM;QACd+H,OAAO,EAAE9G,aAAa,GAAG,OAAO,GAAG;MACrC;IAAE;MAAA+G,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACH,CAAC,EAGD,CAAClH,aAAa,iBACbrB,OAAA;MACE0H,KAAK,EAAE;QACLvH,QAAQ,EAAE,UAAU;QACpB8H,GAAG,EAAE,CAAC;QACNC,IAAI,EAAE,CAAC;QACP9G,KAAK,EAAE,MAAM;QACbhB,MAAM,EAAE,MAAM;QACdE;MACF;IAAE;MAAA8H,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACH,CACF,EAGA7H,QAAQ,iBACPV,OAAA;MACE0H,KAAK,EAAE;QACLvH,QAAQ,EAAE,UAAU;QACpBI,MAAM,EAAE,CAAC;QACTa,KAAK,EAAE,MAAM;QACbhB,MAAM,EAAE;MACV,CAAE;MAAAM,QAAA,EAEDA;IAAQ;MAAA0H,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACN,CACN;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACE,CAAC;AAEV,CAAC;AAAC5H,EAAA,CA3cIV,iBAAiB;AAAAuI,EAAA,GAAjBvI,iBAAiB;AA6cvB,eAAeA,iBAAiB;AAAC,IAAAuI,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}