{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/effects/scrollingeffects/SlidingBackground.jsx\",\n  _s = $RefreshSig$();\n// Helper function to convert color to rgba with opacity\nconst withOpacity = (color, opacity) => {\n  // Handle hex colors\n  if (color.startsWith('#')) {\n    // Convert hex to rgb\n    let r = 0,\n      g = 0,\n      b = 0;\n\n    // Handle #RGB format\n    if (color.length === 4) {\n      r = parseInt(color[1] + color[1], 16);\n      g = parseInt(color[2] + color[2], 16);\n      b = parseInt(color[3] + color[3], 16);\n    }\n    // Handle #RRGGBB format\n    else if (color.length === 7) {\n      r = parseInt(color.substring(1, 3), 16);\n      g = parseInt(color.substring(3, 5), 16);\n      b = parseInt(color.substring(5, 7), 16);\n    }\n    return `rgba(${r}, ${g}, ${b}, ${opacity})`;\n  }\n\n  // Handle rgb/rgba colors\n  if (color.startsWith('rgb')) {\n    // If already rgba, replace the opacity\n    if (color.startsWith('rgba')) {\n      return color.replace(/rgba\\((.+?),\\s*[\\d.]+\\)/, `rgba($1, ${opacity})`);\n    }\n    // Convert rgb to rgba\n    return color.replace(/rgb\\((.+?)\\)/, `rgba($1, ${opacity})`);\n  }\n\n  // Handle named colors by using a semi-transparent black as fallback\n  return `rgba(0, 0, 0, ${opacity})`;\n};\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\n\n/**\n* PainterlyBackground Component\n* \n* A smooth, high-quality background component with painterly fade effects and \n* fluid parallax scrolling that properly handles high-resolution images.\n* \n* @param {Object} props - Component props\n* @param {string} props.image - URL of the background image\n* @param {string} [props.position='top'] - Position of the focused area ('top', 'middle', 'bottom')\n* @param {string|number} [props.height='33vh'] - Height of the component\n* @param {number} [props.parallaxFactor=0.4] - How much the image moves relative to scroll (lower = smoother)\n* @param {string} [props.backgroundColor='#000'] - Background color\n* @param {number} [props.zIndex=0] - z-index of the component\n* @param {number} [props.fadeSize=0.4] - Size of the fade effect (0-1)\n* @param {number} [props.opacity=1] - Overall opacity of the component\n* @param {React.ReactNode} [props.children] - Content to render on top of the background\n*/\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SlidingBackground = ({\n  image,\n  position = 'top',\n  height = '33vh',\n  parallaxFactor = 0.4,\n  backgroundColor = '#000',\n  zIndex = 0,\n  fadeSize = 0.4,\n  opacity = 1,\n  children\n}) => {\n  _s();\n  // Refs\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const imageRef = useRef(null);\n  const rafRef = useRef(null);\n  const targetScrollY = useRef(0);\n  const currentScrollY = useRef(0);\n\n  // State\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0\n  });\n  const [isImageLoaded, setIsImageLoaded] = useState(false);\n  const [imageAspect, setImageAspect] = useState(0);\n\n  // Calculate dimensions for the image and canvas\n  const calculateDimensions = useCallback(() => {\n    if (!containerRef.current) return;\n    const rect = containerRef.current.getBoundingClientRect();\n    setDimensions({\n      width: rect.width,\n      height: rect.height\n    });\n  }, []);\n\n  // Load high-quality image with proper handling\n  useEffect(() => {\n    const img = new Image();\n    img.crossOrigin = \"Anonymous\";\n    img.onload = () => {\n      imageRef.current = img;\n      setImageAspect(img.width / img.height);\n      setIsImageLoaded(true);\n    };\n    img.onerror = err => {\n      console.error(\"Failed to load image:\", err);\n    };\n    img.src = image;\n    return () => {\n      img.onload = null;\n      img.onerror = null;\n    };\n  }, [image]);\n\n  // Set up canvas dimensions and handle resize\n  useEffect(() => {\n    calculateDimensions();\n    const handleResize = () => {\n      calculateDimensions();\n\n      // Immediately render after resize to prevent flickering\n      if (isImageLoaded) {\n        renderCanvas();\n      }\n    };\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, [calculateDimensions, isImageLoaded]);\n\n  // Update canvas based on current dimensions\n  useEffect(() => {\n    if (canvasRef.current && dimensions.width && dimensions.height) {\n      const canvas = canvasRef.current;\n      const dpr = window.devicePixelRatio || 1;\n\n      // Set display size\n      canvas.style.width = `${dimensions.width}px`;\n      canvas.style.height = `${dimensions.height}px`;\n\n      // Set actual size with high DPR for retina displays\n      canvas.width = dimensions.width * dpr;\n      canvas.height = dimensions.height * dpr;\n\n      // Scale all drawing operations for high DPR\n      const ctx = canvas.getContext('2d');\n      ctx.scale(dpr, dpr);\n    }\n  }, [dimensions]);\n\n  // Smooth scroll animation using easing\n  const animateScroll = useCallback(() => {\n    // LERP (Linear Interpolation) for smooth transitions\n    const ease = 0.08; // Lower = smoother but slower\n\n    // Calculate new position with easing\n    const delta = targetScrollY.current - currentScrollY.current;\n    currentScrollY.current += delta * ease;\n\n    // Only render if changed enough to be visible\n    if (Math.abs(delta) > 0.1) {\n      renderCanvas();\n      rafRef.current = requestAnimationFrame(animateScroll);\n    } else {\n      // Snap to target when very close to avoid tiny movements\n      currentScrollY.current = targetScrollY.current;\n      renderCanvas();\n    }\n  }, [renderCanvas]);\n\n  // Render the canvas with painterly effects\n  const renderCanvas = useCallback(() => {\n    if (!canvasRef.current || !imageRef.current || !dimensions.width || !dimensions.height) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const dpr = window.devicePixelRatio || 1;\n\n    // Calculate the rendering context size (accounting for DPR)\n    const renderWidth = dimensions.width;\n    const renderHeight = dimensions.height;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, renderWidth, renderHeight);\n\n    // Calculate parallax offset based on current interpolated scroll position\n    const parallaxOffset = currentScrollY.current * parallaxFactor;\n\n    // Calculate image dimensions to maintain aspect ratio\n    const canvasAspect = renderWidth / renderHeight;\n    let drawWidth, drawHeight, offsetX, offsetY;\n\n    // Ensure image covers the entire canvas with some overflow for parallax\n    if (imageAspect > canvasAspect) {\n      // Image is wider than canvas (relative to height)\n      drawHeight = renderHeight * 1.1; // Add 10% to allow for parallax movement\n      drawWidth = drawHeight * imageAspect;\n      offsetX = (renderWidth - drawWidth) / 2;\n      offsetY = 0;\n    } else {\n      // Image is taller than canvas (relative to width)\n      drawWidth = renderWidth * 1.1; // Add 10% to allow for parallax movement\n      drawHeight = drawWidth / imageAspect;\n      offsetX = 0;\n      offsetY = (renderHeight - drawHeight) / 2;\n    }\n\n    // Adjust based on position setting\n    if (position === 'top') {\n      offsetY = 0;\n    } else if (position === 'bottom') {\n      offsetY = renderHeight - drawHeight;\n    } else if (position === 'middle') {\n      offsetY = (renderHeight - drawHeight) / 2;\n    }\n\n    // Apply parallax offset\n    offsetY += parallaxOffset;\n\n    // Global opacity\n    ctx.globalAlpha = opacity;\n\n    // Draw the image\n    ctx.drawImage(imageRef.current, offsetX, offsetY, drawWidth, drawHeight);\n\n    // Painterly noise texture function (creates organic texture)\n    const addPainterlyNoise = (x, y, intensity = 0.15) => {\n      // Use Perlin-like noise approximation for a more organic feel\n      const noise = Math.sin(x * 0.01) * Math.sin(y * 0.01) * Math.sin(x * 0.02 + y * 0.03) * Math.sin(y * 0.02 + x * 0.01);\n      return noise * intensity;\n    };\n\n    // Painterly fade effects\n    const fadeTopHeight = Math.floor(renderHeight * fadeSize);\n    const fadeBottomHeight = Math.floor(renderHeight * fadeSize);\n    const shouldFadeTop = position === 'bottom' || position === 'middle';\n    const shouldFadeBottom = position === 'top' || position === 'middle';\n\n    // Top fade with painterly effect\n    if (shouldFadeTop) {\n      // Create a canvas pattern for painterly texture\n      const patternCanvas = document.createElement('canvas');\n      const patternSize = 256;\n      patternCanvas.width = patternSize;\n      patternCanvas.height = patternSize;\n      const patternCtx = patternCanvas.getContext('2d');\n\n      // Create textured gradient\n      const patternGradient = patternCtx.createLinearGradient(0, 0, 0, patternSize);\n      patternGradient.addColorStop(0, backgroundColor);\n      patternGradient.addColorStop(0.65, withOpacity(backgroundColor, 0.7));\n      patternGradient.addColorStop(0.85, withOpacity(backgroundColor, 0.3));\n      patternGradient.addColorStop(1, withOpacity(backgroundColor, 0));\n\n      // Add texture\n      patternCtx.fillStyle = patternGradient;\n      patternCtx.fillRect(0, 0, patternSize, patternSize);\n\n      // Add noise to the pattern\n      const patternData = patternCtx.getImageData(0, 0, patternSize, patternSize);\n      const pixels = patternData.data;\n      for (let y = 0; y < patternSize; y++) {\n        for (let x = 0; x < patternSize; x++) {\n          // Increase noise toward the bottom (where transparency begins)\n          const noiseIntensity = 0.1 + y / patternSize * 0.2;\n          const noise = addPainterlyNoise(x, y, noiseIntensity);\n          const idx = (y * patternSize + x) * 4;\n          const alpha = pixels[idx + 3];\n\n          // Only modify partially transparent pixels for better edge effect\n          if (alpha > 0 && alpha < 255) {\n            pixels[idx + 3] = Math.max(0, Math.min(255, alpha + noise * 40));\n          }\n        }\n      }\n      patternCtx.putImageData(patternData, 0, 0);\n\n      // Create brush stroke effect at the bottom edge\n      patternCtx.globalCompositeOperation = 'destination-out';\n\n      // Draw some random \"brush strokes\" at the bottom\n      const strokeCount = 8;\n      for (let i = 0; i < strokeCount; i++) {\n        const x = patternSize / strokeCount * i + Math.random() * 20 - 10;\n        const y = patternSize * 0.8 + Math.random() * 20;\n        const width = patternSize / strokeCount * 1.2;\n        const height = Math.random() * 30 + 20;\n        patternCtx.beginPath();\n        patternCtx.ellipse(x, y, width / 2, height / 2, 0, 0, Math.PI * 2);\n        patternCtx.fill();\n      }\n\n      // Apply the pattern to the main canvas\n      const pattern = ctx.createPattern(patternCanvas, 'repeat-x');\n      ctx.save();\n\n      // Scale the pattern to fit the fade area\n      const scaleY = fadeTopHeight / patternSize;\n      ctx.translate(0, 0);\n      ctx.scale(1, scaleY);\n      ctx.fillStyle = pattern;\n      ctx.fillRect(0, 0, renderWidth, fadeTopHeight / scaleY);\n      ctx.restore();\n    }\n\n    // Bottom fade with painterly effect\n    if (shouldFadeBottom) {\n      const startY = renderHeight - fadeBottomHeight;\n\n      // Create a canvas pattern for painterly texture\n      const patternCanvas = document.createElement('canvas');\n      const patternSize = 256;\n      patternCanvas.width = patternSize;\n      patternCanvas.height = patternSize;\n      const patternCtx = patternCanvas.getContext('2d');\n\n      // Create textured gradient\n      const patternGradient = patternCtx.createLinearGradient(0, 0, 0, patternSize);\n      patternGradient.addColorStop(0, withOpacity(backgroundColor, 0));\n      patternGradient.addColorStop(0.15, withOpacity(backgroundColor, 0.3));\n      patternGradient.addColorStop(0.35, withOpacity(backgroundColor, 0.7));\n      patternGradient.addColorStop(1, backgroundColor);\n\n      // Add texture\n      patternCtx.fillStyle = patternGradient;\n      patternCtx.fillRect(0, 0, patternSize, patternSize);\n\n      // Add noise to the pattern\n      const patternData = patternCtx.getImageData(0, 0, patternSize, patternSize);\n      const pixels = patternData.data;\n      for (let y = 0; y < patternSize; y++) {\n        for (let x = 0; x < patternSize; x++) {\n          // Increase noise at the top (where transparency begins)\n          const noiseIntensity = 0.2 - y / patternSize * 0.15;\n          const noise = addPainterlyNoise(x, y, noiseIntensity);\n          const idx = (y * patternSize + x) * 4;\n          const alpha = pixels[idx + 3];\n\n          // Only modify partially transparent pixels for better edge effect\n          if (alpha > 0 && alpha < 255) {\n            pixels[idx + 3] = Math.max(0, Math.min(255, alpha + noise * 40));\n          }\n        }\n      }\n      patternCtx.putImageData(patternData, 0, 0);\n\n      // Create brush stroke effect at the top edge\n      patternCtx.globalCompositeOperation = 'destination-out';\n\n      // Draw some random \"brush strokes\" at the top\n      const strokeCount = 8;\n      for (let i = 0; i < strokeCount; i++) {\n        const x = patternSize / strokeCount * i + Math.random() * 20 - 10;\n        const y = patternSize * 0.2 - Math.random() * 10;\n        const width = patternSize / strokeCount * 1.2;\n        const height = Math.random() * 25 + 15;\n        patternCtx.beginPath();\n        patternCtx.ellipse(x, y, width / 2, height / 2, 0, 0, Math.PI * 2);\n        patternCtx.fill();\n      }\n\n      // Apply the pattern to the main canvas\n      const pattern = ctx.createPattern(patternCanvas, 'repeat-x');\n      ctx.save();\n\n      // Scale the pattern to fit the fade area\n      const scaleY = fadeBottomHeight / patternSize;\n      ctx.translate(0, startY);\n      ctx.scale(1, scaleY);\n      ctx.fillStyle = pattern;\n      ctx.fillRect(0, 0, renderWidth, patternSize);\n      ctx.restore();\n    }\n\n    // For debugging: show the actual image area\n    /*\n    ctx.strokeStyle = \"rgba(255,0,0,0.5)\";\n    ctx.lineWidth = 2;\n    ctx.strokeRect(offsetX, offsetY, drawWidth, drawHeight);\n    */\n  }, [dimensions, parallaxFactor, position, backgroundColor, opacity, fadeSize, imageAspect]);\n\n  // Scroll event handler using requestAnimationFrame for performance\n  useEffect(() => {\n    const handleScroll = () => {\n      targetScrollY.current = window.scrollY;\n\n      // Only start animation if we're not already animating\n      if (!rafRef.current) {\n        rafRef.current = requestAnimationFrame(animateScroll);\n      }\n    };\n    window.addEventListener('scroll', handleScroll, {\n      passive: true\n    });\n\n    // Initialize animation\n    targetScrollY.current = window.scrollY;\n    currentScrollY.current = window.scrollY;\n\n    // Initial render\n    if (isImageLoaded) {\n      renderCanvas();\n    }\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n      if (rafRef.current) {\n        cancelAnimationFrame(rafRef.current);\n        rafRef.current = null;\n      }\n    };\n  }, [animateScroll, renderCanvas, isImageLoaded]);\n\n  // Re-render when image loads\n  useEffect(() => {\n    if (isImageLoaded) {\n      renderCanvas();\n    }\n  }, [isImageLoaded, renderCanvas]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'relative',\n      width: '100%',\n      height,\n      overflow: 'hidden',\n      zIndex,\n      backgroundColor\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        display: isImageLoaded ? 'block' : 'none'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 443,\n      columnNumber: 3\n    }, this), !isImageLoaded && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        backgroundColor\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 457,\n      columnNumber: 5\n    }, this), children && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: 'relative',\n        zIndex: 1,\n        width: '100%',\n        height: '100%'\n      },\n      children: children\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 471,\n      columnNumber: 5\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 432,\n    columnNumber: 1\n  }, this);\n};\n_s(SlidingBackground, \"vWZJJVrjvNoML1WnZZQmXhgYZbQ=\");\n_c = SlidingBackground;\nexport default SlidingBackground;\nvar _c;\n$RefreshReg$(_c, \"SlidingBackground\");","map":{"version":3,"names":["withOpacity","color","opacity","startsWith","r","g","b","length","parseInt","substring","replace","React","useRef","useEffect","useState","useCallback","jsxDEV","_jsxDEV","SlidingBackground","image","position","height","parallaxFactor","backgroundColor","zIndex","fadeSize","children","_s","containerRef","canvasRef","imageRef","rafRef","targetScrollY","currentScrollY","dimensions","setDimensions","width","isImageLoaded","setIsImageLoaded","imageAspect","setImageAspect","calculateDimensions","current","rect","getBoundingClientRect","img","Image","crossOrigin","onload","onerror","err","console","error","src","handleResize","renderCanvas","window","addEventListener","removeEventListener","canvas","dpr","devicePixelRatio","style","ctx","getContext","scale","animateScroll","ease","delta","Math","abs","requestAnimationFrame","renderWidth","renderHeight","clearRect","parallaxOffset","canvasAspect","drawWidth","drawHeight","offsetX","offsetY","globalAlpha","drawImage","addPainterlyNoise","x","y","intensity","noise","sin","fadeTopHeight","floor","fadeBottomHeight","shouldFadeTop","shouldFadeBottom","patternCanvas","document","createElement","patternSize","patternCtx","patternGradient","createLinearGradient","addColorStop","fillStyle","fillRect","patternData","getImageData","pixels","data","noiseIntensity","idx","alpha","max","min","putImageData","globalCompositeOperation","strokeCount","i","random","beginPath","ellipse","PI","fill","pattern","createPattern","save","scaleY","translate","restore","startY","handleScroll","scrollY","passive","cancelAnimationFrame","ref","overflow","top","left","display","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/effects/scrollingeffects/SlidingBackground.jsx"],"sourcesContent":["// Helper function to convert color to rgba with opacity\nconst withOpacity = (color, opacity) => {\n  // Handle hex colors\n  if (color.startsWith('#')) {\n    // Convert hex to rgb\n    let r = 0, g = 0, b = 0;\n    \n    // Handle #RGB format\n    if (color.length === 4) {\n      r = parseInt(color[1] + color[1], 16);\n      g = parseInt(color[2] + color[2], 16);\n      b = parseInt(color[3] + color[3], 16);\n    } \n    // Handle #RRGGBB format\n    else if (color.length === 7) {\n      r = parseInt(color.substring(1, 3), 16);\n      g = parseInt(color.substring(3, 5), 16);\n      b = parseInt(color.substring(5, 7), 16);\n    }\n    \n    return `rgba(${r}, ${g}, ${b}, ${opacity})`;\n  }\n  \n  // Handle rgb/rgba colors\n  if (color.startsWith('rgb')) {\n    // If already rgba, replace the opacity\n    if (color.startsWith('rgba')) {\n      return color.replace(/rgba\\((.+?),\\s*[\\d.]+\\)/, `rgba($1, ${opacity})`);\n    }\n    // Convert rgb to rgba\n    return color.replace(/rgb\\((.+?)\\)/, `rgba($1, ${opacity})`);\n  }\n  \n  // Handle named colors by using a semi-transparent black as fallback\n  return `rgba(0, 0, 0, ${opacity})`;\n};import React, { useRef, useEffect, useState, useCallback } from 'react';\n\n/**\n* PainterlyBackground Component\n* \n* A smooth, high-quality background component with painterly fade effects and \n* fluid parallax scrolling that properly handles high-resolution images.\n* \n* @param {Object} props - Component props\n* @param {string} props.image - URL of the background image\n* @param {string} [props.position='top'] - Position of the focused area ('top', 'middle', 'bottom')\n* @param {string|number} [props.height='33vh'] - Height of the component\n* @param {number} [props.parallaxFactor=0.4] - How much the image moves relative to scroll (lower = smoother)\n* @param {string} [props.backgroundColor='#000'] - Background color\n* @param {number} [props.zIndex=0] - z-index of the component\n* @param {number} [props.fadeSize=0.4] - Size of the fade effect (0-1)\n* @param {number} [props.opacity=1] - Overall opacity of the component\n* @param {React.ReactNode} [props.children] - Content to render on top of the background\n*/\nconst SlidingBackground = ({\nimage,\nposition = 'top',\nheight = '33vh',\nparallaxFactor = 0.4,\nbackgroundColor = '#000',\nzIndex = 0,\nfadeSize = 0.4,\nopacity = 1,\nchildren\n}) => {\n// Refs\nconst containerRef = useRef(null);\nconst canvasRef = useRef(null);\nconst imageRef = useRef(null);\nconst rafRef = useRef(null);\nconst targetScrollY = useRef(0);\nconst currentScrollY = useRef(0);\n\n// State\nconst [dimensions, setDimensions] = useState({ width: 0, height: 0 });\nconst [isImageLoaded, setIsImageLoaded] = useState(false);\nconst [imageAspect, setImageAspect] = useState(0);\n\n// Calculate dimensions for the image and canvas\nconst calculateDimensions = useCallback(() => {\nif (!containerRef.current) return;\n\nconst rect = containerRef.current.getBoundingClientRect();\nsetDimensions({\n  width: rect.width,\n  height: rect.height\n});\n}, []);\n\n// Load high-quality image with proper handling\nuseEffect(() => {\nconst img = new Image();\nimg.crossOrigin = \"Anonymous\";\n\nimg.onload = () => {\n  imageRef.current = img;\n  setImageAspect(img.width / img.height);\n  setIsImageLoaded(true);\n};\n\nimg.onerror = (err) => {\n  console.error(\"Failed to load image:\", err);\n};\n\nimg.src = image;\n\nreturn () => {\n  img.onload = null;\n  img.onerror = null;\n};\n}, [image]);\n\n// Set up canvas dimensions and handle resize\nuseEffect(() => {\ncalculateDimensions();\n\nconst handleResize = () => {\n  calculateDimensions();\n  \n  // Immediately render after resize to prevent flickering\n  if (isImageLoaded) {\n    renderCanvas();\n  }\n};\n\nwindow.addEventListener('resize', handleResize);\nreturn () => window.removeEventListener('resize', handleResize);\n}, [calculateDimensions, isImageLoaded]);\n\n// Update canvas based on current dimensions\nuseEffect(() => {\nif (canvasRef.current && dimensions.width && dimensions.height) {\n  const canvas = canvasRef.current;\n  const dpr = window.devicePixelRatio || 1;\n  \n  // Set display size\n  canvas.style.width = `${dimensions.width}px`;\n  canvas.style.height = `${dimensions.height}px`;\n  \n  // Set actual size with high DPR for retina displays\n  canvas.width = dimensions.width * dpr;\n  canvas.height = dimensions.height * dpr;\n  \n  // Scale all drawing operations for high DPR\n  const ctx = canvas.getContext('2d');\n  ctx.scale(dpr, dpr);\n}\n}, [dimensions]);\n\n// Smooth scroll animation using easing\nconst animateScroll = useCallback(() => {\n// LERP (Linear Interpolation) for smooth transitions\nconst ease = 0.08; // Lower = smoother but slower\n\n// Calculate new position with easing\nconst delta = targetScrollY.current - currentScrollY.current;\ncurrentScrollY.current += delta * ease;\n\n// Only render if changed enough to be visible\nif (Math.abs(delta) > 0.1) {\n  renderCanvas();\n  rafRef.current = requestAnimationFrame(animateScroll);\n} else {\n  // Snap to target when very close to avoid tiny movements\n  currentScrollY.current = targetScrollY.current;\n  renderCanvas();\n}\n}, [renderCanvas]);\n\n// Render the canvas with painterly effects\nconst renderCanvas = useCallback(() => {\nif (!canvasRef.current || !imageRef.current || !dimensions.width || !dimensions.height) return;\n\nconst canvas = canvasRef.current;\nconst ctx = canvas.getContext('2d');\nconst dpr = window.devicePixelRatio || 1;\n\n// Calculate the rendering context size (accounting for DPR)\nconst renderWidth = dimensions.width;\nconst renderHeight = dimensions.height;\n\n// Clear canvas\nctx.clearRect(0, 0, renderWidth, renderHeight);\n\n// Calculate parallax offset based on current interpolated scroll position\nconst parallaxOffset = currentScrollY.current * parallaxFactor;\n\n// Calculate image dimensions to maintain aspect ratio\nconst canvasAspect = renderWidth / renderHeight;\nlet drawWidth, drawHeight, offsetX, offsetY;\n\n// Ensure image covers the entire canvas with some overflow for parallax\nif (imageAspect > canvasAspect) {\n  // Image is wider than canvas (relative to height)\n  drawHeight = renderHeight * 1.1; // Add 10% to allow for parallax movement\n  drawWidth = drawHeight * imageAspect;\n  offsetX = (renderWidth - drawWidth) / 2;\n  offsetY = 0;\n} else {\n  // Image is taller than canvas (relative to width)\n  drawWidth = renderWidth * 1.1; // Add 10% to allow for parallax movement\n  drawHeight = drawWidth / imageAspect;\n  offsetX = 0;\n  offsetY = (renderHeight - drawHeight) / 2;\n}\n\n// Adjust based on position setting\nif (position === 'top') {\n  offsetY = 0;\n} else if (position === 'bottom') {\n  offsetY = renderHeight - drawHeight;\n} else if (position === 'middle') {\n  offsetY = (renderHeight - drawHeight) / 2;\n}\n\n// Apply parallax offset\noffsetY += parallaxOffset;\n\n// Global opacity\nctx.globalAlpha = opacity;\n\n// Draw the image\nctx.drawImage(imageRef.current, offsetX, offsetY, drawWidth, drawHeight);\n\n// Painterly noise texture function (creates organic texture)\nconst addPainterlyNoise = (x, y, intensity = 0.15) => {\n  // Use Perlin-like noise approximation for a more organic feel\n  const noise = Math.sin(x * 0.01) * Math.sin(y * 0.01) * \n               Math.sin(x * 0.02 + y * 0.03) * Math.sin(y * 0.02 + x * 0.01);\n  return noise * intensity;\n};\n\n// Painterly fade effects\nconst fadeTopHeight = Math.floor(renderHeight * fadeSize);\nconst fadeBottomHeight = Math.floor(renderHeight * fadeSize);\nconst shouldFadeTop = position === 'bottom' || position === 'middle';\nconst shouldFadeBottom = position === 'top' || position === 'middle';\n\n// Top fade with painterly effect\nif (shouldFadeTop) {\n  // Create a canvas pattern for painterly texture\n  const patternCanvas = document.createElement('canvas');\n  const patternSize = 256;\n  patternCanvas.width = patternSize;\n  patternCanvas.height = patternSize;\n  const patternCtx = patternCanvas.getContext('2d');\n  \n  // Create textured gradient\n  const patternGradient = patternCtx.createLinearGradient(0, 0, 0, patternSize);\n  patternGradient.addColorStop(0, backgroundColor);\n  patternGradient.addColorStop(0.65, withOpacity(backgroundColor, 0.7));\n  patternGradient.addColorStop(0.85, withOpacity(backgroundColor, 0.3));\n  patternGradient.addColorStop(1, withOpacity(backgroundColor, 0));\n  \n  // Add texture\n  patternCtx.fillStyle = patternGradient;\n  patternCtx.fillRect(0, 0, patternSize, patternSize);\n  \n  // Add noise to the pattern\n  const patternData = patternCtx.getImageData(0, 0, patternSize, patternSize);\n  const pixels = patternData.data;\n  \n  for (let y = 0; y < patternSize; y++) {\n    for (let x = 0; x < patternSize; x++) {\n      // Increase noise toward the bottom (where transparency begins)\n      const noiseIntensity = 0.1 + (y / patternSize) * 0.2;\n      const noise = addPainterlyNoise(x, y, noiseIntensity);\n      \n      const idx = (y * patternSize + x) * 4;\n      const alpha = pixels[idx + 3];\n      \n      // Only modify partially transparent pixels for better edge effect\n      if (alpha > 0 && alpha < 255) {\n        pixels[idx + 3] = Math.max(0, Math.min(255, alpha + noise * 40));\n      }\n    }\n  }\n  \n  patternCtx.putImageData(patternData, 0, 0);\n  \n  // Create brush stroke effect at the bottom edge\n  patternCtx.globalCompositeOperation = 'destination-out';\n  \n  // Draw some random \"brush strokes\" at the bottom\n  const strokeCount = 8;\n  for (let i = 0; i < strokeCount; i++) {\n    const x = (patternSize / strokeCount) * i + Math.random() * 20 - 10;\n    const y = patternSize * 0.8 + Math.random() * 20;\n    const width = patternSize / strokeCount * 1.2;\n    const height = Math.random() * 30 + 20;\n    \n    patternCtx.beginPath();\n    patternCtx.ellipse(x, y, width/2, height/2, 0, 0, Math.PI * 2);\n    patternCtx.fill();\n  }\n  \n  // Apply the pattern to the main canvas\n  const pattern = ctx.createPattern(patternCanvas, 'repeat-x');\n  ctx.save();\n  \n  // Scale the pattern to fit the fade area\n  const scaleY = fadeTopHeight / patternSize;\n  ctx.translate(0, 0);\n  ctx.scale(1, scaleY);\n  ctx.fillStyle = pattern;\n  ctx.fillRect(0, 0, renderWidth, fadeTopHeight / scaleY);\n  \n  ctx.restore();\n}\n\n// Bottom fade with painterly effect\nif (shouldFadeBottom) {\n  const startY = renderHeight - fadeBottomHeight;\n  \n  // Create a canvas pattern for painterly texture\n  const patternCanvas = document.createElement('canvas');\n  const patternSize = 256;\n  patternCanvas.width = patternSize;\n  patternCanvas.height = patternSize;\n  const patternCtx = patternCanvas.getContext('2d');\n  \n  // Create textured gradient\n  const patternGradient = patternCtx.createLinearGradient(0, 0, 0, patternSize);\n  patternGradient.addColorStop(0, withOpacity(backgroundColor, 0));\n  patternGradient.addColorStop(0.15, withOpacity(backgroundColor, 0.3));\n  patternGradient.addColorStop(0.35, withOpacity(backgroundColor, 0.7));\n  patternGradient.addColorStop(1, backgroundColor);\n  \n  // Add texture\n  patternCtx.fillStyle = patternGradient;\n  patternCtx.fillRect(0, 0, patternSize, patternSize);\n  \n  // Add noise to the pattern\n  const patternData = patternCtx.getImageData(0, 0, patternSize, patternSize);\n  const pixels = patternData.data;\n  \n  for (let y = 0; y < patternSize; y++) {\n    for (let x = 0; x < patternSize; x++) {\n      // Increase noise at the top (where transparency begins)\n      const noiseIntensity = 0.2 - (y / patternSize) * 0.15;\n      const noise = addPainterlyNoise(x, y, noiseIntensity);\n      \n      const idx = (y * patternSize + x) * 4;\n      const alpha = pixels[idx + 3];\n      \n      // Only modify partially transparent pixels for better edge effect\n      if (alpha > 0 && alpha < 255) {\n        pixels[idx + 3] = Math.max(0, Math.min(255, alpha + noise * 40));\n      }\n    }\n  }\n  \n  patternCtx.putImageData(patternData, 0, 0);\n  \n  // Create brush stroke effect at the top edge\n  patternCtx.globalCompositeOperation = 'destination-out';\n  \n  // Draw some random \"brush strokes\" at the top\n  const strokeCount = 8;\n  for (let i = 0; i < strokeCount; i++) {\n    const x = (patternSize / strokeCount) * i + Math.random() * 20 - 10;\n    const y = patternSize * 0.2 - Math.random() * 10;\n    const width = patternSize / strokeCount * 1.2;\n    const height = Math.random() * 25 + 15;\n    \n    patternCtx.beginPath();\n    patternCtx.ellipse(x, y, width/2, height/2, 0, 0, Math.PI * 2);\n    patternCtx.fill();\n  }\n  \n  // Apply the pattern to the main canvas\n  const pattern = ctx.createPattern(patternCanvas, 'repeat-x');\n  ctx.save();\n  \n  // Scale the pattern to fit the fade area\n  const scaleY = fadeBottomHeight / patternSize;\n  ctx.translate(0, startY);\n  ctx.scale(1, scaleY);\n  ctx.fillStyle = pattern;\n  ctx.fillRect(0, 0, renderWidth, patternSize);\n  \n  ctx.restore();\n}\n\n// For debugging: show the actual image area\n/*\nctx.strokeStyle = \"rgba(255,0,0,0.5)\";\nctx.lineWidth = 2;\nctx.strokeRect(offsetX, offsetY, drawWidth, drawHeight);\n*/\n}, [dimensions, parallaxFactor, position, backgroundColor, opacity, fadeSize, imageAspect]);\n\n// Scroll event handler using requestAnimationFrame for performance\nuseEffect(() => {\nconst handleScroll = () => {\n  targetScrollY.current = window.scrollY;\n  \n  // Only start animation if we're not already animating\n  if (!rafRef.current) {\n    rafRef.current = requestAnimationFrame(animateScroll);\n  }\n};\n\nwindow.addEventListener('scroll', handleScroll, { passive: true });\n\n// Initialize animation\ntargetScrollY.current = window.scrollY;\ncurrentScrollY.current = window.scrollY;\n\n// Initial render\nif (isImageLoaded) {\n  renderCanvas();\n}\n\nreturn () => {\n  window.removeEventListener('scroll', handleScroll);\n  if (rafRef.current) {\n    cancelAnimationFrame(rafRef.current);\n    rafRef.current = null;\n  }\n};\n}, [animateScroll, renderCanvas, isImageLoaded]);\n\n// Re-render when image loads\nuseEffect(() => {\nif (isImageLoaded) {\n  renderCanvas();\n}\n}, [isImageLoaded, renderCanvas]);\n\nreturn (\n<div\n  ref={containerRef}\n  style={{\n    position: 'relative',\n    width: '100%',\n    height,\n    overflow: 'hidden',\n    zIndex,\n    backgroundColor\n  }}\n>\n  <canvas\n    ref={canvasRef}\n    style={{\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      display: isImageLoaded ? 'block' : 'none'\n    }}\n  />\n  \n  {/* Loading state */}\n  {!isImageLoaded && (\n    <div\n      style={{\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        backgroundColor\n      }}\n    />\n  )}\n  \n  {/* Content container */}\n  {children && (\n    <div\n      style={{\n        position: 'relative',\n        zIndex: 1,\n        width: '100%',\n        height: '100%'\n      }}\n    >\n      {children}\n    </div>\n  )}\n</div>\n);\n};\n\nexport default SlidingBackground;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}