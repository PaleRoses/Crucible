{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/Background.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect, useCallback } from 'react';\n\n/**\n * Background Component\n * \n * Creates an immersive infinite stellar background that generates new stars\n * as the user scrolls down the page, with realistic stellar rendering.\n * \n * Features:\n * - Infinite star field that spans the entire document height\n * - New stars are generated as the user scrolls down\n * - Realistic star rendering with proper glow effects\n * - Extremely subtle parallax effect on scroll\n * - Optimized for performance across devices\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Background = () => {\n  _s();\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const documentHeightRef = useRef(0);\n  const visibleAreaRef = useRef({\n    top: 0,\n    bottom: 0\n  });\n  const starMapRef = useRef(new Map());\n  const animationFrameRef = useRef(null);\n  const lastTimeRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n\n  // Component state\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0,\n    pixelRatio: 1\n  });\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n\n  // Configuration wrapped in useMemo to prevent unnecessary re-renders\n  const CONFIG = useMemo(() => ({\n    // Star parameters\n    starDensity: 0.0001,\n    // Stars per pixel area\n    cellSize: 500,\n    // Size of star generation cells\n    bufferCells: 1,\n    // Buffer cells outside visible area\n    starSizeMin: 0.8,\n    starSizeMax: 2.5,\n    starOpacityMin: 0.15,\n    starOpacityMax: 0.85,\n    // Motion and animation\n    baseMovementSpeed: 0.00015,\n    // Very subtle movement\n    pulseFrequency: 0.00004,\n    // Slower pulsing\n    pulseIntensity: 0.25,\n    // Subtle pulse\n\n    // Parallax effect\n    parallaxIntensity: 0.04,\n    // Extremely subtle parallax\n\n    // Performance parameters\n    maxFPS: 30,\n    useGlow: true\n  }), []);\n\n  // Warm, golden color palette wrapped in useMemo\n  const COLORS = useMemo(() => ({\n    // Main star colors (warm golden tones)\n    stars: ['rgba(255, 243, 200, alpha)',\n    // Warm yellow\n    'rgba(255, 231, 164, alpha)',\n    // Golden\n    'rgba(255, 236, 179, alpha)',\n    // Pale gold\n    'rgba(252, 249, 231, alpha)',\n    // Off-white gold\n    'rgba(255, 225, 205, alpha)' // Warm white (slight orange)\n    ],\n    // Background gradient colors\n    background: {\n      topColor: 'rgb(8, 8, 12)',\n      bottomColor: 'rgb(15, 15, 20)'\n    }\n  }), []);\n\n  // Get color with opacity\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    return baseColor.replace(/alpha\\)$/, `${safeOpacity})`);\n  }, []);\n\n  // Detect reduced motion preference\n  useEffect(() => {\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    const handleReducedMotionChange = e => {\n      setPrefersReducedMotion(e.matches);\n    };\n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n    };\n  }, []);\n\n  // Get the current document height\n  const updateDocumentHeight = useCallback(() => {\n    const documentHeight = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);\n    documentHeightRef.current = documentHeight;\n\n    // Update container height if needed\n    if (containerRef.current) {\n      containerRef.current.style.height = `${documentHeight}px`;\n    }\n  }, []);\n\n  // Track scroll position for parallax and star generation\n  useEffect(() => {\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n\n      // Update visible area\n      const viewportHeight = window.innerHeight;\n      visibleAreaRef.current = {\n        top: window.scrollY,\n        bottom: window.scrollY + viewportHeight\n      };\n\n      // Generate stars for newly visible areas\n      generateStarsForVisibleArea();\n    };\n    const handleResize = () => {\n      // Update document height on resize\n      updateDocumentHeight();\n\n      // Update canvas dimensions\n      setupCanvas();\n\n      // Reset visible area\n      const viewportHeight = window.innerHeight;\n      visibleAreaRef.current = {\n        top: window.scrollY,\n        bottom: window.scrollY + viewportHeight\n      };\n\n      // Clear existing stars and regenerate\n      starMapRef.current.clear();\n      generateStarsForVisibleArea();\n    };\n    window.addEventListener('scroll', handleScroll, {\n      passive: true\n    });\n    window.addEventListener('resize', handleResize);\n\n    // Initial call\n    updateDocumentHeight();\n    handleScroll();\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n      window.removeEventListener('resize', handleResize);\n    };\n  }, [updateDocumentHeight]);\n\n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) return false;\n    const canvas = canvasRef.current;\n\n    // Get viewport dimensions\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const pixelRatio = window.devicePixelRatio || 1;\n\n    // Set canvas size accounting for pixel ratio\n    canvas.width = width * pixelRatio;\n    canvas.height = height * pixelRatio;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n\n    // Update dimensions state\n    setDimensions({\n      width,\n      height,\n      pixelRatio\n    });\n    return true;\n  }, []);\n\n  // Generate a deterministic random number based on input coordinates\n  const seededRandom = useCallback((x, y, seed = 1) => {\n    const dot = x * 12.9898 + y * 78.233 + seed;\n    return Math.sin(dot) * 43758.5453 % 1;\n  }, []);\n\n  // Generate stars for a specific cell\n  const generateStarsForCell = useCallback((cellX, cellY) => {\n    const cellKey = `${cellX},${cellY}`;\n\n    // Check if we already generated stars for this cell\n    if (starMapRef.current.has(cellKey)) {\n      return starMapRef.current.get(cellKey);\n    }\n    const stars = [];\n    const cellWidth = CONFIG.cellSize;\n    const cellHeight = CONFIG.cellSize;\n    const startX = cellX * cellWidth;\n    const startY = cellY * cellHeight;\n\n    // Calculate how many stars based on density\n    const starCount = Math.floor(cellWidth * cellHeight * CONFIG.starDensity);\n\n    // Create stars with deterministic positions based on cell coordinates\n    for (let i = 0; i < starCount; i++) {\n      // Use seeded random for deterministic star placement\n      const rx = seededRandom(cellX, i, 1);\n      const ry = seededRandom(cellY, i, 2);\n      const rz = seededRandom(cellX, cellY, i * 3);\n      const star = {};\n\n      // Position within cell\n      star.x = startX + rx * cellWidth;\n      star.y = startY + ry * cellHeight;\n      star.z = rz * 0.8 + 0.1; // Depth (0.1 to 0.9)\n\n      // Visual properties with seeded random\n      star.size = (seededRandom(cellX, i, 4) * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n      star.baseOpacity = seededRandom(cellX, i, 5) * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n      star.opacity = star.baseOpacity;\n\n      // Animation properties\n      star.pulsePhase = seededRandom(cellX, i, 6) * Math.PI * 2;\n      star.pulseSpeed = seededRandom(cellX, i, 7) * 0.002 + 0.001;\n\n      // Motion properties - very subtle\n      star.movementX = (seededRandom(cellX, i, 8) * 2 - 1) * CONFIG.baseMovementSpeed;\n      star.movementY = (seededRandom(cellX, i, 9) * 2 - 1) * CONFIG.baseMovementSpeed;\n      star.initialX = star.x;\n      star.initialY = star.y;\n\n      // Star shape properties - add variation for more realistic stars\n      star.rays = seededRandom(cellX, i, 10) > 0.7 ? Math.floor(seededRandom(cellX, i, 11) * 2) + 4 : 0;\n      star.rayLength = star.size * (seededRandom(cellX, i, 12) * 0.7 + 0.3);\n      star.rayIntensity = seededRandom(cellX, i, 13) * 0.4 + 0.3;\n\n      // Color variation\n      const colorIndex = Math.floor(seededRandom(cellX, i, 14) * COLORS.stars.length);\n      star.color = COLORS.stars[colorIndex];\n      stars.push(star);\n    }\n\n    // Store in map\n    starMapRef.current.set(cellKey, stars);\n    return stars;\n  }, [CONFIG, COLORS.stars, seededRandom]);\n\n  // Generate stars for the visible area and buffer\n  const generateStarsForVisibleArea = useCallback(() => {\n    if (!isInitialized) return;\n    const {\n      top,\n      bottom\n    } = visibleAreaRef.current;\n\n    // Calculate which cells are visible\n    const startCellY = Math.floor(top / CONFIG.cellSize) - CONFIG.bufferCells;\n    const endCellY = Math.ceil(bottom / CONFIG.cellSize) + CONFIG.bufferCells;\n\n    // Width cells (always visible)\n    const startCellX = 0;\n    const endCellX = Math.ceil(dimensions.width / CONFIG.cellSize);\n\n    // Generate stars for all visible cells\n    for (let y = startCellY; y <= endCellY; y++) {\n      for (let x = startCellX; x < endCellX; x++) {\n        generateStarsForCell(x, y);\n      }\n    }\n  }, [isInitialized, dimensions.width, CONFIG.cellSize, CONFIG.bufferCells, generateStarsForCell]);\n\n  // Get all visible stars\n  const getVisibleStars = useCallback(() => {\n    const visibleStars = [];\n    const buffer = dimensions.height; // Extra buffer to account for parallax\n\n    // Calculate which cells could be visible\n    const startCellY = Math.floor((visibleAreaRef.current.top - buffer) / CONFIG.cellSize);\n    const endCellY = Math.ceil((visibleAreaRef.current.bottom + buffer) / CONFIG.cellSize);\n    const startCellX = 0;\n    const endCellX = Math.ceil(dimensions.width / CONFIG.cellSize);\n\n    // Collect stars from all potentially visible cells\n    for (let y = startCellY; y <= endCellY; y++) {\n      for (let x = startCellX; x < endCellX; x++) {\n        const cellKey = `${x},${y}`;\n        if (starMapRef.current.has(cellKey)) {\n          visibleStars.push(...starMapRef.current.get(cellKey));\n        }\n      }\n    }\n    return visibleStars;\n  }, [dimensions.height, dimensions.width, CONFIG.cellSize]);\n\n  // Update animation state\n  const updateAnimation = useCallback((deltaTime, timestamp) => {\n    // Global time factor for animations\n    const timeFactor = timestamp * 0.001;\n\n    // Parallax effect from scroll - extremely subtle\n    const parallaxOffset = scrollPositionRef.current * CONFIG.parallaxIntensity;\n\n    // Motion dampening for reduced motion preference\n    const motionFactor = prefersReducedMotion ? 0.1 : 1;\n\n    // Get all visible stars\n    const visibleStars = getVisibleStars();\n\n    // Update stars\n    for (let i = 0; i < visibleStars.length; i++) {\n      const star = visibleStars[i];\n\n      // Small positional oscillation around initial position\n      star.x = star.initialX + Math.sin(timeFactor * 0.2 + star.pulsePhase) * 0.5 * motionFactor;\n      star.y = star.initialY + Math.cos(timeFactor * 0.3 + star.pulsePhase * 1.3) * 0.5 * motionFactor;\n\n      // Apply parallax offset based on depth (z) - extremely subtle\n      const starParallax = parallaxOffset * (1 - star.z) * 0.5;\n      star.parallaxY = starParallax;\n\n      // Subtle pulsing effect - more natural by combining multiple sine waves\n      const pulseFactor = (Math.sin(timeFactor * star.pulseSpeed + star.pulsePhase) * 0.5 + Math.sin(timeFactor * star.pulseSpeed * 0.4 + star.pulsePhase * 1.3) * 0.3) * 0.15 + 0.85;\n      star.opacity = star.baseOpacity * pulseFactor;\n\n      // Vary ray intensity based on pulse\n      if (star.rays > 0) {\n        star.currentRayIntensity = star.rayIntensity * pulseFactor;\n      }\n    }\n  }, [CONFIG.parallaxIntensity, prefersReducedMotion, getVisibleStars]);\n\n  // Render a more realistic star with optional rays\n  const drawStar = useCallback((ctx, star, y) => {\n    // Skip stars that are far outside the visible area (accounting for parallax)\n    if (y < visibleAreaRef.current.top - 50 || y > visibleAreaRef.current.bottom + 50) {\n      return;\n    }\n\n    // Ensure we have positive values to prevent \"Negative radius\" errors\n    const glowRadius = Math.max(0.1, star.size * 2);\n    try {\n      // Draw outer glow for all stars\n      const gradient = ctx.createRadialGradient(star.x, y, 0, star.x, y, glowRadius);\n      gradient.addColorStop(0, getColor(star.color, star.opacity * 0.9));\n      gradient.addColorStop(0.5, getColor(star.color, star.opacity * 0.3));\n      gradient.addColorStop(1, getColor(star.color, 0));\n      ctx.beginPath();\n      ctx.fillStyle = gradient;\n      ctx.arc(star.x, y, glowRadius, 0, Math.PI * 2);\n      ctx.fill();\n\n      // Draw bright core\n      ctx.beginPath();\n      ctx.fillStyle = getColor(star.color, star.opacity);\n      ctx.arc(star.x, y, Math.max(0.1, star.size * 0.5), 0, Math.PI * 2);\n      ctx.fill();\n\n      // Draw rays for some stars\n      if (star.rays > 0 && star.opacity > 0.3) {\n        ctx.save();\n        ctx.translate(star.x, y);\n        ctx.rotate(Math.sin(Date.now() * 0.0001) * 0.05); // Very slight rotation\n\n        for (let i = 0; i < star.rays; i++) {\n          const angle = i / star.rays * Math.PI * 2;\n          const rayLength = Math.max(0.1, star.rayLength * (0.7 + Math.sin(Date.now() * 0.001 + i) * 0.3));\n          ctx.beginPath();\n          ctx.moveTo(0, 0);\n          ctx.lineTo(Math.cos(angle) * rayLength, Math.sin(angle) * rayLength);\n\n          // Create gradient for ray\n          const rayGradient = ctx.createLinearGradient(0, 0, Math.cos(angle) * rayLength, Math.sin(angle) * rayLength);\n          rayGradient.addColorStop(0, getColor(star.color, star.opacity * 0.9));\n          rayGradient.addColorStop(1, getColor(star.color, 0));\n          ctx.strokeStyle = rayGradient;\n          ctx.lineWidth = Math.max(0.1, star.size * 0.3);\n          ctx.stroke();\n        }\n        ctx.restore();\n      }\n    } catch (error) {\n      // Silently handle any canvas drawing errors\n      // This prevents errors from breaking the entire component\n    }\n  }, [getColor]);\n\n  // Render the scene\n  const renderScene = useCallback(() => {\n    if (!canvasRef.current) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Apply device pixel ratio scaling\n    ctx.setTransform(dimensions.pixelRatio, 0, 0, dimensions.pixelRatio, 0, 0);\n\n    // Clear canvas\n    ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n\n    // Draw background gradient\n    const gradient = ctx.createLinearGradient(0, 0, 0, dimensions.height);\n    gradient.addColorStop(0, COLORS.background.topColor);\n    gradient.addColorStop(1, COLORS.background.bottomColor);\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, dimensions.width, dimensions.height);\n\n    // Enable global composition for better glow effect\n    ctx.globalCompositeOperation = 'lighter';\n\n    // Get all visible stars\n    const visibleStars = getVisibleStars();\n\n    // Draw stars\n    for (const star of visibleStars) {\n      // Skip almost invisible stars\n      if (star.opacity < 0.02) continue;\n\n      // Calculate screen position based on scroll\n      // Adjust y position relative to canvas (which is fixed to the viewport)\n      const screenY = star.y - visibleAreaRef.current.top + (star.parallaxY || 0);\n\n      // Only render stars that are visible in the viewport plus a small buffer\n      if (screenY >= -50 && screenY <= dimensions.height + 50) {\n        // Draw star with enhanced rendering\n        drawStar(ctx, star, screenY);\n      }\n    }\n\n    // Reset global composition\n    ctx.globalCompositeOperation = 'source-over';\n  }, [dimensions, COLORS, getVisibleStars, drawStar]);\n\n  // Main animation loop\n  const animate = useCallback(timestamp => {\n    if (!isInitialized) {\n      animationFrameRef.current = requestAnimationFrame(animate);\n      return;\n    }\n\n    // Calculate delta time with cap to prevent large jumps\n    const deltaTime = lastTimeRef.current ? Math.min(timestamp - lastTimeRef.current, 33) : 16;\n    lastTimeRef.current = timestamp;\n\n    // Update animation state\n    updateAnimation(deltaTime, timestamp);\n\n    // Render scene\n    renderScene();\n\n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(animate);\n  }, [isInitialized, updateAnimation, renderScene]);\n\n  // Initialize component on mount\n  useEffect(() => {\n    // Initialize canvas\n    const canvasInitialized = setupCanvas();\n    if (canvasInitialized) {\n      // Set initial viewport\n      const viewportHeight = window.innerHeight;\n      visibleAreaRef.current = {\n        top: window.scrollY,\n        bottom: window.scrollY + viewportHeight\n      };\n\n      // Update document height\n      updateDocumentHeight();\n\n      // Generate initial stars\n      generateStarsForVisibleArea();\n      setIsInitialized(true);\n    }\n  }, [setupCanvas, updateDocumentHeight, generateStarsForVisibleArea]);\n\n  // Start animation loop\n  useEffect(() => {\n    if (!isInitialized) return;\n\n    // Start animation\n    animationFrameRef.current = requestAnimationFrame(animate);\n\n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [isInitialized, animate]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      // Will be updated to full document height\n      overflow: 'hidden',\n      zIndex: -1,\n      pointerEvents: 'none'\n    },\n    \"aria-hidden\": \"true\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'fixed',\n        // Canvas stays fixed but renders content based on scroll\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 531,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 517,\n    columnNumber: 5\n  }, this);\n};\n_s(Background, \"+ZDLn0Cat3FKlHl70azrN5GQ+pQ=\");\n_c = Background;\nexport default Background;\nvar _c;\n$RefreshReg$(_c, \"Background\");","map":{"version":3,"names":["React","useRef","useState","useEffect","useCallback","jsxDEV","_jsxDEV","Background","_s","containerRef","canvasRef","documentHeightRef","visibleAreaRef","top","bottom","starMapRef","Map","animationFrameRef","lastTimeRef","scrollPositionRef","dimensions","setDimensions","width","height","pixelRatio","isInitialized","setIsInitialized","prefersReducedMotion","setPrefersReducedMotion","CONFIG","useMemo","starDensity","cellSize","bufferCells","starSizeMin","starSizeMax","starOpacityMin","starOpacityMax","baseMovementSpeed","pulseFrequency","pulseIntensity","parallaxIntensity","maxFPS","useGlow","COLORS","stars","background","topColor","bottomColor","getColor","baseColor","opacity","safeOpacity","Math","max","min","replace","reducedMotionQuery","window","matchMedia","matches","handleReducedMotionChange","e","addEventListener","removeEventListener","updateDocumentHeight","documentHeight","document","body","scrollHeight","offsetHeight","documentElement","clientHeight","current","style","handleScroll","scrollY","viewportHeight","innerHeight","generateStarsForVisibleArea","handleResize","setupCanvas","clear","passive","canvas","innerWidth","devicePixelRatio","seededRandom","x","y","seed","dot","sin","generateStarsForCell","cellX","cellY","cellKey","has","get","cellWidth","cellHeight","startX","startY","starCount","floor","i","rx","ry","rz","star","z","size","baseOpacity","pulsePhase","PI","pulseSpeed","movementX","movementY","initialX","initialY","rays","rayLength","rayIntensity","colorIndex","length","color","push","set","startCellY","endCellY","ceil","startCellX","endCellX","getVisibleStars","visibleStars","buffer","updateAnimation","deltaTime","timestamp","timeFactor","parallaxOffset","motionFactor","cos","starParallax","parallaxY","pulseFactor","currentRayIntensity","drawStar","ctx","glowRadius","gradient","createRadialGradient","addColorStop","beginPath","fillStyle","arc","fill","save","translate","rotate","Date","now","angle","moveTo","lineTo","rayGradient","createLinearGradient","strokeStyle","lineWidth","stroke","restore","error","renderScene","getContext","setTransform","clearRect","fillRect","globalCompositeOperation","screenY","animate","requestAnimationFrame","canvasInitialized","cancelAnimationFrame","ref","position","left","overflow","zIndex","pointerEvents","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/Background.jsx"],"sourcesContent":["import React, { useRef, useState, useEffect, useCallback } from 'react';\n\n/**\n * Background Component\n * \n * Creates an immersive infinite stellar background that generates new stars\n * as the user scrolls down the page, with realistic stellar rendering.\n * \n * Features:\n * - Infinite star field that spans the entire document height\n * - New stars are generated as the user scrolls down\n * - Realistic star rendering with proper glow effects\n * - Extremely subtle parallax effect on scroll\n * - Optimized for performance across devices\n */\nconst Background = () => {\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const documentHeightRef = useRef(0);\n  const visibleAreaRef = useRef({ top: 0, bottom: 0 });\n  const starMapRef = useRef(new Map());\n  const animationFrameRef = useRef(null);\n  const lastTimeRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n  \n  // Component state\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0, pixelRatio: 1 });\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  \n  // Configuration wrapped in useMemo to prevent unnecessary re-renders\n  const CONFIG = useMemo(() => ({\n    // Star parameters\n    starDensity: 0.0001,    // Stars per pixel area\n    cellSize: 500,          // Size of star generation cells\n    bufferCells: 1,         // Buffer cells outside visible area\n    starSizeMin: 0.8,\n    starSizeMax: 2.5,\n    starOpacityMin: 0.15,\n    starOpacityMax: 0.85,\n    \n    // Motion and animation\n    baseMovementSpeed: 0.00015,  // Very subtle movement\n    pulseFrequency: 0.00004,     // Slower pulsing\n    pulseIntensity: 0.25,        // Subtle pulse\n    \n    // Parallax effect\n    parallaxIntensity: 0.04,     // Extremely subtle parallax\n    \n    // Performance parameters\n    maxFPS: 30,\n    useGlow: true\n  }), []);\n  \n  // Warm, golden color palette wrapped in useMemo\n  const COLORS = useMemo(() => ({\n    // Main star colors (warm golden tones)\n    stars: [\n      'rgba(255, 243, 200, alpha)', // Warm yellow\n      'rgba(255, 231, 164, alpha)', // Golden\n      'rgba(255, 236, 179, alpha)', // Pale gold\n      'rgba(252, 249, 231, alpha)', // Off-white gold\n      'rgba(255, 225, 205, alpha)'  // Warm white (slight orange)\n    ],\n    \n    // Background gradient colors\n    background: {\n      topColor: 'rgb(8, 8, 12)',\n      bottomColor: 'rgb(15, 15, 20)'\n    }\n  }), []);\n  \n  // Get color with opacity\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    return baseColor.replace(/alpha\\)$/, `${safeOpacity})`);\n  }, []);\n  \n  // Detect reduced motion preference\n  useEffect(() => {\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    \n    const handleReducedMotionChange = (e) => {\n      setPrefersReducedMotion(e.matches);\n    };\n    \n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n    \n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n    };\n  }, []);\n  \n  // Get the current document height\n  const updateDocumentHeight = useCallback(() => {\n    const documentHeight = Math.max(\n      document.body.scrollHeight,\n      document.body.offsetHeight,\n      document.documentElement.clientHeight,\n      document.documentElement.scrollHeight,\n      document.documentElement.offsetHeight\n    );\n    documentHeightRef.current = documentHeight;\n    \n    // Update container height if needed\n    if (containerRef.current) {\n      containerRef.current.style.height = `${documentHeight}px`;\n    }\n  }, []);\n  \n  // Track scroll position for parallax and star generation\n  useEffect(() => {\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n      \n      // Update visible area\n      const viewportHeight = window.innerHeight;\n      visibleAreaRef.current = {\n        top: window.scrollY,\n        bottom: window.scrollY + viewportHeight\n      };\n      \n      // Generate stars for newly visible areas\n      generateStarsForVisibleArea();\n    };\n    \n    const handleResize = () => {\n      // Update document height on resize\n      updateDocumentHeight();\n      \n      // Update canvas dimensions\n      setupCanvas();\n      \n      // Reset visible area\n      const viewportHeight = window.innerHeight;\n      visibleAreaRef.current = {\n        top: window.scrollY,\n        bottom: window.scrollY + viewportHeight\n      };\n      \n      // Clear existing stars and regenerate\n      starMapRef.current.clear();\n      generateStarsForVisibleArea();\n    };\n    \n    window.addEventListener('scroll', handleScroll, { passive: true });\n    window.addEventListener('resize', handleResize);\n    \n    // Initial call\n    updateDocumentHeight();\n    handleScroll();\n    \n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n      window.removeEventListener('resize', handleResize);\n    };\n  }, [updateDocumentHeight]);\n  \n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) return false;\n    \n    const canvas = canvasRef.current;\n    \n    // Get viewport dimensions\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const pixelRatio = window.devicePixelRatio || 1;\n    \n    // Set canvas size accounting for pixel ratio\n    canvas.width = width * pixelRatio;\n    canvas.height = height * pixelRatio;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n    \n    // Update dimensions state\n    setDimensions({\n      width,\n      height,\n      pixelRatio\n    });\n    \n    return true;\n  }, []);\n  \n  // Generate a deterministic random number based on input coordinates\n  const seededRandom = useCallback((x, y, seed = 1) => {\n    const dot = x * 12.9898 + y * 78.233 + seed;\n    return (Math.sin(dot) * 43758.5453) % 1;\n  }, []);\n  \n  // Generate stars for a specific cell\n  const generateStarsForCell = useCallback((cellX, cellY) => {\n    const cellKey = `${cellX},${cellY}`;\n    \n    // Check if we already generated stars for this cell\n    if (starMapRef.current.has(cellKey)) {\n      return starMapRef.current.get(cellKey);\n    }\n    \n    const stars = [];\n    const cellWidth = CONFIG.cellSize;\n    const cellHeight = CONFIG.cellSize;\n    const startX = cellX * cellWidth;\n    const startY = cellY * cellHeight;\n    \n    // Calculate how many stars based on density\n    const starCount = Math.floor(cellWidth * cellHeight * CONFIG.starDensity);\n    \n    // Create stars with deterministic positions based on cell coordinates\n    for (let i = 0; i < starCount; i++) {\n      // Use seeded random for deterministic star placement\n      const rx = seededRandom(cellX, i, 1);\n      const ry = seededRandom(cellY, i, 2);\n      const rz = seededRandom(cellX, cellY, i * 3);\n      \n      const star = {};\n      \n      // Position within cell\n      star.x = startX + rx * cellWidth;\n      star.y = startY + ry * cellHeight;\n      star.z = rz * 0.8 + 0.1; // Depth (0.1 to 0.9)\n      \n      // Visual properties with seeded random\n      star.size = (seededRandom(cellX, i, 4) * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n      star.baseOpacity = seededRandom(cellX, i, 5) * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n      star.opacity = star.baseOpacity;\n      \n      // Animation properties\n      star.pulsePhase = seededRandom(cellX, i, 6) * Math.PI * 2;\n      star.pulseSpeed = seededRandom(cellX, i, 7) * 0.002 + 0.001;\n      \n      // Motion properties - very subtle\n      star.movementX = (seededRandom(cellX, i, 8) * 2 - 1) * CONFIG.baseMovementSpeed;\n      star.movementY = (seededRandom(cellX, i, 9) * 2 - 1) * CONFIG.baseMovementSpeed;\n      star.initialX = star.x;\n      star.initialY = star.y;\n      \n      // Star shape properties - add variation for more realistic stars\n      star.rays = seededRandom(cellX, i, 10) > 0.7 ? Math.floor(seededRandom(cellX, i, 11) * 2) + 4 : 0;\n      star.rayLength = star.size * (seededRandom(cellX, i, 12) * 0.7 + 0.3);\n      star.rayIntensity = seededRandom(cellX, i, 13) * 0.4 + 0.3;\n      \n      // Color variation\n      const colorIndex = Math.floor(seededRandom(cellX, i, 14) * COLORS.stars.length);\n      star.color = COLORS.stars[colorIndex];\n      \n      stars.push(star);\n    }\n    \n    // Store in map\n    starMapRef.current.set(cellKey, stars);\n    \n    return stars;\n  }, [CONFIG, COLORS.stars, seededRandom]);\n  \n  // Generate stars for the visible area and buffer\n  const generateStarsForVisibleArea = useCallback(() => {\n    if (!isInitialized) return;\n    \n    const { top, bottom } = visibleAreaRef.current;\n    \n    // Calculate which cells are visible\n    const startCellY = Math.floor(top / CONFIG.cellSize) - CONFIG.bufferCells;\n    const endCellY = Math.ceil(bottom / CONFIG.cellSize) + CONFIG.bufferCells;\n    \n    // Width cells (always visible)\n    const startCellX = 0;\n    const endCellX = Math.ceil(dimensions.width / CONFIG.cellSize);\n    \n    // Generate stars for all visible cells\n    for (let y = startCellY; y <= endCellY; y++) {\n      for (let x = startCellX; x < endCellX; x++) {\n        generateStarsForCell(x, y);\n      }\n    }\n  }, [isInitialized, dimensions.width, CONFIG.cellSize, CONFIG.bufferCells, generateStarsForCell]);\n  \n  // Get all visible stars\n  const getVisibleStars = useCallback(() => {\n    const visibleStars = [];\n    const buffer = dimensions.height; // Extra buffer to account for parallax\n    \n    // Calculate which cells could be visible\n    const startCellY = Math.floor((visibleAreaRef.current.top - buffer) / CONFIG.cellSize);\n    const endCellY = Math.ceil((visibleAreaRef.current.bottom + buffer) / CONFIG.cellSize);\n    const startCellX = 0;\n    const endCellX = Math.ceil(dimensions.width / CONFIG.cellSize);\n    \n    // Collect stars from all potentially visible cells\n    for (let y = startCellY; y <= endCellY; y++) {\n      for (let x = startCellX; x < endCellX; x++) {\n        const cellKey = `${x},${y}`;\n        if (starMapRef.current.has(cellKey)) {\n          visibleStars.push(...starMapRef.current.get(cellKey));\n        }\n      }\n    }\n    \n    return visibleStars;\n  }, [dimensions.height, dimensions.width, CONFIG.cellSize]);\n  \n  // Update animation state\n  const updateAnimation = useCallback((deltaTime, timestamp) => {\n    // Global time factor for animations\n    const timeFactor = timestamp * 0.001;\n    \n    // Parallax effect from scroll - extremely subtle\n    const parallaxOffset = scrollPositionRef.current * CONFIG.parallaxIntensity;\n    \n    // Motion dampening for reduced motion preference\n    const motionFactor = prefersReducedMotion ? 0.1 : 1;\n    \n    // Get all visible stars\n    const visibleStars = getVisibleStars();\n    \n    // Update stars\n    for (let i = 0; i < visibleStars.length; i++) {\n      const star = visibleStars[i];\n      \n      // Small positional oscillation around initial position\n      star.x = star.initialX + Math.sin(timeFactor * 0.2 + star.pulsePhase) * 0.5 * motionFactor;\n      star.y = star.initialY + Math.cos(timeFactor * 0.3 + star.pulsePhase * 1.3) * 0.5 * motionFactor;\n      \n      // Apply parallax offset based on depth (z) - extremely subtle\n      const starParallax = parallaxOffset * (1 - star.z) * 0.5;\n      star.parallaxY = starParallax;\n      \n      // Subtle pulsing effect - more natural by combining multiple sine waves\n      const pulseFactor = (\n        Math.sin(timeFactor * star.pulseSpeed + star.pulsePhase) * 0.5 + \n        Math.sin(timeFactor * star.pulseSpeed * 0.4 + star.pulsePhase * 1.3) * 0.3\n      ) * 0.15 + 0.85;\n      \n      star.opacity = star.baseOpacity * pulseFactor;\n      \n      // Vary ray intensity based on pulse\n      if (star.rays > 0) {\n        star.currentRayIntensity = star.rayIntensity * pulseFactor;\n      }\n    }\n  }, [CONFIG.parallaxIntensity, prefersReducedMotion, getVisibleStars]);\n  \n  // Render a more realistic star with optional rays\n  const drawStar = useCallback((ctx, star, y) => {\n    // Skip stars that are far outside the visible area (accounting for parallax)\n    if (y < visibleAreaRef.current.top - 50 || y > visibleAreaRef.current.bottom + 50) {\n      return;\n    }\n    \n    // Ensure we have positive values to prevent \"Negative radius\" errors\n    const glowRadius = Math.max(0.1, star.size * 2);\n    \n    try {\n      // Draw outer glow for all stars\n      const gradient = ctx.createRadialGradient(star.x, y, 0, star.x, y, glowRadius);\n      gradient.addColorStop(0, getColor(star.color, star.opacity * 0.9));\n      gradient.addColorStop(0.5, getColor(star.color, star.opacity * 0.3));\n      gradient.addColorStop(1, getColor(star.color, 0));\n      \n      ctx.beginPath();\n      ctx.fillStyle = gradient;\n      ctx.arc(star.x, y, glowRadius, 0, Math.PI * 2);\n      ctx.fill();\n      \n      // Draw bright core\n      ctx.beginPath();\n      ctx.fillStyle = getColor(star.color, star.opacity);\n      ctx.arc(star.x, y, Math.max(0.1, star.size * 0.5), 0, Math.PI * 2);\n      ctx.fill();\n      \n      // Draw rays for some stars\n      if (star.rays > 0 && star.opacity > 0.3) {\n        ctx.save();\n        ctx.translate(star.x, y);\n        ctx.rotate(Math.sin(Date.now() * 0.0001) * 0.05); // Very slight rotation\n        \n        for (let i = 0; i < star.rays; i++) {\n          const angle = (i / star.rays) * Math.PI * 2;\n          const rayLength = Math.max(0.1, star.rayLength * (0.7 + Math.sin(Date.now() * 0.001 + i) * 0.3));\n          \n          ctx.beginPath();\n          ctx.moveTo(0, 0);\n          ctx.lineTo(Math.cos(angle) * rayLength, Math.sin(angle) * rayLength);\n          \n          // Create gradient for ray\n          const rayGradient = ctx.createLinearGradient(\n            0, 0,\n            Math.cos(angle) * rayLength, Math.sin(angle) * rayLength\n          );\n          rayGradient.addColorStop(0, getColor(star.color, star.opacity * 0.9));\n          rayGradient.addColorStop(1, getColor(star.color, 0));\n          \n          ctx.strokeStyle = rayGradient;\n          ctx.lineWidth = Math.max(0.1, star.size * 0.3);\n          ctx.stroke();\n        }\n        \n        ctx.restore();\n      }\n    } catch (error) {\n      // Silently handle any canvas drawing errors\n      // This prevents errors from breaking the entire component\n    }\n  }, [getColor]);\n  \n  // Render the scene\n  const renderScene = useCallback(() => {\n    if (!canvasRef.current) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    \n    if (!ctx) return;\n    \n    // Apply device pixel ratio scaling\n    ctx.setTransform(dimensions.pixelRatio, 0, 0, dimensions.pixelRatio, 0, 0);\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n    \n    // Draw background gradient\n    const gradient = ctx.createLinearGradient(0, 0, 0, dimensions.height);\n    gradient.addColorStop(0, COLORS.background.topColor);\n    gradient.addColorStop(1, COLORS.background.bottomColor);\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, dimensions.width, dimensions.height);\n    \n    // Enable global composition for better glow effect\n    ctx.globalCompositeOperation = 'lighter';\n    \n    // Get all visible stars\n    const visibleStars = getVisibleStars();\n    \n    // Draw stars\n    for (const star of visibleStars) {\n      // Skip almost invisible stars\n      if (star.opacity < 0.02) continue;\n      \n      // Calculate screen position based on scroll\n      // Adjust y position relative to canvas (which is fixed to the viewport)\n      const screenY = star.y - visibleAreaRef.current.top + (star.parallaxY || 0);\n      \n      // Only render stars that are visible in the viewport plus a small buffer\n      if (screenY >= -50 && screenY <= dimensions.height + 50) {\n        // Draw star with enhanced rendering\n        drawStar(ctx, star, screenY);\n      }\n    }\n    \n    // Reset global composition\n    ctx.globalCompositeOperation = 'source-over';\n  }, [dimensions, COLORS, getVisibleStars, drawStar]);\n  \n  // Main animation loop\n  const animate = useCallback((timestamp) => {\n    if (!isInitialized) {\n      animationFrameRef.current = requestAnimationFrame(animate);\n      return;\n    }\n    \n    // Calculate delta time with cap to prevent large jumps\n    const deltaTime = lastTimeRef.current ? Math.min(timestamp - lastTimeRef.current, 33) : 16;\n    lastTimeRef.current = timestamp;\n    \n    // Update animation state\n    updateAnimation(deltaTime, timestamp);\n    \n    // Render scene\n    renderScene();\n    \n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(animate);\n  }, [isInitialized, updateAnimation, renderScene]);\n  \n  // Initialize component on mount\n  useEffect(() => {\n    // Initialize canvas\n    const canvasInitialized = setupCanvas();\n    \n    if (canvasInitialized) {\n      // Set initial viewport\n      const viewportHeight = window.innerHeight;\n      visibleAreaRef.current = {\n        top: window.scrollY,\n        bottom: window.scrollY + viewportHeight\n      };\n      \n      // Update document height\n      updateDocumentHeight();\n      \n      // Generate initial stars\n      generateStarsForVisibleArea();\n      \n      setIsInitialized(true);\n    }\n  }, [setupCanvas, updateDocumentHeight, generateStarsForVisibleArea]);\n  \n  // Start animation loop\n  useEffect(() => {\n    if (!isInitialized) return;\n    \n    // Start animation\n    animationFrameRef.current = requestAnimationFrame(animate);\n    \n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [isInitialized, animate]);\n  \n  return (\n    <div\n      ref={containerRef}\n      style={{\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',  // Will be updated to full document height\n        overflow: 'hidden',\n        zIndex: -1,\n        pointerEvents: 'none'\n      }}\n      aria-hidden=\"true\"\n    >\n      <canvas\n        ref={canvasRef}\n        style={{\n          position: 'fixed',  // Canvas stays fixed but renders content based on scroll\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%'\n        }}\n      />\n    </div>\n  );\n};\n\nexport default Background;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}