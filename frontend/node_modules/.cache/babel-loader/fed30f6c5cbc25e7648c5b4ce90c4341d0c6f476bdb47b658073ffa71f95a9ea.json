{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/Background.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from 'react';\nimport './background.css';\n\n// Zodiac constellation definitions - simplified vertex patterns\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CONSTELLATIONS = [{\n  name: 'Venus',\n  vertices: [\n  // Cross/stem vertices\n  {\n    x: 0.3,\n    y: 0.3\n  },\n  // Center point (junction)\n  {\n    x: 0.3,\n    y: 0.37\n  },\n  // Bottom of stem\n  {\n    x: 0.27,\n    y: 0.3\n  },\n  // Left of cross\n  {\n    x: 0.33,\n    y: 0.3\n  },\n  // Right of cross\n\n  // Circle vertices - using 12 points for a smoother circle\n  {\n    x: 0.3,\n    y: 0.23\n  },\n  // Top point\n  {\n    x: 0.315,\n    y: 0.232\n  },\n  // 1 o'clock\n  {\n    x: 0.328,\n    y: 0.24\n  },\n  // 2 o'clock\n  {\n    x: 0.335,\n    y: 0.255\n  },\n  // 3 o'clock\n  {\n    x: 0.332,\n    y: 0.27\n  },\n  // 4 o'clock\n  {\n    x: 0.324,\n    y: 0.283\n  },\n  // 5 o'clock\n  {\n    x: 0.3,\n    y: 0.29\n  },\n  // 6 o'clock (connects to stem)\n  {\n    x: 0.276,\n    y: 0.283\n  },\n  // 7 o'clock\n  {\n    x: 0.268,\n    y: 0.27\n  },\n  // 8 o'clock\n  {\n    x: 0.265,\n    y: 0.255\n  },\n  // 9 o'clock\n  {\n    x: 0.272,\n    y: 0.24\n  },\n  // 10 o'clock\n  {\n    x: 0.285,\n    y: 0.232\n  } // 11 o'clock\n  ],\n  edges: [\n  // Cross/stem connections\n  [0, 1],\n  // Vertical stem\n  [2, 3],\n  // Horizontal cross\n\n  // Circle connections - connect each point to the next\n  [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 11], [11, 12], [12, 13], [13, 14], [14, 15], [15, 4],\n  // Connect circle to stem\n  [10, 0]]\n}, {\n  name: 'Cassiopeia',\n  vertices: [{\n    x: 0.7,\n    y: 0.15\n  }, {\n    x: 0.75,\n    y: 0.2\n  }, {\n    x: 0.8,\n    y: 0.15\n  }, {\n    x: 0.85,\n    y: 0.2\n  }, {\n    x: 0.9,\n    y: 0.15\n  }],\n  edges: [[0, 1], [1, 2], [2, 3], [3, 4]]\n}, {\n  name: 'Lyra',\n  vertices: [{\n    x: 0.6,\n    y: 0.65\n  }, {\n    x: 0.65,\n    y: 0.6\n  }, {\n    x: 0.65,\n    y: 0.7\n  }, {\n    x: 0.7,\n    y: 0.65\n  }, {\n    x: 0.64,\n    y: 0.65\n  }],\n  edges: [[0, 1], [0, 2], [1, 3], [2, 3], [4, 0], [4, 1], [4, 2], [4, 3]]\n}];\nconst Background = ({\n  cursorPosition,\n  setCursorPosition\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n  const particlesRef = useRef([]);\n  const constellationsRef = useRef([]);\n  const requestRef = useRef(null);\n  const timeRef = useRef(0);\n  const lastCursorPosition = useRef({\n    x: 0,\n    y: 0\n  });\n  const parallaxLayersRef = useRef([]);\n\n  // Update constellation-wide properties\n  useEffect(() => {\n    // Safety check for invalid parallax calculations\n    const validateCoordinates = () => {\n      constellationsRef.current.forEach(constellation => {\n        // Reset the constellation if center becomes invalid\n        if (!isFinite(constellation.centerX) || !isFinite(constellation.centerY)) {\n          const originalConstellation = CONSTELLATIONS.find(c => c.name === constellation.name);\n\n          // Recalculate center point\n          const vertices = originalConstellation.vertices.map(vertex => ({\n            x: vertex.x * window.innerWidth,\n            y: vertex.y * window.innerHeight\n          }));\n          constellation.centerX = vertices.reduce((sum, v) => sum + v.x, 0) / vertices.length;\n          constellation.centerY = vertices.reduce((sum, v) => sum + v.y, 0) / vertices.length;\n\n          // Reset vertices to original positions\n          constellation.vertices.forEach((vertex, index) => {\n            const originalVertex = originalConstellation.vertices[index];\n            vertex.x = originalVertex.x * window.innerWidth;\n            vertex.y = originalVertex.y * window.innerHeight;\n            vertex.initialX = vertex.x;\n            vertex.initialY = vertex.y;\n          });\n        }\n\n        // Check and fix any individual vertex coordinates\n        constellation.vertices.forEach(vertex => {\n          if (!isFinite(vertex.x) || !isFinite(vertex.y)) {\n            // Reset to initial position if available\n            if (isFinite(vertex.initialX) && isFinite(vertex.initialY)) {\n              vertex.x = vertex.initialX;\n              vertex.y = vertex.initialY;\n            } else {\n              // Fallback to center position\n              vertex.x = constellation.centerX;\n              vertex.y = constellation.centerY;\n              vertex.initialX = vertex.x;\n              vertex.initialY = vertex.y;\n            }\n          }\n        });\n      });\n    };\n\n    // Run validation every second\n    const intervalId = setInterval(validateCoordinates, 1000);\n    return () => clearInterval(intervalId);\n  }, []);\n  useEffect(() => {\n    // Create three distinct parallax layers\n    parallaxLayersRef.current = [{\n      depth: 0.2,\n      // Distant layer (moves slowest)\n      particles: Array(30).fill().map(() => ({\n        x: Math.random() * window.innerWidth,\n        y: Math.random() * window.innerHeight,\n        initialX: Math.random() * window.innerWidth,\n        initialY: Math.random() * window.innerHeight,\n        size: Math.random() * 1 + 0.3,\n        baseSize: Math.random() * 1 + 0.3,\n        speedX: (Math.random() - 0.5) * 0.05,\n        speedY: (Math.random() - 0.5) * 0.05,\n        opacity: Math.random() * 0.2 + 0.05,\n        baseOpacity: Math.random() * 0.2 + 0.05,\n        twinkleSpeed: Math.random() * 0.01 + 0.002,\n        twinklePhase: Math.random() * Math.PI * 2,\n        twinkleProbability: Math.random() * 0.0003 + 0.0001\n      }))\n    }, {\n      depth: 0.5,\n      // Middle layer\n      particles: Array(40).fill().map(() => ({\n        x: Math.random() * window.innerWidth,\n        y: Math.random() * window.innerHeight,\n        initialX: Math.random() * window.innerWidth,\n        initialY: Math.random() * window.innerHeight,\n        size: Math.random() * 1.5 + 0.5,\n        baseSize: Math.random() * 1.5 + 0.5,\n        speedX: (Math.random() - 0.5) * 0.1,\n        speedY: (Math.random() - 0.5) * 0.1,\n        opacity: Math.random() * 0.25 + 0.1,\n        baseOpacity: Math.random() * 0.25 + 0.1,\n        twinkleSpeed: Math.random() * 0.015 + 0.004,\n        twinklePhase: Math.random() * Math.PI * 2,\n        twinkleProbability: Math.random() * 0.0004 + 0.0002\n      }))\n    }, {\n      depth: 0.8,\n      // Close layer (moves fastest)\n      particles: Array(20).fill().map(() => ({\n        x: Math.random() * window.innerWidth,\n        y: Math.random() * window.innerHeight,\n        initialX: Math.random() * window.innerWidth,\n        initialY: Math.random() * window.innerHeight,\n        size: Math.random() * 1.8 + 0.8,\n        baseSize: Math.random() * 1.8 + 0.8,\n        speedX: (Math.random() - 0.5) * 0.15,\n        speedY: (Math.random() - 0.5) * 0.15,\n        opacity: Math.random() * 0.35 + 0.15,\n        baseOpacity: Math.random() * 0.35 + 0.15,\n        twinkleSpeed: Math.random() * 0.02 + 0.006,\n        twinklePhase: Math.random() * Math.PI * 2,\n        twinkleProbability: Math.random() * 0.0005 + 0.0003\n      }))\n    }];\n\n    // Combine all particles for the regular background animation\n    particlesRef.current = parallaxLayersRef.current.flatMap(layer => layer.particles);\n\n    // Initialize constellations with actual screen positions and parallax properties\n    constellationsRef.current = CONSTELLATIONS.map(constellation => {\n      const vertices = constellation.vertices.map(vertex => ({\n        x: vertex.x * window.innerWidth,\n        y: vertex.y * window.innerHeight,\n        initialX: vertex.x * window.innerWidth,\n        initialY: vertex.y * window.innerHeight,\n        size: 1.8,\n        // Slightly larger than regular particles\n        baseSize: 1.8,\n        opacity: 0.25,\n        baseOpacity: 0.25,\n        isTwinkling: false,\n        twinkleProgress: 0,\n        twinkleSpeed: Math.random() * 0.03 + 0.01,\n        lastTwinkle: 0,\n        twinkleInterval: Math.random() * 5000 + 2000,\n        // Random interval between twinkles\n        // Parallax properties unique to constellation stars\n        parallaxDepth: 0.3 + Math.random() * 0.1 // Different depth per star for subtle variation\n      }));\n      return {\n        name: constellation.name,\n        vertices,\n        edges: constellation.edges,\n        // Unique properties for each constellation\n        rotation: 0,\n        rotationSpeed: (Math.random() - 0.5) * 0.00003,\n        // Very slow rotation\n        breathePhase: Math.random() * Math.PI * 2,\n        breatheSpeed: 0.0003 + Math.random() * 0.0002,\n        parallaxDepth: 0.35,\n        // Constellation as whole has its own parallax depth\n        centerX: vertices.reduce((sum, v) => sum + v.x, 0) / vertices.length,\n        centerY: vertices.reduce((sum, v) => sum + v.y, 0) / vertices.length\n      };\n    });\n    return () => {\n      if (requestRef.current) {\n        cancelAnimationFrame(requestRef.current);\n      }\n    };\n  }, []);\n\n  // Canvas animation for background particles and constellations\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n\n    // Calculate parallax offset based on cursor movement\n    const calculateParallaxOffset = depth => {\n      // Only calculate parallax if we have previous cursor position\n      if (!lastCursorPosition.current.x || !cursorPosition.x) return {\n        x: 0,\n        y: 0\n      };\n\n      // Get movement delta\n      const deltaX = cursorPosition.x - lastCursorPosition.current.x;\n      const deltaY = cursorPosition.y - lastCursorPosition.current.y;\n\n      // Apply movement at different rates based on depth (deeper = slower movement)\n      return {\n        x: deltaX * depth,\n        y: deltaY * depth\n      };\n    };\n    const animate = timestamp => {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      timeRef.current = timestamp;\n\n      // Update cursor positions and calculate movement\n      if (cursorPosition.x && cursorPosition.y) {\n        // Store current position for next frame's comparison\n        lastCursorPosition.current = {\n          ...cursorPosition\n        };\n      }\n\n      // Process and draw each parallax layer\n      parallaxLayersRef.current.forEach(layer => {\n        const parallaxOffset = calculateParallaxOffset(layer.depth);\n        layer.particles.forEach(particle => {\n          // Update natural movement\n          particle.x += particle.speedX;\n          particle.y += particle.speedY;\n\n          // Apply parallax effect\n          if (parallaxOffset.x || parallaxOffset.y) {\n            particle.x += parallaxOffset.x;\n            particle.y += parallaxOffset.y;\n          }\n\n          // Wrap around screen\n          if (particle.x < 0) particle.x = canvas.width;\n          if (particle.x > canvas.width) particle.x = 0;\n          if (particle.y < 0) particle.y = canvas.height;\n          if (particle.y > canvas.height) particle.y = 0;\n\n          // Handle twinkling effect\n          if (Math.random() < particle.twinkleProbability) {\n            particle.isTwinkling = true;\n          }\n          if (particle.isTwinkling) {\n            // Use sine wave for smooth twinkling effect\n            const twinkleFactor = Math.sin(timeRef.current * particle.twinkleSpeed + particle.twinklePhase);\n            const normalizedTwinkle = (twinkleFactor + 1) / 2; // Convert from [-1,1] to [0,1]\n\n            particle.size = particle.baseSize + particle.baseSize * 0.7 * normalizedTwinkle;\n            particle.opacity = particle.baseOpacity + 0.4 * normalizedTwinkle;\n\n            // Complete one twinkle cycle\n            if (timeRef.current * particle.twinkleSpeed + particle.twinklePhase > particle.twinklePhase + Math.PI * 2) {\n              particle.isTwinkling = false;\n              particle.twinklePhase = Math.random() * Math.PI * 2; // Reset phase for next time\n              particle.size = particle.baseSize;\n              particle.opacity = particle.baseOpacity;\n            }\n          }\n\n          // Draw particle with color slightly based on layer (deeper = bluer, closer = warmer)\n          let r = 191;\n          let g = 173;\n          let b = 127 + (1 - layer.depth) * 30; // Adjust blue component based on depth\n\n          ctx.beginPath();\n          ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);\n          ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${particle.opacity})`;\n          ctx.fill();\n        });\n      });\n\n      // Draw constellations with advanced effects\n      constellationsRef.current.forEach(constellation => {\n        // Update constellation-wide properties\n        constellation.rotation += constellation.rotationSpeed;\n        constellation.breathePhase += constellation.breatheSpeed;\n\n        // Calculate breathe effect - subtly expands and contracts the constellation\n        const breatheFactor = Math.sin(constellation.breathePhase) * 0.02 + 1; // 2% expansion/contraction\n\n        // Apply parallax effect to the entire constellation\n        const constellationParallaxOffset = calculateParallaxOffset(constellation.parallaxDepth);\n        let constellationOffsetX = constellationParallaxOffset.x * 1.2; // Slightly enhanced parallax\n        let constellationOffsetY = constellationParallaxOffset.y * 1.2;\n\n        // Draw edges (lines) with subtle glow effect\n        constellation.edges.forEach(edge => {\n          const startVertex = constellation.vertices[edge[0]];\n          const endVertex = constellation.vertices[edge[1]];\n\n          // Skip drawing if coordinates are invalid\n          if (!isFinite(startVertex.x) || !isFinite(startVertex.y) || !isFinite(endVertex.x) || !isFinite(endVertex.y)) {\n            return;\n          }\n\n          // Apply breathing effect from constellation center\n          const startOffsetX = (startVertex.initialX - constellation.centerX) * breatheFactor;\n          const startOffsetY = (startVertex.initialY - constellation.centerY) * breatheFactor;\n          const endOffsetX = (endVertex.initialX - constellation.centerX) * breatheFactor;\n          const endOffsetY = (endVertex.initialY - constellation.centerY) * breatheFactor;\n\n          // Apply constellation rotation (very subtle)\n          const startRotatedX = Math.cos(constellation.rotation) * startOffsetX - Math.sin(constellation.rotation) * startOffsetY;\n          const startRotatedY = Math.sin(constellation.rotation) * startOffsetX + Math.cos(constellation.rotation) * startOffsetY;\n          const endRotatedX = Math.cos(constellation.rotation) * endOffsetX - Math.sin(constellation.rotation) * endOffsetY;\n          const endRotatedY = Math.sin(constellation.rotation) * endOffsetX + Math.cos(constellation.rotation) * endOffsetY;\n\n          // Final positions with parallax applied\n          const startX = constellation.centerX + startRotatedX + constellationOffsetX;\n          const startY = constellation.centerY + startRotatedY + constellationOffsetY;\n          const endX = constellation.centerX + endRotatedX + constellationOffsetX;\n          const endY = constellation.centerY + endRotatedY + constellationOffsetY;\n\n          // Soft glow effect for lines that pulses with breathing\n          const glowWidth = 2;\n          const glowIntensity = Math.sin(constellation.breathePhase) * 0.05 + 0.1;\n\n          // Draw edge with glow\n          ctx.beginPath();\n          ctx.strokeStyle = 'rgba(191, 173, 127, 0.05)';\n          ctx.lineWidth = glowWidth;\n          ctx.moveTo(startX, startY);\n          ctx.lineTo(endX, endY);\n          ctx.stroke();\n\n          // Draw main line\n          ctx.beginPath();\n          ctx.strokeStyle = `rgba(191, 173, 127, ${glowIntensity})`;\n          ctx.lineWidth = 0.5;\n          ctx.moveTo(startX, startY);\n          ctx.lineTo(endX, endY);\n          ctx.stroke();\n\n          // Update vertex positions based on the calculated edge positions\n          if (edge[0] === 0) {\n            constellation.vertices[edge[0]].x = startX;\n            constellation.vertices[edge[0]].y = startY;\n          }\n          if (edge[1] === 0) {\n            constellation.vertices[edge[1]].x = endX;\n            constellation.vertices[edge[1]].y = endY;\n          }\n        });\n\n        // Draw and update vertices\n        constellation.vertices.forEach((vertex, index) => {\n          // If vertex hasn't been positioned by edge calculations\n          if (index > 0) {\n            // Apply breathing effect from constellation center\n            const vertexOffsetX = (vertex.initialX - constellation.centerX) * breatheFactor;\n            const vertexOffsetY = (vertex.initialY - constellation.centerY) * breatheFactor;\n\n            // Apply constellation rotation\n            const vertexRotatedX = Math.cos(constellation.rotation) * vertexOffsetX - Math.sin(constellation.rotation) * vertexOffsetY;\n            const vertexRotatedY = Math.sin(constellation.rotation) * vertexOffsetX + Math.cos(constellation.rotation) * vertexOffsetY;\n\n            // Apply constellation-wide parallax and vertex-specific parallax\n            const vertexParallaxOffset = calculateParallaxOffset(vertex.parallaxDepth);\n            vertex.x = constellation.centerX + vertexRotatedX + constellationOffsetX + vertexParallaxOffset.x * 0.3;\n            vertex.y = constellation.centerY + vertexRotatedY + constellationOffsetY + vertexParallaxOffset.y * 0.3;\n          }\n\n          // Occasional twinkling for constellation stars\n          if (timeRef.current - vertex.lastTwinkle > vertex.twinkleInterval) {\n            vertex.isTwinkling = true;\n            vertex.twinkleProgress = 0;\n            vertex.lastTwinkle = timeRef.current;\n          }\n          if (vertex.isTwinkling) {\n            vertex.twinkleProgress += vertex.twinkleSpeed;\n\n            // Create a pulse effect\n            const pulseFactor = Math.sin(vertex.twinkleProgress * Math.PI);\n            vertex.size = vertex.baseSize + vertex.baseSize * pulseFactor;\n            vertex.opacity = vertex.baseOpacity + 0.5 * pulseFactor;\n\n            // End twinkling after one cycle\n            if (vertex.twinkleProgress >= 1) {\n              vertex.isTwinkling = false;\n              vertex.size = vertex.baseSize;\n              vertex.opacity = vertex.baseOpacity;\n            }\n          }\n\n          // Draw subtle glow behind constellation vertex\n          const glowRadius = vertex.size * 2;\n\n          // Validate coordinates before creating gradient\n          if (isFinite(vertex.x) && isFinite(vertex.y)) {\n            const gradient = ctx.createRadialGradient(vertex.x, vertex.y, 0, vertex.x, vertex.y, glowRadius);\n            gradient.addColorStop(0, `rgba(207, 185, 130, ${vertex.opacity * 0.5})`);\n            gradient.addColorStop(1, 'rgba(207, 185, 130, 0)');\n            ctx.beginPath();\n            ctx.arc(vertex.x, vertex.y, glowRadius, 0, Math.PI * 2);\n            ctx.fillStyle = gradient;\n            ctx.fill();\n\n            // Draw constellation vertex\n            ctx.beginPath();\n            ctx.arc(vertex.x, vertex.y, vertex.size, 0, Math.PI * 2);\n            ctx.fillStyle = `rgba(207, 185, 130, ${vertex.opacity})`;\n            ctx.fill();\n          }\n        });\n      });\n\n      // Draw cursor influence - very subtle glow\n      if (cursorPosition.x && cursorPosition.y && isFinite(cursorPosition.x) && isFinite(cursorPosition.y)) {\n        const gradient = ctx.createRadialGradient(cursorPosition.x, cursorPosition.y, 0, cursorPosition.x, cursorPosition.y, 80);\n        gradient.addColorStop(0, 'rgba(160, 142, 97, 0.03)');\n        gradient.addColorStop(1, 'rgba(160, 142, 97, 0)');\n        ctx.beginPath();\n        ctx.arc(cursorPosition.x, cursorPosition.y, 80, 0, Math.PI * 2);\n        ctx.fillStyle = gradient;\n        ctx.fill();\n      }\n      requestRef.current = requestAnimationFrame(animate);\n    };\n    animate(0);\n\n    // Mouse move handler for parallax effect\n    const handleMouseMove = e => {\n      if (setCursorPosition) {\n        setCursorPosition({\n          x: e.clientX,\n          y: e.clientY\n        });\n      }\n    };\n\n    // Resize handler\n    const handleResize = () => {\n      canvas.width = window.innerWidth;\n      canvas.height = window.innerHeight;\n\n      // Reposition constellation vertices on resize\n      constellationsRef.current = constellationsRef.current.map(constellation => {\n        const vertices = constellation.vertices.map((vertex, index) => {\n          const originalVertex = CONSTELLATIONS.find(c => c.name === constellation.name).vertices[index];\n          return {\n            ...vertex,\n            x: originalVertex.x * window.innerWidth,\n            y: originalVertex.y * window.innerHeight\n          };\n        });\n        return {\n          ...constellation,\n          vertices\n        };\n      });\n\n      // Reset parallax layer particles positions\n      parallaxLayersRef.current.forEach(layer => {\n        layer.particles.forEach(particle => {\n          particle.initialX = Math.random() * window.innerWidth;\n          particle.initialY = Math.random() * window.innerHeight;\n          particle.x = particle.initialX;\n          particle.y = particle.initialY;\n        });\n      });\n    };\n    window.addEventListener('resize', handleResize);\n    window.addEventListener('mousemove', handleMouseMove);\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      window.removeEventListener('mousemove', handleMouseMove);\n      cancelAnimationFrame(requestRef.current);\n    };\n  }, [cursorPosition]);\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    className: \"background-canvas\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 526,\n    columnNumber: 10\n  }, this);\n};\n_s(Background, \"5EjDyxT2OuucPaEldOUCAGjiH/M=\");\n_c = Background;\nexport default Background;\nvar _c;\n$RefreshReg$(_c, \"Background\");","map":{"version":3,"names":["React","useEffect","useRef","jsxDEV","_jsxDEV","CONSTELLATIONS","name","vertices","x","y","edges","Background","cursorPosition","setCursorPosition","_s","canvasRef","particlesRef","constellationsRef","requestRef","timeRef","lastCursorPosition","parallaxLayersRef","validateCoordinates","current","forEach","constellation","isFinite","centerX","centerY","originalConstellation","find","c","map","vertex","window","innerWidth","innerHeight","reduce","sum","v","length","index","originalVertex","initialX","initialY","intervalId","setInterval","clearInterval","depth","particles","Array","fill","Math","random","size","baseSize","speedX","speedY","opacity","baseOpacity","twinkleSpeed","twinklePhase","PI","twinkleProbability","flatMap","layer","isTwinkling","twinkleProgress","lastTwinkle","twinkleInterval","parallaxDepth","rotation","rotationSpeed","breathePhase","breatheSpeed","cancelAnimationFrame","canvas","ctx","getContext","width","height","calculateParallaxOffset","deltaX","deltaY","animate","timestamp","clearRect","parallaxOffset","particle","twinkleFactor","sin","normalizedTwinkle","r","g","b","beginPath","arc","fillStyle","breatheFactor","constellationParallaxOffset","constellationOffsetX","constellationOffsetY","edge","startVertex","endVertex","startOffsetX","startOffsetY","endOffsetX","endOffsetY","startRotatedX","cos","startRotatedY","endRotatedX","endRotatedY","startX","startY","endX","endY","glowWidth","glowIntensity","strokeStyle","lineWidth","moveTo","lineTo","stroke","vertexOffsetX","vertexOffsetY","vertexRotatedX","vertexRotatedY","vertexParallaxOffset","pulseFactor","glowRadius","gradient","createRadialGradient","addColorStop","requestAnimationFrame","handleMouseMove","e","clientX","clientY","handleResize","addEventListener","removeEventListener","ref","className","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/Background.js"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport './background.css';\n\n// Zodiac constellation definitions - simplified vertex patterns\nconst CONSTELLATIONS = [\n  {\n    name: 'Venus',\n    vertices: [\n      // Cross/stem vertices\n      { x: 0.3, y: 0.3 },  // Center point (junction)\n      { x: 0.3, y: 0.37 }, // Bottom of stem\n      { x: 0.27, y: 0.3 }, // Left of cross\n      { x: 0.33, y: 0.3 }, // Right of cross\n      \n      // Circle vertices - using 12 points for a smoother circle\n      { x: 0.3, y: 0.23 },  // Top point\n      { x: 0.315, y: 0.232 }, // 1 o'clock\n      { x: 0.328, y: 0.24 },  // 2 o'clock\n      { x: 0.335, y: 0.255 }, // 3 o'clock\n      { x: 0.332, y: 0.27 },  // 4 o'clock\n      { x: 0.324, y: 0.283 }, // 5 o'clock\n      { x: 0.3, y: 0.29 },    // 6 o'clock (connects to stem)\n      { x: 0.276, y: 0.283 }, // 7 o'clock\n      { x: 0.268, y: 0.27 },  // 8 o'clock\n      { x: 0.265, y: 0.255 }, // 9 o'clock\n      { x: 0.272, y: 0.24 },  // 10 o'clock\n      { x: 0.285, y: 0.232 }  // 11 o'clock\n    ],\n    edges: [\n      // Cross/stem connections\n      [0, 1], // Vertical stem\n      [2, 3], // Horizontal cross\n      \n      // Circle connections - connect each point to the next\n      [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10],\n      [10, 11], [11, 12], [12, 13], [13, 14], [14, 15], [15, 4],\n      \n      // Connect circle to stem\n      [10, 0]\n    ]\n  },\n  {\n    name: 'Cassiopeia',\n    vertices: [\n      { x: 0.7, y: 0.15 }, { x: 0.75, y: 0.2 }, { x: 0.8, y: 0.15 },\n      { x: 0.85, y: 0.2 }, { x: 0.9, y: 0.15 }\n    ],\n    edges: [[0, 1], [1, 2], [2, 3], [3, 4]]\n  },\n  {\n    name: 'Lyra',\n    vertices: [\n      { x: 0.6, y: 0.65 }, { x: 0.65, y: 0.6 }, { x: 0.65, y: 0.7 },\n      { x: 0.7, y: 0.65 }, { x: 0.64, y: 0.65 }\n    ],\n    edges: [[0, 1], [0, 2], [1, 3], [2, 3], [4, 0], [4, 1], [4, 2], [4, 3]]\n  }\n];\n\nconst Background = ({ cursorPosition, setCursorPosition }) => {\n  const canvasRef = useRef(null);\n  const particlesRef = useRef([]);\n  const constellationsRef = useRef([]);\n  const requestRef = useRef(null);\n  const timeRef = useRef(0);\n  const lastCursorPosition = useRef({ x: 0, y: 0 });\n  const parallaxLayersRef = useRef([]);\n  \n  // Update constellation-wide properties\n  useEffect(() => {\n    // Safety check for invalid parallax calculations\n    const validateCoordinates = () => {\n      constellationsRef.current.forEach(constellation => {\n        // Reset the constellation if center becomes invalid\n        if (!isFinite(constellation.centerX) || !isFinite(constellation.centerY)) {\n          const originalConstellation = CONSTELLATIONS.find(c => c.name === constellation.name);\n          \n          // Recalculate center point\n          const vertices = originalConstellation.vertices.map(vertex => ({\n            x: vertex.x * window.innerWidth,\n            y: vertex.y * window.innerHeight\n          }));\n          \n          constellation.centerX = vertices.reduce((sum, v) => sum + v.x, 0) / vertices.length;\n          constellation.centerY = vertices.reduce((sum, v) => sum + v.y, 0) / vertices.length;\n          \n          // Reset vertices to original positions\n          constellation.vertices.forEach((vertex, index) => {\n            const originalVertex = originalConstellation.vertices[index];\n            vertex.x = originalVertex.x * window.innerWidth;\n            vertex.y = originalVertex.y * window.innerHeight;\n            vertex.initialX = vertex.x;\n            vertex.initialY = vertex.y;\n          });\n        }\n        \n        // Check and fix any individual vertex coordinates\n        constellation.vertices.forEach(vertex => {\n          if (!isFinite(vertex.x) || !isFinite(vertex.y)) {\n            // Reset to initial position if available\n            if (isFinite(vertex.initialX) && isFinite(vertex.initialY)) {\n              vertex.x = vertex.initialX;\n              vertex.y = vertex.initialY;\n            } else {\n              // Fallback to center position\n              vertex.x = constellation.centerX;\n              vertex.y = constellation.centerY;\n              vertex.initialX = vertex.x;\n              vertex.initialY = vertex.y;\n            }\n          }\n        });\n      });\n    };\n    \n    // Run validation every second\n    const intervalId = setInterval(validateCoordinates, 1000);\n    \n    return () => clearInterval(intervalId);\n  }, []);\n  useEffect(() => {\n    // Create three distinct parallax layers\n    parallaxLayersRef.current = [\n      {\n        depth: 0.2, // Distant layer (moves slowest)\n        particles: Array(30).fill().map(() => ({\n          x: Math.random() * window.innerWidth,\n          y: Math.random() * window.innerHeight,\n          initialX: Math.random() * window.innerWidth,\n          initialY: Math.random() * window.innerHeight,\n          size: Math.random() * 1 + 0.3,\n          baseSize: Math.random() * 1 + 0.3,\n          speedX: (Math.random() - 0.5) * 0.05,\n          speedY: (Math.random() - 0.5) * 0.05,\n          opacity: Math.random() * 0.2 + 0.05,\n          baseOpacity: Math.random() * 0.2 + 0.05,\n          twinkleSpeed: Math.random() * 0.01 + 0.002,\n          twinklePhase: Math.random() * Math.PI * 2,\n          twinkleProbability: Math.random() * 0.0003 + 0.0001\n        }))\n      },\n      {\n        depth: 0.5, // Middle layer\n        particles: Array(40).fill().map(() => ({\n          x: Math.random() * window.innerWidth,\n          y: Math.random() * window.innerHeight,\n          initialX: Math.random() * window.innerWidth,\n          initialY: Math.random() * window.innerHeight,\n          size: Math.random() * 1.5 + 0.5,\n          baseSize: Math.random() * 1.5 + 0.5,\n          speedX: (Math.random() - 0.5) * 0.1,\n          speedY: (Math.random() - 0.5) * 0.1,\n          opacity: Math.random() * 0.25 + 0.1,\n          baseOpacity: Math.random() * 0.25 + 0.1,\n          twinkleSpeed: Math.random() * 0.015 + 0.004,\n          twinklePhase: Math.random() * Math.PI * 2,\n          twinkleProbability: Math.random() * 0.0004 + 0.0002\n        }))\n      },\n      {\n        depth: 0.8, // Close layer (moves fastest)\n        particles: Array(20).fill().map(() => ({\n          x: Math.random() * window.innerWidth,\n          y: Math.random() * window.innerHeight,\n          initialX: Math.random() * window.innerWidth,\n          initialY: Math.random() * window.innerHeight,\n          size: Math.random() * 1.8 + 0.8,\n          baseSize: Math.random() * 1.8 + 0.8,\n          speedX: (Math.random() - 0.5) * 0.15,\n          speedY: (Math.random() - 0.5) * 0.15,\n          opacity: Math.random() * 0.35 + 0.15,\n          baseOpacity: Math.random() * 0.35 + 0.15,\n          twinkleSpeed: Math.random() * 0.02 + 0.006,\n          twinklePhase: Math.random() * Math.PI * 2,\n          twinkleProbability: Math.random() * 0.0005 + 0.0003\n        }))\n      }\n    ];\n    \n    // Combine all particles for the regular background animation\n    particlesRef.current = parallaxLayersRef.current.flatMap(layer => layer.particles);\n    \n    // Initialize constellations with actual screen positions and parallax properties\n    constellationsRef.current = CONSTELLATIONS.map(constellation => {\n      const vertices = constellation.vertices.map(vertex => ({\n        x: vertex.x * window.innerWidth,\n        y: vertex.y * window.innerHeight,\n        initialX: vertex.x * window.innerWidth,\n        initialY: vertex.y * window.innerHeight,\n        size: 1.8, // Slightly larger than regular particles\n        baseSize: 1.8,\n        opacity: 0.25,\n        baseOpacity: 0.25,\n        isTwinkling: false,\n        twinkleProgress: 0,\n        twinkleSpeed: Math.random() * 0.03 + 0.01,\n        lastTwinkle: 0,\n        twinkleInterval: Math.random() * 5000 + 2000, // Random interval between twinkles\n        // Parallax properties unique to constellation stars\n        parallaxDepth: 0.3 + Math.random() * 0.1 // Different depth per star for subtle variation\n      }));\n      \n      return {\n        name: constellation.name,\n        vertices,\n        edges: constellation.edges,\n        // Unique properties for each constellation\n        rotation: 0,\n        rotationSpeed: (Math.random() - 0.5) * 0.00003, // Very slow rotation\n        breathePhase: Math.random() * Math.PI * 2,\n        breatheSpeed: 0.0003 + Math.random() * 0.0002,\n        parallaxDepth: 0.35, // Constellation as whole has its own parallax depth\n        centerX: vertices.reduce((sum, v) => sum + v.x, 0) / vertices.length,\n        centerY: vertices.reduce((sum, v) => sum + v.y, 0) / vertices.length\n      };\n    });\n    \n    return () => {\n      if (requestRef.current) {\n        cancelAnimationFrame(requestRef.current);\n      }\n    };\n  }, []);\n  \n  // Canvas animation for background particles and constellations\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    const ctx = canvas.getContext('2d');\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n    \n    // Calculate parallax offset based on cursor movement\n    const calculateParallaxOffset = (depth) => {\n      // Only calculate parallax if we have previous cursor position\n      if (!lastCursorPosition.current.x || !cursorPosition.x) return { x: 0, y: 0 };\n      \n      // Get movement delta\n      const deltaX = cursorPosition.x - lastCursorPosition.current.x;\n      const deltaY = cursorPosition.y - lastCursorPosition.current.y;\n      \n      // Apply movement at different rates based on depth (deeper = slower movement)\n      return {\n        x: deltaX * depth,\n        y: deltaY * depth\n      };\n    };\n    \n    const animate = (timestamp) => {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      timeRef.current = timestamp;\n      \n      // Update cursor positions and calculate movement\n      if (cursorPosition.x && cursorPosition.y) {\n        // Store current position for next frame's comparison\n        lastCursorPosition.current = { ...cursorPosition };\n      }\n      \n      // Process and draw each parallax layer\n      parallaxLayersRef.current.forEach(layer => {\n        const parallaxOffset = calculateParallaxOffset(layer.depth);\n        \n        layer.particles.forEach(particle => {\n          // Update natural movement\n          particle.x += particle.speedX;\n          particle.y += particle.speedY;\n          \n          // Apply parallax effect\n          if (parallaxOffset.x || parallaxOffset.y) {\n            particle.x += parallaxOffset.x;\n            particle.y += parallaxOffset.y;\n          }\n          \n          // Wrap around screen\n          if (particle.x < 0) particle.x = canvas.width;\n          if (particle.x > canvas.width) particle.x = 0;\n          if (particle.y < 0) particle.y = canvas.height;\n          if (particle.y > canvas.height) particle.y = 0;\n          \n          // Handle twinkling effect\n          if (Math.random() < particle.twinkleProbability) {\n            particle.isTwinkling = true;\n          }\n          \n          if (particle.isTwinkling) {\n            // Use sine wave for smooth twinkling effect\n            const twinkleFactor = Math.sin(timeRef.current * particle.twinkleSpeed + particle.twinklePhase);\n            const normalizedTwinkle = (twinkleFactor + 1) / 2; // Convert from [-1,1] to [0,1]\n            \n            particle.size = particle.baseSize + (particle.baseSize * 0.7 * normalizedTwinkle);\n            particle.opacity = particle.baseOpacity + (0.4 * normalizedTwinkle);\n            \n            // Complete one twinkle cycle\n            if (timeRef.current * particle.twinkleSpeed + particle.twinklePhase > particle.twinklePhase + Math.PI * 2) {\n              particle.isTwinkling = false;\n              particle.twinklePhase = Math.random() * Math.PI * 2; // Reset phase for next time\n              particle.size = particle.baseSize;\n              particle.opacity = particle.baseOpacity;\n            }\n          }\n          \n          // Draw particle with color slightly based on layer (deeper = bluer, closer = warmer)\n          let r = 191;\n          let g = 173;\n          let b = 127 + (1 - layer.depth) * 30; // Adjust blue component based on depth\n          \n          ctx.beginPath();\n          ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);\n          ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${particle.opacity})`;\n          ctx.fill();\n        });\n      });\n      \n      // Draw constellations with advanced effects\n      constellationsRef.current.forEach(constellation => {\n        // Update constellation-wide properties\n        constellation.rotation += constellation.rotationSpeed;\n        constellation.breathePhase += constellation.breatheSpeed;\n        \n        // Calculate breathe effect - subtly expands and contracts the constellation\n        const breatheFactor = Math.sin(constellation.breathePhase) * 0.02 + 1; // 2% expansion/contraction\n        \n        // Apply parallax effect to the entire constellation\n        const constellationParallaxOffset = calculateParallaxOffset(constellation.parallaxDepth);\n        let constellationOffsetX = constellationParallaxOffset.x * 1.2; // Slightly enhanced parallax\n        let constellationOffsetY = constellationParallaxOffset.y * 1.2;\n        \n        // Draw edges (lines) with subtle glow effect\n        constellation.edges.forEach(edge => {\n          const startVertex = constellation.vertices[edge[0]];\n          const endVertex = constellation.vertices[edge[1]];\n          \n          // Skip drawing if coordinates are invalid\n          if (!isFinite(startVertex.x) || !isFinite(startVertex.y) || \n              !isFinite(endVertex.x) || !isFinite(endVertex.y)) {\n            return;\n          }\n          \n          // Apply breathing effect from constellation center\n          const startOffsetX = (startVertex.initialX - constellation.centerX) * breatheFactor;\n          const startOffsetY = (startVertex.initialY - constellation.centerY) * breatheFactor;\n          const endOffsetX = (endVertex.initialX - constellation.centerX) * breatheFactor;\n          const endOffsetY = (endVertex.initialY - constellation.centerY) * breatheFactor;\n          \n          // Apply constellation rotation (very subtle)\n          const startRotatedX = Math.cos(constellation.rotation) * startOffsetX - Math.sin(constellation.rotation) * startOffsetY;\n          const startRotatedY = Math.sin(constellation.rotation) * startOffsetX + Math.cos(constellation.rotation) * startOffsetY;\n          const endRotatedX = Math.cos(constellation.rotation) * endOffsetX - Math.sin(constellation.rotation) * endOffsetY;\n          const endRotatedY = Math.sin(constellation.rotation) * endOffsetX + Math.cos(constellation.rotation) * endOffsetY;\n          \n          // Final positions with parallax applied\n          const startX = constellation.centerX + startRotatedX + constellationOffsetX;\n          const startY = constellation.centerY + startRotatedY + constellationOffsetY;\n          const endX = constellation.centerX + endRotatedX + constellationOffsetX;\n          const endY = constellation.centerY + endRotatedY + constellationOffsetY;\n          \n          // Soft glow effect for lines that pulses with breathing\n          const glowWidth = 2;\n          const glowIntensity = (Math.sin(constellation.breathePhase) * 0.05 + 0.1);\n          \n          // Draw edge with glow\n          ctx.beginPath();\n          ctx.strokeStyle = 'rgba(191, 173, 127, 0.05)';\n          ctx.lineWidth = glowWidth;\n          ctx.moveTo(startX, startY);\n          ctx.lineTo(endX, endY);\n          ctx.stroke();\n          \n          // Draw main line\n          ctx.beginPath();\n          ctx.strokeStyle = `rgba(191, 173, 127, ${glowIntensity})`;\n          ctx.lineWidth = 0.5;\n          ctx.moveTo(startX, startY);\n          ctx.lineTo(endX, endY);\n          ctx.stroke();\n          \n          // Update vertex positions based on the calculated edge positions\n          if (edge[0] === 0) {\n            constellation.vertices[edge[0]].x = startX;\n            constellation.vertices[edge[0]].y = startY;\n          }\n          if (edge[1] === 0) {\n            constellation.vertices[edge[1]].x = endX;\n            constellation.vertices[edge[1]].y = endY;\n          }\n        });\n        \n        // Draw and update vertices\n        constellation.vertices.forEach((vertex, index) => {\n          // If vertex hasn't been positioned by edge calculations\n          if (index > 0) {\n            // Apply breathing effect from constellation center\n            const vertexOffsetX = (vertex.initialX - constellation.centerX) * breatheFactor;\n            const vertexOffsetY = (vertex.initialY - constellation.centerY) * breatheFactor;\n            \n            // Apply constellation rotation\n            const vertexRotatedX = Math.cos(constellation.rotation) * vertexOffsetX - Math.sin(constellation.rotation) * vertexOffsetY;\n            const vertexRotatedY = Math.sin(constellation.rotation) * vertexOffsetX + Math.cos(constellation.rotation) * vertexOffsetY;\n            \n            // Apply constellation-wide parallax and vertex-specific parallax\n            const vertexParallaxOffset = calculateParallaxOffset(vertex.parallaxDepth);\n            vertex.x = constellation.centerX + vertexRotatedX + constellationOffsetX + vertexParallaxOffset.x * 0.3;\n            vertex.y = constellation.centerY + vertexRotatedY + constellationOffsetY + vertexParallaxOffset.y * 0.3;\n          }\n          \n          // Occasional twinkling for constellation stars\n          if (timeRef.current - vertex.lastTwinkle > vertex.twinkleInterval) {\n            vertex.isTwinkling = true;\n            vertex.twinkleProgress = 0;\n            vertex.lastTwinkle = timeRef.current;\n          }\n          \n          if (vertex.isTwinkling) {\n            vertex.twinkleProgress += vertex.twinkleSpeed;\n            \n            // Create a pulse effect\n            const pulseFactor = Math.sin(vertex.twinkleProgress * Math.PI);\n            vertex.size = vertex.baseSize + (vertex.baseSize * pulseFactor);\n            vertex.opacity = vertex.baseOpacity + (0.5 * pulseFactor);\n            \n            // End twinkling after one cycle\n            if (vertex.twinkleProgress >= 1) {\n              vertex.isTwinkling = false;\n              vertex.size = vertex.baseSize;\n              vertex.opacity = vertex.baseOpacity;\n            }\n          }\n          \n          // Draw subtle glow behind constellation vertex\n          const glowRadius = vertex.size * 2;\n          \n          // Validate coordinates before creating gradient\n          if (isFinite(vertex.x) && isFinite(vertex.y)) {\n            const gradient = ctx.createRadialGradient(\n              vertex.x, vertex.y, 0,\n              vertex.x, vertex.y, glowRadius\n            );\n            gradient.addColorStop(0, `rgba(207, 185, 130, ${vertex.opacity * 0.5})`);\n            gradient.addColorStop(1, 'rgba(207, 185, 130, 0)');\n            \n            ctx.beginPath();\n            ctx.arc(vertex.x, vertex.y, glowRadius, 0, Math.PI * 2);\n            ctx.fillStyle = gradient;\n            ctx.fill();\n            \n            // Draw constellation vertex\n            ctx.beginPath();\n            ctx.arc(vertex.x, vertex.y, vertex.size, 0, Math.PI * 2);\n            ctx.fillStyle = `rgba(207, 185, 130, ${vertex.opacity})`;\n            ctx.fill();\n          }\n        });\n      });\n      \n      // Draw cursor influence - very subtle glow\n      if (cursorPosition.x && cursorPosition.y && \n          isFinite(cursorPosition.x) && isFinite(cursorPosition.y)) {\n        const gradient = ctx.createRadialGradient(\n          cursorPosition.x, cursorPosition.y, 0,\n          cursorPosition.x, cursorPosition.y, 80\n        );\n        gradient.addColorStop(0, 'rgba(160, 142, 97, 0.03)');\n        gradient.addColorStop(1, 'rgba(160, 142, 97, 0)');\n        ctx.beginPath();\n        ctx.arc(cursorPosition.x, cursorPosition.y, 80, 0, Math.PI * 2);\n        ctx.fillStyle = gradient;\n        ctx.fill();\n      }\n      \n      requestRef.current = requestAnimationFrame(animate);\n    };\n    \n    animate(0);\n    \n    // Mouse move handler for parallax effect\n    const handleMouseMove = (e) => {\n      if (setCursorPosition) {\n        setCursorPosition({ x: e.clientX, y: e.clientY });\n      }\n    };\n    \n    // Resize handler\n    const handleResize = () => {\n      canvas.width = window.innerWidth;\n      canvas.height = window.innerHeight;\n      \n      // Reposition constellation vertices on resize\n      constellationsRef.current = constellationsRef.current.map(constellation => {\n        const vertices = constellation.vertices.map((vertex, index) => {\n          const originalVertex = CONSTELLATIONS.find(c => c.name === constellation.name).vertices[index];\n          return {\n            ...vertex,\n            x: originalVertex.x * window.innerWidth,\n            y: originalVertex.y * window.innerHeight\n          };\n        });\n        \n        return {\n          ...constellation,\n          vertices\n        };\n      });\n      \n      // Reset parallax layer particles positions\n      parallaxLayersRef.current.forEach(layer => {\n        layer.particles.forEach(particle => {\n          particle.initialX = Math.random() * window.innerWidth;\n          particle.initialY = Math.random() * window.innerHeight;\n          particle.x = particle.initialX;\n          particle.y = particle.initialY;\n        });\n      });\n    };\n    \n    window.addEventListener('resize', handleResize);\n    window.addEventListener('mousemove', handleMouseMove);\n    \n    return () => {\n      window.removeEventListener('resize', handleResize);\n      window.removeEventListener('mousemove', handleMouseMove);\n      cancelAnimationFrame(requestRef.current);\n    };\n  }, [cursorPosition]);\n  \n  return <canvas ref={canvasRef} className=\"background-canvas\" />;\n};\n\nexport default Background;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}