{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/MeteorShower.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef, useMemo } from 'react';\nimport { createUseStyles } from 'react-jss';\n\n// Utility function to generate random number within a range\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst randomRange = (min, max) => Math.random() * (max - min) + min;\n\n// Utility to generate a random point above the viewport\nconst randomTopPoint = (width, extraHeight = 0) => ({\n  x: randomRange(0, width),\n  y: randomRange(-200 - extraHeight, -50)\n});\n\n// Utility to generate a random point at the bottom of the viewport\nconst randomBottomPoint = (width, height, extraWidth = 0) => ({\n  x: randomRange(-extraWidth, width + extraWidth),\n  y: randomRange(height * 0.7, height + 100)\n});\n\n// CSS-in-JS styles for the MeteorShower component\nconst useStyles = createUseStyles({\n  meteorShowerContainer: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: props => props.height || '100vh',\n    overflow: 'hidden',\n    pointerEvents: 'none',\n    zIndex: props => props.zIndex || 5\n  },\n  canvas: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%'\n  }\n});\n\n/**\n * MeteorShower Component\n * \n * Creates an animated meteor shower effect with customizable parameters.\n * Meteors fall from above the visible area and can explode into particles.\n * \n * @param {Object} props - Component props\n * @param {number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=5] - Z-index for the container\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.meteorCount=15] - Number of meteors to generate\n * @param {number} [props.meteorMinSize=1] - Minimum size of meteors\n * @param {number} [props.meteorMaxSize=3] - Maximum size of meteors\n * @param {number} [props.meteorMinSpeed=0.1] - Minimum speed of meteors\n * @param {number} [props.meteorMaxSpeed=0.3] - Maximum speed of meteors\n * @param {number} [props.meteorMinLength=100] - Minimum trail length\n * @param {number} [props.meteorMaxLength=250] - Maximum trail length\n * @param {string} [props.meteorColor='rgba(255, 215, 0, 0.8)'] - Base color for meteors\n * @param {string} [props.glowColor='rgba(255, 235, 150, 0.5)'] - Glow color for meteors\n * @param {string} [props.coreColor='rgba(255, 255, 230, 1)'] - Core color for meteors\n * @param {boolean} [props.enableParallax=false] - Enable parallax effect on scroll\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of parallax effect\n * @param {boolean} [props.enableExplosions=true] - Enable explosion effect when meteors reach bottom\n * @param {number} [props.explosionParticles=20] - Number of particles in each explosion\n * @param {number} [props.fadeOutStart=null] - Time (ms) when meteors start fading out (null = never)\n * @param {number} [props.fadeOutDuration=1500] - Duration of fade out animation\n * @param {number} [props.spawnInterval=800] - Time between meteor spawns (ms)\n * @param {number} [props.maxMeteorsOnScreen=15] - Maximum meteors visible simultaneously\n * @param {Function} [props.onComplete] - Callback when all meteors have completed\n */\nconst MeteorShower = ({\n  height = '100vh',\n  zIndex = 5,\n  active = true,\n  meteorCount = 15,\n  meteorMinSize = 1,\n  meteorMaxSize = 3,\n  meteorMinSpeed = 0.1,\n  meteorMaxSpeed = 0.3,\n  meteorMinLength = 100,\n  meteorMaxLength = 250,\n  meteorColor = 'rgba(255, 215, 0, 0.8)',\n  // Golden\n  glowColor = 'rgba(255, 235, 150, 0.5)',\n  // Warm glow\n  coreColor = 'rgba(255, 255, 230, 1)',\n  // Bright core\n  enableParallax = false,\n  parallaxIntensity = 0.2,\n  enableExplosions = true,\n  explosionParticles = 20,\n  fadeOutStart = null,\n  fadeOutDuration = 1500,\n  spawnInterval = 800,\n  maxMeteorsOnScreen = 15,\n  onComplete = () => {}\n}) => {\n  _s();\n  const classes = useStyles({\n    height,\n    zIndex\n  });\n  const canvasRef = useRef(null);\n  const meteorsRef = useRef([]);\n  const particlesRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n  const startTimeRef = useRef(null);\n  const nextSpawnTimeRef = useRef(0);\n  const completedCountRef = useRef(0);\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0\n  });\n\n  // Initialize meteors array\n  const initializeMeteor = () => {\n    const width = dimensions.width;\n    const height = dimensions.height;\n    if (!width || !height) return null;\n\n    // Determine start and end points\n    const start = randomTopPoint(width, 50);\n    const end = randomBottomPoint(width, height, 100);\n\n    // Calculate angle for direction\n    const angle = Math.atan2(end.y - start.y, end.x - start.x);\n\n    // Create meteor object\n    return {\n      x: start.x,\n      y: start.y,\n      targetX: end.x,\n      targetY: end.y,\n      angle,\n      size: randomRange(meteorMinSize, meteorMaxSize),\n      length: randomRange(meteorMinLength, meteorMaxLength),\n      speed: randomRange(meteorMinSpeed, meteorMaxSpeed),\n      progress: 0,\n      active: true,\n      hasExploded: false,\n      trailOpacity: randomRange(0.6, 0.9),\n      pulsePhase: randomRange(0, Math.PI * 2),\n      pulseSpeed: randomRange(0.005, 0.015),\n      rotationOffset: randomRange(-0.2, 0.2),\n      // Add some random variations for unique appearance\n      sizeVariation: randomRange(0.9, 1.1),\n      colorHueShift: Math.floor(randomRange(-10, 10)),\n      trailSegments: Math.floor(randomRange(8, 16))\n    };\n  };\n\n  // Create a particle explosion at a given position\n  const createExplosion = (x, y, size, color) => {\n    const particles = [];\n    const baseSpeed = size * 0.15;\n    for (let i = 0; i < explosionParticles; i++) {\n      const angle = randomRange(0, Math.PI * 2);\n      const speed = randomRange(baseSpeed * 0.5, baseSpeed * 1.5);\n      const particleSize = randomRange(size * 0.1, size * 0.4);\n      const lifetime = randomRange(800, 1600);\n      particles.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        size: particleSize,\n        originalSize: particleSize,\n        color,\n        opacity: randomRange(0.7, 1),\n        lifetime,\n        age: 0,\n        rotationSpeed: randomRange(-0.05, 0.05),\n        rotation: randomRange(0, Math.PI * 2),\n        // Add flickering effect\n        flickerSpeed: randomRange(0.05, 0.15),\n        flickerPhase: randomRange(0, Math.PI * 2)\n      });\n    }\n    particlesRef.current = [...particlesRef.current, ...particles];\n  };\n\n  // Update canvas dimensions on resize\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (canvasRef.current) {\n        const width = window.innerWidth;\n        const height = parseInt(height, 10) || window.innerHeight;\n        setDimensions({\n          width,\n          height\n        });\n        canvasRef.current.width = width;\n        canvasRef.current.height = height;\n      }\n    };\n    updateDimensions();\n    window.addEventListener('resize', updateDimensions);\n    return () => {\n      window.removeEventListener('resize', updateDimensions);\n    };\n  }, [height]);\n\n  // Handle parallax effect on scroll\n  useEffect(() => {\n    if (!enableParallax) return;\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    window.addEventListener('scroll', handleScroll);\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [enableParallax]);\n\n  // Main animation loop\n  useEffect(() => {\n    if (!active || !dimensions.width || !dimensions.height) return;\n\n    // Initialize start time\n    startTimeRef.current = performance.now();\n\n    // Animation function\n    const animate = timestamp => {\n      if (!canvasRef.current) return;\n      const ctx = canvasRef.current.getContext('2d');\n      const width = dimensions.width;\n      const height = dimensions.height;\n\n      // Initialize lastTimestamp on first run\n      if (lastTimestampRef.current === 0) {\n        lastTimestampRef.current = timestamp;\n        nextSpawnTimeRef.current = timestamp;\n      }\n\n      // Calculate delta time (capped to prevent jumps after tab switching)\n      const deltaTime = Math.min(timestamp - lastTimestampRef.current, 50);\n      lastTimestampRef.current = timestamp;\n\n      // Calculate global fade based on fadeOutStart\n      let globalOpacity = 1;\n      if (fadeOutStart !== null && timestamp - startTimeRef.current > fadeOutStart) {\n        const fadeProgress = (timestamp - startTimeRef.current - fadeOutStart) / fadeOutDuration;\n        globalOpacity = Math.max(0, 1 - fadeProgress);\n        if (globalOpacity <= 0) {\n          // Animation complete, call onComplete callback\n          onComplete();\n          cancelAnimationFrame(animationFrameRef.current);\n          return;\n        }\n      }\n\n      // Clear canvas\n      ctx.clearRect(0, 0, width, height);\n\n      // Apply parallax offset\n      let parallaxOffset = 0;\n      if (enableParallax) {\n        parallaxOffset = scrollPositionRef.current * parallaxIntensity;\n      }\n\n      // Spawn new meteors if needed\n      if (meteorsRef.current.length < maxMeteorsOnScreen && completedCountRef.current < meteorCount && timestamp > nextSpawnTimeRef.current) {\n        const newMeteor = initializeMeteor();\n        if (newMeteor) {\n          meteorsRef.current.push(newMeteor);\n        }\n        nextSpawnTimeRef.current = timestamp + spawnInterval;\n      }\n\n      // Update and draw meteors\n      meteorsRef.current = meteorsRef.current.filter(meteor => {\n        // Skip if not active\n        if (!meteor.active) return false;\n\n        // Update progress\n        meteor.progress += meteor.speed * (deltaTime / 16);\n\n        // Calculate current position\n        const dx = meteor.targetX - meteor.x;\n        const dy = meteor.targetY - meteor.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        meteor.x += Math.cos(meteor.angle) * meteor.speed * (deltaTime / 1.5);\n        meteor.y += Math.sin(meteor.angle) * meteor.speed * (deltaTime / 1.5);\n\n        // Check if meteor has reached its target\n        if (meteor.progress >= 1 || meteor.y > height + 50) {\n          // Create explosion if enabled\n          if (enableExplosions && !meteor.hasExploded && meteor.y <= height + 50) {\n            createExplosion(meteor.x, meteor.y, meteor.size * 5, meteorColor);\n            meteor.hasExploded = true;\n          }\n\n          // Mark as completed\n          if (completedCountRef.current < meteorCount) {\n            completedCountRef.current++;\n          }\n          return false;\n        }\n\n        // Apply pulse effect\n        const pulseEffect = Math.sin(timestamp * meteor.pulseSpeed + meteor.pulsePhase) * 0.2 + 1;\n\n        // Calculate adjusted positions with parallax\n        const adjustedY = meteor.y + parallaxOffset * (meteor.size / meteorMaxSize);\n\n        // Draw meteor trail (gradient line)\n        const trailLength = meteor.length * meteor.speed * pulseEffect;\n        const trailStartX = meteor.x - Math.cos(meteor.angle) * trailLength;\n        const trailStartY = adjustedY - Math.sin(meteor.angle) * trailLength;\n\n        // Create gradient for trail\n        const gradient = ctx.createLinearGradient(meteor.x, adjustedY, trailStartX, trailStartY);\n        gradient.addColorStop(0, coreColor.replace(/[\\d.]+\\)$/, meteor.trailOpacity * globalOpacity + ')'));\n        gradient.addColorStop(0.3, meteorColor.replace(/[\\d.]+\\)$/, meteor.trailOpacity * 0.8 * globalOpacity + ')'));\n        gradient.addColorStop(1, meteorColor.replace(/[\\d.]+\\)$/, '0)'));\n\n        // Draw trail segments with slight variation for more natural look\n        ctx.lineWidth = meteor.size * meteor.sizeVariation * pulseEffect;\n        ctx.strokeStyle = gradient;\n        ctx.lineCap = 'round';\n\n        // Set up shadow/glow effect\n        ctx.shadowColor = glowColor;\n        ctx.shadowBlur = meteor.size * 5 * pulseEffect;\n\n        // Draw the main trail\n        ctx.beginPath();\n        ctx.moveTo(meteor.x, adjustedY);\n        ctx.lineTo(trailStartX, trailStartY);\n        ctx.stroke();\n\n        // Draw the meteor head (brightest part)\n        ctx.shadowColor = glowColor;\n        ctx.shadowBlur = meteor.size * 10 * pulseEffect;\n\n        // Draw the head gradient\n        const headGradient = ctx.createRadialGradient(meteor.x, adjustedY, 0, meteor.x, adjustedY, meteor.size * 2);\n        headGradient.addColorStop(0, coreColor.replace(/[\\d.]+\\)$/, globalOpacity + ')'));\n        headGradient.addColorStop(0.3, meteorColor.replace(/[\\d.]+\\)$/, 0.7 * globalOpacity + ')'));\n        headGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');\n        ctx.fillStyle = headGradient;\n        ctx.beginPath();\n        ctx.arc(meteor.x, adjustedY, meteor.size * 1.5 * pulseEffect, 0, Math.PI * 2);\n        ctx.fill();\n        return true;\n      });\n\n      // Update and draw particles\n      particlesRef.current = particlesRef.current.filter(particle => {\n        // Update age\n        particle.age += deltaTime;\n        if (particle.age >= particle.lifetime) {\n          return false;\n        }\n\n        // Calculate life progress (0 to 1)\n        const lifeProgress = particle.age / particle.lifetime;\n\n        // Update position\n        particle.x += particle.vx;\n        particle.vy += 0.01; // Slight gravity\n        particle.y += particle.vy;\n\n        // Calculate size based on life progress (grow then shrink)\n        const sizeProgress = lifeProgress <= 0.2 ? lifeProgress / 0.2 // Grow during first 20%\n        : 1 - (lifeProgress - 0.2) / 0.8; // Shrink during remaining 80%\n\n        // Calculate opacity\n        const opacityProgress = 1 - lifeProgress;\n        const flickerEffect = Math.sin(particle.age * particle.flickerSpeed + particle.flickerPhase) * 0.3 + 0.7;\n\n        // Apply rotation\n        particle.rotation += particle.rotationSpeed;\n\n        // Calculate final size and opacity\n        const size = particle.originalSize * sizeProgress * flickerEffect;\n        const opacity = particle.opacity * opacityProgress * flickerEffect * globalOpacity;\n\n        // Skip drawing if too small or transparent\n        if (size <= 0.1 || opacity <= 0.01) return true;\n\n        // Draw particle\n        ctx.save();\n        ctx.translate(particle.x, particle.y);\n        ctx.rotate(particle.rotation);\n\n        // Create glow effect\n        ctx.shadowColor = glowColor;\n        ctx.shadowBlur = size * 3;\n\n        // Draw the particle\n        ctx.fillStyle = particle.color.replace(/[\\d.]+\\)$/, opacity + ')');\n\n        // Draw as a diamond shape for Elden Ring aesthetics\n        ctx.beginPath();\n        ctx.moveTo(0, -size);\n        ctx.lineTo(size / 2, 0);\n        ctx.lineTo(0, size);\n        ctx.lineTo(-size / 2, 0);\n        ctx.closePath();\n        ctx.fill();\n        ctx.restore();\n        return true;\n      });\n\n      // Continue animation\n      animationFrameRef.current = requestAnimationFrame(animate);\n    };\n\n    // Start animation\n    animationFrameRef.current = requestAnimationFrame(animate);\n\n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [active, dimensions, meteorMinSize, meteorMaxSize, meteorMinSpeed, meteorMaxSpeed, meteorMinLength, meteorMaxLength, meteorColor, glowColor, coreColor, enableParallax, parallaxIntensity, enableExplosions, explosionParticles, fadeOutStart, fadeOutDuration, spawnInterval, maxMeteorsOnScreen, meteorCount, onComplete]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: classes.meteorShowerContainer,\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      className: classes.canvas\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 462,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 461,\n    columnNumber: 5\n  }, this);\n};\n\n/**\n * EldenRingMeteorShower Component\n * \n * A preset version of the MeteorShower with Elden Ring-inspired styling.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_s(MeteorShower, \"O38NOmVAaFBucLhNox6nYKt5knM=\", false, function () {\n  return [useStyles];\n});\n_c = MeteorShower;\nexport const EldenRingMeteorShower = props => {\n  // Elden Ring-inspired preset values\n  const eldenRingPresets = {\n    meteorColor: 'rgba(255, 215, 0, 0.8)',\n    // Golden color\n    glowColor: 'rgba(255, 235, 150, 0.6)',\n    // Warm glow\n    coreColor: 'rgba(255, 248, 220, 1)',\n    // Bright core\n    meteorMinSize: 1.5,\n    // Slightly larger meteors\n    meteorMaxSize: 4,\n    meteorMinLength: 150,\n    // Longer trails\n    meteorMaxLength: 350,\n    meteorMinSpeed: 0.15,\n    // Faster movement\n    meteorMaxSpeed: 0.35,\n    enableExplosions: true,\n    explosionParticles: 25,\n    // More particles\n    spawnInterval: 600,\n    // Faster spawning\n    maxMeteorsOnScreen: 20 // More meteors\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...eldenRingPresets,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 492,\n    columnNumber: 10\n  }, this);\n};\n_c2 = EldenRingMeteorShower;\nexport default MeteorShower;\nvar _c, _c2;\n$RefreshReg$(_c, \"MeteorShower\");\n$RefreshReg$(_c2, \"EldenRingMeteorShower\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useMemo","createUseStyles","jsxDEV","_jsxDEV","randomRange","min","max","Math","random","randomTopPoint","width","extraHeight","x","y","randomBottomPoint","height","extraWidth","useStyles","meteorShowerContainer","position","top","left","props","overflow","pointerEvents","zIndex","canvas","MeteorShower","active","meteorCount","meteorMinSize","meteorMaxSize","meteorMinSpeed","meteorMaxSpeed","meteorMinLength","meteorMaxLength","meteorColor","glowColor","coreColor","enableParallax","parallaxIntensity","enableExplosions","explosionParticles","fadeOutStart","fadeOutDuration","spawnInterval","maxMeteorsOnScreen","onComplete","_s","classes","canvasRef","meteorsRef","particlesRef","animationFrameRef","lastTimestampRef","scrollPositionRef","startTimeRef","nextSpawnTimeRef","completedCountRef","dimensions","setDimensions","initializeMeteor","start","end","angle","atan2","targetX","targetY","size","length","speed","progress","hasExploded","trailOpacity","pulsePhase","PI","pulseSpeed","rotationOffset","sizeVariation","colorHueShift","floor","trailSegments","createExplosion","color","particles","baseSpeed","i","particleSize","lifetime","push","vx","cos","vy","sin","originalSize","opacity","age","rotationSpeed","rotation","flickerSpeed","flickerPhase","current","updateDimensions","window","innerWidth","parseInt","innerHeight","addEventListener","removeEventListener","handleScroll","scrollY","performance","now","animate","timestamp","ctx","getContext","deltaTime","globalOpacity","fadeProgress","cancelAnimationFrame","clearRect","parallaxOffset","newMeteor","filter","meteor","dx","dy","distance","sqrt","pulseEffect","adjustedY","trailLength","trailStartX","trailStartY","gradient","createLinearGradient","addColorStop","replace","lineWidth","strokeStyle","lineCap","shadowColor","shadowBlur","beginPath","moveTo","lineTo","stroke","headGradient","createRadialGradient","fillStyle","arc","fill","particle","lifeProgress","sizeProgress","opacityProgress","flickerEffect","save","translate","rotate","closePath","restore","requestAnimationFrame","className","children","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","EldenRingMeteorShower","eldenRingPresets","_c2","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/MeteorShower.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef, useMemo } from 'react';\nimport { createUseStyles } from 'react-jss';\n\n// Utility function to generate random number within a range\nconst randomRange = (min, max) => Math.random() * (max - min) + min;\n\n// Utility to generate a random point above the viewport\nconst randomTopPoint = (width, extraHeight = 0) => ({\n  x: randomRange(0, width),\n  y: randomRange(-200 - extraHeight, -50),\n});\n\n// Utility to generate a random point at the bottom of the viewport\nconst randomBottomPoint = (width, height, extraWidth = 0) => ({\n  x: randomRange(-extraWidth, width + extraWidth),\n  y: randomRange(height * 0.7, height + 100),\n});\n\n// CSS-in-JS styles for the MeteorShower component\nconst useStyles = createUseStyles({\n  meteorShowerContainer: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: props => props.height || '100vh',\n    overflow: 'hidden',\n    pointerEvents: 'none',\n    zIndex: props => props.zIndex || 5,\n  },\n  canvas: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n  },\n});\n\n/**\n * MeteorShower Component\n * \n * Creates an animated meteor shower effect with customizable parameters.\n * Meteors fall from above the visible area and can explode into particles.\n * \n * @param {Object} props - Component props\n * @param {number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=5] - Z-index for the container\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.meteorCount=15] - Number of meteors to generate\n * @param {number} [props.meteorMinSize=1] - Minimum size of meteors\n * @param {number} [props.meteorMaxSize=3] - Maximum size of meteors\n * @param {number} [props.meteorMinSpeed=0.1] - Minimum speed of meteors\n * @param {number} [props.meteorMaxSpeed=0.3] - Maximum speed of meteors\n * @param {number} [props.meteorMinLength=100] - Minimum trail length\n * @param {number} [props.meteorMaxLength=250] - Maximum trail length\n * @param {string} [props.meteorColor='rgba(255, 215, 0, 0.8)'] - Base color for meteors\n * @param {string} [props.glowColor='rgba(255, 235, 150, 0.5)'] - Glow color for meteors\n * @param {string} [props.coreColor='rgba(255, 255, 230, 1)'] - Core color for meteors\n * @param {boolean} [props.enableParallax=false] - Enable parallax effect on scroll\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of parallax effect\n * @param {boolean} [props.enableExplosions=true] - Enable explosion effect when meteors reach bottom\n * @param {number} [props.explosionParticles=20] - Number of particles in each explosion\n * @param {number} [props.fadeOutStart=null] - Time (ms) when meteors start fading out (null = never)\n * @param {number} [props.fadeOutDuration=1500] - Duration of fade out animation\n * @param {number} [props.spawnInterval=800] - Time between meteor spawns (ms)\n * @param {number} [props.maxMeteorsOnScreen=15] - Maximum meteors visible simultaneously\n * @param {Function} [props.onComplete] - Callback when all meteors have completed\n */\nconst MeteorShower = ({\n  height = '100vh',\n  zIndex = 5,\n  active = true,\n  meteorCount = 15,\n  meteorMinSize = 1,\n  meteorMaxSize = 3,\n  meteorMinSpeed = 0.1,\n  meteorMaxSpeed = 0.3,\n  meteorMinLength = 100,\n  meteorMaxLength = 250,\n  meteorColor = 'rgba(255, 215, 0, 0.8)', // Golden\n  glowColor = 'rgba(255, 235, 150, 0.5)', // Warm glow\n  coreColor = 'rgba(255, 255, 230, 1)',   // Bright core\n  enableParallax = false,\n  parallaxIntensity = 0.2,\n  enableExplosions = true,\n  explosionParticles = 20,\n  fadeOutStart = null,\n  fadeOutDuration = 1500,\n  spawnInterval = 800,\n  maxMeteorsOnScreen = 15,\n  onComplete = () => {}\n}) => {\n  const classes = useStyles({ height, zIndex });\n  const canvasRef = useRef(null);\n  const meteorsRef = useRef([]);\n  const particlesRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n  const startTimeRef = useRef(null);\n  const nextSpawnTimeRef = useRef(0);\n  const completedCountRef = useRef(0);\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n  \n  // Initialize meteors array\n  const initializeMeteor = () => {\n    const width = dimensions.width;\n    const height = dimensions.height;\n    \n    if (!width || !height) return null;\n    \n    // Determine start and end points\n    const start = randomTopPoint(width, 50);\n    const end = randomBottomPoint(width, height, 100);\n    \n    // Calculate angle for direction\n    const angle = Math.atan2(end.y - start.y, end.x - start.x);\n    \n    // Create meteor object\n    return {\n      x: start.x,\n      y: start.y,\n      targetX: end.x,\n      targetY: end.y,\n      angle,\n      size: randomRange(meteorMinSize, meteorMaxSize),\n      length: randomRange(meteorMinLength, meteorMaxLength),\n      speed: randomRange(meteorMinSpeed, meteorMaxSpeed),\n      progress: 0,\n      active: true,\n      hasExploded: false,\n      trailOpacity: randomRange(0.6, 0.9),\n      pulsePhase: randomRange(0, Math.PI * 2),\n      pulseSpeed: randomRange(0.005, 0.015),\n      rotationOffset: randomRange(-0.2, 0.2),\n      // Add some random variations for unique appearance\n      sizeVariation: randomRange(0.9, 1.1),\n      colorHueShift: Math.floor(randomRange(-10, 10)),\n      trailSegments: Math.floor(randomRange(8, 16))\n    };\n  };\n  \n  // Create a particle explosion at a given position\n  const createExplosion = (x, y, size, color) => {\n    const particles = [];\n    const baseSpeed = size * 0.15;\n    \n    for (let i = 0; i < explosionParticles; i++) {\n      const angle = randomRange(0, Math.PI * 2);\n      const speed = randomRange(baseSpeed * 0.5, baseSpeed * 1.5);\n      const particleSize = randomRange(size * 0.1, size * 0.4);\n      const lifetime = randomRange(800, 1600);\n      \n      particles.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        size: particleSize,\n        originalSize: particleSize,\n        color,\n        opacity: randomRange(0.7, 1),\n        lifetime,\n        age: 0,\n        rotationSpeed: randomRange(-0.05, 0.05),\n        rotation: randomRange(0, Math.PI * 2),\n        // Add flickering effect\n        flickerSpeed: randomRange(0.05, 0.15),\n        flickerPhase: randomRange(0, Math.PI * 2)\n      });\n    }\n    \n    particlesRef.current = [...particlesRef.current, ...particles];\n  };\n  \n  // Update canvas dimensions on resize\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (canvasRef.current) {\n        const width = window.innerWidth;\n        const height = parseInt(height, 10) || window.innerHeight;\n        setDimensions({ width, height });\n        canvasRef.current.width = width;\n        canvasRef.current.height = height;\n      }\n    };\n    \n    updateDimensions();\n    window.addEventListener('resize', updateDimensions);\n    \n    return () => {\n      window.removeEventListener('resize', updateDimensions);\n    };\n  }, [height]);\n  \n  // Handle parallax effect on scroll\n  useEffect(() => {\n    if (!enableParallax) return;\n    \n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    \n    window.addEventListener('scroll', handleScroll);\n    \n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [enableParallax]);\n  \n  // Main animation loop\n  useEffect(() => {\n    if (!active || !dimensions.width || !dimensions.height) return;\n    \n    // Initialize start time\n    startTimeRef.current = performance.now();\n    \n    // Animation function\n    const animate = (timestamp) => {\n      if (!canvasRef.current) return;\n      \n      const ctx = canvasRef.current.getContext('2d');\n      const width = dimensions.width;\n      const height = dimensions.height;\n      \n      // Initialize lastTimestamp on first run\n      if (lastTimestampRef.current === 0) {\n        lastTimestampRef.current = timestamp;\n        nextSpawnTimeRef.current = timestamp;\n      }\n      \n      // Calculate delta time (capped to prevent jumps after tab switching)\n      const deltaTime = Math.min(timestamp - lastTimestampRef.current, 50);\n      lastTimestampRef.current = timestamp;\n      \n      // Calculate global fade based on fadeOutStart\n      let globalOpacity = 1;\n      if (fadeOutStart !== null && timestamp - startTimeRef.current > fadeOutStart) {\n        const fadeProgress = (timestamp - startTimeRef.current - fadeOutStart) / fadeOutDuration;\n        globalOpacity = Math.max(0, 1 - fadeProgress);\n        \n        if (globalOpacity <= 0) {\n          // Animation complete, call onComplete callback\n          onComplete();\n          cancelAnimationFrame(animationFrameRef.current);\n          return;\n        }\n      }\n      \n      // Clear canvas\n      ctx.clearRect(0, 0, width, height);\n      \n      // Apply parallax offset\n      let parallaxOffset = 0;\n      if (enableParallax) {\n        parallaxOffset = scrollPositionRef.current * parallaxIntensity;\n      }\n      \n      // Spawn new meteors if needed\n      if (meteorsRef.current.length < maxMeteorsOnScreen && \n          completedCountRef.current < meteorCount && \n          timestamp > nextSpawnTimeRef.current) {\n        const newMeteor = initializeMeteor();\n        if (newMeteor) {\n          meteorsRef.current.push(newMeteor);\n        }\n        nextSpawnTimeRef.current = timestamp + spawnInterval;\n      }\n      \n      // Update and draw meteors\n      meteorsRef.current = meteorsRef.current.filter(meteor => {\n        // Skip if not active\n        if (!meteor.active) return false;\n        \n        // Update progress\n        meteor.progress += meteor.speed * (deltaTime / 16);\n        \n        // Calculate current position\n        const dx = meteor.targetX - meteor.x;\n        const dy = meteor.targetY - meteor.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        \n        meteor.x += Math.cos(meteor.angle) * meteor.speed * (deltaTime / 1.5);\n        meteor.y += Math.sin(meteor.angle) * meteor.speed * (deltaTime / 1.5);\n        \n        // Check if meteor has reached its target\n        if (meteor.progress >= 1 || meteor.y > height + 50) {\n          // Create explosion if enabled\n          if (enableExplosions && !meteor.hasExploded && meteor.y <= height + 50) {\n            createExplosion(meteor.x, meteor.y, meteor.size * 5, meteorColor);\n            meteor.hasExploded = true;\n          }\n          \n          // Mark as completed\n          if (completedCountRef.current < meteorCount) {\n            completedCountRef.current++;\n          }\n          \n          return false;\n        }\n        \n        // Apply pulse effect\n        const pulseEffect = Math.sin(timestamp * meteor.pulseSpeed + meteor.pulsePhase) * 0.2 + 1;\n        \n        // Calculate adjusted positions with parallax\n        const adjustedY = meteor.y + parallaxOffset * (meteor.size / meteorMaxSize);\n        \n        // Draw meteor trail (gradient line)\n        const trailLength = meteor.length * meteor.speed * pulseEffect;\n        const trailStartX = meteor.x - Math.cos(meteor.angle) * trailLength;\n        const trailStartY = adjustedY - Math.sin(meteor.angle) * trailLength;\n        \n        // Create gradient for trail\n        const gradient = ctx.createLinearGradient(\n          meteor.x, adjustedY, \n          trailStartX, trailStartY\n        );\n        \n        gradient.addColorStop(0, coreColor.replace(/[\\d.]+\\)$/, (meteor.trailOpacity * globalOpacity) + ')'));\n        gradient.addColorStop(0.3, meteorColor.replace(/[\\d.]+\\)$/, (meteor.trailOpacity * 0.8 * globalOpacity) + ')'));\n        gradient.addColorStop(1, meteorColor.replace(/[\\d.]+\\)$/, '0)'));\n        \n        // Draw trail segments with slight variation for more natural look\n        ctx.lineWidth = meteor.size * meteor.sizeVariation * pulseEffect;\n        ctx.strokeStyle = gradient;\n        ctx.lineCap = 'round';\n        \n        // Set up shadow/glow effect\n        ctx.shadowColor = glowColor;\n        ctx.shadowBlur = meteor.size * 5 * pulseEffect;\n        \n        // Draw the main trail\n        ctx.beginPath();\n        ctx.moveTo(meteor.x, adjustedY);\n        ctx.lineTo(trailStartX, trailStartY);\n        ctx.stroke();\n        \n        // Draw the meteor head (brightest part)\n        ctx.shadowColor = glowColor;\n        ctx.shadowBlur = meteor.size * 10 * pulseEffect;\n        \n        // Draw the head gradient\n        const headGradient = ctx.createRadialGradient(\n          meteor.x, adjustedY, 0,\n          meteor.x, adjustedY, meteor.size * 2\n        );\n        \n        headGradient.addColorStop(0, coreColor.replace(/[\\d.]+\\)$/, globalOpacity + ')'));\n        headGradient.addColorStop(0.3, meteorColor.replace(/[\\d.]+\\)$/, (0.7 * globalOpacity) + ')'));\n        headGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');\n        \n        ctx.fillStyle = headGradient;\n        ctx.beginPath();\n        ctx.arc(meteor.x, adjustedY, meteor.size * 1.5 * pulseEffect, 0, Math.PI * 2);\n        ctx.fill();\n        \n        return true;\n      });\n      \n      // Update and draw particles\n      particlesRef.current = particlesRef.current.filter(particle => {\n        // Update age\n        particle.age += deltaTime;\n        \n        if (particle.age >= particle.lifetime) {\n          return false;\n        }\n        \n        // Calculate life progress (0 to 1)\n        const lifeProgress = particle.age / particle.lifetime;\n        \n        // Update position\n        particle.x += particle.vx;\n        particle.vy += 0.01; // Slight gravity\n        particle.y += particle.vy;\n        \n        // Calculate size based on life progress (grow then shrink)\n        const sizeProgress = lifeProgress <= 0.2 \n          ? lifeProgress / 0.2  // Grow during first 20%\n          : 1 - ((lifeProgress - 0.2) / 0.8); // Shrink during remaining 80%\n        \n        // Calculate opacity\n        const opacityProgress = 1 - lifeProgress;\n        const flickerEffect = Math.sin(particle.age * particle.flickerSpeed + particle.flickerPhase) * 0.3 + 0.7;\n        \n        // Apply rotation\n        particle.rotation += particle.rotationSpeed;\n        \n        // Calculate final size and opacity\n        const size = particle.originalSize * sizeProgress * flickerEffect;\n        const opacity = particle.opacity * opacityProgress * flickerEffect * globalOpacity;\n        \n        // Skip drawing if too small or transparent\n        if (size <= 0.1 || opacity <= 0.01) return true;\n        \n        // Draw particle\n        ctx.save();\n        ctx.translate(particle.x, particle.y);\n        ctx.rotate(particle.rotation);\n        \n        // Create glow effect\n        ctx.shadowColor = glowColor;\n        ctx.shadowBlur = size * 3;\n        \n        // Draw the particle\n        ctx.fillStyle = particle.color.replace(/[\\d.]+\\)$/, opacity + ')');\n        \n        // Draw as a diamond shape for Elden Ring aesthetics\n        ctx.beginPath();\n        ctx.moveTo(0, -size);\n        ctx.lineTo(size / 2, 0);\n        ctx.lineTo(0, size);\n        ctx.lineTo(-size / 2, 0);\n        ctx.closePath();\n        ctx.fill();\n        \n        ctx.restore();\n        \n        return true;\n      });\n      \n      // Continue animation\n      animationFrameRef.current = requestAnimationFrame(animate);\n    };\n    \n    // Start animation\n    animationFrameRef.current = requestAnimationFrame(animate);\n    \n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [\n    active, \n    dimensions, \n    meteorMinSize, \n    meteorMaxSize, \n    meteorMinSpeed, \n    meteorMaxSpeed, \n    meteorMinLength, \n    meteorMaxLength, \n    meteorColor, \n    glowColor, \n    coreColor, \n    enableParallax, \n    parallaxIntensity, \n    enableExplosions, \n    explosionParticles, \n    fadeOutStart, \n    fadeOutDuration, \n    spawnInterval, \n    maxMeteorsOnScreen, \n    meteorCount, \n    onComplete\n  ]);\n  \n  return (\n    <div className={classes.meteorShowerContainer}>\n      <canvas ref={canvasRef} className={classes.canvas} />\n    </div>\n  );\n};\n\n/**\n * EldenRingMeteorShower Component\n * \n * A preset version of the MeteorShower with Elden Ring-inspired styling.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const EldenRingMeteorShower = (props) => {\n  // Elden Ring-inspired preset values\n  const eldenRingPresets = {\n    meteorColor: 'rgba(255, 215, 0, 0.8)',     // Golden color\n    glowColor: 'rgba(255, 235, 150, 0.6)',     // Warm glow\n    coreColor: 'rgba(255, 248, 220, 1)',       // Bright core\n    meteorMinSize: 1.5,                        // Slightly larger meteors\n    meteorMaxSize: 4,\n    meteorMinLength: 150,                      // Longer trails\n    meteorMaxLength: 350,\n    meteorMinSpeed: 0.15,                      // Faster movement\n    meteorMaxSpeed: 0.35,\n    enableExplosions: true,\n    explosionParticles: 25,                    // More particles\n    spawnInterval: 600,                        // Faster spawning\n    maxMeteorsOnScreen: 20                     // More meteors\n  };\n  \n  return <MeteorShower {...eldenRingPresets} {...props} />;\n};\n\nexport default MeteorShower;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}