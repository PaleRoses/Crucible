{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/MeteorShower.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport { createUseStyles } from 'react-jss';\n\n// Utility function to generate random number within a range\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst randomRange = (min, max) => Math.random() * (max - min) + min;\n\n// Utility to generate a random point above the viewport\nconst randomTopPoint = (width, extraHeight = 0) => ({\n  x: randomRange(0, width),\n  y: randomRange(-200 - extraHeight, -50)\n});\n\n// Utility to generate a random point at the bottom of the viewport\nconst randomBottomPoint = (width, height, extraWidth = 0) => ({\n  x: randomRange(-extraWidth, width + extraWidth),\n  y: randomRange(height * 0.7, height + 100)\n});\n\n// CSS-in-JS styles for the MeteorShower component\nconst useStyles = createUseStyles({\n  meteorShowerContainer: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: props => props.containerHeight || '100vh',\n    overflow: 'hidden',\n    pointerEvents: 'none',\n    zIndex: props => props.zIndex || 5\n  },\n  canvas: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%'\n  }\n});\n\n/**\n * MeteorShower Component\n * \n * Creates an animated meteor shower effect with customizable parameters.\n * Meteors fall from above the visible area and can explode into particles.\n * \n * @param {Object} props - Component props\n * @param {number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=5] - Z-index for the container\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.meteorCount=15] - Number of meteors to generate\n * @param {number} [props.meteorMinSize=1] - Minimum size of meteors\n * @param {number} [props.meteorMaxSize=3] - Maximum size of meteors\n * @param {number} [props.meteorMinSpeed=0.1] - Minimum speed of meteors\n * @param {number} [props.meteorMaxSpeed=0.3] - Maximum speed of meteors\n * @param {number} [props.meteorMinLength=100] - Minimum trail length\n * @param {number} [props.meteorMaxLength=250] - Maximum trail length\n * @param {string} [props.meteorColor='rgba(255, 215, 0, 0.8)'] - Base color for meteors\n * @param {string} [props.glowColor='rgba(255, 235, 150, 0.5)'] - Glow color for meteors\n * @param {string} [props.coreColor='rgba(255, 255, 230, 1)'] - Core color for meteors\n * @param {boolean} [props.enableParallax=false] - Enable parallax effect on scroll\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of parallax effect\n * @param {boolean} [props.enableExplosions=true] - Enable explosion effect when meteors reach bottom\n * @param {number} [props.explosionParticles=20] - Number of particles in each explosion\n * @param {number} [props.fadeOutStart=null] - Time (ms) when meteors start fading out (null = never)\n * @param {number} [props.fadeOutDuration=1500] - Duration of fade out animation\n * @param {number} [props.spawnInterval=800] - Time between meteor spawns (ms)\n * @param {number} [props.maxMeteorsOnScreen=15] - Maximum meteors visible simultaneously\n * @param {Function} [props.onComplete] - Callback when all meteors have completed\n */\nconst MeteorShower = ({\n  height = '100vh',\n  zIndex = 5,\n  active = true,\n  meteorCount = 15,\n  meteorMinSize = 1,\n  meteorMaxSize = 3,\n  meteorMinSpeed = 0.1,\n  meteorMaxSpeed = 0.3,\n  meteorMinLength = 100,\n  meteorMaxLength = 250,\n  meteorColor = 'rgba(255, 215, 0, 0.8)',\n  // Golden\n  glowColor = 'rgba(255, 235, 150, 0.5)',\n  // Warm glow\n  coreColor = 'rgba(255, 255, 230, 1)',\n  // Bright core\n  enableParallax = false,\n  parallaxIntensity = 0.2,\n  enableExplosions = true,\n  explosionParticles = 20,\n  fadeOutStart = null,\n  fadeOutDuration = 1500,\n  spawnInterval = 800,\n  maxMeteorsOnScreen = 15,\n  onComplete = () => {}\n}) => {\n  _s();\n  const classes = useStyles({\n    containerHeight: height,\n    zIndex\n  });\n  const canvasRef = useRef(null);\n  const meteorsRef = useRef([]);\n  const particlesRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n  const startTimeRef = useRef(null);\n  const nextSpawnTimeRef = useRef(0);\n  const completedCountRef = useRef(0);\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0\n  });\n\n  // Initialize meteors array\n  const initializeMeteor = () => {\n    const width = dimensions.width;\n    const height = dimensions.height;\n    if (!width || !height) return null;\n\n    // Determine start and end points\n    const start = randomTopPoint(width, 50);\n    const end = randomBottomPoint(width, height, 100);\n\n    // Calculate angle for direction\n    const angle = Math.atan2(end.y - start.y, end.x - start.x);\n\n    // Create meteor object\n    return {\n      x: start.x,\n      y: start.y,\n      targetX: end.x,\n      targetY: end.y,\n      angle,\n      size: randomRange(meteorMinSize, meteorMaxSize),\n      length: randomRange(meteorMinLength, meteorMaxLength),\n      speed: randomRange(meteorMinSpeed, meteorMaxSpeed),\n      progress: 0,\n      active: true,\n      hasExploded: false,\n      trailOpacity: randomRange(0.6, 0.9),\n      pulsePhase: randomRange(0, Math.PI * 2),\n      pulseSpeed: randomRange(0.005, 0.015),\n      rotationOffset: randomRange(-0.2, 0.2),\n      // Add some random variations for unique appearance\n      sizeVariation: randomRange(0.9, 1.1),\n      colorHueShift: Math.floor(randomRange(-10, 10)),\n      trailSegments: Math.floor(randomRange(8, 16))\n    };\n  };\n\n  // Create a particle explosion at a given position\n  const createExplosion = (x, y, size, color) => {\n    const particles = [];\n    const baseSpeed = size * 0.15;\n    for (let i = 0; i < explosionParticles; i++) {\n      const angle = randomRange(0, Math.PI * 2);\n      const speed = randomRange(baseSpeed * 0.5, baseSpeed * 1.5);\n      const particleSize = randomRange(size * 0.1, size * 0.4);\n      const lifetime = randomRange(800, 1600);\n      particles.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        size: particleSize,\n        originalSize: particleSize,\n        color,\n        opacity: randomRange(0.7, 1),\n        lifetime,\n        age: 0,\n        rotationSpeed: randomRange(-0.05, 0.05),\n        rotation: randomRange(0, Math.PI * 2),\n        // Add flickering effect\n        flickerSpeed: randomRange(0.05, 0.15),\n        flickerPhase: randomRange(0, Math.PI * 2)\n      });\n    }\n    particlesRef.current = [...particlesRef.current, ...particles];\n  };\n\n  // Update canvas dimensions on resize\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (canvasRef.current) {\n        const width = window.innerWidth;\n        const containerHeight = typeof height === 'string' && height.endsWith('vh') ? parseInt(height, 10) / 100 * window.innerHeight : parseInt(height, 10) || window.innerHeight;\n        setDimensions({\n          width,\n          height: containerHeight\n        });\n        canvasRef.current.width = width;\n        canvasRef.current.height = containerHeight;\n      }\n    };\n    updateDimensions();\n    window.addEventListener('resize', updateDimensions);\n    return () => {\n      window.removeEventListener('resize', updateDimensions);\n    };\n  }, [height]);\n\n  // Handle parallax effect on scroll\n  useEffect(() => {\n    if (!enableParallax) return;\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    window.addEventListener('scroll', handleScroll);\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [enableParallax]);\n\n  // Main animation loop\n  useEffect(() => {\n    if (!active || !dimensions.width || !dimensions.height) return;\n\n    // Initialize start time\n    startTimeRef.current = performance.now();\n\n    // Animation function\n    const animate = timestamp => {\n      if (!canvasRef.current) return;\n      const ctx = canvasRef.current.getContext('2d');\n      const width = dimensions.width;\n      const height = dimensions.height;\n\n      // Initialize lastTimestamp on first run\n      if (lastTimestampRef.current === 0) {\n        lastTimestampRef.current = timestamp;\n        nextSpawnTimeRef.current = timestamp;\n      }\n\n      // Calculate delta time (capped to prevent jumps after tab switching)\n      const deltaTime = Math.min(timestamp - lastTimestampRef.current, 50);\n      lastTimestampRef.current = timestamp;\n\n      // Calculate global fade based on fadeOutStart\n      let globalOpacity = 1;\n      if (fadeOutStart !== null && timestamp - startTimeRef.current > fadeOutStart) {\n        const fadeProgress = (timestamp - startTimeRef.current - fadeOutStart) / fadeOutDuration;\n        globalOpacity = Math.max(0, 1 - fadeProgress);\n        if (globalOpacity <= 0) {\n          // Animation complete, call onComplete callback\n          onComplete();\n          cancelAnimationFrame(animationFrameRef.current);\n          return;\n        }\n      }\n\n      // Clear canvas\n      ctx.clearRect(0, 0, width, height);\n\n      // Apply parallax offset\n      let parallaxOffset = 0;\n      if (enableParallax) {\n        parallaxOffset = scrollPositionRef.current * parallaxIntensity;\n      }\n\n      // Spawn new meteors if needed\n      if (meteorsRef.current.length < maxMeteorsOnScreen && completedCountRef.current < meteorCount && timestamp > nextSpawnTimeRef.current) {\n        const newMeteor = initializeMeteor();\n        if (newMeteor) {\n          meteorsRef.current.push(newMeteor);\n        }\n        nextSpawnTimeRef.current = timestamp + spawnInterval;\n      }\n\n      // Update and draw meteors\n      meteorsRef.current = meteorsRef.current.filter(meteor => {\n        // Skip if not active\n        if (!meteor.active) return false;\n\n        // Update progress\n        meteor.progress += meteor.speed * (deltaTime / 16);\n\n        // Calculate current position\n        meteor.x += Math.cos(meteor.angle) * meteor.speed * (deltaTime / 1.5);\n        meteor.y += Math.sin(meteor.angle) * meteor.speed * (deltaTime / 1.5);\n\n        // Check if meteor has reached its target\n        if (meteor.progress >= 1 || meteor.y > height + 50) {\n          // Create explosion if enabled\n          if (enableExplosions && !meteor.hasExploded && meteor.y <= height + 50) {\n            createExplosion(meteor.x, meteor.y, meteor.size * 5, meteorColor);\n            meteor.hasExploded = true;\n          }\n\n          // Mark as completed\n          if (completedCountRef.current < meteorCount) {\n            completedCountRef.current++;\n          }\n          return false;\n        }\n\n        // Apply pulse effect\n        const pulseEffect = Math.sin(timestamp * meteor.pulseSpeed + meteor.pulsePhase) * 0.2 + 1;\n\n        // Calculate adjusted positions with parallax\n        const adjustedY = meteor.y + parallaxOffset * (meteor.size / meteorMaxSize);\n\n        // Draw meteor trail (gradient line)\n        const trailLength = meteor.length * meteor.speed * pulseEffect;\n        const trailStartX = meteor.x - Math.cos(meteor.angle) * trailLength;\n        const trailStartY = adjustedY - Math.sin(meteor.angle) * trailLength;\n\n        // Create gradient for trail\n        const gradient = ctx.createLinearGradient(meteor.x, adjustedY, trailStartX, trailStartY);\n        gradient.addColorStop(0, coreColor.replace(/[\\d.]+\\)$/, meteor.trailOpacity * globalOpacity + ')'));\n        gradient.addColorStop(0.3, meteorColor.replace(/[\\d.]+\\)$/, meteor.trailOpacity * 0.8 * globalOpacity + ')'));\n        gradient.addColorStop(1, meteorColor.replace(/[\\d.]+\\)$/, '0)'));\n\n        // Draw trail segments with slight variation for more natural look\n        ctx.lineWidth = meteor.size * meteor.sizeVariation * pulseEffect;\n        ctx.strokeStyle = gradient;\n        ctx.lineCap = 'round';\n\n        // Set up shadow/glow effect\n        ctx.shadowColor = glowColor;\n        ctx.shadowBlur = meteor.size * 5 * pulseEffect;\n\n        // Draw the main trail\n        ctx.beginPath();\n        ctx.moveTo(meteor.x, adjustedY);\n        ctx.lineTo(trailStartX, trailStartY);\n        ctx.stroke();\n\n        // Draw the meteor head (brightest part)\n        ctx.shadowColor = glowColor;\n        ctx.shadowBlur = meteor.size * 10 * pulseEffect;\n\n        // Draw the head gradient\n        const headGradient = ctx.createRadialGradient(meteor.x, adjustedY, 0, meteor.x, adjustedY, meteor.size * 2);\n        headGradient.addColorStop(0, coreColor.replace(/[\\d.]+\\)$/, globalOpacity + ')'));\n        headGradient.addColorStop(0.3, meteorColor.replace(/[\\d.]+\\)$/, 0.7 * globalOpacity + ')'));\n        headGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');\n        ctx.fillStyle = headGradient;\n        ctx.beginPath();\n        ctx.arc(meteor.x, adjustedY, meteor.size * 1.5 * pulseEffect, 0, Math.PI * 2);\n        ctx.fill();\n        return true;\n      });\n\n      // Update and draw particles\n      particlesRef.current = particlesRef.current.filter(particle => {\n        // Update age\n        particle.age += deltaTime;\n        if (particle.age >= particle.lifetime) {\n          return false;\n        }\n\n        // Calculate life progress (0 to 1)\n        const lifeProgress = particle.age / particle.lifetime;\n\n        // Update position\n        particle.x += particle.vx;\n        particle.vy += 0.01; // Slight gravity\n        particle.y += particle.vy;\n\n        // Calculate size based on life progress (grow then shrink)\n        const sizeProgress = lifeProgress <= 0.2 ? lifeProgress / 0.2 // Grow during first 20%\n        : 1 - (lifeProgress - 0.2) / 0.8; // Shrink during remaining 80%\n\n        // Calculate opacity\n        const opacityProgress = 1 - lifeProgress;\n        const flickerEffect = Math.sin(particle.age * particle.flickerSpeed + particle.flickerPhase) * 0.3 + 0.7;\n\n        // Apply rotation\n        particle.rotation += particle.rotationSpeed;\n\n        // Calculate final size and opacity\n        const size = particle.originalSize * sizeProgress * flickerEffect;\n        const opacity = particle.opacity * opacityProgress * flickerEffect * globalOpacity;\n\n        // Skip drawing if too small or transparent\n        if (size <= 0.1 || opacity <= 0.01) return true;\n\n        // Draw particle\n        ctx.save();\n        ctx.translate(particle.x, particle.y);\n        ctx.rotate(particle.rotation);\n\n        // Create glow effect\n        ctx.shadowColor = glowColor;\n        ctx.shadowBlur = size * 3;\n\n        // Draw the particle\n        ctx.fillStyle = particle.color.replace(/[\\d.]+\\)$/, opacity + ')');\n\n        // Draw as a diamond shape for Elden Ring aesthetics\n        ctx.beginPath();\n        ctx.moveTo(0, -size);\n        ctx.lineTo(size / 2, 0);\n        ctx.lineTo(0, size);\n        ctx.lineTo(-size / 2, 0);\n        ctx.closePath();\n        ctx.fill();\n        ctx.restore();\n        return true;\n      });\n\n      // Continue animation\n      animationFrameRef.current = requestAnimationFrame(animate);\n    };\n\n    // Start animation\n    animationFrameRef.current = requestAnimationFrame(animate);\n\n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [active, dimensions, meteorMinSize, meteorMaxSize, meteorMinSpeed, meteorMaxSpeed, meteorMinLength, meteorMaxLength, meteorColor, glowColor, coreColor, enableParallax, parallaxIntensity, enableExplosions, explosionParticles, fadeOutStart, fadeOutDuration, spawnInterval, maxMeteorsOnScreen, meteorCount, onComplete]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: classes.meteorShowerContainer,\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      className: classes.canvas\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 461,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 460,\n    columnNumber: 5\n  }, this);\n};\n\n/**\n * EldenRingMeteorShower Component\n * \n * A preset version of the MeteorShower with Elden Ring-inspired styling.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_s(MeteorShower, \"O38NOmVAaFBucLhNox6nYKt5knM=\", false, function () {\n  return [useStyles];\n});\n_c = MeteorShower;\nexport const EldenRingMeteorShower = props => {\n  // Elden Ring-inspired preset values\n  const eldenRingPresets = {\n    meteorColor: 'rgba(255, 215, 0, 0.8)',\n    // Golden color\n    glowColor: 'rgba(255, 235, 150, 0.6)',\n    // Warm glow\n    coreColor: 'rgba(255, 248, 220, 1)',\n    // Bright core\n    meteorMinSize: 1.5,\n    // Slightly larger meteors\n    meteorMaxSize: 4,\n    meteorMinLength: 150,\n    // Longer trails\n    meteorMaxLength: 350,\n    meteorMinSpeed: 0.15,\n    // Faster movement\n    meteorMaxSpeed: 0.35,\n    enableExplosions: true,\n    explosionParticles: 25,\n    // More particles\n    spawnInterval: 600,\n    // Faster spawning\n    maxMeteorsOnScreen: 20 // More meteors\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...eldenRingPresets,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 491,\n    columnNumber: 10\n  }, this);\n};\n_c2 = EldenRingMeteorShower;\nexport default MeteorShower;\nvar _c, _c2;\n$RefreshReg$(_c, \"MeteorShower\");\n$RefreshReg$(_c2, \"EldenRingMeteorShower\");","map":{"version":3,"names":["React","useState","useEffect","useRef","createUseStyles","jsxDEV","_jsxDEV","randomRange","min","max","Math","random","randomTopPoint","width","extraHeight","x","y","randomBottomPoint","height","extraWidth","useStyles","meteorShowerContainer","position","top","left","props","containerHeight","overflow","pointerEvents","zIndex","canvas","MeteorShower","active","meteorCount","meteorMinSize","meteorMaxSize","meteorMinSpeed","meteorMaxSpeed","meteorMinLength","meteorMaxLength","meteorColor","glowColor","coreColor","enableParallax","parallaxIntensity","enableExplosions","explosionParticles","fadeOutStart","fadeOutDuration","spawnInterval","maxMeteorsOnScreen","onComplete","_s","classes","canvasRef","meteorsRef","particlesRef","animationFrameRef","lastTimestampRef","scrollPositionRef","startTimeRef","nextSpawnTimeRef","completedCountRef","dimensions","setDimensions","initializeMeteor","start","end","angle","atan2","targetX","targetY","size","length","speed","progress","hasExploded","trailOpacity","pulsePhase","PI","pulseSpeed","rotationOffset","sizeVariation","colorHueShift","floor","trailSegments","createExplosion","color","particles","baseSpeed","i","particleSize","lifetime","push","vx","cos","vy","sin","originalSize","opacity","age","rotationSpeed","rotation","flickerSpeed","flickerPhase","current","updateDimensions","window","innerWidth","endsWith","parseInt","innerHeight","addEventListener","removeEventListener","handleScroll","scrollY","performance","now","animate","timestamp","ctx","getContext","deltaTime","globalOpacity","fadeProgress","cancelAnimationFrame","clearRect","parallaxOffset","newMeteor","filter","meteor","pulseEffect","adjustedY","trailLength","trailStartX","trailStartY","gradient","createLinearGradient","addColorStop","replace","lineWidth","strokeStyle","lineCap","shadowColor","shadowBlur","beginPath","moveTo","lineTo","stroke","headGradient","createRadialGradient","fillStyle","arc","fill","particle","lifeProgress","sizeProgress","opacityProgress","flickerEffect","save","translate","rotate","closePath","restore","requestAnimationFrame","className","children","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","EldenRingMeteorShower","eldenRingPresets","_c2","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/MeteorShower.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport { createUseStyles } from 'react-jss';\n\n// Utility function to generate random number within a range\nconst randomRange = (min, max) => Math.random() * (max - min) + min;\n\n// Utility to generate a random point above the viewport\nconst randomTopPoint = (width, extraHeight = 0) => ({\n  x: randomRange(0, width),\n  y: randomRange(-200 - extraHeight, -50),\n});\n\n// Utility to generate a random point at the bottom of the viewport\nconst randomBottomPoint = (width, height, extraWidth = 0) => ({\n  x: randomRange(-extraWidth, width + extraWidth),\n  y: randomRange(height * 0.7, height + 100),\n});\n\n// CSS-in-JS styles for the MeteorShower component\nconst useStyles = createUseStyles({\n  meteorShowerContainer: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: props => props.containerHeight || '100vh',\n    overflow: 'hidden',\n    pointerEvents: 'none',\n    zIndex: props => props.zIndex || 5,\n  },\n  canvas: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n  },\n});\n\n/**\n * MeteorShower Component\n * \n * Creates an animated meteor shower effect with customizable parameters.\n * Meteors fall from above the visible area and can explode into particles.\n * \n * @param {Object} props - Component props\n * @param {number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=5] - Z-index for the container\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.meteorCount=15] - Number of meteors to generate\n * @param {number} [props.meteorMinSize=1] - Minimum size of meteors\n * @param {number} [props.meteorMaxSize=3] - Maximum size of meteors\n * @param {number} [props.meteorMinSpeed=0.1] - Minimum speed of meteors\n * @param {number} [props.meteorMaxSpeed=0.3] - Maximum speed of meteors\n * @param {number} [props.meteorMinLength=100] - Minimum trail length\n * @param {number} [props.meteorMaxLength=250] - Maximum trail length\n * @param {string} [props.meteorColor='rgba(255, 215, 0, 0.8)'] - Base color for meteors\n * @param {string} [props.glowColor='rgba(255, 235, 150, 0.5)'] - Glow color for meteors\n * @param {string} [props.coreColor='rgba(255, 255, 230, 1)'] - Core color for meteors\n * @param {boolean} [props.enableParallax=false] - Enable parallax effect on scroll\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of parallax effect\n * @param {boolean} [props.enableExplosions=true] - Enable explosion effect when meteors reach bottom\n * @param {number} [props.explosionParticles=20] - Number of particles in each explosion\n * @param {number} [props.fadeOutStart=null] - Time (ms) when meteors start fading out (null = never)\n * @param {number} [props.fadeOutDuration=1500] - Duration of fade out animation\n * @param {number} [props.spawnInterval=800] - Time between meteor spawns (ms)\n * @param {number} [props.maxMeteorsOnScreen=15] - Maximum meteors visible simultaneously\n * @param {Function} [props.onComplete] - Callback when all meteors have completed\n */\nconst MeteorShower = ({\n  height = '100vh',\n  zIndex = 5,\n  active = true,\n  meteorCount = 15,\n  meteorMinSize = 1,\n  meteorMaxSize = 3,\n  meteorMinSpeed = 0.1,\n  meteorMaxSpeed = 0.3,\n  meteorMinLength = 100,\n  meteorMaxLength = 250,\n  meteorColor = 'rgba(255, 215, 0, 0.8)', // Golden\n  glowColor = 'rgba(255, 235, 150, 0.5)', // Warm glow\n  coreColor = 'rgba(255, 255, 230, 1)',   // Bright core\n  enableParallax = false,\n  parallaxIntensity = 0.2,\n  enableExplosions = true,\n  explosionParticles = 20,\n  fadeOutStart = null,\n  fadeOutDuration = 1500,\n  spawnInterval = 800,\n  maxMeteorsOnScreen = 15,\n  onComplete = () => {}\n}) => {\n  const classes = useStyles({ containerHeight: height, zIndex });\n  const canvasRef = useRef(null);\n  const meteorsRef = useRef([]);\n  const particlesRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n  const startTimeRef = useRef(null);\n  const nextSpawnTimeRef = useRef(0);\n  const completedCountRef = useRef(0);\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n  \n  // Initialize meteors array\n  const initializeMeteor = () => {\n    const width = dimensions.width;\n    const height = dimensions.height;\n    \n    if (!width || !height) return null;\n    \n    // Determine start and end points\n    const start = randomTopPoint(width, 50);\n    const end = randomBottomPoint(width, height, 100);\n    \n    // Calculate angle for direction\n    const angle = Math.atan2(end.y - start.y, end.x - start.x);\n    \n    // Create meteor object\n    return {\n      x: start.x,\n      y: start.y,\n      targetX: end.x,\n      targetY: end.y,\n      angle,\n      size: randomRange(meteorMinSize, meteorMaxSize),\n      length: randomRange(meteorMinLength, meteorMaxLength),\n      speed: randomRange(meteorMinSpeed, meteorMaxSpeed),\n      progress: 0,\n      active: true,\n      hasExploded: false,\n      trailOpacity: randomRange(0.6, 0.9),\n      pulsePhase: randomRange(0, Math.PI * 2),\n      pulseSpeed: randomRange(0.005, 0.015),\n      rotationOffset: randomRange(-0.2, 0.2),\n      // Add some random variations for unique appearance\n      sizeVariation: randomRange(0.9, 1.1),\n      colorHueShift: Math.floor(randomRange(-10, 10)),\n      trailSegments: Math.floor(randomRange(8, 16))\n    };\n  };\n  \n  // Create a particle explosion at a given position\n  const createExplosion = (x, y, size, color) => {\n    const particles = [];\n    const baseSpeed = size * 0.15;\n    \n    for (let i = 0; i < explosionParticles; i++) {\n      const angle = randomRange(0, Math.PI * 2);\n      const speed = randomRange(baseSpeed * 0.5, baseSpeed * 1.5);\n      const particleSize = randomRange(size * 0.1, size * 0.4);\n      const lifetime = randomRange(800, 1600);\n      \n      particles.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        size: particleSize,\n        originalSize: particleSize,\n        color,\n        opacity: randomRange(0.7, 1),\n        lifetime,\n        age: 0,\n        rotationSpeed: randomRange(-0.05, 0.05),\n        rotation: randomRange(0, Math.PI * 2),\n        // Add flickering effect\n        flickerSpeed: randomRange(0.05, 0.15),\n        flickerPhase: randomRange(0, Math.PI * 2)\n      });\n    }\n    \n    particlesRef.current = [...particlesRef.current, ...particles];\n  };\n  \n  // Update canvas dimensions on resize\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (canvasRef.current) {\n        const width = window.innerWidth;\n        const containerHeight = typeof height === 'string' && height.endsWith('vh') \n          ? (parseInt(height, 10) / 100) * window.innerHeight\n          : parseInt(height, 10) || window.innerHeight;\n          \n        setDimensions({ width, height: containerHeight });\n        canvasRef.current.width = width;\n        canvasRef.current.height = containerHeight;\n      }\n    };\n    \n    updateDimensions();\n    window.addEventListener('resize', updateDimensions);\n    \n    return () => {\n      window.removeEventListener('resize', updateDimensions);\n    };\n  }, [height]);\n  \n  // Handle parallax effect on scroll\n  useEffect(() => {\n    if (!enableParallax) return;\n    \n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    \n    window.addEventListener('scroll', handleScroll);\n    \n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [enableParallax]);\n  \n  // Main animation loop\n  useEffect(() => {\n    if (!active || !dimensions.width || !dimensions.height) return;\n    \n    // Initialize start time\n    startTimeRef.current = performance.now();\n    \n    // Animation function\n    const animate = (timestamp) => {\n      if (!canvasRef.current) return;\n      \n      const ctx = canvasRef.current.getContext('2d');\n      const width = dimensions.width;\n      const height = dimensions.height;\n      \n      // Initialize lastTimestamp on first run\n      if (lastTimestampRef.current === 0) {\n        lastTimestampRef.current = timestamp;\n        nextSpawnTimeRef.current = timestamp;\n      }\n      \n      // Calculate delta time (capped to prevent jumps after tab switching)\n      const deltaTime = Math.min(timestamp - lastTimestampRef.current, 50);\n      lastTimestampRef.current = timestamp;\n      \n      // Calculate global fade based on fadeOutStart\n      let globalOpacity = 1;\n      if (fadeOutStart !== null && timestamp - startTimeRef.current > fadeOutStart) {\n        const fadeProgress = (timestamp - startTimeRef.current - fadeOutStart) / fadeOutDuration;\n        globalOpacity = Math.max(0, 1 - fadeProgress);\n        \n        if (globalOpacity <= 0) {\n          // Animation complete, call onComplete callback\n          onComplete();\n          cancelAnimationFrame(animationFrameRef.current);\n          return;\n        }\n      }\n      \n      // Clear canvas\n      ctx.clearRect(0, 0, width, height);\n      \n      // Apply parallax offset\n      let parallaxOffset = 0;\n      if (enableParallax) {\n        parallaxOffset = scrollPositionRef.current * parallaxIntensity;\n      }\n      \n      // Spawn new meteors if needed\n      if (meteorsRef.current.length < maxMeteorsOnScreen && \n          completedCountRef.current < meteorCount && \n          timestamp > nextSpawnTimeRef.current) {\n        const newMeteor = initializeMeteor();\n        if (newMeteor) {\n          meteorsRef.current.push(newMeteor);\n        }\n        nextSpawnTimeRef.current = timestamp + spawnInterval;\n      }\n      \n      // Update and draw meteors\n      meteorsRef.current = meteorsRef.current.filter(meteor => {\n        // Skip if not active\n        if (!meteor.active) return false;\n        \n        // Update progress\n        meteor.progress += meteor.speed * (deltaTime / 16);\n        \n        // Calculate current position\n        meteor.x += Math.cos(meteor.angle) * meteor.speed * (deltaTime / 1.5);\n        meteor.y += Math.sin(meteor.angle) * meteor.speed * (deltaTime / 1.5);\n        \n        // Check if meteor has reached its target\n        if (meteor.progress >= 1 || meteor.y > height + 50) {\n          // Create explosion if enabled\n          if (enableExplosions && !meteor.hasExploded && meteor.y <= height + 50) {\n            createExplosion(meteor.x, meteor.y, meteor.size * 5, meteorColor);\n            meteor.hasExploded = true;\n          }\n          \n          // Mark as completed\n          if (completedCountRef.current < meteorCount) {\n            completedCountRef.current++;\n          }\n          \n          return false;\n        }\n        \n        // Apply pulse effect\n        const pulseEffect = Math.sin(timestamp * meteor.pulseSpeed + meteor.pulsePhase) * 0.2 + 1;\n        \n        // Calculate adjusted positions with parallax\n        const adjustedY = meteor.y + parallaxOffset * (meteor.size / meteorMaxSize);\n        \n        // Draw meteor trail (gradient line)\n        const trailLength = meteor.length * meteor.speed * pulseEffect;\n        const trailStartX = meteor.x - Math.cos(meteor.angle) * trailLength;\n        const trailStartY = adjustedY - Math.sin(meteor.angle) * trailLength;\n        \n        // Create gradient for trail\n        const gradient = ctx.createLinearGradient(\n          meteor.x, adjustedY, \n          trailStartX, trailStartY\n        );\n        \n        gradient.addColorStop(0, coreColor.replace(/[\\d.]+\\)$/, (meteor.trailOpacity * globalOpacity) + ')'));\n        gradient.addColorStop(0.3, meteorColor.replace(/[\\d.]+\\)$/, (meteor.trailOpacity * 0.8 * globalOpacity) + ')'));\n        gradient.addColorStop(1, meteorColor.replace(/[\\d.]+\\)$/, '0)'));\n        \n        // Draw trail segments with slight variation for more natural look\n        ctx.lineWidth = meteor.size * meteor.sizeVariation * pulseEffect;\n        ctx.strokeStyle = gradient;\n        ctx.lineCap = 'round';\n        \n        // Set up shadow/glow effect\n        ctx.shadowColor = glowColor;\n        ctx.shadowBlur = meteor.size * 5 * pulseEffect;\n        \n        // Draw the main trail\n        ctx.beginPath();\n        ctx.moveTo(meteor.x, adjustedY);\n        ctx.lineTo(trailStartX, trailStartY);\n        ctx.stroke();\n        \n        // Draw the meteor head (brightest part)\n        ctx.shadowColor = glowColor;\n        ctx.shadowBlur = meteor.size * 10 * pulseEffect;\n        \n        // Draw the head gradient\n        const headGradient = ctx.createRadialGradient(\n          meteor.x, adjustedY, 0,\n          meteor.x, adjustedY, meteor.size * 2\n        );\n        \n        headGradient.addColorStop(0, coreColor.replace(/[\\d.]+\\)$/, globalOpacity + ')'));\n        headGradient.addColorStop(0.3, meteorColor.replace(/[\\d.]+\\)$/, (0.7 * globalOpacity) + ')'));\n        headGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');\n        \n        ctx.fillStyle = headGradient;\n        ctx.beginPath();\n        ctx.arc(meteor.x, adjustedY, meteor.size * 1.5 * pulseEffect, 0, Math.PI * 2);\n        ctx.fill();\n        \n        return true;\n      });\n      \n      // Update and draw particles\n      particlesRef.current = particlesRef.current.filter(particle => {\n        // Update age\n        particle.age += deltaTime;\n        \n        if (particle.age >= particle.lifetime) {\n          return false;\n        }\n        \n        // Calculate life progress (0 to 1)\n        const lifeProgress = particle.age / particle.lifetime;\n        \n        // Update position\n        particle.x += particle.vx;\n        particle.vy += 0.01; // Slight gravity\n        particle.y += particle.vy;\n        \n        // Calculate size based on life progress (grow then shrink)\n        const sizeProgress = lifeProgress <= 0.2 \n          ? lifeProgress / 0.2  // Grow during first 20%\n          : 1 - ((lifeProgress - 0.2) / 0.8); // Shrink during remaining 80%\n        \n        // Calculate opacity\n        const opacityProgress = 1 - lifeProgress;\n        const flickerEffect = Math.sin(particle.age * particle.flickerSpeed + particle.flickerPhase) * 0.3 + 0.7;\n        \n        // Apply rotation\n        particle.rotation += particle.rotationSpeed;\n        \n        // Calculate final size and opacity\n        const size = particle.originalSize * sizeProgress * flickerEffect;\n        const opacity = particle.opacity * opacityProgress * flickerEffect * globalOpacity;\n        \n        // Skip drawing if too small or transparent\n        if (size <= 0.1 || opacity <= 0.01) return true;\n        \n        // Draw particle\n        ctx.save();\n        ctx.translate(particle.x, particle.y);\n        ctx.rotate(particle.rotation);\n        \n        // Create glow effect\n        ctx.shadowColor = glowColor;\n        ctx.shadowBlur = size * 3;\n        \n        // Draw the particle\n        ctx.fillStyle = particle.color.replace(/[\\d.]+\\)$/, opacity + ')');\n        \n        // Draw as a diamond shape for Elden Ring aesthetics\n        ctx.beginPath();\n        ctx.moveTo(0, -size);\n        ctx.lineTo(size / 2, 0);\n        ctx.lineTo(0, size);\n        ctx.lineTo(-size / 2, 0);\n        ctx.closePath();\n        ctx.fill();\n        \n        ctx.restore();\n        \n        return true;\n      });\n      \n      // Continue animation\n      animationFrameRef.current = requestAnimationFrame(animate);\n    };\n    \n    // Start animation\n    animationFrameRef.current = requestAnimationFrame(animate);\n    \n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [\n    active, \n    dimensions, \n    meteorMinSize, \n    meteorMaxSize, \n    meteorMinSpeed, \n    meteorMaxSpeed, \n    meteorMinLength, \n    meteorMaxLength, \n    meteorColor, \n    glowColor, \n    coreColor, \n    enableParallax, \n    parallaxIntensity, \n    enableExplosions, \n    explosionParticles, \n    fadeOutStart, \n    fadeOutDuration, \n    spawnInterval, \n    maxMeteorsOnScreen, \n    meteorCount, \n    onComplete\n  ]);\n  \n  return (\n    <div className={classes.meteorShowerContainer}>\n      <canvas ref={canvasRef} className={classes.canvas} />\n    </div>\n  );\n};\n\n/**\n * EldenRingMeteorShower Component\n * \n * A preset version of the MeteorShower with Elden Ring-inspired styling.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const EldenRingMeteorShower = (props) => {\n  // Elden Ring-inspired preset values\n  const eldenRingPresets = {\n    meteorColor: 'rgba(255, 215, 0, 0.8)',     // Golden color\n    glowColor: 'rgba(255, 235, 150, 0.6)',     // Warm glow\n    coreColor: 'rgba(255, 248, 220, 1)',       // Bright core\n    meteorMinSize: 1.5,                        // Slightly larger meteors\n    meteorMaxSize: 4,\n    meteorMinLength: 150,                      // Longer trails\n    meteorMaxLength: 350,\n    meteorMinSpeed: 0.15,                      // Faster movement\n    meteorMaxSpeed: 0.35,\n    enableExplosions: true,\n    explosionParticles: 25,                    // More particles\n    spawnInterval: 600,                        // Faster spawning\n    maxMeteorsOnScreen: 20                     // More meteors\n  };\n  \n  return <MeteorShower {...eldenRingPresets} {...props} />;\n};\n\nexport default MeteorShower;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}