{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/layout/Background.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useCallback, useMemo } from 'react';\nimport { useScroll, useSpring } from 'framer-motion';\n\n/**\n * Background Component\n * \n * Combines canvas-based star rendering with scroll-based parallax effects\n * for an immersive, performance-optimized background that responds to scrolling.\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Background = ({\n  config = {}\n}) => {\n  _s();\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const starsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimeRef = useRef(0);\n  const lastScrollYRef = useRef(0);\n\n  // Use refs instead of state to prevent re-renders\n  const isInitializedRef = useRef(false);\n  const firstRenderCompleteRef = useRef(false);\n\n  // Store dimensions in a ref to avoid re-renders when they change\n  const dimensionsRef = useRef({\n    width: 0,\n    height: 0,\n    pixelRatio: 1\n  });\n\n  // Get scroll position using framer-motion\n  const {\n    scrollY\n  } = useScroll({\n    smooth: 0.05 // Smoother scrolling for high-framerate animations\n  });\n\n  // Use spring physics for smoother scrolling effect\n  const springScrollY = useSpring(scrollY, {\n    stiffness: 10,\n    damping: 25,\n    mass: 0.5,\n    restDelta: 0.001,\n    restSpeed: 0.001\n  });\n\n  // Track spring scrollY value without causing re-renders\n  const springScrollYRef = useRef(0);\n  useEffect(() => {\n    const unsubscribe = springScrollY.onChange(value => {\n      springScrollYRef.current = value;\n    });\n    return () => unsubscribe();\n  }, [springScrollY]);\n\n  // Configuration - wrapped in useMemo to prevent recreation on each render\n  // Merge default config with user-provided config\n  const CONFIG = useMemo(() => ({\n    // Star appearance\n    starCount: 200,\n    starSizeMin: 0.8,\n    starSizeMax: 2.5,\n    starOpacityMin: 0.15,\n    starOpacityMax: 0.85,\n    // Parallax and movement parameters\n    baseMovementSpeed: 0.00004,\n    // Reduced for slower movement\n    pulseFrequency: 0.00002,\n    // Slower pulsing\n    parallaxEnabled: true,\n    parallaxFactor: 0.5,\n    // How much stars move relative to scroll (0-1)\n\n    // Trail effect parameters\n    trailEnabled: true,\n    // Enable subtle trails\n    trailLength: 10,\n    // Very short trail length (in pixels)\n    trailOpacityFactor: 0.5,\n    // Trail opacity relative to star opacity\n\n    // Twinkling effect parameters\n    twinkleEnabled: true,\n    // Enable stars to fade in and out\n    twinkleProbability: 0.01,\n    // Probability of a star beginning to twinkle each frame\n    twinkleDuration: [2000, 4000],\n    // Min and max duration of a twinkle cycle in ms\n\n    // Random movement parameters\n    randomMovementEnabled: true,\n    // Enable small random movements\n    randomMovementIntensity: 0.03,\n    // Intensity of random movement\n    directionChangeFrequency: 0.01,\n    // Probability of changing direction each frame\n\n    // Physics parameters for bouncy effect\n    springStrength: 0.08,\n    // Higher = snappier\n    dampingFactor: 0.9,\n    // Higher = less bouncy (0-1)\n\n    // Star distribution parameters\n    verticalSpreadFactor: 3,\n    // How many screen heights to spread stars across\n    offscreenBuffer: 1,\n    // How many screen heights above viewport to generate stars\n\n    // Performance parameters\n    maxFPS: 30,\n    useRays: false,\n    // Disable ray rendering for performance\n\n    // Session persistence\n    sessionKey: 'scrolling_star_background_config',\n    // Override with user config\n    ...config\n  }), [config]);\n\n  // Warm, golden color palette - wrapped in useMemo\n  const COLORS = useMemo(() => ({\n    // Star colors\n    stars: ['rgba(255, 243, 200, alpha)',\n    // Warm yellow\n    'rgba(255, 231, 164, alpha)',\n    // Golden\n    'rgba(252, 249, 231, alpha)' // Off-white gold\n    ],\n    // Background gradient colors\n    background: {\n      topColor: 'rgb(8, 8, 12)',\n      bottomColor: 'rgb(15, 15, 20)'\n    },\n    // Override with user config if provided\n    ...(config.colors || {})\n  }), [config.colors]);\n\n  // Pre-generated color values to avoid string replacements during animation\n  const colorCache = useMemo(() => {\n    const cache = {};\n    COLORS.stars.forEach(baseColor => {\n      cache[baseColor] = {};\n      for (let opacity = 0; opacity <= 10; opacity++) {\n        const value = opacity / 10;\n        cache[baseColor][value] = baseColor.replace(/alpha\\)$/, `${value})`);\n      }\n    });\n    return cache;\n  }, [COLORS.stars]);\n\n  // Get color with opacity from cache (faster than string replacement)\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    // Round to nearest 0.1 to use cached values\n    const roundedOpacity = Math.round(safeOpacity * 10) / 10;\n    return colorCache[baseColor][roundedOpacity] || baseColor.replace(/alpha\\)$/, `${safeOpacity})`);\n  }, [colorCache]);\n\n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) return false;\n    const canvas = canvasRef.current;\n\n    // Get viewport dimensions\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const pixelRatio = window.devicePixelRatio || 1;\n\n    // Set canvas size accounting for pixel ratio\n    canvas.width = width * pixelRatio;\n    canvas.height = height * pixelRatio;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n\n    // Ensure canvas is visible with a background color\n    const ctx = canvas.getContext('2d', {\n      alpha: false\n    }); // Optimize for non-transparent canvas\n    if (ctx) {\n      ctx.fillStyle = 'rgb(15, 15, 20)';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n\n    // Update dimensions ref instead of state\n    dimensionsRef.current = {\n      width,\n      height,\n      pixelRatio\n    };\n    return true;\n  }, []);\n\n  // Generate a new star configuration\n  const generateStarSeeds = useCallback(() => {\n    const {\n      width,\n      height\n    } = dimensionsRef.current;\n    if (!width || !height) return [];\n    const starSeeds = [];\n    for (let i = 0; i < CONFIG.starCount; i++) {\n      starSeeds.push({\n        xSeed: Math.random(),\n        // Distribute stars vertically across multiple screen heights\n        // Including above the viewport for continuous scrolling effect\n        ySeed: Math.random() * CONFIG.verticalSpreadFactor - CONFIG.offscreenBuffer,\n        zSeed: Math.random() * 0.8 + 0.1,\n        sizeSeed: Math.random(),\n        opacitySeed: Math.random(),\n        phaseSeed: Math.random() * Math.PI * 2,\n        speedSeed: Math.random() * 0.2 + 0.9,\n        pulseSpeedSeed: Math.random() * 0.002 + 0.001,\n        colorIndex: Math.floor(Math.random() * COLORS.stars.length),\n        // Parallax factor determines how much this star moves with scrolling\n        // Deeper stars (higher z) move less for realistic parallax\n        parallaxFactorSeed: Math.random() * 0.5 + 0.1\n      });\n    }\n    return starSeeds;\n  }, [CONFIG, COLORS.stars.length]);\n\n  // Load or generate session-persistent configuration\n  const getSessionConfiguration = useCallback(() => {\n    // First ensure dimensions are set\n    if (!dimensionsRef.current.width) return {\n      starSeeds: []\n    };\n    try {\n      // Try to load existing configuration from sessionStorage\n      const storedConfig = sessionStorage.getItem(CONFIG.sessionKey);\n      if (storedConfig) {\n        const parsedConfig = JSON.parse(storedConfig);\n        // Check if we have the right number of stars (config might have changed)\n        if (parsedConfig.starSeeds && parsedConfig.starSeeds.length === CONFIG.starCount) {\n          return parsedConfig;\n        }\n      }\n    } catch (error) {\n      console.warn('Could not load star configuration from session storage', error);\n    }\n\n    // Generate new configuration if none exists or if it's invalid\n    const starSeeds = generateStarSeeds();\n\n    // Store new configuration in sessionStorage\n    const newConfig = {\n      starSeeds,\n      timestamp: Date.now()\n    };\n    try {\n      sessionStorage.setItem(CONFIG.sessionKey, JSON.stringify(newConfig));\n    } catch (error) {\n      console.warn('Could not save star configuration to session storage', error);\n    }\n    return newConfig;\n  }, [CONFIG.sessionKey, CONFIG.starCount, generateStarSeeds]);\n\n  // Initialize stars with session-persistent configuration\n  const initializeStars = useCallback(() => {\n    const {\n      width,\n      height\n    } = dimensionsRef.current;\n    if (!width || !height) return;\n\n    // Get or create session-persistent configuration\n    const sessionConfig = getSessionConfiguration();\n    const {\n      starSeeds\n    } = sessionConfig;\n\n    // Clear existing stars\n    starsRef.current = [];\n\n    // Create stars using the persistent seeds\n    for (let i = 0; i < starSeeds.length; i++) {\n      const seed = starSeeds[i];\n      const star = {};\n\n      // Position - use seeds but adapt to current screen dimensions\n      star.x = seed.xSeed * width;\n      // Initial y position - distributed vertically across multiple screen heights\n      star.baseY = (seed.ySeed + CONFIG.offscreenBuffer) * height;\n      star.y = star.baseY;\n      star.z = seed.zSeed; // Depth (0.1 to 0.9)\n\n      // Visual properties\n      star.size = (seed.sizeSeed * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n      star.baseOpacity = seed.opacitySeed * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n      star.opacity = star.baseOpacity;\n\n      // Animation properties\n      star.pulsePhase = seed.phaseSeed;\n      star.pulseSpeed = seed.pulseSpeedSeed;\n      star.movementSpeed = seed.speedSeed * CONFIG.baseMovementSpeed * (1.1 - star.z);\n\n      // Initialize velocity and position tracking for trails\n      star.velocity = 0;\n      star.lastX = star.x;\n      star.lastY = star.y;\n      star.prevX = star.x;\n      star.prevY = star.y;\n\n      // Initialize twinkling properties\n      star.twinkleState = 'visible'; // 'fading-in', 'visible', 'fading-out', 'hidden'\n      star.twinkleProgress = 0;\n      star.twinkleDuration = Math.random() * (CONFIG.twinkleDuration[1] - CONFIG.twinkleDuration[0]) + CONFIG.twinkleDuration[0];\n\n      // Random movement properties\n      star.randomDx = (Math.random() * 2 - 1) * CONFIG.randomMovementIntensity;\n      star.randomDy = (Math.random() * 2 - 1) * CONFIG.randomMovementIntensity;\n\n      // Initialize twinkling properties\n      star.twinkleState = 'visible'; // 'fading-in', 'visible', 'fading-out', 'hidden'\n      star.twinkleProgress = 0;\n      star.twinkleDuration = Math.random() * (CONFIG.twinkleDuration[1] - CONFIG.twinkleDuration[0]) + CONFIG.twinkleDuration[0];\n\n      // Random movement properties\n      star.randomDx = (Math.random() * 2 - 1) * CONFIG.randomMovementIntensity;\n      star.randomDy = (Math.random() * 2 - 1) * CONFIG.randomMovementIntensity;\n\n      // Parallax properties (for scrolling effect)\n      // Make deeper stars (higher z) move less for realistic parallax\n      star.parallaxFactor = seed.parallaxFactorSeed * CONFIG.parallaxFactor * (1 - star.z * 0.5);\n\n      // Physics properties for bouncy effect\n      star.velocity = 0;\n      star.targetY = star.y;\n\n      // Color variation\n      star.color = COLORS.stars[seed.colorIndex];\n\n      // Store in ref\n      starsRef.current.push(star);\n    }\n  }, [CONFIG, COLORS.stars, getSessionConfiguration]);\n\n  // Optimized star rendering with subtle trail effect\n  const drawStar = useCallback((ctx, star) => {\n    // Skip rendering completely invisible stars\n    if (star.opacity < 0.02) return;\n\n    // Draw subtle trail if enabled and star is moving\n    if (CONFIG.trailEnabled && (Math.abs(star.velocity) > 0.001 || Math.abs(star.lastX - star.x) > 0.1)) {\n      // Calculate trail direction based on movement\n      const trailX = star.lastX !== undefined ? star.lastX : star.x - star.velocity * 5;\n      const trailY = star.lastY !== undefined ? star.lastY : star.y - star.velocity * 5;\n\n      // Ensure the trail is very subtle\n      ctx.beginPath();\n      ctx.moveTo(star.x, star.y);\n      ctx.lineTo(trailX, trailY);\n      ctx.strokeStyle = getColor(star.color, star.opacity * CONFIG.trailOpacityFactor);\n      ctx.lineWidth = star.size * 0.6;\n      ctx.lineCap = 'round';\n      ctx.stroke();\n    }\n\n    // Store current position for next frame's trail\n    star.lastX = star.x;\n    star.lastY = star.y;\n\n    // Simplified star rendering without creating new gradients every frame\n    ctx.beginPath();\n    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n    ctx.fillStyle = getColor(star.color, star.opacity);\n    ctx.fill();\n\n    // Simplified glow effect without expensive gradient creation\n    if (star.opacity > 0.3) {\n      ctx.beginPath();\n      ctx.arc(star.x, star.y, star.size * 1.8, 0, Math.PI * 2);\n      ctx.fillStyle = getColor(star.color, star.opacity * 0.4);\n      ctx.fill();\n    }\n  }, [CONFIG.trailEnabled, CONFIG.trailOpacityFactor, getColor]);\n\n  // Render the scene - optimized for performance\n  const renderScene = useCallback(() => {\n    if (!canvasRef.current) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d', {\n      alpha: false\n    });\n    if (!ctx) return;\n    const {\n      width,\n      height,\n      pixelRatio\n    } = dimensionsRef.current;\n\n    // Clear canvas\n    ctx.fillStyle = COLORS.background.topColor;\n    ctx.fillRect(0, 0, width * pixelRatio, height * pixelRatio);\n\n    // Apply device pixel ratio scaling only once\n    ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n\n    // Enable global composition for better glow effect\n    ctx.globalCompositeOperation = 'lighter';\n\n    // Draw stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n\n      // Only draw stars that are within or near the viewport\n      // This improves performance by not rendering stars far outside view\n      if (star.y > -50 && star.y < height + 50) {\n        drawStar(ctx, star);\n      }\n    }\n\n    // Reset global composition\n    ctx.globalCompositeOperation = 'source-over';\n  }, [COLORS.background.topColor, drawStar]);\n\n  // Update animation state - optimized for performance\n  const updateAnimation = useCallback((deltaTime, timestamp) => {\n    const {\n      width,\n      height\n    } = dimensionsRef.current;\n    const currentScrollY = springScrollYRef.current;\n    lastScrollYRef.current = currentScrollY;\n\n    // Global time factor for animations\n    const timeFactor = timestamp * 0.001;\n\n    // Update stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n\n      // Calculate parallax effect based on scroll position\n      if (CONFIG.parallaxEnabled) {\n        // Update target position based on scroll (parallax effect)\n        star.targetY = star.baseY - currentScrollY * star.parallaxFactor;\n      }\n\n      // Apply spring physics for bouncy effect\n      const displacement = star.targetY - star.y;\n      const springForce = displacement * CONFIG.springStrength;\n\n      // Update velocity with spring force\n      star.velocity += springForce;\n\n      // Apply damping to velocity\n      star.velocity *= CONFIG.dampingFactor;\n\n      // Update position based on velocity\n      star.y += star.velocity;\n\n      // Gentle random movement in x direction based on time\n      star.x += Math.sin(timeFactor * 0.2 + star.pulsePhase) * star.movementSpeed * deltaTime;\n\n      // Wrap around horizontal edges\n      if (star.x < 0) star.x = width;\n      if (star.x > width) star.x = 0;\n\n      // Wrap around vertical edges - with larger range to account for scrolling\n      // We need to check the actual position (not base position)\n      // This ensures stars are always available within and around the viewport\n      const totalHeight = height * CONFIG.verticalSpreadFactor;\n\n      // Calculate the visual position relative to scroll (where it appears on screen)\n      const visualY = star.y + currentScrollY * star.parallaxFactor;\n      if (visualY < -height * CONFIG.offscreenBuffer) {\n        // If star is too far above viewport, wrap to bottom\n        star.baseY += totalHeight;\n        star.y = star.baseY - currentScrollY * star.parallaxFactor;\n        star.targetY = star.y;\n        star.velocity = 0; // Reset velocity for smoother transition\n      } else if (visualY > totalHeight - height * CONFIG.offscreenBuffer) {\n        // If star is too far below viewport, wrap to top\n        star.baseY -= totalHeight;\n        star.y = star.baseY - currentScrollY * star.parallaxFactor;\n        star.targetY = star.y;\n        star.velocity = 0; // Reset velocity for smoother transition\n      }\n\n      // Simplified pulsing effect\n      const pulseFactor = Math.sin(timeFactor * star.pulseSpeed + star.pulsePhase) * 0.15 + 0.85;\n      star.opacity = star.baseOpacity * pulseFactor;\n    }\n  }, [CONFIG]);\n\n  // Define the animation loop function\n  const animate = useCallback(function animationLoop(timestamp) {\n    if (!isInitializedRef.current) {\n      animationFrameRef.current = requestAnimationFrame(animationLoop);\n      return;\n    }\n\n    // Limit FPS\n    const minFrameTime = 1000 / CONFIG.maxFPS;\n    const elapsed = timestamp - (lastTimeRef.current || 0);\n    if (elapsed < minFrameTime) {\n      animationFrameRef.current = requestAnimationFrame(animationLoop);\n      return;\n    }\n\n    // Calculate delta time with cap to prevent large jumps\n    const deltaTime = lastTimeRef.current ? Math.min(elapsed, 50) : 16;\n    lastTimeRef.current = timestamp;\n\n    // Update animation state\n    updateAnimation(deltaTime, timestamp);\n\n    // Render scene\n    renderScene();\n\n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(animationLoop);\n  }, [CONFIG.maxFPS, updateAnimation, renderScene]);\n\n  // Comprehensive initialization and resize handling\n  useEffect(() => {\n    // One-time initialization function\n    const initialize = () => {\n      if (setupCanvas()) {\n        // Create stars only after canvas is ready\n        initializeStars();\n        // Mark as initialized but don't trigger re-render\n        isInitializedRef.current = true;\n        // Start animation only after everything is ready\n        animationFrameRef.current = requestAnimationFrame(animate);\n      }\n    };\n\n    // Handle resize events\n    const handleResize = () => {\n      // Only re-initialize if already initialized\n      if (isInitializedRef.current) {\n        setupCanvas();\n        initializeStars();\n        // No need to change initialization state\n      }\n    };\n\n    // Throttle resize events\n    let resizeTimer;\n    const throttledResize = () => {\n      if (!resizeTimer) {\n        resizeTimer = setTimeout(() => {\n          resizeTimer = null;\n          handleResize();\n        }, 200); // 200ms throttle\n      }\n    };\n\n    // Add resize listener\n    window.addEventListener('resize', throttledResize);\n\n    // Run initialization after first render is complete\n    // This prevents the \"double load\" effect\n    requestAnimationFrame(() => {\n      firstRenderCompleteRef.current = true;\n      initialize();\n    });\n\n    // Cleanup\n    return () => {\n      window.removeEventListener('resize', throttledResize);\n      if (resizeTimer) clearTimeout(resizeTimer);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [setupCanvas, initializeStars, animate]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      width: '100vw',\n      height: '100vh',\n      overflow: 'hidden',\n      zIndex: -1,\n      pointerEvents: 'none'\n    },\n    \"aria-hidden\": \"true\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 554,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 540,\n    columnNumber: 5\n  }, this);\n};\n_s(Background, \"BHEdB8YX5e7XN34Yz+HcXfkz2bE=\", false, function () {\n  return [useScroll, useSpring];\n});\n_c = Background;\nexport default Background;\nvar _c;\n$RefreshReg$(_c, \"Background\");","map":{"version":3,"names":["React","useRef","useEffect","useCallback","useMemo","useScroll","useSpring","jsxDEV","_jsxDEV","Background","config","_s","containerRef","canvasRef","starsRef","animationFrameRef","lastTimeRef","lastScrollYRef","isInitializedRef","firstRenderCompleteRef","dimensionsRef","width","height","pixelRatio","scrollY","smooth","springScrollY","stiffness","damping","mass","restDelta","restSpeed","springScrollYRef","unsubscribe","onChange","value","current","CONFIG","starCount","starSizeMin","starSizeMax","starOpacityMin","starOpacityMax","baseMovementSpeed","pulseFrequency","parallaxEnabled","parallaxFactor","trailEnabled","trailLength","trailOpacityFactor","twinkleEnabled","twinkleProbability","twinkleDuration","randomMovementEnabled","randomMovementIntensity","directionChangeFrequency","springStrength","dampingFactor","verticalSpreadFactor","offscreenBuffer","maxFPS","useRays","sessionKey","COLORS","stars","background","topColor","bottomColor","colors","colorCache","cache","forEach","baseColor","opacity","replace","getColor","safeOpacity","Math","max","min","roundedOpacity","round","setupCanvas","canvas","window","innerWidth","innerHeight","devicePixelRatio","style","ctx","getContext","alpha","fillStyle","fillRect","generateStarSeeds","starSeeds","i","push","xSeed","random","ySeed","zSeed","sizeSeed","opacitySeed","phaseSeed","PI","speedSeed","pulseSpeedSeed","colorIndex","floor","length","parallaxFactorSeed","getSessionConfiguration","storedConfig","sessionStorage","getItem","parsedConfig","JSON","parse","error","console","warn","newConfig","timestamp","Date","now","setItem","stringify","initializeStars","sessionConfig","seed","star","x","baseY","y","z","size","baseOpacity","pulsePhase","pulseSpeed","movementSpeed","velocity","lastX","lastY","prevX","prevY","twinkleState","twinkleProgress","randomDx","randomDy","targetY","color","drawStar","abs","trailX","undefined","trailY","beginPath","moveTo","lineTo","strokeStyle","lineWidth","lineCap","stroke","arc","fill","renderScene","setTransform","globalCompositeOperation","updateAnimation","deltaTime","currentScrollY","timeFactor","displacement","springForce","sin","totalHeight","visualY","pulseFactor","animate","animationLoop","requestAnimationFrame","minFrameTime","elapsed","initialize","handleResize","resizeTimer","throttledResize","setTimeout","addEventListener","removeEventListener","clearTimeout","cancelAnimationFrame","ref","position","top","left","overflow","zIndex","pointerEvents","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/layout/Background.jsx"],"sourcesContent":["import React, { useRef, useEffect, useCallback, useMemo } from 'react';\nimport { useScroll, useSpring } from 'framer-motion';\n\n/**\n * Background Component\n * \n * Combines canvas-based star rendering with scroll-based parallax effects\n * for an immersive, performance-optimized background that responds to scrolling.\n */\nconst Background = ({ config = {} }) => {\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const starsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimeRef = useRef(0);\n  const lastScrollYRef = useRef(0);\n  \n  // Use refs instead of state to prevent re-renders\n  const isInitializedRef = useRef(false);\n  const firstRenderCompleteRef = useRef(false);\n  \n  // Store dimensions in a ref to avoid re-renders when they change\n  const dimensionsRef = useRef({ width: 0, height: 0, pixelRatio: 1 });\n  \n  // Get scroll position using framer-motion\n  const { scrollY } = useScroll({\n    smooth: 0.05  // Smoother scrolling for high-framerate animations\n  });\n  \n  // Use spring physics for smoother scrolling effect\n  const springScrollY = useSpring(scrollY, {\n    stiffness: 10,\n    damping: 25,\n    mass: 0.5,\n    restDelta: 0.001,\n    restSpeed: 0.001\n  });\n  \n  // Track spring scrollY value without causing re-renders\n  const springScrollYRef = useRef(0);\n  useEffect(() => {\n    const unsubscribe = springScrollY.onChange(value => {\n      springScrollYRef.current = value;\n    });\n    return () => unsubscribe();\n  }, [springScrollY]);\n  \n  // Configuration - wrapped in useMemo to prevent recreation on each render\n  // Merge default config with user-provided config\n  const CONFIG = useMemo(() => ({\n    // Star appearance\n    starCount: 200,\n    starSizeMin: 0.8,\n    starSizeMax: 2.5,\n    starOpacityMin: 0.15,\n    starOpacityMax: 0.85,\n    \n    // Parallax and movement parameters\n    baseMovementSpeed: 0.00004,  // Reduced for slower movement\n    pulseFrequency: 0.00002,     // Slower pulsing\n    parallaxEnabled: true,\n    parallaxFactor: 0.5,  // How much stars move relative to scroll (0-1)\n    \n    // Trail effect parameters\n    trailEnabled: true,          // Enable subtle trails\n    trailLength: 10,              // Very short trail length (in pixels)\n    trailOpacityFactor: 0.5,     // Trail opacity relative to star opacity\n    \n    // Twinkling effect parameters\n    twinkleEnabled: true,        // Enable stars to fade in and out\n    twinkleProbability: 0.01,    // Probability of a star beginning to twinkle each frame\n    twinkleDuration: [2000, 4000], // Min and max duration of a twinkle cycle in ms\n    \n    // Random movement parameters\n    randomMovementEnabled: true,   // Enable small random movements\n    randomMovementIntensity: 0.03, // Intensity of random movement\n    directionChangeFrequency: 0.01, // Probability of changing direction each frame\n    \n    // Physics parameters for bouncy effect\n    springStrength: 0.08,  // Higher = snappier\n    dampingFactor: 0.9,    // Higher = less bouncy (0-1)\n    \n    // Star distribution parameters\n    verticalSpreadFactor: 3,  // How many screen heights to spread stars across\n    offscreenBuffer: 1,      // How many screen heights above viewport to generate stars\n    \n    // Performance parameters\n    maxFPS: 30,\n    useRays: false,  // Disable ray rendering for performance\n    \n    // Session persistence\n    sessionKey: 'scrolling_star_background_config',\n    \n    // Override with user config\n    ...config\n  }), [config]);\n  \n  // Warm, golden color palette - wrapped in useMemo\n  const COLORS = useMemo(() => ({\n    // Star colors\n    stars: [\n      'rgba(255, 243, 200, alpha)', // Warm yellow\n      'rgba(255, 231, 164, alpha)', // Golden\n      'rgba(252, 249, 231, alpha)'  // Off-white gold\n    ],\n    \n    // Background gradient colors\n    background: {\n      topColor: 'rgb(8, 8, 12)',\n      bottomColor: 'rgb(15, 15, 20)'\n    },\n    \n    // Override with user config if provided\n    ...(config.colors || {})\n  }), [config.colors]);\n  \n  // Pre-generated color values to avoid string replacements during animation\n  const colorCache = useMemo(() => {\n    const cache = {};\n    COLORS.stars.forEach(baseColor => {\n      cache[baseColor] = {};\n      for (let opacity = 0; opacity <= 10; opacity++) {\n        const value = opacity / 10;\n        cache[baseColor][value] = baseColor.replace(/alpha\\)$/, `${value})`);\n      }\n    });\n    return cache;\n  }, [COLORS.stars]);\n  \n  // Get color with opacity from cache (faster than string replacement)\n  const getColor = useCallback((baseColor, opacity) => {\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    // Round to nearest 0.1 to use cached values\n    const roundedOpacity = Math.round(safeOpacity * 10) / 10;\n    return colorCache[baseColor][roundedOpacity] || baseColor.replace(/alpha\\)$/, `${safeOpacity})`);\n  }, [colorCache]);\n  \n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current) return false;\n    \n    const canvas = canvasRef.current;\n    \n    // Get viewport dimensions\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const pixelRatio = window.devicePixelRatio || 1;\n    \n    // Set canvas size accounting for pixel ratio\n    canvas.width = width * pixelRatio;\n    canvas.height = height * pixelRatio;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n    \n    // Ensure canvas is visible with a background color\n    const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for non-transparent canvas\n    if (ctx) {\n      ctx.fillStyle = 'rgb(15, 15, 20)';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    \n    // Update dimensions ref instead of state\n    dimensionsRef.current = { width, height, pixelRatio };\n    \n    return true;\n  }, []);\n  \n  // Generate a new star configuration\n  const generateStarSeeds = useCallback(() => {\n    const { width, height } = dimensionsRef.current;\n    if (!width || !height) return [];\n    \n    const starSeeds = [];\n    \n    for (let i = 0; i < CONFIG.starCount; i++) {\n      starSeeds.push({\n        xSeed: Math.random(),\n        // Distribute stars vertically across multiple screen heights\n        // Including above the viewport for continuous scrolling effect\n        ySeed: Math.random() * CONFIG.verticalSpreadFactor - CONFIG.offscreenBuffer,\n        zSeed: Math.random() * 0.8 + 0.1,\n        sizeSeed: Math.random(),\n        opacitySeed: Math.random(),\n        phaseSeed: Math.random() * Math.PI * 2,\n        speedSeed: Math.random() * 0.2 + 0.9,\n        pulseSpeedSeed: Math.random() * 0.002 + 0.001,\n        colorIndex: Math.floor(Math.random() * COLORS.stars.length),\n        // Parallax factor determines how much this star moves with scrolling\n        // Deeper stars (higher z) move less for realistic parallax\n        parallaxFactorSeed: Math.random() * 0.5 + 0.1\n      });\n    }\n    \n    return starSeeds;\n  }, [CONFIG, COLORS.stars.length]);\n  \n  // Load or generate session-persistent configuration\n  const getSessionConfiguration = useCallback(() => {\n    // First ensure dimensions are set\n    if (!dimensionsRef.current.width) return { starSeeds: [] };\n    \n    try {\n      // Try to load existing configuration from sessionStorage\n      const storedConfig = sessionStorage.getItem(CONFIG.sessionKey);\n      \n      if (storedConfig) {\n        const parsedConfig = JSON.parse(storedConfig);\n        // Check if we have the right number of stars (config might have changed)\n        if (parsedConfig.starSeeds && parsedConfig.starSeeds.length === CONFIG.starCount) {\n          return parsedConfig;\n        }\n      }\n    } catch (error) {\n      console.warn('Could not load star configuration from session storage', error);\n    }\n    \n    // Generate new configuration if none exists or if it's invalid\n    const starSeeds = generateStarSeeds();\n    \n    // Store new configuration in sessionStorage\n    const newConfig = { starSeeds, timestamp: Date.now() };\n    try {\n      sessionStorage.setItem(CONFIG.sessionKey, JSON.stringify(newConfig));\n    } catch (error) {\n      console.warn('Could not save star configuration to session storage', error);\n    }\n    \n    return newConfig;\n  }, [CONFIG.sessionKey, CONFIG.starCount, generateStarSeeds]);\n  \n  // Initialize stars with session-persistent configuration\n  const initializeStars = useCallback(() => {\n    const { width, height } = dimensionsRef.current;\n    if (!width || !height) return;\n    \n    // Get or create session-persistent configuration\n    const sessionConfig = getSessionConfiguration();\n    const { starSeeds } = sessionConfig;\n    \n    // Clear existing stars\n    starsRef.current = [];\n    \n    // Create stars using the persistent seeds\n    for (let i = 0; i < starSeeds.length; i++) {\n      const seed = starSeeds[i];\n      const star = {};\n      \n      // Position - use seeds but adapt to current screen dimensions\n      star.x = seed.xSeed * width;\n      // Initial y position - distributed vertically across multiple screen heights\n      star.baseY = (seed.ySeed + CONFIG.offscreenBuffer) * height;\n      star.y = star.baseY;\n      star.z = seed.zSeed; // Depth (0.1 to 0.9)\n      \n      // Visual properties\n      star.size = (seed.sizeSeed * (CONFIG.starSizeMax - CONFIG.starSizeMin) + CONFIG.starSizeMin) * star.z;\n      star.baseOpacity = seed.opacitySeed * (CONFIG.starOpacityMax - CONFIG.starOpacityMin) + CONFIG.starOpacityMin;\n      star.opacity = star.baseOpacity;\n      \n      // Animation properties\n      star.pulsePhase = seed.phaseSeed;\n      star.pulseSpeed = seed.pulseSpeedSeed;\n      star.movementSpeed = seed.speedSeed * CONFIG.baseMovementSpeed * (1.1 - star.z);\n      \n      // Initialize velocity and position tracking for trails\n      star.velocity = 0;\n      star.lastX = star.x;\n      star.lastY = star.y;\n      star.prevX = star.x;\n      star.prevY = star.y;\n      \n      // Initialize twinkling properties\n      star.twinkleState = 'visible'; // 'fading-in', 'visible', 'fading-out', 'hidden'\n      star.twinkleProgress = 0;\n      star.twinkleDuration = Math.random() * \n        (CONFIG.twinkleDuration[1] - CONFIG.twinkleDuration[0]) + \n        CONFIG.twinkleDuration[0];\n      \n      // Random movement properties\n      star.randomDx = (Math.random() * 2 - 1) * CONFIG.randomMovementIntensity;\n      star.randomDy = (Math.random() * 2 - 1) * CONFIG.randomMovementIntensity;\n      \n      // Initialize twinkling properties\n      star.twinkleState = 'visible'; // 'fading-in', 'visible', 'fading-out', 'hidden'\n      star.twinkleProgress = 0;\n      star.twinkleDuration = Math.random() * \n        (CONFIG.twinkleDuration[1] - CONFIG.twinkleDuration[0]) + \n        CONFIG.twinkleDuration[0];\n      \n      // Random movement properties\n      star.randomDx = (Math.random() * 2 - 1) * CONFIG.randomMovementIntensity;\n      star.randomDy = (Math.random() * 2 - 1) * CONFIG.randomMovementIntensity;\n      \n      // Parallax properties (for scrolling effect)\n      // Make deeper stars (higher z) move less for realistic parallax\n      star.parallaxFactor = seed.parallaxFactorSeed * CONFIG.parallaxFactor * (1 - star.z * 0.5);\n      \n      // Physics properties for bouncy effect\n      star.velocity = 0;\n      star.targetY = star.y;\n      \n      // Color variation\n      star.color = COLORS.stars[seed.colorIndex];\n      \n      // Store in ref\n      starsRef.current.push(star);\n    }\n  }, [CONFIG, COLORS.stars, getSessionConfiguration]);\n  \n  // Optimized star rendering with subtle trail effect\n  const drawStar = useCallback((ctx, star) => {\n    // Skip rendering completely invisible stars\n    if (star.opacity < 0.02) return;\n    \n    // Draw subtle trail if enabled and star is moving\n    if (CONFIG.trailEnabled && (Math.abs(star.velocity) > 0.001 || Math.abs(star.lastX - star.x) > 0.1)) {\n      // Calculate trail direction based on movement\n      const trailX = star.lastX !== undefined ? star.lastX : star.x - star.velocity * 5;\n      const trailY = star.lastY !== undefined ? star.lastY : star.y - star.velocity * 5;\n      \n      // Ensure the trail is very subtle\n      ctx.beginPath();\n      ctx.moveTo(star.x, star.y);\n      ctx.lineTo(trailX, trailY);\n      ctx.strokeStyle = getColor(star.color, star.opacity * CONFIG.trailOpacityFactor);\n      ctx.lineWidth = star.size * 0.6;\n      ctx.lineCap = 'round';\n      ctx.stroke();\n    }\n    \n    // Store current position for next frame's trail\n    star.lastX = star.x;\n    star.lastY = star.y;\n    \n    // Simplified star rendering without creating new gradients every frame\n    ctx.beginPath();\n    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n    ctx.fillStyle = getColor(star.color, star.opacity);\n    ctx.fill();\n    \n    // Simplified glow effect without expensive gradient creation\n    if (star.opacity > 0.3) {\n      ctx.beginPath();\n      ctx.arc(star.x, star.y, star.size * 1.8, 0, Math.PI * 2);\n      ctx.fillStyle = getColor(star.color, star.opacity * 0.4);\n      ctx.fill();\n    }\n  }, [CONFIG.trailEnabled, CONFIG.trailOpacityFactor, getColor]);\n  \n  // Render the scene - optimized for performance\n  const renderScene = useCallback(() => {\n    if (!canvasRef.current) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d', { alpha: false });\n    \n    if (!ctx) return;\n    \n    const { width, height, pixelRatio } = dimensionsRef.current;\n    \n    // Clear canvas\n    ctx.fillStyle = COLORS.background.topColor;\n    ctx.fillRect(0, 0, width * pixelRatio, height * pixelRatio);\n    \n    // Apply device pixel ratio scaling only once\n    ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    \n    // Enable global composition for better glow effect\n    ctx.globalCompositeOperation = 'lighter';\n    \n    // Draw stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n      \n      // Only draw stars that are within or near the viewport\n      // This improves performance by not rendering stars far outside view\n      if (star.y > -50 && star.y < height + 50) {\n        drawStar(ctx, star);\n      }\n    }\n    \n    // Reset global composition\n    ctx.globalCompositeOperation = 'source-over';\n  }, [COLORS.background.topColor, drawStar]);\n  \n  // Update animation state - optimized for performance\n  const updateAnimation = useCallback((deltaTime, timestamp) => {\n    const { width, height } = dimensionsRef.current;\n    const currentScrollY = springScrollYRef.current;\n    lastScrollYRef.current = currentScrollY;\n    \n    // Global time factor for animations\n    const timeFactor = timestamp * 0.001;\n    \n    // Update stars\n    for (let i = 0; i < starsRef.current.length; i++) {\n      const star = starsRef.current[i];\n      \n      // Calculate parallax effect based on scroll position\n      if (CONFIG.parallaxEnabled) {\n        // Update target position based on scroll (parallax effect)\n        star.targetY = star.baseY - (currentScrollY * star.parallaxFactor);\n      }\n      \n      // Apply spring physics for bouncy effect\n      const displacement = star.targetY - star.y;\n      const springForce = displacement * CONFIG.springStrength;\n      \n      // Update velocity with spring force\n      star.velocity += springForce;\n      \n      // Apply damping to velocity\n      star.velocity *= CONFIG.dampingFactor;\n      \n      // Update position based on velocity\n      star.y += star.velocity;\n      \n      // Gentle random movement in x direction based on time\n      star.x += Math.sin(timeFactor * 0.2 + star.pulsePhase) * star.movementSpeed * deltaTime;\n      \n      // Wrap around horizontal edges\n      if (star.x < 0) star.x = width;\n      if (star.x > width) star.x = 0;\n      \n      // Wrap around vertical edges - with larger range to account for scrolling\n      // We need to check the actual position (not base position)\n      // This ensures stars are always available within and around the viewport\n      const totalHeight = height * CONFIG.verticalSpreadFactor;\n      \n      // Calculate the visual position relative to scroll (where it appears on screen)\n      const visualY = star.y + currentScrollY * star.parallaxFactor;\n      \n      if (visualY < -height * CONFIG.offscreenBuffer) {\n        // If star is too far above viewport, wrap to bottom\n        star.baseY += totalHeight;\n        star.y = star.baseY - (currentScrollY * star.parallaxFactor);\n        star.targetY = star.y;\n        star.velocity = 0; // Reset velocity for smoother transition\n      } else if (visualY > totalHeight - height * CONFIG.offscreenBuffer) {\n        // If star is too far below viewport, wrap to top\n        star.baseY -= totalHeight;\n        star.y = star.baseY - (currentScrollY * star.parallaxFactor);\n        star.targetY = star.y;\n        star.velocity = 0; // Reset velocity for smoother transition\n      }\n      \n      // Simplified pulsing effect\n      const pulseFactor = Math.sin(timeFactor * star.pulseSpeed + star.pulsePhase) * 0.15 + 0.85;\n      star.opacity = star.baseOpacity * pulseFactor;\n    }\n  }, [CONFIG]);\n  \n  // Define the animation loop function\n  const animate = useCallback(function animationLoop(timestamp) {\n    if (!isInitializedRef.current) {\n      animationFrameRef.current = requestAnimationFrame(animationLoop);\n      return;\n    }\n    \n    // Limit FPS\n    const minFrameTime = 1000 / CONFIG.maxFPS;\n    const elapsed = timestamp - (lastTimeRef.current || 0);\n    \n    if (elapsed < minFrameTime) {\n      animationFrameRef.current = requestAnimationFrame(animationLoop);\n      return;\n    }\n    \n    // Calculate delta time with cap to prevent large jumps\n    const deltaTime = lastTimeRef.current ? Math.min(elapsed, 50) : 16;\n    lastTimeRef.current = timestamp;\n    \n    // Update animation state\n    updateAnimation(deltaTime, timestamp);\n    \n    // Render scene\n    renderScene();\n    \n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(animationLoop);\n  }, [CONFIG.maxFPS, updateAnimation, renderScene]);\n  \n  // Comprehensive initialization and resize handling\n  useEffect(() => {\n    // One-time initialization function\n    const initialize = () => {\n      if (setupCanvas()) {\n        // Create stars only after canvas is ready\n        initializeStars();\n        // Mark as initialized but don't trigger re-render\n        isInitializedRef.current = true;\n        // Start animation only after everything is ready\n        animationFrameRef.current = requestAnimationFrame(animate);\n      }\n    };\n    \n    // Handle resize events\n    const handleResize = () => {\n      // Only re-initialize if already initialized\n      if (isInitializedRef.current) {\n        setupCanvas();\n        initializeStars();\n        // No need to change initialization state\n      }\n    };\n    \n    // Throttle resize events\n    let resizeTimer;\n    const throttledResize = () => {\n      if (!resizeTimer) {\n        resizeTimer = setTimeout(() => {\n          resizeTimer = null;\n          handleResize();\n        }, 200); // 200ms throttle\n      }\n    };\n    \n    // Add resize listener\n    window.addEventListener('resize', throttledResize);\n    \n    // Run initialization after first render is complete\n    // This prevents the \"double load\" effect\n    requestAnimationFrame(() => {\n      firstRenderCompleteRef.current = true;\n      initialize();\n    });\n    \n    // Cleanup\n    return () => {\n      window.removeEventListener('resize', throttledResize);\n      if (resizeTimer) clearTimeout(resizeTimer);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [setupCanvas, initializeStars, animate]);\n  \n  return (\n    <div\n      ref={containerRef}\n      style={{\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        width: '100vw',\n        height: '100vh',\n        overflow: 'hidden',\n        zIndex: -1,\n        pointerEvents: 'none'\n      }}\n      aria-hidden=\"true\"\n    >\n      <canvas\n        ref={canvasRef}\n        style={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%'\n        }}\n      />\n    </div>\n  );\n};\n\nexport default Background;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}