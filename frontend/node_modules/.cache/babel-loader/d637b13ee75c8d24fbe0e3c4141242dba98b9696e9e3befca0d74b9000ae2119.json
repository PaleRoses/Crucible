{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/CosmicDust.jsx\",\n  _s2 = $RefreshSig$();\nimport React, { useRef, useEffect, useCallback, useState, useMemo } from 'react';\n\n/**\n * CosmicDust Component\n * \n * Creates flowing dust particles that move in wave-like patterns across the screen,\n * adding subtle depth and ethereal motion to a cosmic background.\n * \n * Features:\n * - Highly optimized with WebGL rendering option\n * - Adaptive quality based on device capabilities\n * - Memory-efficient with object pooling\n * - Responsive to scroll with parallax effects\n * - Wave patterns customizable with perlin noise\n * \n * @param {Object} props - Component props\n * @param {string|number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=4] - Z-index for the container\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.particleDensity=150] - Number of dust particles\n * @param {number} [props.particleMinSize=0.5] - Minimum size of particles\n * @param {number} [props.particleMaxSize=2.5] - Maximum size of particles\n * @param {number} [props.baseSpeed=0.05] - Base movement speed\n * @param {number} [props.flowComplexity=2] - Complexity of flow patterns (1-5)\n * @param {boolean} [props.enableParallax=true] - Enable parallax effect on scroll\n * @param {number} [props.parallaxIntensity=0.15] - Intensity of parallax effect\n * @param {string[]} [props.colors=['rgba(255,255,255,alpha)', 'rgba(180,190,255,alpha)', 'rgba(255,231,164,alpha)']] - Particle colors with alpha placeholder\n * @param {boolean} [props.adaptiveQuality=true] - Enable adaptive quality based on device\n * @param {boolean} [props.respectReducedMotion=true] - Respect reduced motion preferences\n * @param {number} [props.maxFPS=60] - Target maximum frames per second\n * @param {boolean} [props.useWebGL=false] - Use WebGL rendering for better performance\n * @param {boolean} [props.enableBattery=true] - Enable battery-saving optimizations\n * @param {string} [props.renderingMode='auto'] - Rendering mode: 'auto', '2d', or 'webgl'\n * @param {boolean} [props.enableOffscreenRendering=true] - Enable offscreen canvas when available\n * @param {number} [props.waveSpeed=0.15] - Speed of wave movement\n * @param {number} [props.waveDensity=1.5] - Density of waves\n * @param {number} [props.waveAmplitude=10] - Amplitude of waves\n * @param {boolean} [props.debug=false] - Enable debug visualization\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CosmicDust = ({\n  height = '100vh',\n  zIndex = 4,\n  active = true,\n  particleDensity = 150,\n  particleMinSize = 0.5,\n  particleMaxSize = 2.5,\n  baseSpeed = 0.05,\n  flowComplexity = 2,\n  enableParallax = true,\n  parallaxIntensity = 0.15,\n  colors = ['rgba(255,255,255,alpha)', 'rgba(180,190,255,alpha)', 'rgba(255,231,164,alpha)'],\n  adaptiveQuality = true,\n  respectReducedMotion = true,\n  maxFPS = 60,\n  useWebGL = false,\n  enableBattery = true,\n  renderingMode = 'auto',\n  enableOffscreenRendering = true,\n  waveSpeed = 0.15,\n  waveDensity = 1.5,\n  waveAmplitude = 10,\n  debug = false\n}) => {\n  _s2();\n  var _s = $RefreshSig$();\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const ctxRef = useRef(null);\n  const webGLRef = useRef(null);\n  const offscreenCanvasRef = useRef(null);\n  const particlesRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const fpsTimestampRef = useRef(0);\n  const frameCountRef = useRef(0);\n  const currentFpsRef = useRef(60);\n  const scrollPositionRef = useRef(0);\n  const resizeObserverRef = useRef(null);\n  const visibilityObserverRef = useRef(null);\n  const batteryRef = useRef(null);\n  const visibilityChangeTimeRef = useRef(0);\n  const qualityChangeTimerRef = useRef(null);\n  const lastQualityFactorRef = useRef(1);\n  const stableFrameCountRef = useRef(0);\n  const seedsRef = useRef({\n    xOffset: Math.random() * 10000,\n    yOffset: Math.random() * 10000,\n    zOffset: Math.random() * 10000\n  });\n\n  // Component state\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0,\n    pixelRatio: 1\n  });\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [isVisible, setIsVisible] = useState(false);\n  const [qualityFactor, setQualityFactor] = useState(1);\n  const [actualRenderingMode, setActualRenderingMode] = useState('2d');\n  const [deviceCapabilities, setDeviceCapabilities] = useState({\n    memory: 4,\n    cores: 4,\n    batteryLevel: 1,\n    isMobile: false,\n    supportsWebGL: false,\n    supportsOffscreenCanvas: false\n  });\n\n  // Pre-allocate objects to avoid garbage collection during animation\n  const vectorCache = useRef({\n    temp: {\n      x: 0,\n      y: 0\n    }\n  }).current;\n\n  // Precompute color variants to avoid string operations during animation\n  const colorCacheRef = useRef(new Map());\n\n  // Adaptive settings based on quality factor\n  const adaptedSettings = useMemo(() => {\n    if (!adaptiveQuality || qualityFactor === 1) {\n      return {\n        particleDensity,\n        useHighQualityRendering: true\n      };\n    }\n\n    // Adjust quality-dependent parameters\n    return {\n      particleDensity: Math.max(30, Math.floor(particleDensity * qualityFactor)),\n      useHighQualityRendering: qualityFactor > 0.6\n    };\n  }, [adaptiveQuality, qualityFactor, particleDensity]);\n\n  // Get cached color with opacity\n  const getCachedColor = useCallback((baseColor, opacity) => {\n    // Ensure opacity is always valid\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n\n    // Round opacity to reduce cache size while maintaining visual quality\n    const roundedOpacity = Math.round(safeOpacity * 100) / 100;\n    const key = `${baseColor}-${roundedOpacity}`;\n    if (!colorCacheRef.current.has(key)) {\n      const newColor = baseColor.replace(/alpha\\)$/, roundedOpacity + ')');\n      colorCacheRef.current.set(key, newColor);\n    }\n    return colorCacheRef.current.get(key);\n  }, []);\n\n  // Detect device capabilities and set up optimization strategies\n  const detectCapabilities = useCallback(() => {\n    // Device memory, hardware concurrency, and battery\n    const memory = navigator.deviceMemory || 4;\n    const cores = navigator.hardwareConcurrency || 4;\n    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n\n    // Check WebGL support\n    let supportsWebGL = false;\n    try {\n      const canvas = document.createElement('canvas');\n      supportsWebGL = !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));\n    } catch (e) {\n      supportsWebGL = false;\n    }\n\n    // Check offscreen canvas support\n    const supportsOffscreenCanvas = typeof OffscreenCanvas !== 'undefined';\n\n    // Get battery info if available\n    if (navigator.getBattery && enableBattery) {\n      navigator.getBattery().then(battery => {\n        batteryRef.current = battery;\n        const updateBattery = () => {\n          setDeviceCapabilities(prev => ({\n            ...prev,\n            batteryLevel: battery.level,\n            isCharging: battery.charging\n          }));\n\n          // Reduce quality if on battery and below 30%\n          if (!battery.charging && battery.level < 0.3 && adaptiveQuality) {\n            setQualityFactor(prev => Math.min(prev, 0.6));\n          }\n        };\n\n        // Add battery event listeners\n        battery.addEventListener('levelchange', updateBattery);\n        battery.addEventListener('chargingchange', updateBattery);\n\n        // Initial update\n        updateBattery();\n      }).catch(() => {\n        // Fallback if battery API is not available or fails\n        setDeviceCapabilities(prev => ({\n          ...prev,\n          batteryLevel: 1,\n          isCharging: true\n        }));\n      });\n    }\n\n    // Determine initial rendering mode\n    let initialRenderingMode = '2d';\n    if (renderingMode === 'auto') {\n      if (useWebGL && supportsWebGL) {\n        initialRenderingMode = 'webgl';\n      } else {\n        initialRenderingMode = '2d';\n      }\n    } else {\n      initialRenderingMode = renderingMode === 'webgl' && supportsWebGL ? 'webgl' : '2d';\n    }\n    setActualRenderingMode(initialRenderingMode);\n\n    // Set device capabilities state\n    setDeviceCapabilities({\n      memory,\n      cores,\n      batteryLevel: 1,\n      isCharging: true,\n      isMobile,\n      supportsWebGL,\n      supportsOffscreenCanvas\n    });\n\n    // Calculate quality factor based on capabilities\n    if (adaptiveQuality) {\n      // Base score from hardware\n      const performanceScore = memory * cores / (isMobile ? 2 : 1);\n\n      // Scale quality based on performance score\n      let quality = 1;\n      if (performanceScore > 16) {\n        quality = 1; // High-end devices\n      } else if (performanceScore > 8) {\n        quality = 0.8; // Mid-range devices\n      } else if (performanceScore > 4) {\n        quality = 0.6; // Low-end devices\n      } else {\n        quality = 0.4; // Very low-end devices\n      }\n      setQualityFactor(quality);\n      lastQualityFactorRef.current = quality;\n    }\n  }, [useWebGL, renderingMode, adaptiveQuality, enableBattery]);\n\n  // Initialize WebGL context and shaders if using WebGL\n  const initWebGL = useCallback(() => {\n    if (!canvasRef.current || actualRenderingMode !== 'webgl') return false;\n    try {\n      // Get WebGL context\n      const gl = canvasRef.current.getContext('webgl', {\n        alpha: true,\n        antialias: true,\n        premultipliedAlpha: false,\n        depth: false,\n        powerPreference: 'high-performance',\n        failIfMajorPerformanceCaveat: false\n      });\n      if (!gl) return false;\n      webGLRef.current = gl;\n\n      // Enable blending for transparency\n      gl.enable(gl.BLEND);\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n      // Set clear color to fully transparent\n      gl.clearColor(0.0, 0.0, 0.0, 0.0);\n\n      // Set viewport\n      gl.viewport(0, 0, canvasRef.current.width, canvasRef.current.height);\n\n      // Simple vertex shader for particles\n      const vertexShaderSource = `\n        attribute vec2 aPosition;\n        attribute float aSize;\n        attribute vec4 aColor;\n        \n        varying vec4 vColor;\n        \n        uniform vec2 uResolution;\n        \n        void main() {\n          // Convert to clip space\n          vec2 position = (aPosition / uResolution) * 2.0 - 1.0;\n          position.y = -position.y;\n          \n          gl_Position = vec4(position, 0, 1);\n          gl_PointSize = aSize;\n          vColor = aColor;\n        }\n      `;\n\n      // Simple fragment shader for particles with circular shape\n      const fragmentShaderSource = `\n        precision mediump float;\n        varying vec4 vColor;\n        \n        void main() {\n          // Calculate distance from center for circular point\n          float distance = length(gl_PointCoord - vec2(0.5, 0.5));\n          if (distance > 0.5) {\n            discard; // Outside circle\n          }\n          \n          // Soft edges\n          float alpha = smoothstep(0.5, 0.4, distance) * vColor.a;\n          gl_FragColor = vec4(vColor.rgb, alpha);\n        }\n      `;\n\n      // Compile shader program\n      const createShader = (gl, type, source) => {\n        const shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n          console.error('Shader compilation error:', gl.getShaderInfoLog(shader));\n          gl.deleteShader(shader);\n          return null;\n        }\n        return shader;\n      };\n      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n      if (!vertexShader || !fragmentShader) {\n        return false;\n      }\n      const program = gl.createProgram();\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        console.error('Program linking error:', gl.getProgramInfoLog(program));\n        gl.deleteProgram(program);\n        return false;\n      }\n\n      // Store program references\n      webGLRef.current = {\n        gl,\n        program,\n        attributes: {\n          position: gl.getAttribLocation(program, 'aPosition'),\n          size: gl.getAttribLocation(program, 'aSize'),\n          color: gl.getAttribLocation(program, 'aColor')\n        },\n        uniforms: {\n          resolution: gl.getUniformLocation(program, 'uResolution')\n        }\n      };\n      return true;\n    } catch (error) {\n      console.error('WebGL initialization error:', error);\n      setActualRenderingMode('2d');\n      return false;\n    }\n  }, [actualRenderingMode]);\n\n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current || !containerRef.current) return false;\n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    const rect = container.getBoundingClientRect();\n    const pixelRatio = window.devicePixelRatio || 1;\n\n    // Calculate dimensions\n    const displayWidth = Math.floor(rect.width);\n    const displayHeight = typeof height === 'string' && height.endsWith('vh') ? Math.floor(parseInt(height, 10) / 100 * window.innerHeight) : Math.floor(parseInt(height, 10) || window.innerHeight);\n\n    // Set canvas size accounting for pixel ratio\n    canvas.width = displayWidth * pixelRatio;\n    canvas.height = displayHeight * pixelRatio;\n    canvas.style.width = `${displayWidth}px`;\n    canvas.style.height = `${displayHeight}px`;\n\n    // Get appropriate rendering context\n    if (actualRenderingMode === 'webgl') {\n      initWebGL();\n    } else {\n      // 2D Canvas context\n      const ctx = canvas.getContext('2d', {\n        alpha: true,\n        desynchronized: true,\n        willReadFrequently: false\n      });\n      if (!ctx) return false;\n\n      // Scale context for high-DPI displays\n      ctx.scale(pixelRatio, pixelRatio);\n\n      // Configure context for high-quality rendering\n      if (adaptedSettings.useHighQualityRendering) {\n        ctx.imageSmoothingEnabled = true;\n        ctx.imageSmoothingQuality = 'high';\n      }\n      ctxRef.current = ctx;\n    }\n\n    // Initialize offscreen canvas if supported and enabled\n    if (enableOffscreenRendering && typeof OffscreenCanvas !== 'undefined' && deviceCapabilities.supportsOffscreenCanvas) {\n      try {\n        // Create offscreen canvas\n        const offscreen = new OffscreenCanvas(displayWidth * pixelRatio, displayHeight * pixelRatio);\n\n        // Get 2D context for offscreen canvas\n        const offscreenCtx = offscreen.getContext('2d');\n        if (offscreenCtx) {\n          offscreenCtx.scale(pixelRatio, pixelRatio);\n          offscreenCanvasRef.current = {\n            canvas: offscreen,\n            ctx: offscreenCtx\n          };\n        }\n      } catch (error) {\n        console.warn('Offscreen canvas initialization error:', error);\n      }\n    }\n    setDimensions({\n      width: displayWidth,\n      height: displayHeight,\n      pixelRatio\n    });\n    return true;\n  }, [height, actualRenderingMode, initWebGL, enableOffscreenRendering, deviceCapabilities.supportsOffscreenCanvas, adaptedSettings.useHighQualityRendering]);\n\n  // Pseudo-random hash function for stable noise generation\n  const hashFunction = useCallback((x, y) => {\n    const a = 15485863;\n    const b = 285058399;\n    return (x * a ^ y * b) / 2147483647;\n  }, []);\n\n  // Simplified Perlin noise implementation for flow fields\n  const noise = useCallback((x, y, z) => {\n    const xSeed = seedsRef.current.xOffset;\n    const ySeed = seedsRef.current.yOffset;\n    const zSeed = seedsRef.current.zOffset;\n\n    // Add seeds to coordinates\n    x += xSeed;\n    y += ySeed;\n    z += zSeed;\n\n    // Grid coordinates\n    const xi = Math.floor(x);\n    const yi = Math.floor(y);\n    const zi = Math.floor(z);\n\n    // Fractional parts\n    const xf = x - xi;\n    const yf = y - yi;\n    const zf = z - zi;\n\n    // Smooth interpolation function\n    const fade = t => t * t * t * (t * (t * 6 - 15) + 10);\n\n    // Interpolation weights\n    const u = fade(xf);\n    const v = fade(yf);\n    const w = fade(zf);\n\n    // Hash values for all 8 corners\n    const n000 = hashFunction(xi, yi + zi);\n    const n001 = hashFunction(xi, yi + zi + 1);\n    const n010 = hashFunction(xi, yi + 1 + zi);\n    const n011 = hashFunction(xi, yi + 1 + zi + 1);\n    const n100 = hashFunction(xi + 1, yi + zi);\n    const n101 = hashFunction(xi + 1, yi + zi + 1);\n    const n110 = hashFunction(xi + 1, yi + 1 + zi);\n    const n111 = hashFunction(xi + 1, yi + 1 + zi + 1);\n\n    // Interpolate along x\n    const nx00 = n000 * (1 - u) + n100 * u;\n    const nx01 = n001 * (1 - u) + n101 * u;\n    const nx10 = n010 * (1 - u) + n110 * u;\n    const nx11 = n011 * (1 - u) + n111 * u;\n\n    // Interpolate along y\n    const nxy0 = nx00 * (1 - v) + nx10 * v;\n    const nxy1 = nx01 * (1 - v) + nx11 * v;\n\n    // Interpolate along z and return\n    return nxy0 * (1 - w) + nxy1 * w;\n  }, [hashFunction]);\n\n  // Get flow vector at a given position\n  const getFlowVector = useCallback((x, y, time, scale = 0.01, out = vectorCache.temp) => {\n    // Scale coordinates for smoother flow\n    const scaledX = x * scale * flowComplexity;\n    const scaledY = y * scale * flowComplexity;\n    const scaledTime = time * waveSpeed * 0.2;\n\n    // Use noise function to get flow direction\n    const angle = noise(scaledX, scaledY, scaledTime) * Math.PI * 2;\n\n    // Convert angle to vector\n    out.x = Math.cos(angle);\n    out.y = Math.sin(angle);\n    return out;\n  }, [noise, flowComplexity, waveSpeed, vectorCache.temp]);\n\n  // Create a new dust particle\n  const createParticle = useCallback(() => {\n    const {\n      width,\n      height\n    } = dimensions;\n    if (!width || !height) return null;\n\n    // Get z-depth first to avoid the circular reference\n    const z = Math.random() * 0.9 + 0.1; // 0.1 to 1.0\n\n    // Create particle with random properties\n    const particle = {\n      // Position - randomly distributed across the screen\n      x: Math.random() * width,\n      y: Math.random() * height,\n      // Size - varies by z-depth\n      z,\n      size: 0,\n      // Visual properties\n      opacity: 0,\n      baseOpacity: Math.random() * 0.4 + 0.2,\n      // 0.2 to 0.6\n      color: colors[Math.floor(Math.random() * colors.length)],\n      // Movement properties\n      vx: 0,\n      vy: 0,\n      speed: (Math.random() * 0.5 + 0.5) * baseSpeed,\n      // 0.5x to 1.5x base speed\n\n      // Wave effect properties\n      wavePhase: Math.random() * Math.PI * 2,\n      waveFreq: (Math.random() * 0.5 + 0.75) * waveDensity,\n      waveAmp: (Math.random() * 0.7 + 0.3) * waveAmplitude,\n      // Parallax factor - deeper particles move less\n      parallaxFactor: Math.random() * 0.8 * parallaxIntensity * (1 - 0.7 * z)\n    };\n\n    // Size based on z-depth\n    particle.size = (Math.random() * (particleMaxSize - particleMinSize) + particleMinSize) * z;\n\n    // Set initial opacity lower for fade-in effect\n    particle.opacity = particle.baseOpacity * 0.1;\n    return particle;\n  }, [dimensions, baseSpeed, colors, particleMinSize, particleMaxSize, parallaxIntensity, waveDensity, waveAmplitude]);\n\n  // Initialize particles\n  const initializeParticles = useCallback(() => {\n    // Clear existing particles\n    particlesRef.current = [];\n\n    // Generate particles based on density\n    for (let i = 0; i < adaptedSettings.particleDensity; i++) {\n      const particle = createParticle();\n      if (particle) {\n        particlesRef.current.push(particle);\n      }\n    }\n  }, [adaptedSettings.particleDensity, createParticle]);\n\n  // Detect device capabilities and preferences on mount\n  useEffect(() => {\n    // Check for reduced motion preference\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    const handleReducedMotionChange = e => {\n      setPrefersReducedMotion(e.matches);\n    };\n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n\n    // Detect device capabilities\n    detectCapabilities();\n\n    // Setup visibility change detection to pause when tab is inactive\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        visibilityChangeTimeRef.current = performance.now();\n      } else {\n        // Adjust timing references after visibility changes\n        const timeDelta = performance.now() - visibilityChangeTimeRef.current;\n        lastTimestampRef.current += timeDelta;\n      }\n    };\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n\n    // Cleanup\n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  }, [detectCapabilities]);\n\n  // Setup canvas resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Create a ResizeObserver to detect container size changes\n    const resizeObserver = new ResizeObserver(entries => {\n      // Debounce resize operations\n      if (resizeObserverRef.current.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n      resizeObserverRef.current.timeout = setTimeout(() => {\n        requestAnimationFrame(() => {\n          if (setupCanvas()) {\n            setIsInitialized(true);\n          }\n        });\n      }, 100); // 100ms debounce\n    });\n\n    // Capture current reference to avoid closure issues in cleanup\n    const currentContainer = containerRef.current;\n\n    // Start observing the container\n    resizeObserver.observe(currentContainer);\n    resizeObserverRef.current = {\n      observer: resizeObserver\n    };\n\n    // Initial setup\n    setupCanvas();\n    setIsInitialized(true);\n    return () => {\n      if (resizeObserverRef.current.observer) {\n        resizeObserverRef.current.observer.disconnect();\n      }\n      if (resizeObserverRef.current.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n    };\n  }, [setupCanvas]);\n\n  // Setup intersection observer to only animate when visible\n  useEffect(() => {\n    if (!containerRef.current) return;\n    const observer = new IntersectionObserver(entries => {\n      const isIntersecting = entries[0].isIntersecting;\n\n      // Only change state if visibility actually changed\n      if (isIntersecting !== isVisible) {\n        setIsVisible(isIntersecting);\n        if (isIntersecting) {\n          // Reset timing references when becoming visible again\n          lastTimestampRef.current = 0;\n        }\n      }\n    }, {\n      threshold: 0.01,\n      rootMargin: '100px'\n    });\n\n    // Store current reference to avoid closure issues\n    const currentContainerRef = containerRef.current;\n    observer.observe(currentContainerRef);\n    visibilityObserverRef.current = observer;\n    return () => {\n      if (visibilityObserverRef.current) {\n        visibilityObserverRef.current.disconnect();\n      }\n    };\n  }, [isVisible]);\n\n  // Handle parallax effect on scroll if enabled\n  useEffect(() => {\n    if (!enableParallax) return;\n\n    // Use passive event listener for better performance\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    window.addEventListener('scroll', handleScroll, {\n      passive: true\n    });\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [enableParallax]);\n\n  // Initialize particles once canvas is ready\n  useEffect(() => {\n    if (isInitialized && dimensions.width && dimensions.height) {\n      initializeParticles();\n    }\n  }, [isInitialized, dimensions, initializeParticles]);\n\n  // Render particles with WebGL\n  const renderParticlesWebGL = _s(useCallback(_s(() => {\n    _s();\n    if (!webGLRef.current || !particlesRef.current.length) return;\n    const {\n      gl,\n      program,\n      attributes,\n      uniforms\n    } = webGLRef.current;\n\n    // Clear canvas\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    // Use shader program\n    gl.useProgram(program);\n\n    // Set resolution uniform\n    gl.uniform2f(uniforms.resolution, canvasRef.current.width, canvasRef.current.height);\n\n    // Create buffers for position, size, and color\n    const positions = new Float32Array(particlesRef.current.length * 2);\n    const sizes = new Float32Array(particlesRef.current.length);\n    const colors = new Float32Array(particlesRef.current.length * 4);\n\n    // Fill buffers with particle data\n    for (let i = 0; i < particlesRef.current.length; i++) {\n      const particle = particlesRef.current[i];\n\n      // Position\n      positions[i * 2] = particle.x * dimensions.pixelRatio;\n      positions[i * 2 + 1] = particle.y * dimensions.pixelRatio;\n\n      // Size - scaled by pixel ratio\n      sizes[i] = particle.size * dimensions.pixelRatio;\n\n      // Color - parse from rgba string\n      // Simplified without regex for performance\n      const rgbaStart = particle.color.indexOf('(') + 1;\n      const rgbaEnd = particle.color.indexOf('alpha') - 1;\n      const rgbaValues = particle.color.substring(rgbaStart, rgbaEnd).split(',');\n      colors[i * 4] = parseInt(rgbaValues[0], 10) / 255;\n      colors[i * 4 + 1] = parseInt(rgbaValues[1], 10) / 255;\n      colors[i * 4 + 2] = parseInt(rgbaValues[2], 10) / 255;\n      colors[i * 4 + 3] = particle.opacity;\n    }\n\n    // Position buffer\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(attributes.position);\n    gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 0, 0);\n\n    // Size buffer\n    const sizeBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, sizes, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(attributes.size);\n    gl.vertexAttribPointer(attributes.size, 1, gl.FLOAT, false, 0, 0);\n\n    // Color buffer\n    const colorBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(attributes.color);\n    gl.vertexAttribPointer(attributes.color, 4, gl.FLOAT, false, 0, 0);\n\n    // Draw particles\n    gl.drawArrays(gl.POINTS, 0, particlesRef.current.length);\n\n    // Clean up\n    gl.disableVertexAttribArray(attributes.position);\n    gl.disableVertexAttribArray(attributes.size);\n    gl.disableVertexAttribArray(attributes.color);\n    gl.deleteBuffer(positionBuffer);\n    gl.deleteBuffer(sizeBuffer);\n    gl.deleteBuffer(colorBuffer);\n  }, \"ZdQBZ3rq7bWAAMQq6hlVCmYF0jM=\", false, function () {\n    return [gl.useProgram];\n  }), [dimensions.pixelRatio]), \"ZdQBZ3rq7bWAAMQq6hlVCmYF0jM=\", true);\n\n  // Render particles with Canvas 2D\n  const renderParticles2D = useCallback(ctx => {\n    if (!ctx || !particlesRef.current.length) return;\n\n    // Clear canvas with transparent background\n    ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n\n    // Enable global composition for additively blending particles\n    ctx.globalCompositeOperation = 'lighter';\n\n    // Draw each particle\n    for (let i = 0; i < particlesRef.current.length; i++) {\n      const particle = particlesRef.current[i];\n\n      // Skip nearly invisible particles\n      if (particle.opacity < 0.02) continue;\n\n      // Draw particle\n      ctx.beginPath();\n      ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);\n\n      // Set color with opacity\n      ctx.fillStyle = getCachedColor(particle.color, particle.opacity);\n      ctx.fill();\n\n      // Draw soft glow if using high quality rendering\n      if (adaptedSettings.useHighQualityRendering && particle.opacity > 0.1) {\n        ctx.beginPath();\n        ctx.arc(particle.x, particle.y, particle.size * 2, 0, Math.PI * 2);\n        ctx.fillStyle = getCachedColor(particle.color, particle.opacity * 0.3);\n        ctx.fill();\n      }\n    }\n\n    // Reset composite operation\n    ctx.globalCompositeOperation = 'source-over';\n\n    // Draw debug info if enabled\n    if (debug) {\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n      ctx.font = '12px monospace';\n      ctx.fillText(`FPS: ${currentFpsRef.current}`, 10, 20);\n      ctx.fillText(`Particles: ${particlesRef.current.length}`, 10, 40);\n      ctx.fillText(`Quality: ${qualityFactor.toFixed(2)}`, 10, 60);\n      ctx.fillText(`Rendering: ${actualRenderingMode}`, 10, 80);\n    }\n  }, [dimensions, adaptedSettings.useHighQualityRendering, getCachedColor, debug, qualityFactor, actualRenderingMode]);\n\n  // Update particle positions and properties\n  const updateParticles = useCallback((deltaTime, timestamp) => {\n    const {\n      width,\n      height\n    } = dimensions;\n    if (!width || !height) return;\n\n    // Calculate time factor for animations\n    const timeFactor = timestamp * 0.001;\n    const scrollY = scrollPositionRef.current;\n\n    // Update particles\n    for (let i = 0; i < particlesRef.current.length; i++) {\n      const particle = particlesRef.current[i];\n\n      // Gradually fade in particles\n      if (particle.opacity < particle.baseOpacity) {\n        particle.opacity = Math.min(particle.baseOpacity, particle.opacity + deltaTime * 0.0005);\n      }\n\n      // Get flow direction at particle position\n      const flow = getFlowVector(particle.x, particle.y, timeFactor);\n\n      // Apply parallax effect if enabled\n      let parallaxOffsetY = 0;\n      if (enableParallax) {\n        parallaxOffsetY = scrollY * particle.parallaxFactor;\n      }\n\n      // Calculate wave effect\n      const waveOffset = Math.sin(particle.x * particle.waveFreq * 0.01 + timeFactor * particle.waveFreq + particle.wavePhase) * particle.waveAmp;\n\n      // Update velocity based on flow field and wave\n      particle.vx = flow.x * particle.speed;\n      particle.vy = flow.y * particle.speed + waveOffset * 0.01;\n\n      // Apply velocity to position\n      particle.x += particle.vx * deltaTime;\n      particle.y += particle.vy * deltaTime - parallaxOffsetY * 0.1;\n\n      // Wrap around screen edges with buffer area\n      const buffer = particle.size * 4;\n      if (particle.x < -buffer) {\n        particle.x = width + buffer;\n        // Randomize Y slightly when wrapping horizontally\n        particle.y = Math.random() * height;\n      } else if (particle.x > width + buffer) {\n        particle.x = -buffer;\n        // Randomize Y slightly when wrapping horizontally\n        particle.y = Math.random() * height;\n      }\n      if (particle.y < -buffer) {\n        particle.y = height + buffer;\n        // Randomize X slightly when wrapping vertically\n        particle.x = Math.random() * width;\n      } else if (particle.y > height + buffer) {\n        particle.y = -buffer;\n        // Randomize X slightly when wrapping vertically\n        particle.x = Math.random() * width;\n      }\n    }\n  }, [dimensions, enableParallax, getFlowVector]);\n\n  // FPS limiter for consistent animation speed\n  const fpsLimiter = useCallback((timestamp, callback) => {\n    // Skip animation if hidden, inactive, or reduced motion\n    if (!isVisible || !active || respectReducedMotion && prefersReducedMotion || document.hidden) {\n      animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n      return;\n    }\n    const targetFrameTime = 1000 / maxFPS;\n    const elapsed = timestamp - lastTimestampRef.current;\n    if (elapsed >= targetFrameTime || lastTimestampRef.current === 0) {\n      // Calculate correct delta\n      const delta = lastTimestampRef.current === 0 ? 16 : elapsed;\n\n      // Update timestamp, limiting delta to avoid jumps after inactivity\n      lastTimestampRef.current = timestamp - elapsed % targetFrameTime;\n\n      // Run animation callback with capped delta time\n      callback(Math.min(delta, 50), timestamp);\n\n      // FPS tracking for debug and adaptive quality\n      frameCountRef.current++;\n      if (timestamp - fpsTimestampRef.current >= 1000) {\n        currentFpsRef.current = frameCountRef.current;\n        frameCountRef.current = 0;\n        fpsTimestampRef.current = timestamp;\n\n        // Log FPS in debug mode\n        if (debug) {\n          console.log(`CosmicDust FPS: ${currentFpsRef.current}, Quality: ${qualityFactor.toFixed(2)}`);\n        }\n\n        // Dynamic quality adjustment based on performance with debouncing\n        if (adaptiveQuality) {\n          // Check if FPS is stable by counting consecutive frames within target range\n          if (currentFpsRef.current >= maxFPS * 0.95) {\n            stableFrameCountRef.current += 1;\n          } else if (currentFpsRef.current < maxFPS * 0.7) {\n            stableFrameCountRef.current = 0;\n          }\n\n          // Avoid frequent quality changes by using a timer\n          if (qualityChangeTimerRef.current) {\n            clearTimeout(qualityChangeTimerRef.current);\n          }\n          qualityChangeTimerRef.current = setTimeout(() => {\n            // Only change quality if FPS has been stable or is very low\n            if (currentFpsRef.current < maxFPS * 0.7) {\n              // If FPS is below 70% of target, reduce quality\n              setQualityFactor(prev => {\n                const newQuality = Math.max(0.4, prev * 0.9);\n                lastQualityFactorRef.current = newQuality;\n                return newQuality;\n              });\n            } else if (stableFrameCountRef.current >= 3 && qualityFactor < 1) {\n              // If FPS has been high for several frames, gradually increase quality\n              setQualityFactor(prev => {\n                const newQuality = Math.min(1, prev * 1.05);\n                lastQualityFactorRef.current = newQuality;\n                return newQuality;\n              });\n            }\n          }, 500); // Wait 500ms before changing quality to avoid rapid oscillation\n        }\n      }\n    }\n\n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n  }, [isVisible, active, respectReducedMotion, prefersReducedMotion, maxFPS, debug, adaptiveQuality, qualityFactor]);\n\n  // Main animation handler\n  const handleAnimation = useCallback((deltaTime, timestamp) => {\n    // Skip if component is not ready\n    if (!canvasRef.current || !isInitialized) return;\n\n    // Update particle positions\n    updateParticles(deltaTime, timestamp);\n\n    // Render based on selected mode\n    if (actualRenderingMode === 'webgl' && webGLRef.current) {\n      // WebGL rendering path\n      renderParticlesWebGL();\n    } else {\n      // Canvas 2D rendering path\n      const ctx = ctxRef.current;\n      if (!ctx) return;\n\n      // Render particles\n      renderParticles2D(ctx);\n    }\n  }, [isInitialized, actualRenderingMode, updateParticles, renderParticlesWebGL, renderParticles2D]);\n\n  // Main animation loop\n  useEffect(() => {\n    if (!active || !isInitialized || !dimensions.width || !dimensions.height) {\n      return;\n    }\n\n    // Start animation with FPS limiter\n    fpsTimestampRef.current = performance.now();\n    frameCountRef.current = 0;\n    lastTimestampRef.current = 0;\n    animationFrameRef.current = requestAnimationFrame(timestamp => {\n      fpsLimiter(timestamp, handleAnimation);\n    });\n\n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      if (qualityChangeTimerRef.current) {\n        clearTimeout(qualityChangeTimerRef.current);\n      }\n    };\n  }, [active, isInitialized, dimensions, fpsLimiter, handleAnimation]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: height,\n      overflow: 'hidden',\n      pointerEvents: 'none',\n      zIndex: zIndex,\n      // Hardware acceleration\n      backfaceVisibility: 'hidden',\n      transform: 'translateZ(0)',\n      willChange: 'transform'\n    },\n    \"aria-hidden\": \"true\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        // Additional rendering optimizations\n        imageRendering: 'high-quality',\n        // Hardware acceleration\n        backfaceVisibility: 'hidden',\n        transform: 'translateZ(0)',\n        willChange: 'transform',\n        // Ensures proper subpixel rendering\n        filter: 'none'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1087,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1069,\n    columnNumber: 5\n  }, this);\n};\n_s2(CosmicDust, \"lGDGle9LMlOt0B0j9yZIM3ouMRg=\");\n_c = CosmicDust;\nexport default CosmicDust;\nvar _c;\n$RefreshReg$(_c, \"CosmicDust\");","map":{"version":3,"names":["React","useRef","useEffect","useCallback","useState","useMemo","jsxDEV","_jsxDEV","CosmicDust","height","zIndex","active","particleDensity","particleMinSize","particleMaxSize","baseSpeed","flowComplexity","enableParallax","parallaxIntensity","colors","adaptiveQuality","respectReducedMotion","maxFPS","useWebGL","enableBattery","renderingMode","enableOffscreenRendering","waveSpeed","waveDensity","waveAmplitude","debug","_s2","_s","$RefreshSig$","containerRef","canvasRef","ctxRef","webGLRef","offscreenCanvasRef","particlesRef","animationFrameRef","lastTimestampRef","fpsTimestampRef","frameCountRef","currentFpsRef","scrollPositionRef","resizeObserverRef","visibilityObserverRef","batteryRef","visibilityChangeTimeRef","qualityChangeTimerRef","lastQualityFactorRef","stableFrameCountRef","seedsRef","xOffset","Math","random","yOffset","zOffset","dimensions","setDimensions","width","pixelRatio","isInitialized","setIsInitialized","prefersReducedMotion","setPrefersReducedMotion","isVisible","setIsVisible","qualityFactor","setQualityFactor","actualRenderingMode","setActualRenderingMode","deviceCapabilities","setDeviceCapabilities","memory","cores","batteryLevel","isMobile","supportsWebGL","supportsOffscreenCanvas","vectorCache","temp","x","y","current","colorCacheRef","Map","adaptedSettings","useHighQualityRendering","max","floor","getCachedColor","baseColor","opacity","safeOpacity","min","roundedOpacity","round","key","has","newColor","replace","set","get","detectCapabilities","navigator","deviceMemory","hardwareConcurrency","test","userAgent","canvas","document","createElement","window","WebGLRenderingContext","getContext","e","OffscreenCanvas","getBattery","then","battery","updateBattery","prev","level","isCharging","charging","addEventListener","catch","initialRenderingMode","performanceScore","quality","initWebGL","gl","alpha","antialias","premultipliedAlpha","depth","powerPreference","failIfMajorPerformanceCaveat","enable","BLEND","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","clearColor","viewport","vertexShaderSource","fragmentShaderSource","createShader","type","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","error","getShaderInfoLog","deleteShader","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","program","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","attributes","position","getAttribLocation","size","color","uniforms","resolution","getUniformLocation","setupCanvas","container","rect","getBoundingClientRect","devicePixelRatio","displayWidth","displayHeight","endsWith","parseInt","innerHeight","style","ctx","desynchronized","willReadFrequently","scale","imageSmoothingEnabled","imageSmoothingQuality","offscreen","offscreenCtx","warn","hashFunction","a","b","noise","z","xSeed","ySeed","zSeed","xi","yi","zi","xf","yf","zf","fade","t","u","v","w","n000","n001","n010","n011","n100","n101","n110","n111","nx00","nx01","nx10","nx11","nxy0","nxy1","getFlowVector","time","out","scaledX","scaledY","scaledTime","angle","PI","cos","sin","createParticle","particle","baseOpacity","length","vx","vy","speed","wavePhase","waveFreq","waveAmp","parallaxFactor","initializeParticles","i","push","reducedMotionQuery","matchMedia","matches","handleReducedMotionChange","handleVisibilityChange","hidden","performance","now","timeDelta","removeEventListener","resizeObserver","ResizeObserver","entries","timeout","clearTimeout","setTimeout","requestAnimationFrame","currentContainer","observe","observer","disconnect","IntersectionObserver","isIntersecting","threshold","rootMargin","currentContainerRef","handleScroll","scrollY","passive","renderParticlesWebGL","clear","COLOR_BUFFER_BIT","useProgram","uniform2f","positions","Float32Array","sizes","rgbaStart","indexOf","rgbaEnd","rgbaValues","substring","split","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","enableVertexAttribArray","vertexAttribPointer","FLOAT","sizeBuffer","colorBuffer","drawArrays","POINTS","disableVertexAttribArray","deleteBuffer","renderParticles2D","clearRect","globalCompositeOperation","beginPath","arc","fillStyle","fill","font","fillText","toFixed","updateParticles","deltaTime","timestamp","timeFactor","flow","parallaxOffsetY","waveOffset","buffer","fpsLimiter","callback","targetFrameTime","elapsed","delta","log","newQuality","handleAnimation","cancelAnimationFrame","ref","top","left","overflow","pointerEvents","backfaceVisibility","transform","willChange","children","imageRendering","filter","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/CosmicDust.jsx"],"sourcesContent":["import React, { useRef, useEffect, useCallback, useState, useMemo } from 'react';\n\n/**\n * CosmicDust Component\n * \n * Creates flowing dust particles that move in wave-like patterns across the screen,\n * adding subtle depth and ethereal motion to a cosmic background.\n * \n * Features:\n * - Highly optimized with WebGL rendering option\n * - Adaptive quality based on device capabilities\n * - Memory-efficient with object pooling\n * - Responsive to scroll with parallax effects\n * - Wave patterns customizable with perlin noise\n * \n * @param {Object} props - Component props\n * @param {string|number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=4] - Z-index for the container\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.particleDensity=150] - Number of dust particles\n * @param {number} [props.particleMinSize=0.5] - Minimum size of particles\n * @param {number} [props.particleMaxSize=2.5] - Maximum size of particles\n * @param {number} [props.baseSpeed=0.05] - Base movement speed\n * @param {number} [props.flowComplexity=2] - Complexity of flow patterns (1-5)\n * @param {boolean} [props.enableParallax=true] - Enable parallax effect on scroll\n * @param {number} [props.parallaxIntensity=0.15] - Intensity of parallax effect\n * @param {string[]} [props.colors=['rgba(255,255,255,alpha)', 'rgba(180,190,255,alpha)', 'rgba(255,231,164,alpha)']] - Particle colors with alpha placeholder\n * @param {boolean} [props.adaptiveQuality=true] - Enable adaptive quality based on device\n * @param {boolean} [props.respectReducedMotion=true] - Respect reduced motion preferences\n * @param {number} [props.maxFPS=60] - Target maximum frames per second\n * @param {boolean} [props.useWebGL=false] - Use WebGL rendering for better performance\n * @param {boolean} [props.enableBattery=true] - Enable battery-saving optimizations\n * @param {string} [props.renderingMode='auto'] - Rendering mode: 'auto', '2d', or 'webgl'\n * @param {boolean} [props.enableOffscreenRendering=true] - Enable offscreen canvas when available\n * @param {number} [props.waveSpeed=0.15] - Speed of wave movement\n * @param {number} [props.waveDensity=1.5] - Density of waves\n * @param {number} [props.waveAmplitude=10] - Amplitude of waves\n * @param {boolean} [props.debug=false] - Enable debug visualization\n */\nconst CosmicDust = ({\n  height = '100vh',\n  zIndex = 4,\n  active = true,\n  particleDensity = 150,\n  particleMinSize = 0.5,\n  particleMaxSize = 2.5,\n  baseSpeed = 0.05,\n  flowComplexity = 2,\n  enableParallax = true,\n  parallaxIntensity = 0.15,\n  colors = [\n    'rgba(255,255,255,alpha)',\n    'rgba(180,190,255,alpha)',\n    'rgba(255,231,164,alpha)'\n  ],\n  adaptiveQuality = true,\n  respectReducedMotion = true,\n  maxFPS = 60,\n  useWebGL = false,\n  enableBattery = true,\n  renderingMode = 'auto',\n  enableOffscreenRendering = true,\n  waveSpeed = 0.15,\n  waveDensity = 1.5,\n  waveAmplitude = 10,\n  debug = false\n}) => {\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const ctxRef = useRef(null);\n  const webGLRef = useRef(null);\n  const offscreenCanvasRef = useRef(null);\n  const particlesRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const fpsTimestampRef = useRef(0);\n  const frameCountRef = useRef(0);\n  const currentFpsRef = useRef(60);\n  const scrollPositionRef = useRef(0);\n  const resizeObserverRef = useRef(null);\n  const visibilityObserverRef = useRef(null);\n  const batteryRef = useRef(null);\n  const visibilityChangeTimeRef = useRef(0);\n  const qualityChangeTimerRef = useRef(null);\n  const lastQualityFactorRef = useRef(1);\n  const stableFrameCountRef = useRef(0);\n  const seedsRef = useRef({\n    xOffset: Math.random() * 10000,\n    yOffset: Math.random() * 10000,\n    zOffset: Math.random() * 10000\n  });\n  \n  // Component state\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0, pixelRatio: 1 });\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [isVisible, setIsVisible] = useState(false);\n  const [qualityFactor, setQualityFactor] = useState(1);\n  const [actualRenderingMode, setActualRenderingMode] = useState('2d');\n  const [deviceCapabilities, setDeviceCapabilities] = useState({\n    memory: 4,\n    cores: 4,\n    batteryLevel: 1,\n    isMobile: false,\n    supportsWebGL: false,\n    supportsOffscreenCanvas: false\n  });\n  \n  // Pre-allocate objects to avoid garbage collection during animation\n  const vectorCache = useRef({\n    temp: { x: 0, y: 0 }\n  }).current;\n  \n  // Precompute color variants to avoid string operations during animation\n  const colorCacheRef = useRef(new Map());\n  \n  // Adaptive settings based on quality factor\n  const adaptedSettings = useMemo(() => {\n    if (!adaptiveQuality || qualityFactor === 1) {\n      return {\n        particleDensity,\n        useHighQualityRendering: true\n      };\n    }\n    \n    // Adjust quality-dependent parameters\n    return {\n      particleDensity: Math.max(30, Math.floor(particleDensity * qualityFactor)),\n      useHighQualityRendering: qualityFactor > 0.6\n    };\n  }, [adaptiveQuality, qualityFactor, particleDensity]);\n  \n  // Get cached color with opacity\n  const getCachedColor = useCallback((baseColor, opacity) => {\n    // Ensure opacity is always valid\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    \n    // Round opacity to reduce cache size while maintaining visual quality\n    const roundedOpacity = Math.round(safeOpacity * 100) / 100;\n    const key = `${baseColor}-${roundedOpacity}`;\n    \n    if (!colorCacheRef.current.has(key)) {\n      const newColor = baseColor.replace(/alpha\\)$/, roundedOpacity + ')');\n      colorCacheRef.current.set(key, newColor);\n    }\n    \n    return colorCacheRef.current.get(key);\n  }, []);\n  \n  // Detect device capabilities and set up optimization strategies\n  const detectCapabilities = useCallback(() => {\n    // Device memory, hardware concurrency, and battery\n    const memory = navigator.deviceMemory || 4;\n    const cores = navigator.hardwareConcurrency || 4;\n    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n    \n    // Check WebGL support\n    let supportsWebGL = false;\n    try {\n      const canvas = document.createElement('canvas');\n      supportsWebGL = !!(window.WebGLRenderingContext && \n        (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));\n    } catch (e) {\n      supportsWebGL = false;\n    }\n    \n    // Check offscreen canvas support\n    const supportsOffscreenCanvas = typeof OffscreenCanvas !== 'undefined';\n    \n    // Get battery info if available\n    if (navigator.getBattery && enableBattery) {\n      navigator.getBattery().then(battery => {\n        batteryRef.current = battery;\n        \n        const updateBattery = () => {\n          setDeviceCapabilities(prev => ({\n            ...prev,\n            batteryLevel: battery.level,\n            isCharging: battery.charging\n          }));\n          \n          // Reduce quality if on battery and below 30%\n          if (!battery.charging && battery.level < 0.3 && adaptiveQuality) {\n            setQualityFactor(prev => Math.min(prev, 0.6));\n          }\n        };\n        \n        // Add battery event listeners\n        battery.addEventListener('levelchange', updateBattery);\n        battery.addEventListener('chargingchange', updateBattery);\n        \n        // Initial update\n        updateBattery();\n      }).catch(() => {\n        // Fallback if battery API is not available or fails\n        setDeviceCapabilities(prev => ({\n          ...prev,\n          batteryLevel: 1,\n          isCharging: true\n        }));\n      });\n    }\n    \n    // Determine initial rendering mode\n    let initialRenderingMode = '2d';\n    if (renderingMode === 'auto') {\n      if (useWebGL && supportsWebGL) {\n        initialRenderingMode = 'webgl';\n      } else {\n        initialRenderingMode = '2d';\n      }\n    } else {\n      initialRenderingMode = renderingMode === 'webgl' && supportsWebGL ? 'webgl' : '2d';\n    }\n    \n    setActualRenderingMode(initialRenderingMode);\n    \n    // Set device capabilities state\n    setDeviceCapabilities({\n      memory,\n      cores,\n      batteryLevel: 1,\n      isCharging: true,\n      isMobile,\n      supportsWebGL,\n      supportsOffscreenCanvas\n    });\n    \n    // Calculate quality factor based on capabilities\n    if (adaptiveQuality) {\n      // Base score from hardware\n      const performanceScore = (memory * cores) / (isMobile ? 2 : 1);\n      \n      // Scale quality based on performance score\n      let quality = 1;\n      \n      if (performanceScore > 16) {\n        quality = 1; // High-end devices\n      } else if (performanceScore > 8) {\n        quality = 0.8; // Mid-range devices\n      } else if (performanceScore > 4) {\n        quality = 0.6; // Low-end devices\n      } else {\n        quality = 0.4; // Very low-end devices\n      }\n      \n      setQualityFactor(quality);\n      lastQualityFactorRef.current = quality;\n    }\n  }, [useWebGL, renderingMode, adaptiveQuality, enableBattery]);\n  \n  // Initialize WebGL context and shaders if using WebGL\n  const initWebGL = useCallback(() => {\n    if (!canvasRef.current || actualRenderingMode !== 'webgl') return false;\n    \n    try {\n      // Get WebGL context\n      const gl = canvasRef.current.getContext('webgl', {\n        alpha: true,\n        antialias: true,\n        premultipliedAlpha: false,\n        depth: false,\n        powerPreference: 'high-performance',\n        failIfMajorPerformanceCaveat: false\n      });\n      \n      if (!gl) return false;\n      \n      webGLRef.current = gl;\n      \n      // Enable blending for transparency\n      gl.enable(gl.BLEND);\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n      \n      // Set clear color to fully transparent\n      gl.clearColor(0.0, 0.0, 0.0, 0.0);\n      \n      // Set viewport\n      gl.viewport(0, 0, canvasRef.current.width, canvasRef.current.height);\n      \n      // Simple vertex shader for particles\n      const vertexShaderSource = `\n        attribute vec2 aPosition;\n        attribute float aSize;\n        attribute vec4 aColor;\n        \n        varying vec4 vColor;\n        \n        uniform vec2 uResolution;\n        \n        void main() {\n          // Convert to clip space\n          vec2 position = (aPosition / uResolution) * 2.0 - 1.0;\n          position.y = -position.y;\n          \n          gl_Position = vec4(position, 0, 1);\n          gl_PointSize = aSize;\n          vColor = aColor;\n        }\n      `;\n      \n      // Simple fragment shader for particles with circular shape\n      const fragmentShaderSource = `\n        precision mediump float;\n        varying vec4 vColor;\n        \n        void main() {\n          // Calculate distance from center for circular point\n          float distance = length(gl_PointCoord - vec2(0.5, 0.5));\n          if (distance > 0.5) {\n            discard; // Outside circle\n          }\n          \n          // Soft edges\n          float alpha = smoothstep(0.5, 0.4, distance) * vColor.a;\n          gl_FragColor = vec4(vColor.rgb, alpha);\n        }\n      `;\n      \n      // Compile shader program\n      const createShader = (gl, type, source) => {\n        const shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        \n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n          console.error('Shader compilation error:', gl.getShaderInfoLog(shader));\n          gl.deleteShader(shader);\n          return null;\n        }\n        \n        return shader;\n      };\n      \n      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n      \n      if (!vertexShader || !fragmentShader) {\n        return false;\n      }\n      \n      const program = gl.createProgram();\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n      \n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        console.error('Program linking error:', gl.getProgramInfoLog(program));\n        gl.deleteProgram(program);\n        return false;\n      }\n      \n      // Store program references\n      webGLRef.current = {\n        gl,\n        program,\n        attributes: {\n          position: gl.getAttribLocation(program, 'aPosition'),\n          size: gl.getAttribLocation(program, 'aSize'),\n          color: gl.getAttribLocation(program, 'aColor')\n        },\n        uniforms: {\n          resolution: gl.getUniformLocation(program, 'uResolution')\n        }\n      };\n      \n      return true;\n    } catch (error) {\n      console.error('WebGL initialization error:', error);\n      setActualRenderingMode('2d');\n      return false;\n    }\n  }, [actualRenderingMode]);\n  \n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current || !containerRef.current) return false;\n    \n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    const rect = container.getBoundingClientRect();\n    const pixelRatio = window.devicePixelRatio || 1;\n    \n    // Calculate dimensions\n    const displayWidth = Math.floor(rect.width);\n    const displayHeight = typeof height === 'string' && height.endsWith('vh') \n      ? Math.floor((parseInt(height, 10) / 100) * window.innerHeight)\n      : Math.floor(parseInt(height, 10) || window.innerHeight);\n    \n    // Set canvas size accounting for pixel ratio\n    canvas.width = displayWidth * pixelRatio;\n    canvas.height = displayHeight * pixelRatio;\n    canvas.style.width = `${displayWidth}px`;\n    canvas.style.height = `${displayHeight}px`;\n    \n    // Get appropriate rendering context\n    if (actualRenderingMode === 'webgl') {\n      initWebGL();\n    } else {\n      // 2D Canvas context\n      const ctx = canvas.getContext('2d', {\n        alpha: true,\n        desynchronized: true,\n        willReadFrequently: false\n      });\n      \n      if (!ctx) return false;\n      \n      // Scale context for high-DPI displays\n      ctx.scale(pixelRatio, pixelRatio);\n      \n      // Configure context for high-quality rendering\n      if (adaptedSettings.useHighQualityRendering) {\n        ctx.imageSmoothingEnabled = true;\n        ctx.imageSmoothingQuality = 'high';\n      }\n      \n      ctxRef.current = ctx;\n    }\n    \n    // Initialize offscreen canvas if supported and enabled\n    if (enableOffscreenRendering && typeof OffscreenCanvas !== 'undefined' &&\n        deviceCapabilities.supportsOffscreenCanvas) {\n      try {\n        // Create offscreen canvas\n        const offscreen = new OffscreenCanvas(\n          displayWidth * pixelRatio,\n          displayHeight * pixelRatio\n        );\n        \n        // Get 2D context for offscreen canvas\n        const offscreenCtx = offscreen.getContext('2d');\n        if (offscreenCtx) {\n          offscreenCtx.scale(pixelRatio, pixelRatio);\n          offscreenCanvasRef.current = {\n            canvas: offscreen,\n            ctx: offscreenCtx\n          };\n        }\n      } catch (error) {\n        console.warn('Offscreen canvas initialization error:', error);\n      }\n    }\n    \n    setDimensions({\n      width: displayWidth,\n      height: displayHeight,\n      pixelRatio\n    });\n    \n    return true;\n  }, [height, actualRenderingMode, initWebGL, enableOffscreenRendering, deviceCapabilities.supportsOffscreenCanvas, adaptedSettings.useHighQualityRendering]);\n  \n  // Pseudo-random hash function for stable noise generation\n  const hashFunction = useCallback((x, y) => {\n    const a = 15485863;\n    const b = 285058399;\n    return ((x * a) ^ (y * b)) / 2147483647;\n  }, []);\n  \n  // Simplified Perlin noise implementation for flow fields\n  const noise = useCallback((x, y, z) => {\n    const xSeed = seedsRef.current.xOffset;\n    const ySeed = seedsRef.current.yOffset;\n    const zSeed = seedsRef.current.zOffset;\n    \n    // Add seeds to coordinates\n    x += xSeed;\n    y += ySeed;\n    z += zSeed;\n    \n    // Grid coordinates\n    const xi = Math.floor(x);\n    const yi = Math.floor(y);\n    const zi = Math.floor(z);\n    \n    // Fractional parts\n    const xf = x - xi;\n    const yf = y - yi;\n    const zf = z - zi;\n    \n    // Smooth interpolation function\n    const fade = t => t * t * t * (t * (t * 6 - 15) + 10);\n    \n    // Interpolation weights\n    const u = fade(xf);\n    const v = fade(yf);\n    const w = fade(zf);\n    \n    // Hash values for all 8 corners\n    const n000 = hashFunction(xi, yi + zi);\n    const n001 = hashFunction(xi, yi + zi + 1);\n    const n010 = hashFunction(xi, yi + 1 + zi);\n    const n011 = hashFunction(xi, yi + 1 + zi + 1);\n    const n100 = hashFunction(xi + 1, yi + zi);\n    const n101 = hashFunction(xi + 1, yi + zi + 1);\n    const n110 = hashFunction(xi + 1, yi + 1 + zi);\n    const n111 = hashFunction(xi + 1, yi + 1 + zi + 1);\n    \n    // Interpolate along x\n    const nx00 = n000 * (1 - u) + n100 * u;\n    const nx01 = n001 * (1 - u) + n101 * u;\n    const nx10 = n010 * (1 - u) + n110 * u;\n    const nx11 = n011 * (1 - u) + n111 * u;\n    \n    // Interpolate along y\n    const nxy0 = nx00 * (1 - v) + nx10 * v;\n    const nxy1 = nx01 * (1 - v) + nx11 * v;\n    \n    // Interpolate along z and return\n    return nxy0 * (1 - w) + nxy1 * w;\n  }, [hashFunction]);\n  \n  // Get flow vector at a given position\n  const getFlowVector = useCallback((x, y, time, scale = 0.01, out = vectorCache.temp) => {\n    // Scale coordinates for smoother flow\n    const scaledX = x * scale * flowComplexity;\n    const scaledY = y * scale * flowComplexity;\n    const scaledTime = time * waveSpeed * 0.2;\n    \n    // Use noise function to get flow direction\n    const angle = noise(scaledX, scaledY, scaledTime) * Math.PI * 2;\n    \n    // Convert angle to vector\n    out.x = Math.cos(angle);\n    out.y = Math.sin(angle);\n    \n    return out;\n  }, [noise, flowComplexity, waveSpeed, vectorCache.temp]);\n  \n  // Create a new dust particle\n  const createParticle = useCallback(() => {\n    const { width, height } = dimensions;\n    if (!width || !height) return null;\n    \n    // Get z-depth first to avoid the circular reference\n    const z = Math.random() * 0.9 + 0.1; // 0.1 to 1.0\n    \n    // Create particle with random properties\n    const particle = {\n      // Position - randomly distributed across the screen\n      x: Math.random() * width,\n      y: Math.random() * height,\n      \n      // Size - varies by z-depth\n      z,\n      size: 0,\n      \n      // Visual properties\n      opacity: 0,\n      baseOpacity: Math.random() * 0.4 + 0.2, // 0.2 to 0.6\n      color: colors[Math.floor(Math.random() * colors.length)],\n      \n      // Movement properties\n      vx: 0,\n      vy: 0,\n      speed: (Math.random() * 0.5 + 0.5) * baseSpeed, // 0.5x to 1.5x base speed\n      \n      // Wave effect properties\n      wavePhase: Math.random() * Math.PI * 2,\n      waveFreq: (Math.random() * 0.5 + 0.75) * waveDensity,\n      waveAmp: (Math.random() * 0.7 + 0.3) * waveAmplitude,\n      \n      // Parallax factor - deeper particles move less\n      parallaxFactor: Math.random() * 0.8 * parallaxIntensity * (1 - (0.7 * z))\n    };\n    \n    // Size based on z-depth\n    particle.size = (Math.random() * (particleMaxSize - particleMinSize) + particleMinSize) * z;\n    \n    // Set initial opacity lower for fade-in effect\n    particle.opacity = particle.baseOpacity * 0.1;\n    \n    return particle;\n  }, [dimensions, baseSpeed, colors, particleMinSize, particleMaxSize, parallaxIntensity, waveDensity, waveAmplitude]);\n  \n  // Initialize particles\n  const initializeParticles = useCallback(() => {\n    // Clear existing particles\n    particlesRef.current = [];\n    \n    // Generate particles based on density\n    for (let i = 0; i < adaptedSettings.particleDensity; i++) {\n      const particle = createParticle();\n      if (particle) {\n        particlesRef.current.push(particle);\n      }\n    }\n  }, [adaptedSettings.particleDensity, createParticle]);\n  \n  // Detect device capabilities and preferences on mount\n  useEffect(() => {\n    // Check for reduced motion preference\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    \n    const handleReducedMotionChange = (e) => {\n      setPrefersReducedMotion(e.matches);\n    };\n    \n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n    \n    // Detect device capabilities\n    detectCapabilities();\n    \n    // Setup visibility change detection to pause when tab is inactive\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        visibilityChangeTimeRef.current = performance.now();\n      } else {\n        // Adjust timing references after visibility changes\n        const timeDelta = performance.now() - visibilityChangeTimeRef.current;\n        lastTimestampRef.current += timeDelta;\n      }\n    };\n    \n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    \n    // Cleanup\n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  }, [detectCapabilities]);\n  \n  // Setup canvas resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n    \n    // Create a ResizeObserver to detect container size changes\n    const resizeObserver = new ResizeObserver(entries => {\n      // Debounce resize operations\n      if (resizeObserverRef.current.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n      \n      resizeObserverRef.current.timeout = setTimeout(() => {\n        requestAnimationFrame(() => {\n          if (setupCanvas()) {\n            setIsInitialized(true);\n          }\n        });\n      }, 100); // 100ms debounce\n    });\n    \n    // Capture current reference to avoid closure issues in cleanup\n    const currentContainer = containerRef.current;\n    \n    // Start observing the container\n    resizeObserver.observe(currentContainer);\n    resizeObserverRef.current = { observer: resizeObserver };\n    \n    // Initial setup\n    setupCanvas();\n    setIsInitialized(true);\n    \n    return () => {\n      if (resizeObserverRef.current.observer) {\n        resizeObserverRef.current.observer.disconnect();\n      }\n      if (resizeObserverRef.current.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n    };\n  }, [setupCanvas]);\n  \n  // Setup intersection observer to only animate when visible\n  useEffect(() => {\n    if (!containerRef.current) return;\n    \n    const observer = new IntersectionObserver(\n      entries => {\n        const isIntersecting = entries[0].isIntersecting;\n        \n        // Only change state if visibility actually changed\n        if (isIntersecting !== isVisible) {\n          setIsVisible(isIntersecting);\n          \n          if (isIntersecting) {\n            // Reset timing references when becoming visible again\n            lastTimestampRef.current = 0;\n          }\n        }\n      },\n      {\n        threshold: 0.01,\n        rootMargin: '100px'\n      }\n    );\n    \n    // Store current reference to avoid closure issues\n    const currentContainerRef = containerRef.current;\n    observer.observe(currentContainerRef);\n    visibilityObserverRef.current = observer;\n    \n    return () => {\n      if (visibilityObserverRef.current) {\n        visibilityObserverRef.current.disconnect();\n      }\n    };\n  }, [isVisible]);\n  \n  // Handle parallax effect on scroll if enabled\n  useEffect(() => {\n    if (!enableParallax) return;\n    \n    // Use passive event listener for better performance\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    \n    window.addEventListener('scroll', handleScroll, { passive: true });\n    \n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [enableParallax]);\n  \n  // Initialize particles once canvas is ready\n  useEffect(() => {\n    if (isInitialized && dimensions.width && dimensions.height) {\n      initializeParticles();\n    }\n  }, [isInitialized, dimensions, initializeParticles]);\n  \n  // Render particles with WebGL\n  const renderParticlesWebGL = useCallback(() => {\n    if (!webGLRef.current || !particlesRef.current.length) return;\n    \n    const { gl, program, attributes, uniforms } = webGLRef.current;\n    \n    // Clear canvas\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    \n    // Use shader program\n    gl.useProgram(program);\n    \n    // Set resolution uniform\n    gl.uniform2f(\n      uniforms.resolution,\n      canvasRef.current.width,\n      canvasRef.current.height\n    );\n    \n    // Create buffers for position, size, and color\n    const positions = new Float32Array(particlesRef.current.length * 2);\n    const sizes = new Float32Array(particlesRef.current.length);\n    const colors = new Float32Array(particlesRef.current.length * 4);\n    \n    // Fill buffers with particle data\n    for (let i = 0; i < particlesRef.current.length; i++) {\n      const particle = particlesRef.current[i];\n      \n      // Position\n      positions[i * 2] = particle.x * dimensions.pixelRatio;\n      positions[i * 2 + 1] = particle.y * dimensions.pixelRatio;\n      \n      // Size - scaled by pixel ratio\n      sizes[i] = particle.size * dimensions.pixelRatio;\n      \n      // Color - parse from rgba string\n      // Simplified without regex for performance\n      const rgbaStart = particle.color.indexOf('(') + 1;\n      const rgbaEnd = particle.color.indexOf('alpha') - 1;\n      const rgbaValues = particle.color.substring(rgbaStart, rgbaEnd).split(',');\n      \n      colors[i * 4] = parseInt(rgbaValues[0], 10) / 255;\n      colors[i * 4 + 1] = parseInt(rgbaValues[1], 10) / 255;\n      colors[i * 4 + 2] = parseInt(rgbaValues[2], 10) / 255;\n      colors[i * 4 + 3] = particle.opacity;\n    }\n    \n    // Position buffer\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(attributes.position);\n    gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 0, 0);\n    \n    // Size buffer\n    const sizeBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, sizes, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(attributes.size);\n    gl.vertexAttribPointer(attributes.size, 1, gl.FLOAT, false, 0, 0);\n    \n    // Color buffer\n    const colorBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(attributes.color);\n    gl.vertexAttribPointer(attributes.color, 4, gl.FLOAT, false, 0, 0);\n    \n    // Draw particles\n    gl.drawArrays(gl.POINTS, 0, particlesRef.current.length);\n    \n    // Clean up\n    gl.disableVertexAttribArray(attributes.position);\n    gl.disableVertexAttribArray(attributes.size);\n    gl.disableVertexAttribArray(attributes.color);\n    gl.deleteBuffer(positionBuffer);\n    gl.deleteBuffer(sizeBuffer);\n    gl.deleteBuffer(colorBuffer);\n  }, [dimensions.pixelRatio]);\n  \n  // Render particles with Canvas 2D\n  const renderParticles2D = useCallback((ctx) => {\n    if (!ctx || !particlesRef.current.length) return;\n    \n    // Clear canvas with transparent background\n    ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n    \n    // Enable global composition for additively blending particles\n    ctx.globalCompositeOperation = 'lighter';\n    \n    // Draw each particle\n    for (let i = 0; i < particlesRef.current.length; i++) {\n      const particle = particlesRef.current[i];\n      \n      // Skip nearly invisible particles\n      if (particle.opacity < 0.02) continue;\n      \n      // Draw particle\n      ctx.beginPath();\n      ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);\n      \n      // Set color with opacity\n      ctx.fillStyle = getCachedColor(particle.color, particle.opacity);\n      ctx.fill();\n      \n      // Draw soft glow if using high quality rendering\n      if (adaptedSettings.useHighQualityRendering && particle.opacity > 0.1) {\n        ctx.beginPath();\n        ctx.arc(particle.x, particle.y, particle.size * 2, 0, Math.PI * 2);\n        ctx.fillStyle = getCachedColor(particle.color, particle.opacity * 0.3);\n        ctx.fill();\n      }\n    }\n    \n    // Reset composite operation\n    ctx.globalCompositeOperation = 'source-over';\n    \n    // Draw debug info if enabled\n    if (debug) {\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n      ctx.font = '12px monospace';\n      ctx.fillText(`FPS: ${currentFpsRef.current}`, 10, 20);\n      ctx.fillText(`Particles: ${particlesRef.current.length}`, 10, 40);\n      ctx.fillText(`Quality: ${qualityFactor.toFixed(2)}`, 10, 60);\n      ctx.fillText(`Rendering: ${actualRenderingMode}`, 10, 80);\n    }\n  }, [dimensions, adaptedSettings.useHighQualityRendering, getCachedColor, debug, qualityFactor, actualRenderingMode]);\n  \n  // Update particle positions and properties\n  const updateParticles = useCallback((deltaTime, timestamp) => {\n    const { width, height } = dimensions;\n    if (!width || !height) return;\n    \n    // Calculate time factor for animations\n    const timeFactor = timestamp * 0.001;\n    const scrollY = scrollPositionRef.current;\n    \n    // Update particles\n    for (let i = 0; i < particlesRef.current.length; i++) {\n      const particle = particlesRef.current[i];\n      \n      // Gradually fade in particles\n      if (particle.opacity < particle.baseOpacity) {\n        particle.opacity = Math.min(\n          particle.baseOpacity,\n          particle.opacity + deltaTime * 0.0005\n        );\n      }\n      \n      // Get flow direction at particle position\n      const flow = getFlowVector(particle.x, particle.y, timeFactor);\n      \n      // Apply parallax effect if enabled\n      let parallaxOffsetY = 0;\n      if (enableParallax) {\n        parallaxOffsetY = scrollY * particle.parallaxFactor;\n      }\n      \n      // Calculate wave effect\n      const waveOffset = Math.sin(\n        (particle.x * particle.waveFreq * 0.01) + \n        (timeFactor * particle.waveFreq) + \n        particle.wavePhase\n      ) * particle.waveAmp;\n      \n      // Update velocity based on flow field and wave\n      particle.vx = flow.x * particle.speed;\n      particle.vy = flow.y * particle.speed + (waveOffset * 0.01);\n      \n      // Apply velocity to position\n      particle.x += particle.vx * deltaTime;\n      particle.y += particle.vy * deltaTime - parallaxOffsetY * 0.1;\n      \n      // Wrap around screen edges with buffer area\n      const buffer = particle.size * 4;\n      \n      if (particle.x < -buffer) {\n        particle.x = width + buffer;\n        // Randomize Y slightly when wrapping horizontally\n        particle.y = Math.random() * height;\n      } else if (particle.x > width + buffer) {\n        particle.x = -buffer;\n        // Randomize Y slightly when wrapping horizontally\n        particle.y = Math.random() * height;\n      }\n      \n      if (particle.y < -buffer) {\n        particle.y = height + buffer;\n        // Randomize X slightly when wrapping vertically\n        particle.x = Math.random() * width;\n      } else if (particle.y > height + buffer) {\n        particle.y = -buffer;\n        // Randomize X slightly when wrapping vertically\n        particle.x = Math.random() * width;\n      }\n    }\n  }, [dimensions, enableParallax, getFlowVector]);\n  \n  // FPS limiter for consistent animation speed\n  const fpsLimiter = useCallback((timestamp, callback) => {\n    // Skip animation if hidden, inactive, or reduced motion\n    if (!isVisible || !active || (respectReducedMotion && prefersReducedMotion) || document.hidden) {\n      animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n      return;\n    }\n    \n    const targetFrameTime = 1000 / maxFPS;\n    const elapsed = timestamp - lastTimestampRef.current;\n    \n    if (elapsed >= targetFrameTime || lastTimestampRef.current === 0) {\n      // Calculate correct delta\n      const delta = lastTimestampRef.current === 0 ? 16 : elapsed;\n      \n      // Update timestamp, limiting delta to avoid jumps after inactivity\n      lastTimestampRef.current = timestamp - (elapsed % targetFrameTime);\n      \n      // Run animation callback with capped delta time\n      callback(Math.min(delta, 50), timestamp);\n      \n      // FPS tracking for debug and adaptive quality\n      frameCountRef.current++;\n      if (timestamp - fpsTimestampRef.current >= 1000) {\n        currentFpsRef.current = frameCountRef.current;\n        frameCountRef.current = 0;\n        fpsTimestampRef.current = timestamp;\n        \n        // Log FPS in debug mode\n        if (debug) {\n          console.log(`CosmicDust FPS: ${currentFpsRef.current}, Quality: ${qualityFactor.toFixed(2)}`);\n        }\n        \n        // Dynamic quality adjustment based on performance with debouncing\n        if (adaptiveQuality) {\n          // Check if FPS is stable by counting consecutive frames within target range\n          if (currentFpsRef.current >= maxFPS * 0.95) {\n            stableFrameCountRef.current += 1;\n          } else if (currentFpsRef.current < maxFPS * 0.7) {\n            stableFrameCountRef.current = 0;\n          }\n          \n          // Avoid frequent quality changes by using a timer\n          if (qualityChangeTimerRef.current) {\n            clearTimeout(qualityChangeTimerRef.current);\n          }\n          \n          qualityChangeTimerRef.current = setTimeout(() => {\n            // Only change quality if FPS has been stable or is very low\n            if (currentFpsRef.current < maxFPS * 0.7) {\n              // If FPS is below 70% of target, reduce quality\n              setQualityFactor(prev => {\n                const newQuality = Math.max(0.4, prev * 0.9);\n                lastQualityFactorRef.current = newQuality;\n                return newQuality;\n              });\n            } else if (stableFrameCountRef.current >= 3 && qualityFactor < 1) {\n              // If FPS has been high for several frames, gradually increase quality\n              setQualityFactor(prev => {\n                const newQuality = Math.min(1, prev * 1.05);\n                lastQualityFactorRef.current = newQuality;\n                return newQuality;\n              });\n            }\n          }, 500); // Wait 500ms before changing quality to avoid rapid oscillation\n        }\n      }\n    }\n    \n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n  }, [\n    isVisible,\n    active,\n    respectReducedMotion,\n    prefersReducedMotion,\n    maxFPS,\n    debug,\n    adaptiveQuality,\n    qualityFactor\n  ]);\n  \n  // Main animation handler\n  const handleAnimation = useCallback((deltaTime, timestamp) => {\n    // Skip if component is not ready\n    if (!canvasRef.current || !isInitialized) return;\n    \n    // Update particle positions\n    updateParticles(deltaTime, timestamp);\n    \n    // Render based on selected mode\n    if (actualRenderingMode === 'webgl' && webGLRef.current) {\n      // WebGL rendering path\n      renderParticlesWebGL();\n    } else {\n      // Canvas 2D rendering path\n      const ctx = ctxRef.current;\n      if (!ctx) return;\n      \n      // Render particles\n      renderParticles2D(ctx);\n    }\n  }, [\n    isInitialized,\n    actualRenderingMode,\n    updateParticles,\n    renderParticlesWebGL,\n    renderParticles2D\n  ]);\n  \n  // Main animation loop\n  useEffect(() => {\n    if (!active || !isInitialized || !dimensions.width || !dimensions.height) {\n      return;\n    }\n    \n    // Start animation with FPS limiter\n    fpsTimestampRef.current = performance.now();\n    frameCountRef.current = 0;\n    lastTimestampRef.current = 0;\n    \n    animationFrameRef.current = requestAnimationFrame(timestamp => {\n      fpsLimiter(timestamp, handleAnimation);\n    });\n    \n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      \n      if (qualityChangeTimerRef.current) {\n        clearTimeout(qualityChangeTimerRef.current);\n      }\n    };\n  }, [\n    active,\n    isInitialized,\n    dimensions,\n    fpsLimiter,\n    handleAnimation\n  ]);\n  \n  return (\n    <div \n      ref={containerRef}\n      style={{ \n        position: 'absolute',\n        top: 0, \n        left: 0, \n        width: '100%', \n        height: height,\n        overflow: 'hidden', \n        pointerEvents: 'none', \n        zIndex: zIndex,\n        // Hardware acceleration\n        backfaceVisibility: 'hidden',\n        transform: 'translateZ(0)',\n        willChange: 'transform'\n      }}\n      aria-hidden=\"true\"\n    >\n      <canvas \n        ref={canvasRef} \n        style={{ \n          position: 'absolute', \n          top: 0, \n          left: 0, \n          width: '100%', \n          height: '100%',\n          // Additional rendering optimizations\n          imageRendering: 'high-quality',\n          // Hardware acceleration\n          backfaceVisibility: 'hidden',\n          transform: 'translateZ(0)',\n          willChange: 'transform',\n          // Ensures proper subpixel rendering\n          filter: 'none'\n        }} \n      />\n    </div>\n  );\n};\n\nexport default CosmicDust;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}