{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/effects/scrollingeffects/SlidingBackground.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\n\n/**\n * SlidingBackground Component\n * \n * A highly configurable background component with parallax and fade effects\n * that integrates seamlessly into existing page layouts.\n * \n * @param {Object} props - Component props\n * @param {string} props.image - URL of the background image\n * @param {string} [props.position='top'] - Position of the focused area ('top', 'middle', 'bottom')\n * @param {string|number} [props.height='100%'] - Height of the component\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of the parallax effect (0-1)\n * @param {number} [props.parallaxLimitPercent=30] - Maximum percentage of component height the image can move\n * @param {boolean} [props.clampParallax=true] - Whether to clamp parallax movement\n * @param {boolean} [props.enableParallax=true] - Enable/disable parallax effect\n * @param {number} [props.fadeSize=0.4] - Size of the fade effect (0-1, as a fraction of the component)\n * @param {string} [props.backgroundColor='#000'] - Background color for the fade effect\n * @param {number} [props.zIndex=0] - z-index of the component\n * @param {number} [props.blurAmount=0] - Amount of blur for the fade transition (px)\n * @param {number} [props.opacity=1] - Opacity of the background image\n * @param {string} [props.backgroundSize='cover'] - Background size property\n * @param {string} [props.backgroundPosition] - Background position (overrides position setting)\n * @param {string} [props.transitionEffect='gradient'] - Type of transition effect ('gradient', 'dissolve')\n * @param {boolean} [props.fitContainer=true] - Whether the background should fit its container\n * @param {number} [props.heightMultiplier=1.2] - How much larger the background image should be\n * @param {Object} [props.containerStyle={}] - Additional styles for the container\n * @param {boolean} [props.createContainer=true] - Whether to create a container div\n * @param {React.ReactNode} [props.children] - Content to render on top of the background\n * @param {string} [props.className=''] - Additional CSS classes for the container\n */\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst SlidingBackground = ({\n  image,\n  position = 'top',\n  height = '100%',\n  parallaxIntensity = 0.2,\n  parallaxLimitPercent = 30,\n  clampParallax = true,\n  enableParallax = true,\n  fadeSize = 0.4,\n  backgroundColor = '#000',\n  zIndex = 0,\n  blurAmount = 0,\n  opacity = 1,\n  backgroundSize = 'cover',\n  backgroundPosition,\n  transitionEffect = 'gradient',\n  fitContainer = true,\n  heightMultiplier = 1.2,\n  containerStyle = {},\n  createContainer = true,\n  children,\n  className = ''\n}) => {\n  _s();\n  const elementRef = useRef(null);\n  const canvasRef = useRef(null);\n  const [scrollPosition, setScrollPosition] = useState(0);\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0\n  });\n  const [imageLoaded, setImageLoaded] = useState(false);\n  const imageRef = useRef(null);\n  const animationFrameRef = useRef(null);\n\n  /**\n   * Renders the dissolve effect on the canvas\n   * Creates a melting/dissolving transition effect based on scroll position\n   */\n  const renderDissolveEffect = useCallback(() => {\n    if (!canvasRef.current || !imageRef.current || !dimensions.width || !dimensions.height) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const img = imageRef.current;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Calculate parallax offset with clamping if enabled\n    let parallaxOffset = enableParallax ? scrollPosition * parallaxIntensity : 0;\n\n    // Clamp parallax movement if enabled\n    if (clampParallax && enableParallax) {\n      const maxOffset = canvas.height * parallaxLimitPercent / 100;\n      parallaxOffset = Math.max(Math.min(parallaxOffset, maxOffset), -maxOffset);\n    }\n\n    // Calculate image dimensions to maintain aspect ratio while covering the canvas\n    const imgAspect = img.width / img.height;\n    const canvasAspect = canvas.width / canvas.height;\n    let drawWidth, drawHeight, offsetX, offsetY;\n    if (fitContainer) {\n      // Apply heightMultiplier to make image larger than container if needed\n      if (imgAspect > canvasAspect) {\n        // Image is wider than canvas (relative to height)\n        drawHeight = canvas.height * heightMultiplier;\n        drawWidth = drawHeight * imgAspect;\n        offsetX = (canvas.width - drawWidth) / 2;\n        offsetY = (canvas.height - drawHeight) / 2;\n      } else {\n        // Image is taller than canvas (relative to width)\n        drawWidth = canvas.width * heightMultiplier;\n        drawHeight = drawWidth / imgAspect;\n        offsetX = (canvas.width - drawWidth) / 2;\n        offsetY = (canvas.height - drawHeight) / 2;\n      }\n    } else {\n      // Cover the canvas\n      if (imgAspect > canvasAspect) {\n        drawHeight = canvas.height;\n        drawWidth = drawHeight * imgAspect;\n        offsetX = (canvas.width - drawWidth) / 2;\n        offsetY = 0;\n      } else {\n        drawWidth = canvas.width;\n        drawHeight = drawWidth / imgAspect;\n        offsetX = 0;\n        offsetY = (canvas.height - drawHeight) / 2;\n      }\n    }\n\n    // Adjust based on position setting\n    if (position === 'top') {\n      offsetY = 0;\n    } else if (position === 'bottom') {\n      offsetY = canvas.height - drawHeight;\n    } else if (position === 'middle') {\n      offsetY = (canvas.height - drawHeight) / 2;\n    }\n\n    // Apply parallax\n    offsetY += parallaxOffset;\n\n    // Draw the image\n    ctx.globalAlpha = opacity;\n    ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);\n\n    // Apply blur if specified\n    if (blurAmount > 0) {\n      ctx.filter = `blur(${blurAmount}px)`;\n      ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);\n      ctx.filter = 'none';\n    }\n\n    // Determine which edges should fade based on position\n    const shouldFadeTop = position === 'bottom' || position === 'middle';\n    const shouldFadeBottom = position === 'top' || position === 'middle';\n\n    // Top dissolve effect\n    if (shouldFadeTop) {\n      const fadeHeight = Math.floor(canvas.height * fadeSize);\n      const imageData = ctx.getImageData(0, 0, canvas.width, fadeHeight);\n      const pixels = imageData.data;\n      for (let y = 0; y < fadeHeight; y++) {\n        const fadeRatio = 1 - y / fadeHeight;\n        for (let x = 0; x < canvas.width; x++) {\n          const pixelIndex = (y * canvas.width + x) * 4;\n\n          // Apply dissolve effect with random pattern\n          if (Math.random() < fadeRatio * 0.8) {\n            pixels[pixelIndex + 3] = 0; // Set alpha to 0 (transparent)\n          } else {\n            // Gradually decrease opacity\n            pixels[pixelIndex + 3] = pixels[pixelIndex + 3] * (1 - fadeRatio);\n          }\n        }\n      }\n      ctx.putImageData(imageData, 0, 0);\n\n      // Add gradient overlay\n      const gradient = ctx.createLinearGradient(0, 0, 0, fadeHeight);\n      gradient.addColorStop(0, backgroundColor);\n      gradient.addColorStop(1, 'rgba(0,0,0,0)');\n      ctx.fillStyle = gradient;\n      ctx.globalAlpha = 0.7;\n      ctx.fillRect(0, 0, canvas.width, fadeHeight);\n    }\n\n    // Bottom dissolve effect\n    if (shouldFadeBottom) {\n      const fadeHeight = Math.floor(canvas.height * fadeSize);\n      const startY = canvas.height - fadeHeight;\n      const imageData = ctx.getImageData(0, startY, canvas.width, fadeHeight);\n      const pixels = imageData.data;\n      for (let y = 0; y < fadeHeight; y++) {\n        const fadeRatio = y / fadeHeight;\n        for (let x = 0; x < canvas.width; x++) {\n          const pixelIndex = (y * canvas.width + x) * 4;\n\n          // Apply dissolve effect with random pattern\n          if (Math.random() < fadeRatio * 0.8) {\n            pixels[pixelIndex + 3] = 0; // Set alpha to 0 (transparent)\n          } else {\n            // Gradually decrease opacity\n            pixels[pixelIndex + 3] = pixels[pixelIndex + 3] * (1 - fadeRatio);\n          }\n        }\n      }\n      ctx.putImageData(imageData, 0, startY);\n\n      // Add gradient overlay\n      const gradient = ctx.createLinearGradient(0, startY, 0, canvas.height);\n      gradient.addColorStop(0, 'rgba(0,0,0,0)');\n      gradient.addColorStop(1, backgroundColor);\n      ctx.fillStyle = gradient;\n      ctx.globalAlpha = 0.7;\n      ctx.fillRect(0, startY, canvas.width, fadeHeight);\n    }\n  }, [scrollPosition, parallaxIntensity, parallaxLimitPercent, clampParallax, enableParallax, position, opacity, blurAmount, fadeSize, backgroundColor, dimensions.width, dimensions.height, fitContainer, heightMultiplier]);\n\n  // Set up scroll event listener\n  useEffect(() => {\n    // Only attach scroll listener if parallax is enabled\n    if (!enableParallax) {\n      setScrollPosition(0);\n      return;\n    }\n    const handleScroll = () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      animationFrameRef.current = requestAnimationFrame(() => {\n        setScrollPosition(window.scrollY);\n      });\n    };\n    window.addEventListener('scroll', handleScroll, {\n      passive: true\n    });\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [enableParallax]);\n\n  // Update canvas when scroll position changes (for parallax)\n  useEffect(() => {\n    if (imageLoaded && transitionEffect === 'dissolve') {\n      renderDissolveEffect();\n    }\n  }, [scrollPosition, imageLoaded, transitionEffect, renderDissolveEffect]);\n\n  // Handle image loading and canvas setup\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (elementRef.current) {\n        const rect = elementRef.current.getBoundingClientRect();\n        const newDimensions = {\n          width: rect.width,\n          height: rect.height\n        };\n        setDimensions(newDimensions);\n        if (canvasRef.current && transitionEffect === 'dissolve') {\n          canvasRef.current.width = newDimensions.width;\n          canvasRef.current.height = newDimensions.height;\n          if (imageLoaded) {\n            renderDissolveEffect();\n          }\n        }\n      }\n    };\n\n    // Load image if using canvas-based effects\n    if (transitionEffect === 'dissolve') {\n      const img = new Image();\n      img.crossOrigin = \"Anonymous\";\n      img.src = image;\n      img.onload = () => {\n        imageRef.current = img;\n        setImageLoaded(true);\n        updateDimensions();\n      };\n    }\n    updateDimensions();\n    window.addEventListener('resize', updateDimensions);\n    return () => {\n      window.removeEventListener('resize', updateDimensions);\n    };\n  }, [image, transitionEffect, renderDissolveEffect, imageLoaded]);\n\n  // Calculate parallax transformation\n  let parallaxOffset = enableParallax ? scrollPosition * parallaxIntensity : 0;\n\n  // Clamp parallax movement if enabled\n  if (clampParallax && dimensions.height && enableParallax) {\n    const maxOffset = dimensions.height * parallaxLimitPercent / 100;\n    parallaxOffset = Math.max(Math.min(parallaxOffset, maxOffset), -maxOffset);\n  }\n\n  // Determine background position based on position setting\n  let bgPosition = backgroundPosition;\n  if (!bgPosition) {\n    switch (position) {\n      case 'top':\n        bgPosition = 'center top';\n        break;\n      case 'bottom':\n        bgPosition = 'center bottom';\n        break;\n      case 'middle':\n      default:\n        bgPosition = 'center center';\n    }\n  }\n\n  // Determine which edges should fade based on position setting\n  const shouldFadeTop = position === 'bottom' || position === 'middle';\n  const shouldFadeBottom = position === 'top' || position === 'middle';\n\n  // Default container styles\n  const defaultContainerStyle = {\n    position: 'relative',\n    width: '100%',\n    height,\n    overflow: 'hidden',\n    zIndex\n  };\n\n  // Combine default and custom container styles\n  const mergedContainerStyle = {\n    ...defaultContainerStyle,\n    ...containerStyle\n  };\n\n  // Content for rendering\n  const backgroundContent = /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [transitionEffect === 'gradient' && /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: fitContainer ? `${heightMultiplier * 100}%` : '100%',\n          backgroundImage: `url(${image})`,\n          backgroundSize: fitContainer ? 'contain' : backgroundSize,\n          backgroundRepeat: 'no-repeat',\n          backgroundPosition: bgPosition,\n          transform: `translateY(${parallaxOffset}px)`,\n          transition: 'transform 0.1s ease-out',\n          opacity,\n          filter: blurAmount > 0 ? `blur(${blurAmount}px)` : 'none'\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 361,\n        columnNumber: 11\n      }, this), shouldFadeTop && /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: `${fadeSize * 100}%`,\n          background: `linear-gradient(to bottom, ${backgroundColor} 0%, rgba(0,0,0,0) 100%)`,\n          pointerEvents: 'none'\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 381,\n        columnNumber: 13\n      }, this), shouldFadeBottom && /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: 'absolute',\n          bottom: 0,\n          left: 0,\n          width: '100%',\n          height: `${fadeSize * 100}%`,\n          background: `linear-gradient(to top, ${backgroundColor} 0%, rgba(0,0,0,0) 100%)`,\n          pointerEvents: 'none'\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 396,\n        columnNumber: 13\n      }, this)]\n    }, void 0, true), transitionEffect === 'dissolve' && /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 413,\n      columnNumber: 9\n    }, this), children && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: 'relative',\n        zIndex: 1,\n        width: '100%',\n        height: '100%'\n      },\n      children: children\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 427,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true);\n\n  // Render with or without container based on createContainer prop\n  return createContainer ? /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: elementRef,\n    className: className,\n    style: mergedContainerStyle,\n    children: backgroundContent\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 443,\n    columnNumber: 5\n  }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: elementRef,\n    className: className,\n    style: {\n      position: 'relative'\n    },\n    children: backgroundContent\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 451,\n    columnNumber: 5\n  }, this);\n};\n_s(SlidingBackground, \"r/ydtB7w35TrwUflECmXX4hFUbE=\");\n_c = SlidingBackground;\nexport default SlidingBackground;\nvar _c;\n$RefreshReg$(_c, \"SlidingBackground\");","map":{"version":3,"names":["React","useRef","useEffect","useState","useCallback","jsxDEV","_jsxDEV","Fragment","_Fragment","SlidingBackground","image","position","height","parallaxIntensity","parallaxLimitPercent","clampParallax","enableParallax","fadeSize","backgroundColor","zIndex","blurAmount","opacity","backgroundSize","backgroundPosition","transitionEffect","fitContainer","heightMultiplier","containerStyle","createContainer","children","className","_s","elementRef","canvasRef","scrollPosition","setScrollPosition","dimensions","setDimensions","width","imageLoaded","setImageLoaded","imageRef","animationFrameRef","renderDissolveEffect","current","canvas","ctx","getContext","img","clearRect","parallaxOffset","maxOffset","Math","max","min","imgAspect","canvasAspect","drawWidth","drawHeight","offsetX","offsetY","globalAlpha","drawImage","filter","shouldFadeTop","shouldFadeBottom","fadeHeight","floor","imageData","getImageData","pixels","data","y","fadeRatio","x","pixelIndex","random","putImageData","gradient","createLinearGradient","addColorStop","fillStyle","fillRect","startY","handleScroll","cancelAnimationFrame","requestAnimationFrame","window","scrollY","addEventListener","passive","removeEventListener","updateDimensions","rect","getBoundingClientRect","newDimensions","Image","crossOrigin","src","onload","bgPosition","defaultContainerStyle","overflow","mergedContainerStyle","backgroundContent","style","top","left","backgroundImage","backgroundRepeat","transform","transition","fileName","_jsxFileName","lineNumber","columnNumber","background","pointerEvents","bottom","ref","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/effects/scrollingeffects/SlidingBackground.jsx"],"sourcesContent":["import React, { useRef, useEffect, useState, useCallback } from 'react';\n\n/**\n * SlidingBackground Component\n * \n * A highly configurable background component with parallax and fade effects\n * that integrates seamlessly into existing page layouts.\n * \n * @param {Object} props - Component props\n * @param {string} props.image - URL of the background image\n * @param {string} [props.position='top'] - Position of the focused area ('top', 'middle', 'bottom')\n * @param {string|number} [props.height='100%'] - Height of the component\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of the parallax effect (0-1)\n * @param {number} [props.parallaxLimitPercent=30] - Maximum percentage of component height the image can move\n * @param {boolean} [props.clampParallax=true] - Whether to clamp parallax movement\n * @param {boolean} [props.enableParallax=true] - Enable/disable parallax effect\n * @param {number} [props.fadeSize=0.4] - Size of the fade effect (0-1, as a fraction of the component)\n * @param {string} [props.backgroundColor='#000'] - Background color for the fade effect\n * @param {number} [props.zIndex=0] - z-index of the component\n * @param {number} [props.blurAmount=0] - Amount of blur for the fade transition (px)\n * @param {number} [props.opacity=1] - Opacity of the background image\n * @param {string} [props.backgroundSize='cover'] - Background size property\n * @param {string} [props.backgroundPosition] - Background position (overrides position setting)\n * @param {string} [props.transitionEffect='gradient'] - Type of transition effect ('gradient', 'dissolve')\n * @param {boolean} [props.fitContainer=true] - Whether the background should fit its container\n * @param {number} [props.heightMultiplier=1.2] - How much larger the background image should be\n * @param {Object} [props.containerStyle={}] - Additional styles for the container\n * @param {boolean} [props.createContainer=true] - Whether to create a container div\n * @param {React.ReactNode} [props.children] - Content to render on top of the background\n * @param {string} [props.className=''] - Additional CSS classes for the container\n */\nconst SlidingBackground = ({\n  image,\n  position = 'top',\n  height = '100%',\n  parallaxIntensity = 0.2,\n  parallaxLimitPercent = 30,\n  clampParallax = true,\n  enableParallax = true,\n  fadeSize = 0.4,\n  backgroundColor = '#000',\n  zIndex = 0,\n  blurAmount = 0,\n  opacity = 1,\n  backgroundSize = 'cover',\n  backgroundPosition,\n  transitionEffect = 'gradient',\n  fitContainer = true,\n  heightMultiplier = 1.2,\n  containerStyle = {},\n  createContainer = true,\n  children,\n  className = '',\n}) => {\n  const elementRef = useRef(null);\n  const canvasRef = useRef(null);\n  const [scrollPosition, setScrollPosition] = useState(0);\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n  const [imageLoaded, setImageLoaded] = useState(false);\n  const imageRef = useRef(null);\n  const animationFrameRef = useRef(null);\n  \n  /**\n   * Renders the dissolve effect on the canvas\n   * Creates a melting/dissolving transition effect based on scroll position\n   */\n  const renderDissolveEffect = useCallback(() => {\n    if (!canvasRef.current || !imageRef.current || !dimensions.width || !dimensions.height) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const img = imageRef.current;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // Calculate parallax offset with clamping if enabled\n    let parallaxOffset = enableParallax ? scrollPosition * parallaxIntensity : 0;\n    \n    // Clamp parallax movement if enabled\n    if (clampParallax && enableParallax) {\n      const maxOffset = (canvas.height * parallaxLimitPercent) / 100;\n      parallaxOffset = Math.max(Math.min(parallaxOffset, maxOffset), -maxOffset);\n    }\n    \n    // Calculate image dimensions to maintain aspect ratio while covering the canvas\n    const imgAspect = img.width / img.height;\n    const canvasAspect = canvas.width / canvas.height;\n    \n    let drawWidth, drawHeight, offsetX, offsetY;\n    \n    if (fitContainer) {\n      // Apply heightMultiplier to make image larger than container if needed\n      if (imgAspect > canvasAspect) {\n        // Image is wider than canvas (relative to height)\n        drawHeight = canvas.height * heightMultiplier;\n        drawWidth = drawHeight * imgAspect;\n        offsetX = (canvas.width - drawWidth) / 2;\n        offsetY = (canvas.height - drawHeight) / 2;\n      } else {\n        // Image is taller than canvas (relative to width)\n        drawWidth = canvas.width * heightMultiplier;\n        drawHeight = drawWidth / imgAspect;\n        offsetX = (canvas.width - drawWidth) / 2;\n        offsetY = (canvas.height - drawHeight) / 2;\n      }\n    } else {\n      // Cover the canvas\n      if (imgAspect > canvasAspect) {\n        drawHeight = canvas.height;\n        drawWidth = drawHeight * imgAspect;\n        offsetX = (canvas.width - drawWidth) / 2;\n        offsetY = 0;\n      } else {\n        drawWidth = canvas.width;\n        drawHeight = drawWidth / imgAspect;\n        offsetX = 0;\n        offsetY = (canvas.height - drawHeight) / 2;\n      }\n    }\n    \n    // Adjust based on position setting\n    if (position === 'top') {\n      offsetY = 0;\n    } else if (position === 'bottom') {\n      offsetY = canvas.height - drawHeight;\n    } else if (position === 'middle') {\n      offsetY = (canvas.height - drawHeight) / 2;\n    }\n    \n    // Apply parallax\n    offsetY += parallaxOffset;\n    \n    // Draw the image\n    ctx.globalAlpha = opacity;\n    ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);\n    \n    // Apply blur if specified\n    if (blurAmount > 0) {\n      ctx.filter = `blur(${blurAmount}px)`;\n      ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);\n      ctx.filter = 'none';\n    }\n    \n    // Determine which edges should fade based on position\n    const shouldFadeTop = position === 'bottom' || position === 'middle';\n    const shouldFadeBottom = position === 'top' || position === 'middle';\n    \n    // Top dissolve effect\n    if (shouldFadeTop) {\n      const fadeHeight = Math.floor(canvas.height * fadeSize);\n      const imageData = ctx.getImageData(0, 0, canvas.width, fadeHeight);\n      const pixels = imageData.data;\n      \n      for (let y = 0; y < fadeHeight; y++) {\n        const fadeRatio = 1 - (y / fadeHeight);\n        \n        for (let x = 0; x < canvas.width; x++) {\n          const pixelIndex = (y * canvas.width + x) * 4;\n          \n          // Apply dissolve effect with random pattern\n          if (Math.random() < fadeRatio * 0.8) {\n            pixels[pixelIndex + 3] = 0; // Set alpha to 0 (transparent)\n          } else {\n            // Gradually decrease opacity\n            pixels[pixelIndex + 3] = pixels[pixelIndex + 3] * (1 - fadeRatio);\n          }\n        }\n      }\n      \n      ctx.putImageData(imageData, 0, 0);\n      \n      // Add gradient overlay\n      const gradient = ctx.createLinearGradient(0, 0, 0, fadeHeight);\n      gradient.addColorStop(0, backgroundColor);\n      gradient.addColorStop(1, 'rgba(0,0,0,0)');\n      \n      ctx.fillStyle = gradient;\n      ctx.globalAlpha = 0.7;\n      ctx.fillRect(0, 0, canvas.width, fadeHeight);\n    }\n    \n    // Bottom dissolve effect\n    if (shouldFadeBottom) {\n      const fadeHeight = Math.floor(canvas.height * fadeSize);\n      const startY = canvas.height - fadeHeight;\n      const imageData = ctx.getImageData(0, startY, canvas.width, fadeHeight);\n      const pixels = imageData.data;\n      \n      for (let y = 0; y < fadeHeight; y++) {\n        const fadeRatio = y / fadeHeight;\n        \n        for (let x = 0; x < canvas.width; x++) {\n          const pixelIndex = (y * canvas.width + x) * 4;\n          \n          // Apply dissolve effect with random pattern\n          if (Math.random() < fadeRatio * 0.8) {\n            pixels[pixelIndex + 3] = 0; // Set alpha to 0 (transparent)\n          } else {\n            // Gradually decrease opacity\n            pixels[pixelIndex + 3] = pixels[pixelIndex + 3] * (1 - fadeRatio);\n          }\n        }\n      }\n      \n      ctx.putImageData(imageData, 0, startY);\n      \n      // Add gradient overlay\n      const gradient = ctx.createLinearGradient(0, startY, 0, canvas.height);\n      gradient.addColorStop(0, 'rgba(0,0,0,0)');\n      gradient.addColorStop(1, backgroundColor);\n      \n      ctx.fillStyle = gradient;\n      ctx.globalAlpha = 0.7;\n      ctx.fillRect(0, startY, canvas.width, fadeHeight);\n    }\n  }, [\n    scrollPosition,\n    parallaxIntensity,\n    parallaxLimitPercent,\n    clampParallax,\n    enableParallax,\n    position,\n    opacity,\n    blurAmount,\n    fadeSize,\n    backgroundColor,\n    dimensions.width,\n    dimensions.height,\n    fitContainer,\n    heightMultiplier\n  ]);\n  \n  // Set up scroll event listener\n  useEffect(() => {\n    // Only attach scroll listener if parallax is enabled\n    if (!enableParallax) {\n      setScrollPosition(0);\n      return;\n    }\n    \n    const handleScroll = () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      \n      animationFrameRef.current = requestAnimationFrame(() => {\n        setScrollPosition(window.scrollY);\n      });\n    };\n    \n    window.addEventListener('scroll', handleScroll, { passive: true });\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [enableParallax]);\n  \n  // Update canvas when scroll position changes (for parallax)\n  useEffect(() => {\n    if (imageLoaded && transitionEffect === 'dissolve') {\n      renderDissolveEffect();\n    }\n  }, [scrollPosition, imageLoaded, transitionEffect, renderDissolveEffect]);\n  \n  // Handle image loading and canvas setup\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (elementRef.current) {\n        const rect = elementRef.current.getBoundingClientRect();\n        const newDimensions = { \n          width: rect.width, \n          height: rect.height \n        };\n        \n        setDimensions(newDimensions);\n        \n        if (canvasRef.current && transitionEffect === 'dissolve') {\n          canvasRef.current.width = newDimensions.width;\n          canvasRef.current.height = newDimensions.height;\n          \n          if (imageLoaded) {\n            renderDissolveEffect();\n          }\n        }\n      }\n    };\n    \n    // Load image if using canvas-based effects\n    if (transitionEffect === 'dissolve') {\n      const img = new Image();\n      img.crossOrigin = \"Anonymous\";\n      img.src = image;\n      img.onload = () => {\n        imageRef.current = img;\n        setImageLoaded(true);\n        updateDimensions();\n      };\n    }\n    \n    updateDimensions();\n    window.addEventListener('resize', updateDimensions);\n    \n    return () => {\n      window.removeEventListener('resize', updateDimensions);\n    };\n  }, [image, transitionEffect, renderDissolveEffect, imageLoaded]);\n  \n  // Calculate parallax transformation\n  let parallaxOffset = enableParallax ? scrollPosition * parallaxIntensity : 0;\n  \n  // Clamp parallax movement if enabled\n  if (clampParallax && dimensions.height && enableParallax) {\n    const maxOffset = (dimensions.height * parallaxLimitPercent) / 100;\n    parallaxOffset = Math.max(Math.min(parallaxOffset, maxOffset), -maxOffset);\n  }\n  \n  // Determine background position based on position setting\n  let bgPosition = backgroundPosition;\n  if (!bgPosition) {\n    switch (position) {\n      case 'top':\n        bgPosition = 'center top';\n        break;\n      case 'bottom':\n        bgPosition = 'center bottom';\n        break;\n      case 'middle':\n      default:\n        bgPosition = 'center center';\n    }\n  }\n  \n  // Determine which edges should fade based on position setting\n  const shouldFadeTop = position === 'bottom' || position === 'middle';\n  const shouldFadeBottom = position === 'top' || position === 'middle';\n  \n  // Default container styles\n  const defaultContainerStyle = {\n    position: 'relative',\n    width: '100%',\n    height,\n    overflow: 'hidden',\n    zIndex,\n  };\n  \n  // Combine default and custom container styles\n  const mergedContainerStyle = {\n    ...defaultContainerStyle,\n    ...containerStyle\n  };\n  \n  // Content for rendering\n  const backgroundContent = (\n    <>\n      {/* CSS-based gradient transition */}\n      {transitionEffect === 'gradient' && (\n        <>\n          <div\n            style={{\n              position: 'absolute',\n              top: 0,\n              left: 0,\n              width: '100%',\n              height: fitContainer ? `${heightMultiplier * 100}%` : '100%',\n              backgroundImage: `url(${image})`,\n              backgroundSize: fitContainer ? 'contain' : backgroundSize,\n              backgroundRepeat: 'no-repeat',\n              backgroundPosition: bgPosition,\n              transform: `translateY(${parallaxOffset}px)`,\n              transition: 'transform 0.1s ease-out',\n              opacity,\n              filter: blurAmount > 0 ? `blur(${blurAmount}px)` : 'none'\n            }}\n          />\n          \n          {/* Top fade gradient */}\n          {shouldFadeTop && (\n            <div\n              style={{\n                position: 'absolute',\n                top: 0,\n                left: 0,\n                width: '100%',\n                height: `${fadeSize * 100}%`,\n                background: `linear-gradient(to bottom, ${backgroundColor} 0%, rgba(0,0,0,0) 100%)`,\n                pointerEvents: 'none'\n              }}\n            />\n          )}\n          \n          {/* Bottom fade gradient */}\n          {shouldFadeBottom && (\n            <div\n              style={{\n                position: 'absolute',\n                bottom: 0,\n                left: 0,\n                width: '100%',\n                height: `${fadeSize * 100}%`,\n                background: `linear-gradient(to top, ${backgroundColor} 0%, rgba(0,0,0,0) 100%)`,\n                pointerEvents: 'none'\n              }}\n            />\n          )}\n        </>\n      )}\n      \n      {/* Canvas-based dissolve transition */}\n      {transitionEffect === 'dissolve' && (\n        <canvas\n          ref={canvasRef}\n          style={{\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            width: '100%',\n            height: '100%'\n          }}\n        />\n      )}\n      \n      {/* Content container */}\n      {children && (\n        <div\n          style={{\n            position: 'relative',\n            zIndex: 1,\n            width: '100%',\n            height: '100%'\n          }}\n        >\n          {children}\n        </div>\n      )}\n    </>\n  );\n  \n  // Render with or without container based on createContainer prop\n  return createContainer ? (\n    <div\n      ref={elementRef}\n      className={className}\n      style={mergedContainerStyle}\n    >\n      {backgroundContent}\n    </div>\n  ) : (\n    <div ref={elementRef} className={className} style={{ position: 'relative' }}>\n      {backgroundContent}\n    </div>\n  );\n};\n\nexport default SlidingBackground;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}