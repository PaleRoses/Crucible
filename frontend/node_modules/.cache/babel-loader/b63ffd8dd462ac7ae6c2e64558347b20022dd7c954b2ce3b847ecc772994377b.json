{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/MeteorShower.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\n\n/**\n * MeteorShower Component - Enhanced Version\n * \n * Creates an animated meteor shower effect where meteors arc across the sky\n * with comet-like trails and fade away naturally.\n * Features staggered appearance and configurable journey completion.\n * \n * @param {Object} props - Component props\n * @param {string|number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=5] - Z-index for the container\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.meteorDensity=15] - Number of meteors to maintain on screen\n * @param {number} [props.meteorMinSize=1] - Minimum size of meteors\n * @param {number} [props.meteorMaxSize=3] - Maximum size of meteors\n * @param {number} [props.meteorSpeed=0.08] - Base speed of meteors\n * @param {number} [props.trailLength=180] - Length of meteor trails\n * @param {number} [props.trailSegments=20] - Number of segments in each trail\n * @param {string} [props.coreColor='rgba(255, 255, 255, 1)'] - Core color for meteors\n * @param {string} [props.glowColor='rgba(255, 253, 227, 0.9)'] - Glow color for meteors\n * @param {string} [props.trailColor='rgba(191, 173, 127, 0.8)'] - Trail color for meteors\n * @param {boolean} [props.enableParallax=false] - Enable parallax effect on scroll\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of parallax effect\n * @param {boolean} [props.staggered=true] - Enable staggered meteor appearance\n * @param {number} [props.minStaggerDelay=200] - Minimum delay between meteor spawns (ms)\n * @param {number} [props.maxStaggerDelay=2000] - Maximum delay between meteor spawns (ms)\n * @param {number} [props.journeyCompletion=0.9] - When meteors complete their journey (0-1, where 1 is the container height)\n * @param {string} [props.mode='arc'] - Animation mode: 'arc' (curved paths) or 'linear' (straight angled paths)\n * @param {string} [props.direction='both'] - Direction for linear mode: 'left', 'right', or 'both'\n * @param {number} [props.baseAngle=30] - Base angle for linear meteors (degrees)\n * @param {number} [props.angleVariation=15] - Random variation to apply to the base angle (±degrees)\n * @param {boolean} [props.debug=false] - Enable debug visualization\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MeteorShower = ({\n  height = '100vh',\n  zIndex = 5,\n  active = true,\n  meteorDensity = 15,\n  meteorMinSize = 1,\n  meteorMaxSize = 3,\n  meteorSpeed = 0.08,\n  trailLength = 180,\n  trailSegments = 20,\n  coreColor = 'rgba(255, 255, 255, 1)',\n  glowColor = 'rgba(255, 253, 227, 0.9)',\n  trailColor = 'rgba(191, 173, 127, 0.8)',\n  enableParallax = false,\n  parallaxIntensity = 0.2,\n  staggered = true,\n  minStaggerDelay = 200,\n  maxStaggerDelay = 2000,\n  journeyCompletion = 0.9,\n  // Default: complete at 90% of container height\n  mode = 'arc',\n  // 'arc' or 'linear'\n  direction = 'both',\n  // 'left', 'right', or 'both'\n  baseAngle = 30,\n  // Base angle for linear meteors (degrees)\n  angleVariation = 15,\n  // Variation to apply to the angle (±degrees)\n  debug = false\n}) => {\n  _s();\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const meteorsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n  const nextSpawnTimeRef = useRef(0);\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0\n  });\n  const [isInitialized, setIsInitialized] = useState(false);\n\n  // Calculate path parameters for a meteor based on selected mode\n  const calculateMeteorPath = (width, height) => {\n    if (mode === 'arc') {\n      // Original arc path logic\n      // Start point: somewhere along the top of the canvas with randomization\n      const startX = Math.random() * width * 1.5 - width * 0.25;\n\n      // Control how far meteors can start from outside the visible area\n      const startY = Math.random() * -100 - 50;\n\n      // Randomize arc curvature and direction\n      const curveDirection = Math.random() > 0.5 ? 1 : -1;\n      const curveIntensity = Math.random() * 0.4 + 0.2;\n\n      // Calculate control points for quadratic path\n      // End point: adjusted to complete journey according to journeyCompletion parameter\n      const endX = startX + curveDirection * width * curveIntensity;\n      const endY = height * journeyCompletion;\n\n      // Control point: creates the arc shape\n      const controlX = (startX + endX) / 2 + curveDirection * width * curveIntensity;\n      const controlY = (startY + endY) * 0.5;\n      return {\n        pathType: 'arc',\n        start: {\n          x: startX,\n          y: startY\n        },\n        control: {\n          x: controlX,\n          y: controlY\n        },\n        end: {\n          x: endX,\n          y: endY\n        }\n      };\n    } else if (mode === 'linear') {\n      // New linear path logic for traditional meteor shower\n\n      // Determine direction (from left, right, or random)\n      let meteorDirection = direction;\n      if (direction === 'both') {\n        meteorDirection = Math.random() > 0.5 ? 'left' : 'right';\n      }\n\n      // Calculate angle with variation (convert to radians)\n      const angle = (baseAngle + (Math.random() * 2 - 1) * angleVariation) * Math.PI / 180;\n\n      // Set starting positions based on direction\n      let startX;\n      if (meteorDirection === 'left') {\n        // Start from top-left portion of the screen\n        startX = Math.random() * (width * 0.3) - width * 0.1;\n      } else {\n        // Start from top-right portion of the screen\n        startX = width - Math.random() * (width * 0.3) + width * 0.1;\n      }\n\n      // Start slightly above the screen\n      const startY = Math.random() * -100 - 50;\n\n      // Calculate distance meteor will travel based on angle and screen dimensions\n      const distanceToTravel = height * journeyCompletion / Math.cos(angle);\n\n      // Calculate end position using angle\n      let endX, endY;\n      if (meteorDirection === 'left') {\n        // Meteor moves from left to right\n        endX = startX + distanceToTravel * Math.sin(angle);\n        endY = startY + distanceToTravel * Math.cos(angle);\n      } else {\n        // Meteor moves from right to left\n        endX = startX - distanceToTravel * Math.sin(angle);\n        endY = startY + distanceToTravel * Math.cos(angle);\n      }\n      return {\n        pathType: 'linear',\n        start: {\n          x: startX,\n          y: startY\n        },\n        end: {\n          x: endX,\n          y: endY\n        },\n        direction: meteorDirection\n      };\n    }\n  };\n\n  // Calculate position along a path\n  const getPathPoint = (t, path) => {\n    if (path.pathType === 'arc') {\n      // Quadratic bezier curve for arc mode\n      return getQuadraticBezierPoint(t, path.start, path.control, path.end);\n    } else {\n      // Linear interpolation for linear mode\n      return {\n        x: path.start.x + (path.end.x - path.start.x) * t,\n        y: path.start.y + (path.end.y - path.start.y) * t\n      };\n    }\n  };\n\n  // Calculate position along a quadratic bezier curve\n  const getQuadraticBezierPoint = (t, p0, p1, p2) => {\n    const x = Math.pow(1 - t, 2) * p0.x + 2 * (1 - t) * t * p1.x + Math.pow(t, 2) * p2.x;\n    const y = Math.pow(1 - t, 2) * p0.y + 2 * (1 - t) * t * p1.y + Math.pow(t, 2) * p2.y;\n    return {\n      x,\n      y\n    };\n  };\n\n  // Update canvas dimensions on resize\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (canvasRef.current && containerRef.current) {\n        const container = containerRef.current;\n        const rect = container.getBoundingClientRect();\n        const width = rect.width;\n        const containerHeight = typeof height === 'string' && height.endsWith('vh') ? parseInt(height, 10) / 100 * window.innerHeight : parseInt(height, 10) || window.innerHeight;\n        if (debug) {\n          console.log('Setting canvas dimensions:', width, containerHeight);\n        }\n        setDimensions({\n          width,\n          height: containerHeight\n        });\n        canvasRef.current.width = width;\n        canvasRef.current.height = containerHeight;\n        setIsInitialized(true);\n      }\n    };\n    setTimeout(updateDimensions, 100);\n    window.addEventListener('resize', updateDimensions);\n    return () => {\n      window.removeEventListener('resize', updateDimensions);\n    };\n  }, [height, debug]);\n\n  // Handle parallax effect on scroll if enabled\n  useEffect(() => {\n    if (!enableParallax) return;\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    window.addEventListener('scroll', handleScroll);\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [enableParallax]);\n\n  // Memoize the path calculation and position functions to avoid dependency issues\n  const calculateMeteorPathMemoized = useCallback(calculateMeteorPath, [mode, direction, baseAngle, angleVariation, journeyCompletion]);\n  const getPathPointMemoized = useCallback(getPathPoint, []);\n\n  // Memoize the meteor initialization function\n  const initializeMeteorMemoized = useCallback(() => {\n    const width = dimensions.width;\n    const height = dimensions.height;\n    if (!width || !height) return null;\n\n    // Calculate path based on mode\n    const path = calculateMeteorPathMemoized(width, height);\n\n    // Randomize meteor properties\n    const baseSpeed = meteorSpeed * (Math.random() * 0.5 + 0.75);\n    return {\n      path,\n      progress: 0,\n      size: Math.random() * (meteorMaxSize - meteorMinSize) + meteorMinSize,\n      speed: baseSpeed,\n      active: true,\n      positions: new Array(trailSegments).fill({\n        x: path.start.x,\n        y: path.start.y\n      }),\n      opacity: Math.random() * 0.3 + 0.7,\n      fadeThreshold: 0.7 + Math.random() * 0.2,\n      // When to start fading (70-90% of journey)\n      pulsePhase: Math.random() * Math.PI * 2,\n      pulseSpeed: Math.random() * 0.01 + 0.005\n    };\n  }, [dimensions, meteorSpeed, meteorMinSize, meteorMaxSize, trailSegments, calculateMeteorPathMemoized]);\n\n  // Main animation loop\n  useEffect(() => {\n    if (!active || !dimensions.width || !dimensions.height || !isInitialized) {\n      if (debug) {\n        console.log('Animation not starting. Active:', active, 'Dimensions:', dimensions, 'Initialized:', isInitialized);\n      }\n      return;\n    }\n    if (debug) {\n      console.log('Starting animation with dimensions:', dimensions);\n    }\n\n    // Animation function\n    const animate = timestamp => {\n      if (!canvasRef.current) return;\n      const ctx = canvasRef.current.getContext('2d');\n      const width = dimensions.width;\n      const height = dimensions.height;\n\n      // Initialize lastTimestamp on first run\n      if (lastTimestampRef.current === 0) {\n        lastTimestampRef.current = timestamp;\n        nextSpawnTimeRef.current = timestamp;\n      }\n\n      // Calculate delta time (capped to prevent jumps after tab switching)\n      const deltaTime = Math.min(timestamp - lastTimestampRef.current, 50);\n      lastTimestampRef.current = timestamp;\n\n      // Clear canvas\n      ctx.clearRect(0, 0, width, height);\n\n      // Debug mode - draw canvas bounds\n      if (debug) {\n        ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n        ctx.lineWidth = 2;\n        ctx.strokeRect(0, 0, width, height);\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n        ctx.font = '12px monospace';\n        ctx.fillText(`Canvas: ${width}×${height}`, 10, 20);\n        ctx.fillText(`Meteors: ${meteorsRef.current.length}/${meteorDensity}`, 10, 40);\n        ctx.fillText(`Mode: ${mode}`, 10, 60);\n        ctx.fillText(`Direction: ${direction}`, 10, 80);\n        if (staggered) {\n          ctx.fillText(`Next Spawn: ${Math.max(0, (nextSpawnTimeRef.current - timestamp) / 1000).toFixed(2)}s`, 10, 100);\n        }\n      }\n\n      // Apply parallax offset\n      let parallaxOffset = 0;\n      if (enableParallax) {\n        parallaxOffset = scrollPositionRef.current * parallaxIntensity;\n      }\n\n      // Spawn new meteors if needed, with staggering if enabled\n      if (meteorsRef.current.length < meteorDensity) {\n        const canSpawnNow = !staggered || timestamp >= nextSpawnTimeRef.current;\n        if (canSpawnNow) {\n          const newMeteor = initializeMeteorMemoized();\n          if (newMeteor) {\n            meteorsRef.current.push(newMeteor);\n\n            // If staggering is enabled, set the next spawn time\n            if (staggered) {\n              const delay = Math.random() * (maxStaggerDelay - minStaggerDelay) + minStaggerDelay;\n              nextSpawnTimeRef.current = timestamp + delay;\n            }\n          }\n        }\n      }\n\n      // Update and draw meteors\n      meteorsRef.current = meteorsRef.current.filter(meteor => {\n        // Skip if not active\n        if (!meteor.active) return false;\n\n        // Update progress based on speed and delta time\n        meteor.progress += meteor.speed * (deltaTime / 1000);\n\n        // Calculate current position along the path\n        const currentPos = getPathPointMemoized(Math.min(1, meteor.progress), meteor.path);\n\n        // Update position history (for trail)\n        meteor.positions.unshift({\n          x: currentPos.x,\n          y: currentPos.y\n        });\n        meteor.positions = meteor.positions.slice(0, trailSegments);\n\n        // Check if meteor has completed its path\n        if (meteor.progress >= 1) {\n          return false;\n        }\n\n        // Calculate opacity based on progress\n        // Start fading out after reaching the fadeThreshold\n        let currentOpacity = meteor.opacity;\n        if (meteor.progress > meteor.fadeThreshold) {\n          // Map progress from fadeThreshold-1.0 to 1.0-0.0 for opacity\n          const fadeProgress = (meteor.progress - meteor.fadeThreshold) / (1 - meteor.fadeThreshold);\n          currentOpacity = meteor.opacity * (1 - fadeProgress);\n        }\n\n        // Apply pulse/flicker effect\n        const timeFactor = timestamp * 0.001;\n        const pulseEffect = Math.sin(timeFactor * meteor.pulseSpeed + meteor.pulsePhase) * 0.2 + 0.8;\n\n        // Adjust for parallax if enabled\n        const adjustY = enableParallax ? parallaxOffset * (meteor.size / meteorMaxSize) : 0;\n\n        // Draw trail segments\n        for (let i = 0; i < meteor.positions.length - 1; i++) {\n          if (!meteor.positions[i] || !meteor.positions[i + 1]) continue;\n\n          // Calculate segment opacity (decreases along the trail)\n          const segmentOpacity = currentOpacity * (1 - i / meteor.positions.length) * pulseEffect;\n\n          // Skip if nearly invisible\n          if (segmentOpacity < 0.02) continue;\n\n          // Calculate segment width (decreases along the trail)\n          const segmentWidth = meteor.size * (1 - i / meteor.positions.length * 0.7);\n\n          // Set shadow/glow effect\n          ctx.shadowColor = glowColor;\n          ctx.shadowBlur = meteor.size * 3 * pulseEffect;\n\n          // Draw line segment\n          ctx.beginPath();\n          ctx.moveTo(meteor.positions[i].x, meteor.positions[i].y + adjustY);\n          ctx.lineTo(meteor.positions[i + 1].x, meteor.positions[i + 1].y + adjustY);\n\n          // Set line style\n          ctx.lineCap = 'round';\n          ctx.lineWidth = segmentWidth;\n          ctx.strokeStyle = trailColor.replace(/[\\d.]+\\)$/, segmentOpacity + ')');\n          ctx.stroke();\n        }\n\n        // Draw meteor head (brightest part)\n        if (meteor.positions[0]) {\n          // Set shadow/glow for head\n          ctx.shadowColor = glowColor;\n          ctx.shadowBlur = meteor.size * 5 * pulseEffect;\n\n          // Draw outer glow\n          ctx.beginPath();\n          ctx.arc(meteor.positions[0].x, meteor.positions[0].y + adjustY, meteor.size * 1.5, 0, Math.PI * 2);\n          ctx.fillStyle = glowColor.replace(/[\\d.]+\\)$/, currentOpacity * 0.7 * pulseEffect + ')');\n          ctx.fill();\n\n          // Draw inner core\n          ctx.beginPath();\n          ctx.arc(meteor.positions[0].x, meteor.positions[0].y + adjustY, meteor.size * 0.7, 0, Math.PI * 2);\n          ctx.fillStyle = coreColor.replace(/[\\d.]+\\)$/, currentOpacity * pulseEffect + ')');\n          ctx.fill();\n        }\n        return true;\n      });\n\n      // Continue animation\n      animationFrameRef.current = requestAnimationFrame(animate);\n    };\n\n    // Start animation\n    animationFrameRef.current = requestAnimationFrame(animate);\n\n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [active, isInitialized, dimensions, meteorDensity, meteorMinSize, meteorMaxSize, meteorSpeed, trailLength, trailSegments, coreColor, glowColor, trailColor, enableParallax, parallaxIntensity, staggered, minStaggerDelay, maxStaggerDelay, journeyCompletion, mode, direction, baseAngle, angleVariation, debug, getPathPointMemoized, initializeMeteorMemoized]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: height,\n      overflow: 'hidden',\n      pointerEvents: 'none',\n      zIndex: zIndex\n    },\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 472,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 459,\n    columnNumber: 5\n  }, this);\n};\n\n/**\n * GoldenMeteorShower Component\n * \n * A preset version of the MeteorShower with a golden/amber color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_s(MeteorShower, \"ttGYYXlpTjPUWQkeTgd49tAICL8=\");\n_c = MeteorShower;\nexport const GoldenMeteorShower = props => {\n  const goldenPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 253, 227, 0.9)',\n    trailColor: 'rgba(191, 173, 127, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 200,\n    maxStaggerDelay: 2000\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...goldenPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 509,\n    columnNumber: 10\n  }, this);\n};\n\n/**\n * CelestialMeteorShower Component\n * \n * A preset version of the MeteorShower with a bluish-purple color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c2 = GoldenMeteorShower;\nexport const CelestialMeteorShower = props => {\n  const celestialPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(220, 225, 255, 0.9)',\n    trailColor: 'rgba(150, 160, 255, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 300,\n    maxStaggerDelay: 1800\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...celestialPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 535,\n    columnNumber: 10\n  }, this);\n};\n\n/**\n * EmeraldMeteorShower Component\n * \n * A preset version of the MeteorShower with a green color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c3 = CelestialMeteorShower;\nexport const EmeraldMeteorShower = props => {\n  const emeraldPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(215, 255, 230, 0.9)',\n    trailColor: 'rgba(100, 220, 150, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 250,\n    maxStaggerDelay: 1500\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...emeraldPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 561,\n    columnNumber: 10\n  }, this);\n};\n\n/**\n * RubyMeteorShower Component\n * \n * A preset version of the MeteorShower with a red color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c4 = EmeraldMeteorShower;\nexport const RubyMeteorShower = props => {\n  const rubyPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 200, 200, 0.9)',\n    trailColor: 'rgba(220, 100, 100, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 350,\n    maxStaggerDelay: 2200\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...rubyPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 587,\n    columnNumber: 10\n  }, this);\n};\n\n/**\n * ClassicMeteorShower Component\n * \n * A preset version of the MeteorShower with linear paths for a more traditional meteor shower effect.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c5 = RubyMeteorShower;\nexport const ClassicMeteorShower = props => {\n  const classicPreset = {\n    mode: 'linear',\n    direction: 'both',\n    baseAngle: 30,\n    angleVariation: 15,\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.12,\n    trailLength: 200,\n    trailSegments: 25,\n    journeyCompletion: 0.95,\n    staggered: true,\n    minStaggerDelay: 100,\n    maxStaggerDelay: 1000\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...classicPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 614,\n    columnNumber: 10\n  }, this);\n};\n_c6 = ClassicMeteorShower;\nexport default MeteorShower;\nvar _c, _c2, _c3, _c4, _c5, _c6;\n$RefreshReg$(_c, \"MeteorShower\");\n$RefreshReg$(_c2, \"GoldenMeteorShower\");\n$RefreshReg$(_c3, \"CelestialMeteorShower\");\n$RefreshReg$(_c4, \"EmeraldMeteorShower\");\n$RefreshReg$(_c5, \"RubyMeteorShower\");\n$RefreshReg$(_c6, \"ClassicMeteorShower\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useCallback","jsxDEV","_jsxDEV","MeteorShower","height","zIndex","active","meteorDensity","meteorMinSize","meteorMaxSize","meteorSpeed","trailLength","trailSegments","coreColor","glowColor","trailColor","enableParallax","parallaxIntensity","staggered","minStaggerDelay","maxStaggerDelay","journeyCompletion","mode","direction","baseAngle","angleVariation","debug","_s","containerRef","canvasRef","meteorsRef","animationFrameRef","lastTimestampRef","scrollPositionRef","nextSpawnTimeRef","dimensions","setDimensions","width","isInitialized","setIsInitialized","calculateMeteorPath","startX","Math","random","startY","curveDirection","curveIntensity","endX","endY","controlX","controlY","pathType","start","x","y","control","end","meteorDirection","angle","PI","distanceToTravel","cos","sin","getPathPoint","t","path","getQuadraticBezierPoint","p0","p1","p2","pow","updateDimensions","current","container","rect","getBoundingClientRect","containerHeight","endsWith","parseInt","window","innerHeight","console","log","setTimeout","addEventListener","removeEventListener","handleScroll","scrollY","calculateMeteorPathMemoized","getPathPointMemoized","initializeMeteorMemoized","baseSpeed","progress","size","speed","positions","Array","fill","opacity","fadeThreshold","pulsePhase","pulseSpeed","animate","timestamp","ctx","getContext","deltaTime","min","clearRect","strokeStyle","lineWidth","strokeRect","fillStyle","font","fillText","length","max","toFixed","parallaxOffset","canSpawnNow","newMeteor","push","delay","filter","meteor","currentPos","unshift","slice","currentOpacity","fadeProgress","timeFactor","pulseEffect","adjustY","i","segmentOpacity","segmentWidth","shadowColor","shadowBlur","beginPath","moveTo","lineTo","lineCap","replace","stroke","arc","requestAnimationFrame","cancelAnimationFrame","ref","style","position","top","left","overflow","pointerEvents","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","GoldenMeteorShower","props","goldenPreset","_c2","CelestialMeteorShower","celestialPreset","_c3","EmeraldMeteorShower","emeraldPreset","_c4","RubyMeteorShower","rubyPreset","_c5","ClassicMeteorShower","classicPreset","_c6","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/MeteorShower.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef, useCallback } from 'react';\n\n/**\n * MeteorShower Component - Enhanced Version\n * \n * Creates an animated meteor shower effect where meteors arc across the sky\n * with comet-like trails and fade away naturally.\n * Features staggered appearance and configurable journey completion.\n * \n * @param {Object} props - Component props\n * @param {string|number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=5] - Z-index for the container\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.meteorDensity=15] - Number of meteors to maintain on screen\n * @param {number} [props.meteorMinSize=1] - Minimum size of meteors\n * @param {number} [props.meteorMaxSize=3] - Maximum size of meteors\n * @param {number} [props.meteorSpeed=0.08] - Base speed of meteors\n * @param {number} [props.trailLength=180] - Length of meteor trails\n * @param {number} [props.trailSegments=20] - Number of segments in each trail\n * @param {string} [props.coreColor='rgba(255, 255, 255, 1)'] - Core color for meteors\n * @param {string} [props.glowColor='rgba(255, 253, 227, 0.9)'] - Glow color for meteors\n * @param {string} [props.trailColor='rgba(191, 173, 127, 0.8)'] - Trail color for meteors\n * @param {boolean} [props.enableParallax=false] - Enable parallax effect on scroll\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of parallax effect\n * @param {boolean} [props.staggered=true] - Enable staggered meteor appearance\n * @param {number} [props.minStaggerDelay=200] - Minimum delay between meteor spawns (ms)\n * @param {number} [props.maxStaggerDelay=2000] - Maximum delay between meteor spawns (ms)\n * @param {number} [props.journeyCompletion=0.9] - When meteors complete their journey (0-1, where 1 is the container height)\n * @param {string} [props.mode='arc'] - Animation mode: 'arc' (curved paths) or 'linear' (straight angled paths)\n * @param {string} [props.direction='both'] - Direction for linear mode: 'left', 'right', or 'both'\n * @param {number} [props.baseAngle=30] - Base angle for linear meteors (degrees)\n * @param {number} [props.angleVariation=15] - Random variation to apply to the base angle (±degrees)\n * @param {boolean} [props.debug=false] - Enable debug visualization\n */\nconst MeteorShower = ({\n  height = '100vh',\n  zIndex = 5,\n  active = true,\n  meteorDensity = 15,\n  meteorMinSize = 1,\n  meteorMaxSize = 3,\n  meteorSpeed = 0.08,\n  trailLength = 180,\n  trailSegments = 20,\n  coreColor = 'rgba(255, 255, 255, 1)',\n  glowColor = 'rgba(255, 253, 227, 0.9)',\n  trailColor = 'rgba(191, 173, 127, 0.8)',\n  enableParallax = false,\n  parallaxIntensity = 0.2,\n  staggered = true,\n  minStaggerDelay = 200,\n  maxStaggerDelay = 2000,\n  journeyCompletion = 0.9, // Default: complete at 90% of container height\n  mode = 'arc', // 'arc' or 'linear'\n  direction = 'both', // 'left', 'right', or 'both'\n  baseAngle = 30, // Base angle for linear meteors (degrees)\n  angleVariation = 15, // Variation to apply to the angle (±degrees)\n  debug = false\n}) => {\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const meteorsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n  const nextSpawnTimeRef = useRef(0);\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n  const [isInitialized, setIsInitialized] = useState(false);\n  \n  // Calculate path parameters for a meteor based on selected mode\n  const calculateMeteorPath = (width, height) => {\n    if (mode === 'arc') {\n      // Original arc path logic\n      // Start point: somewhere along the top of the canvas with randomization\n      const startX = Math.random() * width * 1.5 - width * 0.25;\n      \n      // Control how far meteors can start from outside the visible area\n      const startY = Math.random() * -100 - 50;\n      \n      // Randomize arc curvature and direction\n      const curveDirection = Math.random() > 0.5 ? 1 : -1;\n      const curveIntensity = Math.random() * 0.4 + 0.2;\n      \n      // Calculate control points for quadratic path\n      // End point: adjusted to complete journey according to journeyCompletion parameter\n      const endX = startX + (curveDirection * width * curveIntensity);\n      const endY = height * journeyCompletion;\n      \n      // Control point: creates the arc shape\n      const controlX = (startX + endX) / 2 + (curveDirection * width * curveIntensity);\n      const controlY = (startY + endY) * 0.5;\n      \n      return {\n        pathType: 'arc',\n        start: { x: startX, y: startY },\n        control: { x: controlX, y: controlY },\n        end: { x: endX, y: endY }\n      };\n    } else if (mode === 'linear') {\n      // New linear path logic for traditional meteor shower\n      \n      // Determine direction (from left, right, or random)\n      let meteorDirection = direction;\n      if (direction === 'both') {\n        meteorDirection = Math.random() > 0.5 ? 'left' : 'right';\n      }\n      \n      // Calculate angle with variation (convert to radians)\n      const angle = ((baseAngle + (Math.random() * 2 - 1) * angleVariation) * Math.PI) / 180;\n      \n      // Set starting positions based on direction\n      let startX;\n      if (meteorDirection === 'left') {\n        // Start from top-left portion of the screen\n        startX = Math.random() * (width * 0.3) - (width * 0.1);\n      } else {\n        // Start from top-right portion of the screen\n        startX = width - Math.random() * (width * 0.3) + (width * 0.1);\n      }\n      \n      // Start slightly above the screen\n      const startY = Math.random() * -100 - 50;\n      \n      // Calculate distance meteor will travel based on angle and screen dimensions\n      const distanceToTravel = (height * journeyCompletion) / Math.cos(angle);\n      \n      // Calculate end position using angle\n      let endX, endY;\n      if (meteorDirection === 'left') {\n        // Meteor moves from left to right\n        endX = startX + distanceToTravel * Math.sin(angle);\n        endY = startY + distanceToTravel * Math.cos(angle);\n      } else {\n        // Meteor moves from right to left\n        endX = startX - distanceToTravel * Math.sin(angle);\n        endY = startY + distanceToTravel * Math.cos(angle);\n      }\n      \n      return {\n        pathType: 'linear',\n        start: { x: startX, y: startY },\n        end: { x: endX, y: endY },\n        direction: meteorDirection\n      };\n    }\n  };\n  \n  // Calculate position along a path\n  const getPathPoint = (t, path) => {\n    if (path.pathType === 'arc') {\n      // Quadratic bezier curve for arc mode\n      return getQuadraticBezierPoint(t, path.start, path.control, path.end);\n    } else {\n      // Linear interpolation for linear mode\n      return {\n        x: path.start.x + (path.end.x - path.start.x) * t,\n        y: path.start.y + (path.end.y - path.start.y) * t\n      };\n    }\n  };\n  \n  // Calculate position along a quadratic bezier curve\n  const getQuadraticBezierPoint = (t, p0, p1, p2) => {\n    const x = Math.pow(1 - t, 2) * p0.x + 2 * (1 - t) * t * p1.x + Math.pow(t, 2) * p2.x;\n    const y = Math.pow(1 - t, 2) * p0.y + 2 * (1 - t) * t * p1.y + Math.pow(t, 2) * p2.y;\n    return { x, y };\n  };\n  \n  // Update canvas dimensions on resize\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (canvasRef.current && containerRef.current) {\n        const container = containerRef.current;\n        const rect = container.getBoundingClientRect();\n        const width = rect.width;\n        const containerHeight = typeof height === 'string' && height.endsWith('vh') \n          ? (parseInt(height, 10) / 100) * window.innerHeight\n          : parseInt(height, 10) || window.innerHeight;\n          \n        if (debug) {\n          console.log('Setting canvas dimensions:', width, containerHeight);\n        }\n        \n        setDimensions({ width, height: containerHeight });\n        canvasRef.current.width = width;\n        canvasRef.current.height = containerHeight;\n        setIsInitialized(true);\n      }\n    };\n    \n    setTimeout(updateDimensions, 100);\n    window.addEventListener('resize', updateDimensions);\n    \n    return () => {\n      window.removeEventListener('resize', updateDimensions);\n    };\n  }, [height, debug]);\n  \n  // Handle parallax effect on scroll if enabled\n  useEffect(() => {\n    if (!enableParallax) return;\n    \n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    \n    window.addEventListener('scroll', handleScroll);\n    \n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [enableParallax]);\n  \n  // Memoize the path calculation and position functions to avoid dependency issues\n  const calculateMeteorPathMemoized = useCallback(calculateMeteorPath, [\n    mode, direction, baseAngle, angleVariation, journeyCompletion\n  ]);\n  \n  const getPathPointMemoized = useCallback(getPathPoint, []);\n  \n  // Memoize the meteor initialization function\n  const initializeMeteorMemoized = useCallback(() => {\n    const width = dimensions.width;\n    const height = dimensions.height;\n    \n    if (!width || !height) return null;\n    \n    // Calculate path based on mode\n    const path = calculateMeteorPathMemoized(width, height);\n    \n    // Randomize meteor properties\n    const baseSpeed = meteorSpeed * (Math.random() * 0.5 + 0.75);\n    \n    return {\n      path,\n      progress: 0,\n      size: Math.random() * (meteorMaxSize - meteorMinSize) + meteorMinSize,\n      speed: baseSpeed,\n      active: true,\n      positions: new Array(trailSegments).fill({ x: path.start.x, y: path.start.y }),\n      opacity: Math.random() * 0.3 + 0.7,\n      fadeThreshold: 0.7 + Math.random() * 0.2, // When to start fading (70-90% of journey)\n      pulsePhase: Math.random() * Math.PI * 2,\n      pulseSpeed: Math.random() * 0.01 + 0.005\n    };\n  }, [\n    dimensions, \n    meteorSpeed, \n    meteorMinSize, \n    meteorMaxSize, \n    trailSegments,\n    calculateMeteorPathMemoized\n  ]);\n  \n  // Main animation loop\n  useEffect(() => {\n    if (!active || !dimensions.width || !dimensions.height || !isInitialized) {\n      if (debug) {\n        console.log('Animation not starting. Active:', active, 'Dimensions:', dimensions, 'Initialized:', isInitialized);\n      }\n      return;\n    }\n    \n    if (debug) {\n      console.log('Starting animation with dimensions:', dimensions);\n    }\n    \n    // Animation function\n    const animate = (timestamp) => {\n      if (!canvasRef.current) return;\n      \n      const ctx = canvasRef.current.getContext('2d');\n      const width = dimensions.width;\n      const height = dimensions.height;\n      \n      // Initialize lastTimestamp on first run\n      if (lastTimestampRef.current === 0) {\n        lastTimestampRef.current = timestamp;\n        nextSpawnTimeRef.current = timestamp;\n      }\n      \n      // Calculate delta time (capped to prevent jumps after tab switching)\n      const deltaTime = Math.min(timestamp - lastTimestampRef.current, 50);\n      lastTimestampRef.current = timestamp;\n      \n      // Clear canvas\n      ctx.clearRect(0, 0, width, height);\n      \n      // Debug mode - draw canvas bounds\n      if (debug) {\n        ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n        ctx.lineWidth = 2;\n        ctx.strokeRect(0, 0, width, height);\n        \n        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n        ctx.font = '12px monospace';\n        ctx.fillText(`Canvas: ${width}×${height}`, 10, 20);\n        ctx.fillText(`Meteors: ${meteorsRef.current.length}/${meteorDensity}`, 10, 40);\n        ctx.fillText(`Mode: ${mode}`, 10, 60);\n        ctx.fillText(`Direction: ${direction}`, 10, 80);\n        if (staggered) {\n          ctx.fillText(`Next Spawn: ${Math.max(0, (nextSpawnTimeRef.current - timestamp) / 1000).toFixed(2)}s`, 10, 100);\n        }\n      }\n      \n      // Apply parallax offset\n      let parallaxOffset = 0;\n      if (enableParallax) {\n        parallaxOffset = scrollPositionRef.current * parallaxIntensity;\n      }\n      \n      // Spawn new meteors if needed, with staggering if enabled\n      if (meteorsRef.current.length < meteorDensity) {\n        const canSpawnNow = !staggered || timestamp >= nextSpawnTimeRef.current;\n        \n        if (canSpawnNow) {\n          const newMeteor = initializeMeteorMemoized();\n          if (newMeteor) {\n            meteorsRef.current.push(newMeteor);\n            \n            // If staggering is enabled, set the next spawn time\n            if (staggered) {\n              const delay = Math.random() * (maxStaggerDelay - minStaggerDelay) + minStaggerDelay;\n              nextSpawnTimeRef.current = timestamp + delay;\n            }\n          }\n        }\n      }\n      \n      // Update and draw meteors\n      meteorsRef.current = meteorsRef.current.filter(meteor => {\n        // Skip if not active\n        if (!meteor.active) return false;\n        \n        // Update progress based on speed and delta time\n        meteor.progress += meteor.speed * (deltaTime / 1000);\n        \n        // Calculate current position along the path\n        const currentPos = getPathPointMemoized(Math.min(1, meteor.progress), meteor.path);\n        \n        // Update position history (for trail)\n        meteor.positions.unshift({ x: currentPos.x, y: currentPos.y });\n        meteor.positions = meteor.positions.slice(0, trailSegments);\n        \n        // Check if meteor has completed its path\n        if (meteor.progress >= 1) {\n          return false;\n        }\n        \n        // Calculate opacity based on progress\n        // Start fading out after reaching the fadeThreshold\n        let currentOpacity = meteor.opacity;\n        if (meteor.progress > meteor.fadeThreshold) {\n          // Map progress from fadeThreshold-1.0 to 1.0-0.0 for opacity\n          const fadeProgress = (meteor.progress - meteor.fadeThreshold) / (1 - meteor.fadeThreshold);\n          currentOpacity = meteor.opacity * (1 - fadeProgress);\n        }\n        \n        // Apply pulse/flicker effect\n        const timeFactor = timestamp * 0.001;\n        const pulseEffect = Math.sin(timeFactor * meteor.pulseSpeed + meteor.pulsePhase) * 0.2 + 0.8;\n        \n        // Adjust for parallax if enabled\n        const adjustY = enableParallax ? parallaxOffset * (meteor.size / meteorMaxSize) : 0;\n        \n        // Draw trail segments\n        for (let i = 0; i < meteor.positions.length - 1; i++) {\n          if (!meteor.positions[i] || !meteor.positions[i+1]) continue;\n          \n          // Calculate segment opacity (decreases along the trail)\n          const segmentOpacity = currentOpacity * (1 - i / meteor.positions.length) * pulseEffect;\n          \n          // Skip if nearly invisible\n          if (segmentOpacity < 0.02) continue;\n          \n          // Calculate segment width (decreases along the trail)\n          const segmentWidth = meteor.size * (1 - i / meteor.positions.length * 0.7);\n          \n          // Set shadow/glow effect\n          ctx.shadowColor = glowColor;\n          ctx.shadowBlur = meteor.size * 3 * pulseEffect;\n          \n          // Draw line segment\n          ctx.beginPath();\n          ctx.moveTo(meteor.positions[i].x, meteor.positions[i].y + adjustY);\n          ctx.lineTo(meteor.positions[i+1].x, meteor.positions[i+1].y + adjustY);\n          \n          // Set line style\n          ctx.lineCap = 'round';\n          ctx.lineWidth = segmentWidth;\n          ctx.strokeStyle = trailColor.replace(/[\\d.]+\\)$/, segmentOpacity + ')');\n          ctx.stroke();\n        }\n        \n        // Draw meteor head (brightest part)\n        if (meteor.positions[0]) {\n          // Set shadow/glow for head\n          ctx.shadowColor = glowColor;\n          ctx.shadowBlur = meteor.size * 5 * pulseEffect;\n          \n          // Draw outer glow\n          ctx.beginPath();\n          ctx.arc(meteor.positions[0].x, meteor.positions[0].y + adjustY, meteor.size * 1.5, 0, Math.PI * 2);\n          ctx.fillStyle = glowColor.replace(/[\\d.]+\\)$/, currentOpacity * 0.7 * pulseEffect + ')');\n          ctx.fill();\n          \n          // Draw inner core\n          ctx.beginPath();\n          ctx.arc(meteor.positions[0].x, meteor.positions[0].y + adjustY, meteor.size * 0.7, 0, Math.PI * 2);\n          ctx.fillStyle = coreColor.replace(/[\\d.]+\\)$/, currentOpacity * pulseEffect + ')');\n          ctx.fill();\n        }\n        \n        return true;\n      });\n      \n      // Continue animation\n      animationFrameRef.current = requestAnimationFrame(animate);\n    };\n    \n    // Start animation\n    animationFrameRef.current = requestAnimationFrame(animate);\n    \n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [\n    active,\n    isInitialized,\n    dimensions,\n    meteorDensity,\n    meteorMinSize,\n    meteorMaxSize,\n    meteorSpeed,\n    trailLength,\n    trailSegments,\n    coreColor,\n    glowColor,\n    trailColor,\n    enableParallax,\n    parallaxIntensity,\n    staggered,\n    minStaggerDelay,\n    maxStaggerDelay,\n    journeyCompletion,\n    mode,\n    direction,\n    baseAngle,\n    angleVariation,\n    debug,\n    getPathPointMemoized,\n    initializeMeteorMemoized\n  ]);\n  \n  return (\n    <div \n      ref={containerRef}\n      style={{ \n        position: 'absolute',\n        top: 0, \n        left: 0, \n        width: '100%', \n        height: height,\n        overflow: 'hidden', \n        pointerEvents: 'none', \n        zIndex: zIndex\n      }}\n    >\n      <canvas \n        ref={canvasRef} \n        style={{ \n          position: 'absolute', \n          top: 0, \n          left: 0, \n          width: '100%', \n          height: '100%'\n        }} \n      />\n    </div>\n  );\n};\n\n/**\n * GoldenMeteorShower Component\n * \n * A preset version of the MeteorShower with a golden/amber color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const GoldenMeteorShower = (props) => {\n  const goldenPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 253, 227, 0.9)',\n    trailColor: 'rgba(191, 173, 127, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 200,\n    maxStaggerDelay: 2000,\n  };\n  \n  return <MeteorShower {...goldenPreset} {...props} />;\n};\n\n/**\n * CelestialMeteorShower Component\n * \n * A preset version of the MeteorShower with a bluish-purple color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const CelestialMeteorShower = (props) => {\n  const celestialPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(220, 225, 255, 0.9)',\n    trailColor: 'rgba(150, 160, 255, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 300,\n    maxStaggerDelay: 1800,\n  };\n  \n  return <MeteorShower {...celestialPreset} {...props} />;\n};\n\n/**\n * EmeraldMeteorShower Component\n * \n * A preset version of the MeteorShower with a green color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const EmeraldMeteorShower = (props) => {\n  const emeraldPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(215, 255, 230, 0.9)',\n    trailColor: 'rgba(100, 220, 150, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 250,\n    maxStaggerDelay: 1500,\n  };\n  \n  return <MeteorShower {...emeraldPreset} {...props} />;\n};\n\n/**\n * RubyMeteorShower Component\n * \n * A preset version of the MeteorShower with a red color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const RubyMeteorShower = (props) => {\n  const rubyPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 200, 200, 0.9)',\n    trailColor: 'rgba(220, 100, 100, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 350,\n    maxStaggerDelay: 2200,\n  };\n  \n  return <MeteorShower {...rubyPreset} {...props} />;\n};\n\n/**\n * ClassicMeteorShower Component\n * \n * A preset version of the MeteorShower with linear paths for a more traditional meteor shower effect.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const ClassicMeteorShower = (props) => {\n  const classicPreset = {\n    mode: 'linear',\n    direction: 'both',\n    baseAngle: 30,\n    angleVariation: 15,\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.12,\n    trailLength: 200,\n    trailSegments: 25,\n    journeyCompletion: 0.95,\n    staggered: true,\n    minStaggerDelay: 100,\n    maxStaggerDelay: 1000,\n  };\n  \n  return <MeteorShower {...classicPreset} {...props} />;\n};\n\nexport default MeteorShower;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}