{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/Background.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef, useEffect, useCallback, useMemo } from 'react';\n\n/**\n * Background Component - Enterprise Performance Optimized Version\n * \n * Creates a highly performant animated background with stars, constellations,\n * and subtle vertex effects that gives the impression of flowing through space.\n * \n * Features:\n * - Advanced performance optimizations with adaptive rendering\n * - Smooth, fluid animations with zero jitter\n * - Memory and battery-efficient rendering pipeline\n * - Accessibility compliance with reduced motion support\n * - Supports hardware acceleration and high-DPI displays\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Background = ({\n  // For backward compatibility - cursor position props (not used in new animation)\n  cursorPosition,\n  setCursorPosition,\n  // Configuration options\n  zIndex = -1,\n  active = true,\n  starCount = 150,\n  starMinSize = 0.5,\n  starMaxSize = 2.5,\n  starMinOpacity = 0.2,\n  starMaxOpacity = 0.8,\n  constellationCount = 8,\n  constellationDensity = 0.3,\n  constellationLineOpacity = 0.15,\n  constellationLineColor = 'rgba(160, 142, 97, 0.4)',\n  coreStarColor = 'rgba(255, 253, 227, 1)',\n  glowStarColor = 'rgba(191, 173, 127, 0.6)',\n  vertexEffectIntensity = 0.5,\n  backgroundMotionSpeed = 0.0005,\n  starPulseDuration = 3000,\n  stellarDriftSpeed = 0.02,\n  adaptiveQuality = true,\n  respectReducedMotion = true,\n  debugMode = false\n}) => {\n  _s();\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const ctxRef = useRef(null);\n  const starsRef = useRef([]);\n  const constellationsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastFrameTimeRef = useRef(0);\n  const frameRateRef = useRef(60);\n  const timeScaleRef = useRef(1);\n  const resizeObserverRef = useRef(null);\n  const isVisibleRef = useRef(true);\n  const deviceCapabilitiesRef = useRef({\n    isHighPerformance: true,\n    isMobile: false,\n    pixelRatio: 1\n  });\n\n  // Component state\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0\n  });\n  const [initialized, setInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [qualityFactor, setQualityFactor] = useState(1);\n\n  // Pre-calculate color variants to avoid string operations during animation\n  const colorCacheRef = useRef(new Map());\n\n  // Adaptive settings based on quality factor and device capabilities\n  const adaptedSettings = useMemo(() => {\n    if (!adaptiveQuality || qualityFactor === 1) {\n      return {\n        starCount,\n        starMinSize,\n        starMaxSize,\n        constellationCount,\n        useGlow: true,\n        useHighQualityRendering: true\n      };\n    }\n\n    // Adjust quality-dependent parameters\n    return {\n      starCount: Math.max(50, Math.floor(starCount * qualityFactor)),\n      starMinSize: Math.max(0.3, starMinSize * qualityFactor),\n      starMaxSize: Math.max(1, starMaxSize * qualityFactor),\n      constellationCount: Math.max(3, Math.floor(constellationCount * qualityFactor)),\n      useGlow: qualityFactor > 0.5,\n      useHighQualityRendering: qualityFactor > 0.7\n    };\n  }, [adaptiveQuality, qualityFactor, starCount, starMinSize, starMaxSize, constellationCount]);\n\n  // Get cached color with opacity\n  const getCachedColor = useCallback((baseColor, opacity) => {\n    // Ensure opacity is always valid\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n\n    // Round opacity to reduce cache size while maintaining visual quality\n    const roundedOpacity = Math.round(safeOpacity * 100) / 100;\n    const key = `${baseColor}-${roundedOpacity}`;\n    if (!colorCacheRef.current.has(key)) {\n      const newColor = baseColor.replace(/[\\d.]+\\)$/, roundedOpacity + ')');\n      colorCacheRef.current.set(key, newColor);\n    }\n    return colorCacheRef.current.get(key);\n  }, []);\n\n  // Detect device capabilities and set quality\n  const detectCapabilities = useCallback(() => {\n    var _navigator, _navigator2, _navigator3, _window;\n    // Device memory, hardware concurrency, and screen\n    const memory = ((_navigator = navigator) === null || _navigator === void 0 ? void 0 : _navigator.deviceMemory) || 4;\n    const cores = ((_navigator2 = navigator) === null || _navigator2 === void 0 ? void 0 : _navigator2.hardwareConcurrency) || 4;\n    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(((_navigator3 = navigator) === null || _navigator3 === void 0 ? void 0 : _navigator3.userAgent) || '');\n    const pixelRatio = ((_window = window) === null || _window === void 0 ? void 0 : _window.devicePixelRatio) || 1;\n\n    // Update device capabilities\n    deviceCapabilitiesRef.current = {\n      isHighPerformance: memory > 4 && cores > 4 && !isMobile,\n      isMobile,\n      pixelRatio: Math.min(pixelRatio, isMobile ? 2 : 3) // Cap pixel ratio to avoid excessive rendering\n    };\n\n    // Calculate quality factor based on capabilities\n    if (adaptiveQuality) {\n      // Base score from hardware\n      const performanceScore = memory * cores / (isMobile ? 2 : 1);\n\n      // Scale quality based on performance score\n      let quality = 1;\n      if (performanceScore > 16) {\n        quality = 1; // High-end devices\n      } else if (performanceScore > 8) {\n        quality = 0.8; // Mid-range devices\n      } else if (performanceScore > 4) {\n        quality = 0.6; // Low-end devices\n      } else {\n        quality = 0.4; // Very low-end devices\n      }\n      setQualityFactor(quality);\n    }\n  }, [adaptiveQuality]);\n\n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current || !containerRef.current) return false;\n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    const rect = container.getBoundingClientRect();\n    const pixelRatio = deviceCapabilitiesRef.current.pixelRatio;\n\n    // Set canvas size accounting for pixel ratio\n    const displayWidth = Math.floor(rect.width);\n    const displayHeight = Math.floor(rect.height);\n    canvas.width = displayWidth * pixelRatio;\n    canvas.height = displayHeight * pixelRatio;\n\n    // Set CSS display size\n    canvas.style.width = `${displayWidth}px`;\n    canvas.style.height = `${displayHeight}px`;\n\n    // Get 2D context\n    const ctx = canvas.getContext('2d', {\n      alpha: true,\n      desynchronized: true,\n      willReadFrequently: false\n    });\n    if (!ctx) return false;\n\n    // Scale context for high-DPI displays\n    ctx.scale(pixelRatio, pixelRatio);\n\n    // Configure context for high-quality rendering\n    if (adaptedSettings.useHighQualityRendering) {\n      ctx.imageSmoothingEnabled = true;\n      ctx.imageSmoothingQuality = 'high';\n    }\n    ctxRef.current = ctx;\n\n    // Update dimensions state\n    setDimensions({\n      width: displayWidth,\n      height: displayHeight\n    });\n    return true;\n  }, [adaptedSettings.useHighQualityRendering]);\n\n  // Initialize constellations based on stars\n  const initializeConstellations = useCallback((stars, width, height) => {\n    const constellations = [];\n\n    // Get a subset of stars to use for constellations\n    const constellationStars = [...stars].sort(() => Math.random() - 0.5).slice(0, Math.floor(stars.length * constellationDensity));\n\n    // Create constellations\n    for (let i = 0; i < adaptedSettings.constellationCount; i++) {\n      // Select random stars for this constellation\n      const starCount = Math.floor(Math.random() * 6) + 3; // 3-8 stars per constellation\n      const constellationPoints = [];\n\n      // Get random starting point\n      const startIndex = Math.floor(Math.random() * constellationStars.length);\n      // Use a separate variable for tracking current star to avoid the linting issue\n      let trackingStarIndex = startIndex;\n\n      // Add the first star\n      const firstStar = constellationStars[trackingStarIndex];\n      constellationPoints.push({\n        x: firstStar.x,\n        y: firstStar.y,\n        starRef: firstStar\n      });\n\n      // Add connections by finding stars that are reasonably close\n      for (let j = 1; j < starCount; j++) {\n        const currentStar = constellationStars[trackingStarIndex];\n\n        // Find nearby stars\n        const nearbyStars = constellationStars.filter((star, index) => {\n          if (index === trackingStarIndex) return false; // Skip current star\n\n          // Check if star is already in constellation\n          const isAlreadyIncluded = constellationPoints.some(point => point.starRef === star);\n          if (isAlreadyIncluded) return false;\n\n          // Calculate distance\n          const dx = star.x - currentStar.x;\n          const dy = star.y - currentStar.y;\n          const distance = Math.sqrt(dx * dx + dy * dy);\n\n          // Find stars within a reasonable distance\n          const maxDistance = Math.min(width, height) * 0.2;\n          return distance < maxDistance;\n        });\n\n        // If no nearby stars, break constellation here\n        if (nearbyStars.length === 0) break;\n\n        // Choose a random nearby star\n        const nextStar = nearbyStars[Math.floor(Math.random() * nearbyStars.length)];\n        const nextStarIndex = constellationStars.indexOf(nextStar);\n\n        // Add to constellation\n        constellationPoints.push({\n          x: nextStar.x,\n          y: nextStar.y,\n          starRef: nextStar\n        });\n\n        // Update current star - use the local tracking variable to avoid the linting issue\n        trackingStarIndex = nextStarIndex;\n      }\n\n      // Only add constellations with enough points\n      if (constellationPoints.length >= 3) {\n        // Calculate center of constellation for rotation\n        const centerX = constellationPoints.reduce((sum, p) => sum + p.x, 0) / constellationPoints.length;\n        const centerY = constellationPoints.reduce((sum, p) => sum + p.y, 0) / constellationPoints.length;\n        constellations.push({\n          points: constellationPoints,\n          opacity: Math.random() * 0.1 + constellationLineOpacity - 0.1,\n          rotation: (Math.random() * 0.0002 - 0.0001) * (Math.random() < 0.5 ? -1 : 1),\n          // Random direction\n          rotationCenter: {\n            x: centerX,\n            y: centerY\n          },\n          // Pre-allocate current property to avoid layout thrashing\n          currentOpacity: constellationLineOpacity\n        });\n      }\n    }\n    constellationsRef.current = constellations;\n  }, [adaptedSettings.constellationCount, constellationDensity, constellationLineOpacity]);\n\n  // Initialize star field\n  const initializeStars = useCallback(() => {\n    const {\n      width,\n      height\n    } = dimensions;\n    if (!width || !height) return;\n    const stars = [];\n\n    // Create stars\n    for (let i = 0; i < adaptedSettings.starCount; i++) {\n      const x = Math.random() * width;\n      const y = Math.random() * height;\n      const size = Math.random() * (adaptedSettings.starMaxSize - adaptedSettings.starMinSize) + adaptedSettings.starMinSize;\n      const opacity = Math.random() * (starMaxOpacity - starMinOpacity) + starMinOpacity;\n      const pulseSpeed = Math.random() * 0.0007 + 0.0003;\n      const pulsePhase = Math.random() * Math.PI * 2;\n\n      // Add drift motion\n      const driftX = (Math.random() - 0.5) * stellarDriftSpeed;\n      const driftY = (Math.random() - 0.5) * stellarDriftSpeed;\n\n      // Add z-depth for parallax effect\n      const zDepth = Math.random() * 0.8 + 0.2; // 0.2 to 1.0\n\n      stars.push({\n        x,\n        y,\n        size,\n        opacity,\n        pulseSpeed,\n        pulsePhase,\n        driftX,\n        driftY,\n        zDepth,\n        originalX: x,\n        originalY: y,\n        // Pre-allocate current properties to avoid layout thrashing\n        currentSize: size,\n        currentOpacity: opacity\n      });\n    }\n    starsRef.current = stars;\n\n    // Create constellations\n    initializeConstellations(stars, width, height);\n  }, [dimensions, adaptedSettings.starCount, adaptedSettings.starMinSize, adaptedSettings.starMaxSize, starMinOpacity, starMaxOpacity, stellarDriftSpeed, initializeConstellations]);\n\n  // Detect reduced motion preference\n  useEffect(() => {\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    const handleReducedMotionChange = e => {\n      setPrefersReducedMotion(e.matches);\n    };\n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n\n    // Detect device capabilities\n    detectCapabilities();\n\n    // Setup visibility change detection\n    const handleVisibilityChange = () => {\n      isVisibleRef.current = !document.hidden;\n    };\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  }, [detectCapabilities]);\n\n  // Update stars and constellations on resize\n  useEffect(() => {\n    if (!dimensions.width || !dimensions.height) return;\n\n    // Initialize stars and constellations\n    initializeStars();\n\n    // Mark component as initialized\n    setInitialized(true);\n  }, [dimensions, initializeStars]);\n\n  // Setup canvas resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Create a ResizeObserver to detect container size changes\n    const resizeObserver = new ResizeObserver(entries => {\n      var _resizeObserverRef$cu;\n      // Debounce resize operations\n      if ((_resizeObserverRef$cu = resizeObserverRef.current) !== null && _resizeObserverRef$cu !== void 0 && _resizeObserverRef$cu.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n      resizeObserverRef.current = {\n        ...resizeObserverRef.current,\n        timeout: setTimeout(() => {\n          setupCanvas();\n        }, 200) // 200ms debounce\n      };\n    });\n\n    // Capture current reference to avoid closure issues in cleanup\n    const currentContainer = containerRef.current;\n\n    // Start observing the container\n    resizeObserver.observe(currentContainer);\n    resizeObserverRef.current = {\n      ...resizeObserverRef.current,\n      observer: resizeObserver\n    };\n\n    // Initial setup\n    setupCanvas();\n    return () => {\n      var _resizeObserverRef$cu2, _resizeObserverRef$cu3;\n      if ((_resizeObserverRef$cu2 = resizeObserverRef.current) !== null && _resizeObserverRef$cu2 !== void 0 && _resizeObserverRef$cu2.observer) {\n        resizeObserverRef.current.observer.disconnect();\n      }\n      if ((_resizeObserverRef$cu3 = resizeObserverRef.current) !== null && _resizeObserverRef$cu3 !== void 0 && _resizeObserverRef$cu3.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n    };\n  }, [setupCanvas]);\n\n  // Update star positions and properties\n  const updateStars = useCallback((deltaTime, timestamp) => {\n    const {\n      width,\n      height\n    } = dimensions;\n\n    // Calculate global drift based on time\n    const globalOffsetX = Math.sin(timestamp * backgroundMotionSpeed) * width * 0.05;\n    const globalOffsetY = Math.cos(timestamp * backgroundMotionSpeed) * height * 0.05;\n\n    // Update each star\n    starsRef.current.forEach(star => {\n      // Apply global movement with parallax effect based on z-depth\n      const parallaxFactor = star.zDepth;\n\n      // Update position with smooth motion\n      star.x = star.originalX + globalOffsetX * parallaxFactor + Math.sin(timestamp * 0.0001 + star.pulsePhase) * 2;\n      star.y = star.originalY + globalOffsetY * parallaxFactor + Math.cos(timestamp * 0.0001 + star.pulsePhase) * 2;\n\n      // Wrap around edges (with buffer zone to prevent popping)\n      if (star.x < -20) star.x = width + 20;\n      if (star.x > width + 20) star.x = -20;\n      if (star.y < -20) star.y = height + 20;\n      if (star.y > height + 20) star.y = -20;\n\n      // Update pulse effect - use modulo to ensure continuous animation\n      const pulseTime = timestamp % starPulseDuration / starPulseDuration;\n      const pulseValue = Math.sin(pulseTime * Math.PI * 2 + star.pulsePhase);\n\n      // Apply subtle pulse to size and opacity\n      star.currentSize = star.size * (1 + pulseValue * 0.2);\n      star.currentOpacity = star.opacity * (0.8 + pulseValue * 0.2);\n    });\n  }, [dimensions, backgroundMotionSpeed, starPulseDuration]);\n\n  // Update constellation positions\n  const updateConstellations = useCallback((deltaTime, timestamp) => {\n    // Only update if we have constellations\n    if (constellationsRef.current.length === 0) return;\n\n    // Update each constellation\n    constellationsRef.current.forEach(constellation => {\n      // Apply rotation to each point around constellation center\n      const rotationAmount = constellation.rotation * deltaTime;\n      const centerX = constellation.rotationCenter.x;\n      const centerY = constellation.rotationCenter.y;\n\n      // Apply subtle unified movement to constellation center\n      const globalPhase = timestamp * 0.0001;\n      const centerDriftX = Math.sin(globalPhase + centerX * 0.01) * 2;\n      const centerDriftY = Math.cos(globalPhase + centerY * 0.01) * 2;\n      constellation.rotationCenter.x += centerDriftX * 0.01;\n      constellation.rotationCenter.y += centerDriftY * 0.01;\n\n      // Update constellation points based on their reference stars\n      constellation.points.forEach(point => {\n        // Get updated star position from reference\n        point.x = point.starRef.x;\n        point.y = point.starRef.y;\n\n        // Apply subtle rotation around constellation center\n        const dx = point.x - centerX;\n        const dy = point.y - centerY;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        const angle = Math.atan2(dy, dx) + rotationAmount;\n\n        // Apply rotation with slight drift\n        point.x = centerX + Math.cos(angle) * distance + centerDriftX * 0.05;\n        point.y = centerY + Math.sin(angle) * distance + centerDriftY * 0.05;\n      });\n\n      // Apply subtle opacity variation based on time\n      constellation.currentOpacity = constellation.opacity * (0.8 + Math.sin(timestamp * 0.0005) * 0.2);\n    });\n  }, []);\n\n  // Render stars with optimized approach\n  const renderStars = useCallback((ctx, timestamp) => {\n    // Skip if context is not available\n    if (!ctx) return;\n\n    // Use high-quality or optimized rendering based on device capabilities\n    const useGlow = adaptedSettings.useGlow && !deviceCapabilitiesRef.current.isMobile;\n\n    // Draw each star\n    starsRef.current.forEach(star => {\n      ctx.beginPath();\n\n      // Apply glow effect for larger stars to create depth\n      if (useGlow && star.size > adaptedSettings.starMinSize + 0.5) {\n        ctx.shadowBlur = star.currentSize * 3;\n        ctx.shadowColor = getCachedColor(glowStarColor, star.currentOpacity * 0.8);\n      }\n\n      // Draw star core with gradient for more realistic appearance\n      const gradient = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, star.currentSize);\n      gradient.addColorStop(0, getCachedColor(coreStarColor, star.currentOpacity));\n      gradient.addColorStop(0.6, getCachedColor(coreStarColor, star.currentOpacity * 0.8));\n      gradient.addColorStop(1, getCachedColor(glowStarColor, star.currentOpacity * 0.3));\n      ctx.arc(star.x, star.y, star.currentSize, 0, Math.PI * 2);\n      ctx.fillStyle = gradient;\n      ctx.fill();\n\n      // Clear shadow settings to improve performance\n      if (useGlow && star.size > adaptedSettings.starMinSize + 0.5) {\n        ctx.shadowBlur = 0;\n        ctx.shadowColor = 'transparent';\n      }\n    });\n  }, [adaptedSettings.useGlow, adaptedSettings.starMinSize, getCachedColor, glowStarColor, coreStarColor]);\n\n  // Render constellations with optimized approach\n  const renderConstellations = useCallback((ctx, timestamp) => {\n    // Skip if context is not available\n    if (!ctx) return;\n\n    // Draw each constellation\n    constellationsRef.current.forEach(constellation => {\n      // Draw lines between stars\n      ctx.beginPath();\n\n      // Move to first point\n      const firstPoint = constellation.points[0];\n      ctx.moveTo(firstPoint.x, firstPoint.y);\n\n      // Connect the dots with smooth lines\n      for (let i = 1; i < constellation.points.length; i++) {\n        const point = constellation.points[i];\n        ctx.lineTo(point.x, point.y);\n      }\n\n      // Set line style and draw with subtle gradient\n      const gradient = ctx.createLinearGradient(constellation.points[0].x, constellation.points[0].y, constellation.points[constellation.points.length - 1].x, constellation.points[constellation.points.length - 1].y);\n      gradient.addColorStop(0, getCachedColor(constellationLineColor, constellation.currentOpacity));\n      gradient.addColorStop(0.5, getCachedColor(constellationLineColor, constellation.currentOpacity * 1.2));\n      gradient.addColorStop(1, getCachedColor(constellationLineColor, constellation.currentOpacity));\n      ctx.strokeStyle = gradient;\n      ctx.lineWidth = 0.7; // Thin lines\n      ctx.lineCap = 'round'; // Rounded ends for smoother appearance\n      ctx.stroke();\n\n      // Add subtle vertex effects at intersection points\n      if (vertexEffectIntensity > 0) {\n        constellation.points.forEach((point, index) => {\n          // Skip first and last points for better aesthetics\n          if (index === 0 || index === constellation.points.length - 1) return;\n\n          // Create subtle pulsing vertex glow\n          const vertexSize = 1.5 * vertexEffectIntensity;\n          const pulseOffset = Math.sin(timestamp * 0.001 + index) * 0.2 + 0.8;\n          ctx.beginPath();\n          ctx.arc(point.x, point.y, vertexSize * pulseOffset, 0, Math.PI * 2);\n\n          // Add subtle glow to vertices\n          if (adaptedSettings.useGlow) {\n            ctx.shadowBlur = vertexSize * 2;\n            ctx.shadowColor = getCachedColor(constellationLineColor, constellation.currentOpacity * 0.8);\n          }\n\n          // Fill vertex with slightly higher opacity\n          const vertexOpacity = Math.min(1, constellation.currentOpacity * 1.4);\n          ctx.fillStyle = getCachedColor(constellationLineColor, vertexOpacity);\n          ctx.fill();\n\n          // Clear shadow for performance\n          if (adaptedSettings.useGlow) {\n            ctx.shadowBlur = 0;\n            ctx.shadowColor = 'transparent';\n          }\n        });\n      }\n    });\n  }, [getCachedColor, constellationLineColor, vertexEffectIntensity, adaptedSettings.useGlow]);\n\n  // Main animation handler\n  const animateBackground = useCallback(timestamp => {\n    // Skip animation if component is hidden, inactive, or user prefers reduced motion\n    const shouldAnimate = isVisibleRef.current && active && !(respectReducedMotion && prefersReducedMotion);\n    if (!shouldAnimate) {\n      animationFrameRef.current = requestAnimationFrame(animateBackground);\n      return;\n    }\n\n    // Calculate delta time for smooth animation\n    const now = timestamp || performance.now();\n    const deltaTime = Math.min(now - lastFrameTimeRef.current, 50); // Cap delta time at 50ms\n    lastFrameTimeRef.current = now;\n\n    // Calculate time scale based on target frame rate\n    const targetDelta = 1000 / 60; // Target 60 FPS\n    const timeScale = deltaTime / targetDelta;\n    timeScaleRef.current = timeScale;\n\n    // Skip rendering if canvas context is not available\n    if (!ctxRef.current) {\n      animationFrameRef.current = requestAnimationFrame(animateBackground);\n      return;\n    }\n\n    // Clear canvas with high-performance clear method\n    ctxRef.current.clearRect(0, 0, dimensions.width, dimensions.height);\n\n    // Update positions\n    updateStars(deltaTime, now);\n    updateConstellations(deltaTime, now);\n\n    // Render everything\n    renderStars(ctxRef.current, now);\n    renderConstellations(ctxRef.current, now);\n\n    // Debug info\n    if (debugMode) {\n      const ctx = ctxRef.current;\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n      ctx.font = '12px monospace';\n      ctx.fillText(`Stars: ${starsRef.current.length}`, 10, 20);\n      ctx.fillText(`Constellations: ${constellationsRef.current.length}`, 10, 40);\n      ctx.fillText(`Quality: ${qualityFactor.toFixed(2)}`, 10, 60);\n      ctx.fillText(`Device: ${deviceCapabilitiesRef.current.isMobile ? 'Mobile' : 'Desktop'}`, 10, 80);\n      ctx.fillText(`FPS: ${Math.round(1000 / (deltaTime || 16))}`, 10, 100);\n    }\n\n    // Request next frame\n    animationFrameRef.current = requestAnimationFrame(animateBackground);\n  }, [active, respectReducedMotion, prefersReducedMotion, dimensions, updateStars, updateConstellations, renderStars, renderConstellations, debugMode, qualityFactor]);\n\n  // Start/stop animation loop\n  useEffect(() => {\n    if (!initialized || !dimensions.width || !dimensions.height) return;\n\n    // Reset timestamp for smooth animation restart\n    lastFrameTimeRef.current = 0;\n\n    // Start animation loop\n    animationFrameRef.current = requestAnimationFrame(animateBackground);\n\n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [initialized, dimensions, animateBackground]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      overflow: 'hidden',\n      zIndex,\n      pointerEvents: 'none',\n      // Use hardware acceleration\n      willChange: 'transform',\n      transform: 'translateZ(0)',\n      backfaceVisibility: 'hidden'\n    },\n    \"aria-hidden\": \"true\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        // Hardware acceleration\n        willChange: 'transform',\n        transform: 'translateZ(0)',\n        backfaceVisibility: 'hidden'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 734,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 716,\n    columnNumber: 5\n  }, this);\n};\n_s(Background, \"G9hQqY9ENkyRZsFF7MurdcHixRI=\");\n_c = Background;\nexport default Background;\nvar _c;\n$RefreshReg$(_c, \"Background\");","map":{"version":3,"names":["React","useState","useRef","useEffect","useCallback","useMemo","jsxDEV","_jsxDEV","Background","cursorPosition","setCursorPosition","zIndex","active","starCount","starMinSize","starMaxSize","starMinOpacity","starMaxOpacity","constellationCount","constellationDensity","constellationLineOpacity","constellationLineColor","coreStarColor","glowStarColor","vertexEffectIntensity","backgroundMotionSpeed","starPulseDuration","stellarDriftSpeed","adaptiveQuality","respectReducedMotion","debugMode","_s","containerRef","canvasRef","ctxRef","starsRef","constellationsRef","animationFrameRef","lastFrameTimeRef","frameRateRef","timeScaleRef","resizeObserverRef","isVisibleRef","deviceCapabilitiesRef","isHighPerformance","isMobile","pixelRatio","dimensions","setDimensions","width","height","initialized","setInitialized","prefersReducedMotion","setPrefersReducedMotion","qualityFactor","setQualityFactor","colorCacheRef","Map","adaptedSettings","useGlow","useHighQualityRendering","Math","max","floor","getCachedColor","baseColor","opacity","safeOpacity","min","roundedOpacity","round","key","current","has","newColor","replace","set","get","detectCapabilities","_navigator","_navigator2","_navigator3","_window","memory","navigator","deviceMemory","cores","hardwareConcurrency","test","userAgent","window","devicePixelRatio","performanceScore","quality","setupCanvas","canvas","container","rect","getBoundingClientRect","displayWidth","displayHeight","style","ctx","getContext","alpha","desynchronized","willReadFrequently","scale","imageSmoothingEnabled","imageSmoothingQuality","initializeConstellations","stars","constellations","constellationStars","sort","random","slice","length","i","constellationPoints","startIndex","trackingStarIndex","firstStar","push","x","y","starRef","j","currentStar","nearbyStars","filter","star","index","isAlreadyIncluded","some","point","dx","dy","distance","sqrt","maxDistance","nextStar","nextStarIndex","indexOf","centerX","reduce","sum","p","centerY","points","rotation","rotationCenter","currentOpacity","initializeStars","size","pulseSpeed","pulsePhase","PI","driftX","driftY","zDepth","originalX","originalY","currentSize","reducedMotionQuery","matchMedia","matches","handleReducedMotionChange","e","addEventListener","handleVisibilityChange","document","hidden","removeEventListener","resizeObserver","ResizeObserver","entries","_resizeObserverRef$cu","timeout","clearTimeout","setTimeout","currentContainer","observe","observer","_resizeObserverRef$cu2","_resizeObserverRef$cu3","disconnect","updateStars","deltaTime","timestamp","globalOffsetX","sin","globalOffsetY","cos","forEach","parallaxFactor","pulseTime","pulseValue","updateConstellations","constellation","rotationAmount","globalPhase","centerDriftX","centerDriftY","angle","atan2","renderStars","beginPath","shadowBlur","shadowColor","gradient","createRadialGradient","addColorStop","arc","fillStyle","fill","renderConstellations","firstPoint","moveTo","lineTo","createLinearGradient","strokeStyle","lineWidth","lineCap","stroke","vertexSize","pulseOffset","vertexOpacity","animateBackground","shouldAnimate","requestAnimationFrame","now","performance","targetDelta","timeScale","clearRect","font","fillText","toFixed","cancelAnimationFrame","ref","position","top","left","overflow","pointerEvents","willChange","transform","backfaceVisibility","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/Background.jsx"],"sourcesContent":["import React, { useState, useRef, useEffect, useCallback, useMemo } from 'react';\n\n/**\n * Background Component - Enterprise Performance Optimized Version\n * \n * Creates a highly performant animated background with stars, constellations,\n * and subtle vertex effects that gives the impression of flowing through space.\n * \n * Features:\n * - Advanced performance optimizations with adaptive rendering\n * - Smooth, fluid animations with zero jitter\n * - Memory and battery-efficient rendering pipeline\n * - Accessibility compliance with reduced motion support\n * - Supports hardware acceleration and high-DPI displays\n */\nconst Background = ({\n  // For backward compatibility - cursor position props (not used in new animation)\n  cursorPosition,\n  setCursorPosition,\n  \n  // Configuration options\n  zIndex = -1,\n  active = true,\n  starCount = 150,\n  starMinSize = 0.5,\n  starMaxSize = 2.5,\n  starMinOpacity = 0.2,\n  starMaxOpacity = 0.8,\n  constellationCount = 8,\n  constellationDensity = 0.3,\n  constellationLineOpacity = 0.15,\n  constellationLineColor = 'rgba(160, 142, 97, 0.4)',\n  coreStarColor = 'rgba(255, 253, 227, 1)',\n  glowStarColor = 'rgba(191, 173, 127, 0.6)',\n  vertexEffectIntensity = 0.5,\n  backgroundMotionSpeed = 0.0005,\n  starPulseDuration = 3000,\n  stellarDriftSpeed = 0.02,\n  adaptiveQuality = true,\n  respectReducedMotion = true,\n  debugMode = false\n}) => {\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const ctxRef = useRef(null);\n  const starsRef = useRef([]);\n  const constellationsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastFrameTimeRef = useRef(0);\n  const frameRateRef = useRef(60);\n  const timeScaleRef = useRef(1);\n  const resizeObserverRef = useRef(null);\n  const isVisibleRef = useRef(true);\n  const deviceCapabilitiesRef = useRef({\n    isHighPerformance: true,\n    isMobile: false,\n    pixelRatio: 1\n  });\n  \n  // Component state\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n  const [initialized, setInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [qualityFactor, setQualityFactor] = useState(1);\n  \n  // Pre-calculate color variants to avoid string operations during animation\n  const colorCacheRef = useRef(new Map());\n  \n  // Adaptive settings based on quality factor and device capabilities\n  const adaptedSettings = useMemo(() => {\n    if (!adaptiveQuality || qualityFactor === 1) {\n      return {\n        starCount,\n        starMinSize,\n        starMaxSize,\n        constellationCount,\n        useGlow: true,\n        useHighQualityRendering: true\n      };\n    }\n    \n    // Adjust quality-dependent parameters\n    return {\n      starCount: Math.max(50, Math.floor(starCount * qualityFactor)),\n      starMinSize: Math.max(0.3, starMinSize * qualityFactor),\n      starMaxSize: Math.max(1, starMaxSize * qualityFactor),\n      constellationCount: Math.max(3, Math.floor(constellationCount * qualityFactor)),\n      useGlow: qualityFactor > 0.5,\n      useHighQualityRendering: qualityFactor > 0.7\n    };\n  }, [\n    adaptiveQuality,\n    qualityFactor,\n    starCount,\n    starMinSize,\n    starMaxSize,\n    constellationCount\n  ]);\n  \n  // Get cached color with opacity\n  const getCachedColor = useCallback((baseColor, opacity) => {\n    // Ensure opacity is always valid\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    \n    // Round opacity to reduce cache size while maintaining visual quality\n    const roundedOpacity = Math.round(safeOpacity * 100) / 100;\n    const key = `${baseColor}-${roundedOpacity}`;\n    \n    if (!colorCacheRef.current.has(key)) {\n      const newColor = baseColor.replace(/[\\d.]+\\)$/, roundedOpacity + ')');\n      colorCacheRef.current.set(key, newColor);\n    }\n    \n    return colorCacheRef.current.get(key);\n  }, []);\n  \n  // Detect device capabilities and set quality\n  const detectCapabilities = useCallback(() => {\n    // Device memory, hardware concurrency, and screen\n    const memory = navigator?.deviceMemory || 4;\n    const cores = navigator?.hardwareConcurrency || 4;\n    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n      navigator?.userAgent || ''\n    );\n    const pixelRatio = window?.devicePixelRatio || 1;\n    \n    // Update device capabilities\n    deviceCapabilitiesRef.current = {\n      isHighPerformance: memory > 4 && cores > 4 && !isMobile,\n      isMobile,\n      pixelRatio: Math.min(pixelRatio, isMobile ? 2 : 3) // Cap pixel ratio to avoid excessive rendering\n    };\n    \n    // Calculate quality factor based on capabilities\n    if (adaptiveQuality) {\n      // Base score from hardware\n      const performanceScore = (memory * cores) / (isMobile ? 2 : 1);\n      \n      // Scale quality based on performance score\n      let quality = 1;\n      \n      if (performanceScore > 16) {\n        quality = 1; // High-end devices\n      } else if (performanceScore > 8) {\n        quality = 0.8; // Mid-range devices\n      } else if (performanceScore > 4) {\n        quality = 0.6; // Low-end devices\n      } else {\n        quality = 0.4; // Very low-end devices\n      }\n      \n      setQualityFactor(quality);\n    }\n  }, [adaptiveQuality]);\n  \n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current || !containerRef.current) return false;\n    \n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    const rect = container.getBoundingClientRect();\n    const pixelRatio = deviceCapabilitiesRef.current.pixelRatio;\n    \n    // Set canvas size accounting for pixel ratio\n    const displayWidth = Math.floor(rect.width);\n    const displayHeight = Math.floor(rect.height);\n    \n    canvas.width = displayWidth * pixelRatio;\n    canvas.height = displayHeight * pixelRatio;\n    \n    // Set CSS display size\n    canvas.style.width = `${displayWidth}px`;\n    canvas.style.height = `${displayHeight}px`;\n    \n    // Get 2D context\n    const ctx = canvas.getContext('2d', {\n      alpha: true,\n      desynchronized: true,\n      willReadFrequently: false\n    });\n    \n    if (!ctx) return false;\n    \n    // Scale context for high-DPI displays\n    ctx.scale(pixelRatio, pixelRatio);\n    \n    // Configure context for high-quality rendering\n    if (adaptedSettings.useHighQualityRendering) {\n      ctx.imageSmoothingEnabled = true;\n      ctx.imageSmoothingQuality = 'high';\n    }\n    \n    ctxRef.current = ctx;\n    \n    // Update dimensions state\n    setDimensions({\n      width: displayWidth,\n      height: displayHeight\n    });\n    \n    return true;\n  }, [adaptedSettings.useHighQualityRendering]);\n  \n  // Initialize constellations based on stars\n  const initializeConstellations = useCallback((stars, width, height) => {\n    const constellations = [];\n    \n    // Get a subset of stars to use for constellations\n    const constellationStars = [...stars]\n      .sort(() => Math.random() - 0.5)\n      .slice(0, Math.floor(stars.length * constellationDensity));\n    \n    // Create constellations\n    for (let i = 0; i < adaptedSettings.constellationCount; i++) {\n      // Select random stars for this constellation\n      const starCount = Math.floor(Math.random() * 6) + 3; // 3-8 stars per constellation\n      const constellationPoints = [];\n      \n      // Get random starting point\n      const startIndex = Math.floor(Math.random() * constellationStars.length);\n      // Use a separate variable for tracking current star to avoid the linting issue\n      let trackingStarIndex = startIndex;\n      \n      // Add the first star\n      const firstStar = constellationStars[trackingStarIndex];\n      constellationPoints.push({\n        x: firstStar.x,\n        y: firstStar.y,\n        starRef: firstStar\n      });\n      \n      // Add connections by finding stars that are reasonably close\n      for (let j = 1; j < starCount; j++) {\n        const currentStar = constellationStars[trackingStarIndex];\n        \n        // Find nearby stars\n        const nearbyStars = constellationStars.filter((star, index) => {\n          if (index === trackingStarIndex) return false; // Skip current star\n          \n          // Check if star is already in constellation\n          const isAlreadyIncluded = constellationPoints.some(point => point.starRef === star);\n          if (isAlreadyIncluded) return false;\n          \n          // Calculate distance\n          const dx = star.x - currentStar.x;\n          const dy = star.y - currentStar.y;\n          const distance = Math.sqrt(dx * dx + dy * dy);\n          \n          // Find stars within a reasonable distance\n          const maxDistance = Math.min(width, height) * 0.2;\n          return distance < maxDistance;\n        });\n        \n        // If no nearby stars, break constellation here\n        if (nearbyStars.length === 0) break;\n        \n        // Choose a random nearby star\n        const nextStar = nearbyStars[Math.floor(Math.random() * nearbyStars.length)];\n        const nextStarIndex = constellationStars.indexOf(nextStar);\n        \n        // Add to constellation\n        constellationPoints.push({\n          x: nextStar.x,\n          y: nextStar.y,\n          starRef: nextStar\n        });\n        \n        // Update current star - use the local tracking variable to avoid the linting issue\n        trackingStarIndex = nextStarIndex;\n      }\n      \n      // Only add constellations with enough points\n      if (constellationPoints.length >= 3) {\n        // Calculate center of constellation for rotation\n        const centerX = constellationPoints.reduce((sum, p) => sum + p.x, 0) / constellationPoints.length;\n        const centerY = constellationPoints.reduce((sum, p) => sum + p.y, 0) / constellationPoints.length;\n        \n        constellations.push({\n          points: constellationPoints,\n          opacity: Math.random() * 0.1 + constellationLineOpacity - 0.1,\n          rotation: (Math.random() * 0.0002 - 0.0001) * (Math.random() < 0.5 ? -1 : 1), // Random direction\n          rotationCenter: { x: centerX, y: centerY },\n          // Pre-allocate current property to avoid layout thrashing\n          currentOpacity: constellationLineOpacity\n        });\n      }\n    }\n    \n    constellationsRef.current = constellations;\n  }, [\n    adaptedSettings.constellationCount,\n    constellationDensity,\n    constellationLineOpacity\n  ]);\n  \n  // Initialize star field\n  const initializeStars = useCallback(() => {\n    const { width, height } = dimensions;\n    if (!width || !height) return;\n    \n    const stars = [];\n    \n    // Create stars\n    for (let i = 0; i < adaptedSettings.starCount; i++) {\n      const x = Math.random() * width;\n      const y = Math.random() * height;\n      const size = Math.random() * (adaptedSettings.starMaxSize - adaptedSettings.starMinSize) + adaptedSettings.starMinSize;\n      const opacity = Math.random() * (starMaxOpacity - starMinOpacity) + starMinOpacity;\n      const pulseSpeed = Math.random() * 0.0007 + 0.0003;\n      const pulsePhase = Math.random() * Math.PI * 2;\n      \n      // Add drift motion\n      const driftX = (Math.random() - 0.5) * stellarDriftSpeed;\n      const driftY = (Math.random() - 0.5) * stellarDriftSpeed;\n      \n      // Add z-depth for parallax effect\n      const zDepth = Math.random() * 0.8 + 0.2; // 0.2 to 1.0\n      \n      stars.push({\n        x,\n        y,\n        size,\n        opacity,\n        pulseSpeed,\n        pulsePhase,\n        driftX,\n        driftY,\n        zDepth,\n        originalX: x,\n        originalY: y,\n        // Pre-allocate current properties to avoid layout thrashing\n        currentSize: size,\n        currentOpacity: opacity\n      });\n    }\n    \n    starsRef.current = stars;\n    \n    // Create constellations\n    initializeConstellations(stars, width, height);\n  }, [\n    dimensions,\n    adaptedSettings.starCount,\n    adaptedSettings.starMinSize,\n    adaptedSettings.starMaxSize,\n    starMinOpacity,\n    starMaxOpacity,\n    stellarDriftSpeed,\n    initializeConstellations\n  ]);\n  \n  // Detect reduced motion preference\n  useEffect(() => {\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    \n    const handleReducedMotionChange = (e) => {\n      setPrefersReducedMotion(e.matches);\n    };\n    \n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n    \n    // Detect device capabilities\n    detectCapabilities();\n    \n    // Setup visibility change detection\n    const handleVisibilityChange = () => {\n      isVisibleRef.current = !document.hidden;\n    };\n    \n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    \n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  }, [detectCapabilities]);\n  \n  // Update stars and constellations on resize\n  useEffect(() => {\n    if (!dimensions.width || !dimensions.height) return;\n    \n    // Initialize stars and constellations\n    initializeStars();\n    \n    // Mark component as initialized\n    setInitialized(true);\n  }, [dimensions, initializeStars]);\n  \n  // Setup canvas resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n    \n    // Create a ResizeObserver to detect container size changes\n    const resizeObserver = new ResizeObserver(entries => {\n      // Debounce resize operations\n      if (resizeObserverRef.current?.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n      \n      resizeObserverRef.current = {\n        ...resizeObserverRef.current,\n        timeout: setTimeout(() => {\n          setupCanvas();\n        }, 200) // 200ms debounce\n      };\n    });\n    \n    // Capture current reference to avoid closure issues in cleanup\n    const currentContainer = containerRef.current;\n    \n    // Start observing the container\n    resizeObserver.observe(currentContainer);\n    resizeObserverRef.current = { \n      ...resizeObserverRef.current,\n      observer: resizeObserver \n    };\n    \n    // Initial setup\n    setupCanvas();\n    \n    return () => {\n      if (resizeObserverRef.current?.observer) {\n        resizeObserverRef.current.observer.disconnect();\n      }\n      if (resizeObserverRef.current?.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n    };\n  }, [setupCanvas]);\n  \n  // Update star positions and properties\n  const updateStars = useCallback((deltaTime, timestamp) => {\n    const { width, height } = dimensions;\n    \n    // Calculate global drift based on time\n    const globalOffsetX = Math.sin(timestamp * backgroundMotionSpeed) * width * 0.05;\n    const globalOffsetY = Math.cos(timestamp * backgroundMotionSpeed) * height * 0.05;\n    \n    // Update each star\n    starsRef.current.forEach(star => {\n      // Apply global movement with parallax effect based on z-depth\n      const parallaxFactor = star.zDepth; \n      \n      // Update position with smooth motion\n      star.x = star.originalX + globalOffsetX * parallaxFactor + Math.sin(timestamp * 0.0001 + star.pulsePhase) * 2;\n      star.y = star.originalY + globalOffsetY * parallaxFactor + Math.cos(timestamp * 0.0001 + star.pulsePhase) * 2;\n      \n      // Wrap around edges (with buffer zone to prevent popping)\n      if (star.x < -20) star.x = width + 20;\n      if (star.x > width + 20) star.x = -20;\n      if (star.y < -20) star.y = height + 20;\n      if (star.y > height + 20) star.y = -20;\n      \n      // Update pulse effect - use modulo to ensure continuous animation\n      const pulseTime = (timestamp % starPulseDuration) / starPulseDuration;\n      const pulseValue = Math.sin(pulseTime * Math.PI * 2 + star.pulsePhase);\n      \n      // Apply subtle pulse to size and opacity\n      star.currentSize = star.size * (1 + pulseValue * 0.2);\n      star.currentOpacity = star.opacity * (0.8 + pulseValue * 0.2);\n    });\n  }, [dimensions, backgroundMotionSpeed, starPulseDuration]);\n  \n  // Update constellation positions\n  const updateConstellations = useCallback((deltaTime, timestamp) => {\n    // Only update if we have constellations\n    if (constellationsRef.current.length === 0) return;\n    \n    // Update each constellation\n    constellationsRef.current.forEach(constellation => {\n      // Apply rotation to each point around constellation center\n      const rotationAmount = constellation.rotation * deltaTime;\n      const centerX = constellation.rotationCenter.x;\n      const centerY = constellation.rotationCenter.y;\n      \n      // Apply subtle unified movement to constellation center\n      const globalPhase = timestamp * 0.0001;\n      const centerDriftX = Math.sin(globalPhase + centerX * 0.01) * 2;\n      const centerDriftY = Math.cos(globalPhase + centerY * 0.01) * 2;\n      \n      constellation.rotationCenter.x += centerDriftX * 0.01;\n      constellation.rotationCenter.y += centerDriftY * 0.01;\n      \n      // Update constellation points based on their reference stars\n      constellation.points.forEach(point => {\n        // Get updated star position from reference\n        point.x = point.starRef.x;\n        point.y = point.starRef.y;\n        \n        // Apply subtle rotation around constellation center\n        const dx = point.x - centerX;\n        const dy = point.y - centerY;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        const angle = Math.atan2(dy, dx) + rotationAmount;\n        \n        // Apply rotation with slight drift\n        point.x = centerX + Math.cos(angle) * distance + centerDriftX * 0.05;\n        point.y = centerY + Math.sin(angle) * distance + centerDriftY * 0.05;\n      });\n      \n      // Apply subtle opacity variation based on time\n      constellation.currentOpacity = constellation.opacity * (0.8 + Math.sin(timestamp * 0.0005) * 0.2);\n    });\n  }, []);\n  \n  // Render stars with optimized approach\n  const renderStars = useCallback((ctx, timestamp) => {\n    // Skip if context is not available\n    if (!ctx) return;\n    \n    // Use high-quality or optimized rendering based on device capabilities\n    const useGlow = adaptedSettings.useGlow && !deviceCapabilitiesRef.current.isMobile;\n    \n    // Draw each star\n    starsRef.current.forEach(star => {\n      ctx.beginPath();\n      \n      // Apply glow effect for larger stars to create depth\n      if (useGlow && star.size > adaptedSettings.starMinSize + 0.5) {\n        ctx.shadowBlur = star.currentSize * 3;\n        ctx.shadowColor = getCachedColor(glowStarColor, star.currentOpacity * 0.8);\n      }\n      \n      // Draw star core with gradient for more realistic appearance\n      const gradient = ctx.createRadialGradient(\n        star.x, star.y, 0,\n        star.x, star.y, star.currentSize\n      );\n      \n      gradient.addColorStop(0, getCachedColor(coreStarColor, star.currentOpacity));\n      gradient.addColorStop(0.6, getCachedColor(coreStarColor, star.currentOpacity * 0.8));\n      gradient.addColorStop(1, getCachedColor(glowStarColor, star.currentOpacity * 0.3));\n      \n      ctx.arc(star.x, star.y, star.currentSize, 0, Math.PI * 2);\n      ctx.fillStyle = gradient;\n      ctx.fill();\n      \n      // Clear shadow settings to improve performance\n      if (useGlow && star.size > adaptedSettings.starMinSize + 0.5) {\n        ctx.shadowBlur = 0;\n        ctx.shadowColor = 'transparent';\n      }\n    });\n  }, [\n    adaptedSettings.useGlow, \n    adaptedSettings.starMinSize,\n    getCachedColor, \n    glowStarColor, \n    coreStarColor\n  ]);\n  \n  // Render constellations with optimized approach\n  const renderConstellations = useCallback((ctx, timestamp) => {\n    // Skip if context is not available\n    if (!ctx) return;\n    \n    // Draw each constellation\n    constellationsRef.current.forEach(constellation => {\n      // Draw lines between stars\n      ctx.beginPath();\n      \n      // Move to first point\n      const firstPoint = constellation.points[0];\n      ctx.moveTo(firstPoint.x, firstPoint.y);\n      \n      // Connect the dots with smooth lines\n      for (let i = 1; i < constellation.points.length; i++) {\n        const point = constellation.points[i];\n        ctx.lineTo(point.x, point.y);\n      }\n      \n      // Set line style and draw with subtle gradient\n      const gradient = ctx.createLinearGradient(\n        constellation.points[0].x, constellation.points[0].y,\n        constellation.points[constellation.points.length - 1].x, constellation.points[constellation.points.length - 1].y\n      );\n      \n      gradient.addColorStop(0, getCachedColor(constellationLineColor, constellation.currentOpacity));\n      gradient.addColorStop(0.5, getCachedColor(constellationLineColor, constellation.currentOpacity * 1.2));\n      gradient.addColorStop(1, getCachedColor(constellationLineColor, constellation.currentOpacity));\n      \n      ctx.strokeStyle = gradient;\n      ctx.lineWidth = 0.7; // Thin lines\n      ctx.lineCap = 'round'; // Rounded ends for smoother appearance\n      ctx.stroke();\n      \n      // Add subtle vertex effects at intersection points\n      if (vertexEffectIntensity > 0) {\n        constellation.points.forEach((point, index) => {\n          // Skip first and last points for better aesthetics\n          if (index === 0 || index === constellation.points.length - 1) return;\n          \n          // Create subtle pulsing vertex glow\n          const vertexSize = 1.5 * vertexEffectIntensity;\n          const pulseOffset = Math.sin(timestamp * 0.001 + index) * 0.2 + 0.8;\n          \n          ctx.beginPath();\n          ctx.arc(point.x, point.y, vertexSize * pulseOffset, 0, Math.PI * 2);\n          \n          // Add subtle glow to vertices\n          if (adaptedSettings.useGlow) {\n            ctx.shadowBlur = vertexSize * 2;\n            ctx.shadowColor = getCachedColor(constellationLineColor, constellation.currentOpacity * 0.8);\n          }\n          \n          // Fill vertex with slightly higher opacity\n          const vertexOpacity = Math.min(1, constellation.currentOpacity * 1.4);\n          ctx.fillStyle = getCachedColor(constellationLineColor, vertexOpacity);\n          ctx.fill();\n          \n          // Clear shadow for performance\n          if (adaptedSettings.useGlow) {\n            ctx.shadowBlur = 0;\n            ctx.shadowColor = 'transparent';\n          }\n        });\n      }\n    });\n  }, [\n    getCachedColor,\n    constellationLineColor,\n    vertexEffectIntensity,\n    adaptedSettings.useGlow\n  ]);\n  \n  // Main animation handler\n  const animateBackground = useCallback((timestamp) => {\n    // Skip animation if component is hidden, inactive, or user prefers reduced motion\n    const shouldAnimate = \n      isVisibleRef.current && \n      active && \n      !(respectReducedMotion && prefersReducedMotion);\n    \n    if (!shouldAnimate) {\n      animationFrameRef.current = requestAnimationFrame(animateBackground);\n      return;\n    }\n    \n    // Calculate delta time for smooth animation\n    const now = timestamp || performance.now();\n    const deltaTime = Math.min(now - lastFrameTimeRef.current, 50); // Cap delta time at 50ms\n    lastFrameTimeRef.current = now;\n    \n    // Calculate time scale based on target frame rate\n    const targetDelta = 1000 / 60; // Target 60 FPS\n    const timeScale = deltaTime / targetDelta;\n    timeScaleRef.current = timeScale;\n    \n    // Skip rendering if canvas context is not available\n    if (!ctxRef.current) {\n      animationFrameRef.current = requestAnimationFrame(animateBackground);\n      return;\n    }\n    \n    // Clear canvas with high-performance clear method\n    ctxRef.current.clearRect(0, 0, dimensions.width, dimensions.height);\n    \n    // Update positions\n    updateStars(deltaTime, now);\n    updateConstellations(deltaTime, now);\n    \n    // Render everything\n    renderStars(ctxRef.current, now);\n    renderConstellations(ctxRef.current, now);\n    \n    // Debug info\n    if (debugMode) {\n      const ctx = ctxRef.current;\n      \n      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n      ctx.font = '12px monospace';\n      ctx.fillText(`Stars: ${starsRef.current.length}`, 10, 20);\n      ctx.fillText(`Constellations: ${constellationsRef.current.length}`, 10, 40);\n      ctx.fillText(`Quality: ${qualityFactor.toFixed(2)}`, 10, 60);\n      ctx.fillText(`Device: ${deviceCapabilitiesRef.current.isMobile ? 'Mobile' : 'Desktop'}`, 10, 80);\n      ctx.fillText(`FPS: ${Math.round(1000 / (deltaTime || 16))}`, 10, 100);\n    }\n    \n    // Request next frame\n    animationFrameRef.current = requestAnimationFrame(animateBackground);\n  }, [\n    active,\n    respectReducedMotion,\n    prefersReducedMotion,\n    dimensions,\n    updateStars,\n    updateConstellations,\n    renderStars,\n    renderConstellations,\n    debugMode,\n    qualityFactor\n  ]);\n  \n  // Start/stop animation loop\n  useEffect(() => {\n    if (!initialized || !dimensions.width || !dimensions.height) return;\n    \n    // Reset timestamp for smooth animation restart\n    lastFrameTimeRef.current = 0;\n    \n    // Start animation loop\n    animationFrameRef.current = requestAnimationFrame(animateBackground);\n    \n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [initialized, dimensions, animateBackground]);\n  \n  return (\n    <div\n      ref={containerRef}\n      style={{\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        overflow: 'hidden',\n        zIndex,\n        pointerEvents: 'none',\n        // Use hardware acceleration\n        willChange: 'transform',\n        transform: 'translateZ(0)',\n        backfaceVisibility: 'hidden'\n      }}\n      aria-hidden=\"true\"\n    >\n      <canvas\n        ref={canvasRef}\n        style={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%',\n          // Hardware acceleration\n          willChange: 'transform',\n          transform: 'translateZ(0)',\n          backfaceVisibility: 'hidden'\n        }}\n      />\n    </div>\n  );\n};\n\nexport default Background;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}