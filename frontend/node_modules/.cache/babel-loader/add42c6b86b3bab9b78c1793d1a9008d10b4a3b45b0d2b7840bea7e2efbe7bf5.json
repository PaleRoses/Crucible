{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/MeteorShower.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';\n\n/**\n * MeteorShower Component - Performance Optimized Version\n * \n * Creates an animated meteor shower effect where meteors arc across the sky\n * with comet-like trails and fade away naturally.\n * Features staggered appearance and configurable journey completion.\n * \n * @param {Object} props - Component props\n * @param {string|number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=5] - Z-index for the container\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.meteorDensity=15] - Number of meteors to maintain on screen\n * @param {number} [props.meteorMinSize=1] - Minimum size of meteors\n * @param {number} [props.meteorMaxSize=3] - Maximum size of meteors\n * @param {number} [props.meteorSpeed=0.08] - Base speed of meteors\n * @param {number} [props.trailLength=180] - Length of meteor trails\n * @param {number} [props.trailSegments=20] - Number of segments in each trail\n * @param {string} [props.coreColor='rgba(255, 255, 255, 1)'] - Core color for meteors\n * @param {string} [props.glowColor='rgba(255, 253, 227, 0.9)'] - Glow color for meteors\n * @param {string} [props.trailColor='rgba(191, 173, 127, 0.8)'] - Trail color for meteors\n * @param {boolean} [props.enableParallax=false] - Enable parallax effect on scroll\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of parallax effect\n * @param {boolean} [props.staggered=true] - Enable staggered meteor appearance\n * @param {number} [props.minStaggerDelay=200] - Minimum delay between meteor spawns (ms)\n * @param {number} [props.maxStaggerDelay=2000] - Maximum delay between meteor spawns (ms)\n * @param {number} [props.journeyCompletion=0.9] - When meteors complete their journey (0-1, where 1 is the container height)\n * @param {string} [props.mode='arc'] - Animation mode: 'arc' (curved paths) or 'linear' (straight angled paths)\n * @param {string} [props.direction='both'] - Direction for linear mode: 'left', 'right', 'both', or 'top'\n * @param {number} [props.baseAngle=30] - Base angle for linear meteors (degrees)\n * @param {number} [props.angleVariation=15] - Random variation to apply to the base angle (Â±degrees)\n * @param {boolean} [props.debug=false] - Enable debug visualization\n * @param {boolean} [props.adaptiveQuality=true] - Enable adaptive quality based on device performance\n * @param {boolean} [props.respectReducedMotion=true] - Respect user's reduced motion preferences\n * @param {number} [props.maxFPS=60] - Target maximum frames per second\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MeteorShower = ({\n  height = '100vh',\n  zIndex = 5,\n  active = true,\n  meteorDensity = 15,\n  meteorMinSize = 1,\n  meteorMaxSize = 3,\n  meteorSpeed = 0.08,\n  trailLength = 180,\n  trailSegments = 20,\n  coreColor = 'rgba(255, 255, 255, 1)',\n  glowColor = 'rgba(255, 253, 227, 0.9)',\n  trailColor = 'rgba(191, 173, 127, 0.8)',\n  enableParallax = false,\n  parallaxIntensity = 0.2,\n  staggered = true,\n  minStaggerDelay = 200,\n  maxStaggerDelay = 2000,\n  journeyCompletion = 0.9,\n  mode = 'arc',\n  direction = 'both',\n  baseAngle = 30,\n  angleVariation = 15,\n  debug = false,\n  adaptiveQuality = true,\n  respectReducedMotion = true,\n  maxFPS = 60\n}) => {\n  _s();\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const ctxRef = useRef(null);\n  const meteorsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const fpsTimestampRef = useRef(0);\n  const frameCountRef = useRef(0);\n  const currentFpsRef = useRef(60);\n  const nextSpawnTimeRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n  const resizeObserverRef = useRef(null);\n\n  // Component state\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0,\n    pixelRatio: 1\n  });\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [isVisible, setIsVisible] = useState(false);\n  const [qualityFactor, setQualityFactor] = useState(1);\n\n  // Pre-allocate objects to avoid garbage collection during animation\n  const pointCache = useRef({\n    current: {\n      x: 0,\n      y: 0\n    },\n    segment: {\n      x: 0,\n      y: 0\n    }\n  }).current;\n\n  // Precompute color variants to avoid string operations during animation\n  const colorCacheRef = useRef(new Map());\n\n  // Get cached color with opacity\n  const getCachedColor = useCallback((baseColor, opacity) => {\n    // Round opacity to reduce cache size while maintaining visual quality\n    const roundedOpacity = Math.round(opacity * 100) / 100;\n    const key = `${baseColor}-${roundedOpacity}`;\n    if (!colorCacheRef.current.has(key)) {\n      const newColor = baseColor.replace(/[\\d.]+\\)$/, roundedOpacity + ')');\n      colorCacheRef.current.set(key, newColor);\n    }\n    return colorCacheRef.current.get(key);\n  }, []);\n\n  // Detect device capabilities and preferences\n  useEffect(() => {\n    // Check for reduced motion preference\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    const handleReducedMotionChange = e => {\n      setPrefersReducedMotion(e.matches);\n    };\n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n\n    // Detect quality level based on device\n    const detectQuality = () => {\n      // Use a combination of device memory, hardware concurrency, and pixel ratio to estimate performance\n      const memory = navigator.deviceMemory || 4; // Default to 4GB if not available\n      const cores = navigator.hardwareConcurrency || 4; // Default to 4 cores\n      const pixelRatio = window.devicePixelRatio || 1;\n\n      // Calculate performance score\n      const performanceScore = memory * cores / pixelRatio;\n\n      // Scale quality based on performance score\n      let quality = 1;\n      if (performanceScore > 16) {\n        quality = 1; // High-end devices: full quality\n      } else if (performanceScore > 8) {\n        quality = 0.8; // Mid-range devices: 80% quality\n      } else if (performanceScore > 4) {\n        quality = 0.6; // Low-end devices: 60% quality\n      } else {\n        quality = 0.4; // Very low-end: 40% quality\n      }\n\n      // Check if it's a mobile device and reduce quality further if needed\n      if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {\n        quality *= 0.8;\n      }\n      return quality;\n    };\n    if (adaptiveQuality) {\n      setQualityFactor(detectQuality());\n    }\n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n    };\n  }, [adaptiveQuality]);\n\n  // Apply adaptive quality settings\n  const adaptedSettings = useMemo(() => {\n    if (!adaptiveQuality || qualityFactor === 1) {\n      return {\n        meteorDensity,\n        trailSegments\n      };\n    }\n\n    // Adjust quality-dependent parameters\n    return {\n      meteorDensity: Math.max(3, Math.floor(meteorDensity * qualityFactor)),\n      trailSegments: Math.max(5, Math.floor(trailSegments * qualityFactor))\n    };\n  }, [adaptiveQuality, qualityFactor, meteorDensity, trailSegments]);\n\n  // Calculate path parameters for a meteor based on selected mode\n  const calculateMeteorPath = useCallback((width, height) => {\n    if (mode === 'arc') {\n      // Original arc path logic\n      // Start point: somewhere along the top of the canvas with randomization\n      const startX = Math.random() * width * 1.5 - width * 0.25;\n\n      // Control how far meteors can start from outside the visible area\n      const startY = Math.random() * -100 - 50;\n\n      // Randomize arc curvature and direction\n      const curveDirection = Math.random() > 0.5 ? 1 : -1;\n      const curveIntensity = Math.random() * 0.4 + 0.2;\n\n      // Calculate control points for quadratic path\n      // End point: adjusted to complete journey according to journeyCompletion parameter\n      const endX = startX + curveDirection * width * curveIntensity;\n      const endY = height * journeyCompletion;\n\n      // Control point: creates the arc shape\n      const controlX = (startX + endX) / 2 + curveDirection * width * curveIntensity;\n      const controlY = (startY + endY) * 0.5;\n      return {\n        pathType: 'arc',\n        start: {\n          x: startX,\n          y: startY\n        },\n        control: {\n          x: controlX,\n          y: controlY\n        },\n        end: {\n          x: endX,\n          y: endY\n        }\n      };\n    } else if (mode === 'linear') {\n      // Linear path logic for traditional meteor shower\n\n      // Determine direction (from left, right, top, or random)\n      let meteorDirection = direction;\n      if (direction === 'both') {\n        meteorDirection = Math.random() > 0.5 ? 'left' : 'right';\n      }\n\n      // Calculate angle with variation (convert to radians)\n      let angle;\n      if (direction === 'top') {\n        // For 'top' direction, maintain consistent 30 degree downward angle to the right\n        // with minimal variation to keep them all falling in a similar direction\n        angle = (30 + (Math.random() * 2 - 1) * 5) * Math.PI / 180;\n      } else {\n        angle = (baseAngle + (Math.random() * 2 - 1) * angleVariation) * Math.PI / 180;\n      }\n\n      // Set starting positions based on direction\n      let startX;\n      if (meteorDirection === 'left') {\n        // Start from top-left portion of the screen\n        startX = Math.random() * (width * 0.3) - width * 0.1;\n      } else if (meteorDirection === 'right') {\n        // Start from top-right portion of the screen\n        startX = width - Math.random() * (width * 0.3) + width * 0.1;\n      } else if (direction === 'top') {\n        // For 'top' direction, distribute meteors across the top with emphasis on left and center\n        const position = Math.random();\n        if (position < 0.5) {\n          // 50% chance: top-left\n          startX = Math.random() * (width * 0.35);\n        } else if (position < 0.85) {\n          // 35% chance: top-center\n          startX = width * 0.35 + Math.random() * (width * 0.35);\n        } else {\n          // 15% chance: top-right\n          startX = width * 0.7 + Math.random() * (width * 0.3);\n        }\n      }\n\n      // Start slightly above the screen\n      const startY = Math.random() * -100 - 50;\n\n      // Calculate distance meteor will travel based on angle and screen dimensions\n      const distanceToTravel = height * journeyCompletion / Math.cos(angle);\n\n      // Calculate end position using angle\n      let endX, endY;\n      if (meteorDirection === 'left' || direction === 'top') {\n        // Meteor moves from left to right (or top to bottom-right for 'top' direction)\n        endX = startX + distanceToTravel * Math.sin(angle);\n        endY = startY + distanceToTravel * Math.cos(angle);\n      } else {\n        // Meteor moves from right to left\n        endX = startX - distanceToTravel * Math.sin(angle);\n        endY = startY + distanceToTravel * Math.cos(angle);\n      }\n      return {\n        pathType: 'linear',\n        start: {\n          x: startX,\n          y: startY\n        },\n        end: {\n          x: endX,\n          y: endY\n        },\n        direction: meteorDirection\n      };\n    }\n  }, [mode, direction, baseAngle, angleVariation, journeyCompletion]);\n\n  // Calculate position along a path - optimized implementation\n  const getPathPoint = useCallback((t, path, outPoint = {\n    x: 0,\n    y: 0\n  }) => {\n    if (path.pathType === 'arc') {\n      // Optimized quadratic bezier calculation\n      const invT = 1 - t;\n      const invTSquared = invT * invT;\n      const tSquared = t * t;\n      const termA = invTSquared;\n      const termB = 2 * invT * t;\n      const termC = tSquared;\n      outPoint.x = termA * path.start.x + termB * path.control.x + termC * path.end.x;\n      outPoint.y = termA * path.start.y + termB * path.control.y + termC * path.end.y;\n      return outPoint;\n    } else {\n      // Optimized linear interpolation\n      outPoint.x = path.start.x + (path.end.x - path.start.x) * t;\n      outPoint.y = path.start.y + (path.end.y - path.start.y) * t;\n      return outPoint;\n    }\n  }, []);\n\n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current || !containerRef.current) return false;\n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    const rect = container.getBoundingClientRect();\n    const pixelRatio = window.devicePixelRatio || 1;\n\n    // Adjust for pixel density (Retina/high-DPI displays)\n    const displayWidth = rect.width;\n    const displayHeight = typeof height === 'string' && height.endsWith('vh') ? parseInt(height, 10) / 100 * window.innerHeight : parseInt(height, 10) || window.innerHeight;\n\n    // Set canvas rendering size (accounting for pixel ratio)\n    canvas.width = displayWidth * pixelRatio;\n    canvas.height = displayHeight * pixelRatio;\n\n    // Set display size via CSS\n    canvas.style.width = `${displayWidth}px`;\n    canvas.style.height = `${displayHeight}px`;\n\n    // Get and configure context\n    const ctx = canvas.getContext('2d', {\n      alpha: true,\n      desynchronized: true,\n      // Enable desynchronized context for better performance\n      willReadFrequently: false\n    });\n\n    // Set high-quality rendering with proper scaling\n    ctx.scale(pixelRatio, pixelRatio);\n\n    // Enable high-quality anti-aliasing and better gamma handling\n    if (ctx.imageSmoothingEnabled !== undefined) {\n      ctx.imageSmoothingEnabled = true;\n      ctx.imageSmoothingQuality = 'high';\n    }\n\n    // Store the context for later use\n    ctxRef.current = ctx;\n    setDimensions({\n      width: displayWidth,\n      height: displayHeight,\n      pixelRatio\n    });\n    return true;\n  }, [height]);\n\n  // Setup canvas resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Create a ResizeObserver to detect container size changes\n    const resizeObserver = new ResizeObserver(() => {\n      // Use requestAnimationFrame to avoid simultaneous layout and rendering\n      requestAnimationFrame(() => {\n        if (setupCanvas()) {\n          setIsInitialized(true);\n        }\n      });\n    });\n\n    // Start observing the container\n    resizeObserver.observe(containerRef.current);\n    resizeObserverRef.current = resizeObserver;\n\n    // Initial setup\n    setupCanvas();\n    setIsInitialized(true);\n    return () => {\n      if (resizeObserverRef.current) {\n        resizeObserverRef.current.disconnect();\n      }\n    };\n  }, [setupCanvas]);\n\n  // Setup intersection observer to only animate when visible\n  useEffect(() => {\n    if (!containerRef.current) return;\n    const observer = new IntersectionObserver(entries => {\n      // Use the most recent entry\n      const entry = entries[entries.length - 1];\n      setIsVisible(entry.isIntersecting);\n    }, {\n      threshold: 0.01,\n      rootMargin: '100px'\n    });\n    observer.observe(containerRef.current);\n    return () => {\n      observer.disconnect();\n    };\n  }, []);\n\n  // Handle parallax effect on scroll if enabled\n  useEffect(() => {\n    if (!enableParallax) return;\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    window.addEventListener('scroll', handleScroll);\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [enableParallax]);\n\n  // Initialize meteor with pooling\n  const initializeMeteor = useCallback(() => {\n    const {\n      width,\n      height\n    } = dimensions;\n    if (!width || !height) return null;\n\n    // Calculate path based on mode\n    const path = calculateMeteorPath(width, height);\n\n    // Randomize meteor properties\n    const baseSpeed = meteorSpeed * (Math.random() * 0.5 + 0.75);\n\n    // Use optimal array for storing positions\n    // Pre-allocate the array with the right size to avoid resizing\n    const positions = Array(adaptedSettings.trailSegments);\n    for (let i = 0; i < adaptedSettings.trailSegments; i++) {\n      positions[i] = {\n        x: path.start.x,\n        y: path.start.y\n      };\n    }\n    return {\n      path,\n      progress: 0,\n      size: Math.random() * (meteorMaxSize - meteorMinSize) + meteorMinSize,\n      speed: baseSpeed,\n      active: true,\n      positions,\n      opacity: Math.random() * 0.3 + 0.7,\n      fadeThreshold: 0.7 + Math.random() * 0.2,\n      // When to start fading (70-90% of journey)\n      pulsePhase: Math.random() * Math.PI * 2,\n      pulseSpeed: Math.random() * 0.01 + 0.005\n    };\n  }, [dimensions, meteorSpeed, meteorMinSize, meteorMaxSize, calculateMeteorPath, adaptedSettings.trailSegments]);\n\n  // FPS limiter for consistent animation speed\n  const fpsLimiter = useCallback((timestamp, callback) => {\n    const targetFrameTime = 1000 / maxFPS;\n    const elapsed = timestamp - lastTimestampRef.current;\n    if (elapsed >= targetFrameTime) {\n      lastTimestampRef.current = timestamp - elapsed % targetFrameTime;\n      callback(elapsed);\n\n      // FPS calculation for debug and adaptive quality\n      frameCountRef.current++;\n      if (timestamp - fpsTimestampRef.current >= 1000) {\n        currentFpsRef.current = frameCountRef.current;\n        frameCountRef.current = 0;\n        fpsTimestampRef.current = timestamp;\n\n        // Adjust quality based on FPS if adaptive quality is enabled\n        if (adaptiveQuality && debug) {\n          console.log(`Current FPS: ${currentFpsRef.current}, Quality Factor: ${qualityFactor}`);\n        }\n      }\n    }\n    animationFrameRef.current = requestAnimationFrame(nextTimestamp => {\n      fpsLimiter(nextTimestamp, callback);\n    });\n  }, [maxFPS, adaptiveQuality, debug, qualityFactor]);\n\n  // Draw a meteor with optimized rendering\n  const drawMeteor = useCallback((ctx, meteor, timestamp, deltaTime, parallaxOffset) => {\n    // Calculate opacity based on progress\n    // Start fading out after reaching the fadeThreshold\n    let currentOpacity = meteor.opacity;\n    if (meteor.progress > meteor.fadeThreshold) {\n      // Map progress from fadeThreshold-1.0 to 1.0-0.0 for opacity\n      const fadeProgress = (meteor.progress - meteor.fadeThreshold) / (1 - meteor.fadeThreshold);\n      currentOpacity = meteor.opacity * (1 - fadeProgress);\n    }\n\n    // Apply pulse/flicker effect\n    const timeFactor = timestamp * 0.001;\n    const pulseEffect = Math.sin(timeFactor * meteor.pulseSpeed + meteor.pulsePhase) * 0.2 + 0.8;\n\n    // Adjust for parallax if enabled\n    const adjustY = enableParallax ? parallaxOffset * (meteor.size / meteorMaxSize) : 0;\n\n    // Get starting opacity and width for optimization\n    let segmentOpacity, segmentWidth;\n\n    // Batch shadow operations to improve performance\n    ctx.shadowColor = glowColor;\n    ctx.shadowBlur = meteor.size * 3 * pulseEffect;\n    ctx.lineCap = 'round';\n\n    // Draw trail segments in reverse for proper layering\n    // This is more efficient than changing globalCompositeOperation\n    for (let i = meteor.positions.length - 2; i >= 0; i--) {\n      const pos1 = meteor.positions[i];\n      const pos2 = meteor.positions[i + 1];\n      if (!pos1 || !pos2) continue;\n\n      // Calculate segment opacity (decreases along the trail)\n      segmentOpacity = currentOpacity * (1 - i / meteor.positions.length) * pulseEffect;\n\n      // Skip if nearly invisible\n      if (segmentOpacity < 0.02) continue;\n\n      // Calculate segment width (decreases along the trail)\n      segmentWidth = meteor.size * (1 - i / meteor.positions.length * 0.7);\n\n      // Draw line segment\n      ctx.beginPath();\n      ctx.moveTo(pos1.x, pos1.y + adjustY);\n      ctx.lineTo(pos2.x, pos2.y + adjustY);\n\n      // Set line style\n      ctx.lineWidth = segmentWidth;\n      ctx.strokeStyle = getCachedColor(trailColor, segmentOpacity);\n      ctx.stroke();\n    }\n\n    // Draw meteor head (brightest part)\n    if (meteor.positions[0]) {\n      const headPos = meteor.positions[0];\n\n      // Set shadow/glow for head\n      ctx.shadowColor = glowColor;\n      ctx.shadowBlur = meteor.size * 5 * pulseEffect;\n\n      // Draw outer glow\n      ctx.beginPath();\n      ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 1.5, 0, Math.PI * 2);\n      ctx.fillStyle = getCachedColor(glowColor, currentOpacity * 0.7 * pulseEffect);\n      ctx.fill();\n\n      // Draw inner core\n      ctx.beginPath();\n      ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 0.7, 0, Math.PI * 2);\n      ctx.fillStyle = getCachedColor(coreColor, currentOpacity * pulseEffect);\n      ctx.fill();\n    }\n  }, [enableParallax, meteorMaxSize, glowColor, trailColor, coreColor, getCachedColor]);\n\n  // Main animation loop\n  useEffect(() => {\n    if (!active || !isInitialized || !isVisible || !dimensions.width || !dimensions.height) {\n      return;\n    }\n    if (respectReducedMotion && prefersReducedMotion) {\n      // Skip animation if user prefers reduced motion\n      return;\n    }\n    const ctx = ctxRef.current;\n    if (!ctx) return;\n\n    // Animation handler function\n    const handleAnimation = deltaTime => {\n      const width = dimensions.width;\n      const height = dimensions.height;\n\n      // Initialize lastTimestamp on first run\n      if (lastTimestampRef.current === 0) {\n        nextSpawnTimeRef.current = performance.now();\n      }\n\n      // Apply parallax offset\n      let parallaxOffset = 0;\n      if (enableParallax) {\n        parallaxOffset = scrollPositionRef.current * parallaxIntensity;\n      }\n\n      // Clear canvas - optimize by only clearing the used portion\n      ctx.clearRect(0, 0, width, height);\n\n      // Debug mode - draw canvas bounds\n      if (debug) {\n        ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n        ctx.lineWidth = 2;\n        ctx.strokeRect(0, 0, width, height);\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n        ctx.font = '12px monospace';\n        ctx.fillText(`Canvas: ${width}Ã${height}`, 10, 20);\n        ctx.fillText(`Meteors: ${meteorsRef.current.length}/${adaptedSettings.meteorDensity}`, 10, 40);\n        ctx.fillText(`Mode: ${mode}`, 10, 60);\n        ctx.fillText(`Direction: ${direction}`, 10, 80);\n        ctx.fillText(`FPS: ${currentFpsRef.current}`, 10, 100);\n        ctx.fillText(`Quality: ${qualityFactor.toFixed(2)}`, 10, 120);\n        if (staggered) {\n          ctx.fillText(`Next Spawn: ${Math.max(0, (nextSpawnTimeRef.current - performance.now()) / 1000).toFixed(2)}s`, 10, 140);\n        }\n      }\n\n      // Spawn new meteors if needed, with staggering if enabled\n      const now = performance.now();\n      if (meteorsRef.current.length < adaptedSettings.meteorDensity) {\n        const canSpawnNow = !staggered || now >= nextSpawnTimeRef.current;\n        if (canSpawnNow) {\n          const newMeteor = initializeMeteor();\n          if (newMeteor) {\n            meteorsRef.current.push(newMeteor);\n\n            // If staggering is enabled, set the next spawn time\n            if (staggered) {\n              const delay = Math.random() * (maxStaggerDelay - minStaggerDelay) + minStaggerDelay;\n              nextSpawnTimeRef.current = now + delay;\n            }\n          }\n        }\n      }\n\n      // Object pool for position calculations to reduce garbage collection\n      const segment = {\n        x: 0,\n        y: 0\n      };\n\n      // Update and draw meteors\n      let i = 0;\n      while (i < meteorsRef.current.length) {\n        const meteor = meteorsRef.current[i];\n\n        // Skip if not active\n        if (!meteor.active) {\n          meteorsRef.current.splice(i, 1);\n          continue;\n        }\n\n        // Update progress based on speed and delta time\n        meteor.progress += meteor.speed * (deltaTime / 1000);\n\n        // Check if meteor has completed its path\n        if (meteor.progress >= 1) {\n          meteorsRef.current.splice(i, 1);\n          continue;\n        }\n\n        // Calculate current position along the path\n        const currentPos = getPathPoint(Math.min(1, meteor.progress), meteor.path, segment);\n\n        // Update position history (for trail) using object pooling\n        // Create a new point object to store the current position\n        const newPos = {\n          x: currentPos.x,\n          y: currentPos.y\n        };\n\n        // Shift positions array - this is more efficient than splice/unshift\n        for (let j = meteor.positions.length - 1; j > 0; j--) {\n          meteor.positions[j] = meteor.positions[j - 1];\n        }\n        meteor.positions[0] = newPos;\n\n        // Draw the meteor\n        drawMeteor(ctx, meteor, now, deltaTime, parallaxOffset);\n\n        // Move to next meteor\n        i++;\n      }\n    };\n\n    // Start animation with FPS limiter\n    fpsTimestampRef.current = performance.now();\n    frameCountRef.current = 0;\n    lastTimestampRef.current = 0;\n    animationFrameRef.current = requestAnimationFrame(timestamp => {\n      fpsLimiter(timestamp, handleAnimation);\n    });\n\n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [active, isInitialized, isVisible, dimensions, mode, direction, enableParallax, parallaxIntensity, staggered, minStaggerDelay, maxStaggerDelay, trailSegments, getPathPoint, initializeMeteor, fpsLimiter, drawMeteor, debug, prefersReducedMotion, respectReducedMotion, adaptedSettings.meteorDensity, qualityFactor]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: height,\n      overflow: 'hidden',\n      pointerEvents: 'none',\n      zIndex: zIndex,\n      // Hardware acceleration\n      backfaceVisibility: 'hidden',\n      transform: 'translateZ(0)',\n      willChange: 'transform'\n    },\n    \"aria-hidden\": \"true\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        // Additional rendering optimizations\n        imageRendering: 'high-quality',\n        // Hardware acceleration\n        backfaceVisibility: 'hidden',\n        transform: 'translateZ(0)',\n        willChange: 'transform'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 741,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 723,\n    columnNumber: 5\n  }, this);\n};\n\n/**\n * GoldenMeteorShower Component\n * \n * A preset version of the MeteorShower with a golden/amber color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_s(MeteorShower, \"5/2Y0dFANkiuQyoe51g0x0Tpvxk=\");\n_c = MeteorShower;\nexport const GoldenMeteorShower = props => {\n  const goldenPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 253, 227, 0.9)',\n    trailColor: 'rgba(191, 173, 127, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 200,\n    maxStaggerDelay: 2000\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...goldenPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 784,\n    columnNumber: 10\n  }, this);\n};\n\n/**\n * CelestialMeteorShower Component\n * \n * A preset version of the MeteorShower with a bluish-purple color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c2 = GoldenMeteorShower;\nexport const CelestialMeteorShower = props => {\n  const celestialPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(220, 225, 255, 0.9)',\n    trailColor: 'rgba(150, 160, 255, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 300,\n    maxStaggerDelay: 1800\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...celestialPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 810,\n    columnNumber: 10\n  }, this);\n};\n\n/**\n * EmeraldMeteorShower Component\n * \n * A preset version of the MeteorShower with a green color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c3 = CelestialMeteorShower;\nexport const EmeraldMeteorShower = props => {\n  const emeraldPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(215, 255, 230, 0.9)',\n    trailColor: 'rgba(100, 220, 150, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 250,\n    maxStaggerDelay: 1500\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...emeraldPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 836,\n    columnNumber: 10\n  }, this);\n};\n\n/**\n * RubyMeteorShower Component\n * \n * A preset version of the MeteorShower with a red color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c4 = EmeraldMeteorShower;\nexport const RubyMeteorShower = props => {\n  const rubyPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 200, 200, 0.9)',\n    trailColor: 'rgba(220, 100, 100, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 350,\n    maxStaggerDelay: 2200\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...rubyPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 862,\n    columnNumber: 10\n  }, this);\n};\n\n/**\n * ClassicMeteorShower Component\n * \n * A preset version of the MeteorShower with linear paths for a more traditional meteor shower effect.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c5 = RubyMeteorShower;\nexport const ClassicMeteorShower = props => {\n  const classicPreset = {\n    mode: 'linear',\n    direction: 'both',\n    baseAngle: 30,\n    angleVariation: 15,\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.12,\n    trailLength: 200,\n    trailSegments: 25,\n    journeyCompletion: 0.95,\n    staggered: true,\n    minStaggerDelay: 100,\n    maxStaggerDelay: 1000\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...classicPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 889,\n    columnNumber: 10\n  }, this);\n};\n/**\n * TopMeteorShower Component\n * \n * A preset version of the MeteorShower with meteors falling from the top of the screen\n * at a consistent 30-degree angle, distributed with emphasis on left and center areas.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c6 = ClassicMeteorShower;\nexport const TopMeteorShower = props => {\n  const topPreset = {\n    mode: 'linear',\n    direction: 'top',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.12,\n    trailLength: 200,\n    trailSegments: 25,\n    journeyCompletion: 0.95,\n    staggered: true,\n    minStaggerDelay: 100,\n    maxStaggerDelay: 1000\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...topPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 914,\n    columnNumber: 10\n  }, this);\n};\n_c7 = TopMeteorShower;\nexport default MeteorShower;\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7;\n$RefreshReg$(_c, \"MeteorShower\");\n$RefreshReg$(_c2, \"GoldenMeteorShower\");\n$RefreshReg$(_c3, \"CelestialMeteorShower\");\n$RefreshReg$(_c4, \"EmeraldMeteorShower\");\n$RefreshReg$(_c5, \"RubyMeteorShower\");\n$RefreshReg$(_c6, \"ClassicMeteorShower\");\n$RefreshReg$(_c7, \"TopMeteorShower\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useCallback","useMemo","jsxDEV","_jsxDEV","MeteorShower","height","zIndex","active","meteorDensity","meteorMinSize","meteorMaxSize","meteorSpeed","trailLength","trailSegments","coreColor","glowColor","trailColor","enableParallax","parallaxIntensity","staggered","minStaggerDelay","maxStaggerDelay","journeyCompletion","mode","direction","baseAngle","angleVariation","debug","adaptiveQuality","respectReducedMotion","maxFPS","_s","containerRef","canvasRef","ctxRef","meteorsRef","animationFrameRef","lastTimestampRef","fpsTimestampRef","frameCountRef","currentFpsRef","nextSpawnTimeRef","scrollPositionRef","resizeObserverRef","dimensions","setDimensions","width","pixelRatio","isInitialized","setIsInitialized","prefersReducedMotion","setPrefersReducedMotion","isVisible","setIsVisible","qualityFactor","setQualityFactor","pointCache","current","x","y","segment","colorCacheRef","Map","getCachedColor","baseColor","opacity","roundedOpacity","Math","round","key","has","newColor","replace","set","get","reducedMotionQuery","window","matchMedia","matches","handleReducedMotionChange","e","addEventListener","detectQuality","memory","navigator","deviceMemory","cores","hardwareConcurrency","devicePixelRatio","performanceScore","quality","test","userAgent","removeEventListener","adaptedSettings","max","floor","calculateMeteorPath","startX","random","startY","curveDirection","curveIntensity","endX","endY","controlX","controlY","pathType","start","control","end","meteorDirection","angle","PI","position","distanceToTravel","cos","sin","getPathPoint","t","path","outPoint","invT","invTSquared","tSquared","termA","termB","termC","setupCanvas","canvas","container","rect","getBoundingClientRect","displayWidth","displayHeight","endsWith","parseInt","innerHeight","style","ctx","getContext","alpha","desynchronized","willReadFrequently","scale","imageSmoothingEnabled","undefined","imageSmoothingQuality","resizeObserver","ResizeObserver","requestAnimationFrame","observe","disconnect","observer","IntersectionObserver","entries","entry","length","isIntersecting","threshold","rootMargin","handleScroll","scrollY","initializeMeteor","baseSpeed","positions","Array","i","progress","size","speed","fadeThreshold","pulsePhase","pulseSpeed","fpsLimiter","timestamp","callback","targetFrameTime","elapsed","console","log","nextTimestamp","drawMeteor","meteor","deltaTime","parallaxOffset","currentOpacity","fadeProgress","timeFactor","pulseEffect","adjustY","segmentOpacity","segmentWidth","shadowColor","shadowBlur","lineCap","pos1","pos2","beginPath","moveTo","lineTo","lineWidth","strokeStyle","stroke","headPos","arc","fillStyle","fill","handleAnimation","performance","now","clearRect","strokeRect","font","fillText","toFixed","canSpawnNow","newMeteor","push","delay","splice","currentPos","min","newPos","j","cancelAnimationFrame","ref","top","left","overflow","pointerEvents","backfaceVisibility","transform","willChange","children","imageRendering","fileName","_jsxFileName","lineNumber","columnNumber","_c","GoldenMeteorShower","props","goldenPreset","_c2","CelestialMeteorShower","celestialPreset","_c3","EmeraldMeteorShower","emeraldPreset","_c4","RubyMeteorShower","rubyPreset","_c5","ClassicMeteorShower","classicPreset","_c6","TopMeteorShower","topPreset","_c7","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/MeteorShower.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';\n\n/**\n * MeteorShower Component - Performance Optimized Version\n * \n * Creates an animated meteor shower effect where meteors arc across the sky\n * with comet-like trails and fade away naturally.\n * Features staggered appearance and configurable journey completion.\n * \n * @param {Object} props - Component props\n * @param {string|number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=5] - Z-index for the container\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.meteorDensity=15] - Number of meteors to maintain on screen\n * @param {number} [props.meteorMinSize=1] - Minimum size of meteors\n * @param {number} [props.meteorMaxSize=3] - Maximum size of meteors\n * @param {number} [props.meteorSpeed=0.08] - Base speed of meteors\n * @param {number} [props.trailLength=180] - Length of meteor trails\n * @param {number} [props.trailSegments=20] - Number of segments in each trail\n * @param {string} [props.coreColor='rgba(255, 255, 255, 1)'] - Core color for meteors\n * @param {string} [props.glowColor='rgba(255, 253, 227, 0.9)'] - Glow color for meteors\n * @param {string} [props.trailColor='rgba(191, 173, 127, 0.8)'] - Trail color for meteors\n * @param {boolean} [props.enableParallax=false] - Enable parallax effect on scroll\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of parallax effect\n * @param {boolean} [props.staggered=true] - Enable staggered meteor appearance\n * @param {number} [props.minStaggerDelay=200] - Minimum delay between meteor spawns (ms)\n * @param {number} [props.maxStaggerDelay=2000] - Maximum delay between meteor spawns (ms)\n * @param {number} [props.journeyCompletion=0.9] - When meteors complete their journey (0-1, where 1 is the container height)\n * @param {string} [props.mode='arc'] - Animation mode: 'arc' (curved paths) or 'linear' (straight angled paths)\n * @param {string} [props.direction='both'] - Direction for linear mode: 'left', 'right', 'both', or 'top'\n * @param {number} [props.baseAngle=30] - Base angle for linear meteors (degrees)\n * @param {number} [props.angleVariation=15] - Random variation to apply to the base angle (Â±degrees)\n * @param {boolean} [props.debug=false] - Enable debug visualization\n * @param {boolean} [props.adaptiveQuality=true] - Enable adaptive quality based on device performance\n * @param {boolean} [props.respectReducedMotion=true] - Respect user's reduced motion preferences\n * @param {number} [props.maxFPS=60] - Target maximum frames per second\n */\nconst MeteorShower = ({\n  height = '100vh',\n  zIndex = 5,\n  active = true,\n  meteorDensity = 15,\n  meteorMinSize = 1,\n  meteorMaxSize = 3,\n  meteorSpeed = 0.08,\n  trailLength = 180,\n  trailSegments = 20,\n  coreColor = 'rgba(255, 255, 255, 1)',\n  glowColor = 'rgba(255, 253, 227, 0.9)',\n  trailColor = 'rgba(191, 173, 127, 0.8)',\n  enableParallax = false,\n  parallaxIntensity = 0.2,\n  staggered = true,\n  minStaggerDelay = 200,\n  maxStaggerDelay = 2000,\n  journeyCompletion = 0.9,\n  mode = 'arc',\n  direction = 'both',\n  baseAngle = 30,\n  angleVariation = 15,\n  debug = false,\n  adaptiveQuality = true,\n  respectReducedMotion = true,\n  maxFPS = 60\n}) => {\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const ctxRef = useRef(null);\n  const meteorsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const fpsTimestampRef = useRef(0);\n  const frameCountRef = useRef(0);\n  const currentFpsRef = useRef(60);\n  const nextSpawnTimeRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n  const resizeObserverRef = useRef(null);\n  \n  // Component state\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0, pixelRatio: 1 });\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [isVisible, setIsVisible] = useState(false);\n  const [qualityFactor, setQualityFactor] = useState(1);\n  \n  // Pre-allocate objects to avoid garbage collection during animation\n  const pointCache = useRef({\n    current: { x: 0, y: 0 },\n    segment: { x: 0, y: 0 }\n  }).current;\n  \n  // Precompute color variants to avoid string operations during animation\n  const colorCacheRef = useRef(new Map());\n  \n  // Get cached color with opacity\n  const getCachedColor = useCallback((baseColor, opacity) => {\n    // Round opacity to reduce cache size while maintaining visual quality\n    const roundedOpacity = Math.round(opacity * 100) / 100;\n    const key = `${baseColor}-${roundedOpacity}`;\n    \n    if (!colorCacheRef.current.has(key)) {\n      const newColor = baseColor.replace(/[\\d.]+\\)$/, roundedOpacity + ')');\n      colorCacheRef.current.set(key, newColor);\n    }\n    \n    return colorCacheRef.current.get(key);\n  }, []);\n  \n  // Detect device capabilities and preferences\n  useEffect(() => {\n    // Check for reduced motion preference\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    \n    const handleReducedMotionChange = (e) => {\n      setPrefersReducedMotion(e.matches);\n    };\n    \n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n    \n    // Detect quality level based on device\n    const detectQuality = () => {\n      // Use a combination of device memory, hardware concurrency, and pixel ratio to estimate performance\n      const memory = navigator.deviceMemory || 4; // Default to 4GB if not available\n      const cores = navigator.hardwareConcurrency || 4; // Default to 4 cores\n      const pixelRatio = window.devicePixelRatio || 1;\n      \n      // Calculate performance score\n      const performanceScore = (memory * cores) / pixelRatio;\n      \n      // Scale quality based on performance score\n      let quality = 1;\n      \n      if (performanceScore > 16) {\n        quality = 1; // High-end devices: full quality\n      } else if (performanceScore > 8) {\n        quality = 0.8; // Mid-range devices: 80% quality\n      } else if (performanceScore > 4) {\n        quality = 0.6; // Low-end devices: 60% quality\n      } else {\n        quality = 0.4; // Very low-end: 40% quality\n      }\n      \n      // Check if it's a mobile device and reduce quality further if needed\n      if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {\n        quality *= 0.8;\n      }\n      \n      return quality;\n    };\n    \n    if (adaptiveQuality) {\n      setQualityFactor(detectQuality());\n    }\n    \n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n    };\n  }, [adaptiveQuality]);\n  \n  // Apply adaptive quality settings\n  const adaptedSettings = useMemo(() => {\n    if (!adaptiveQuality || qualityFactor === 1) {\n      return {\n        meteorDensity,\n        trailSegments\n      };\n    }\n    \n    // Adjust quality-dependent parameters\n    return {\n      meteorDensity: Math.max(3, Math.floor(meteorDensity * qualityFactor)),\n      trailSegments: Math.max(5, Math.floor(trailSegments * qualityFactor))\n    };\n  }, [adaptiveQuality, qualityFactor, meteorDensity, trailSegments]);\n  \n  // Calculate path parameters for a meteor based on selected mode\n  const calculateMeteorPath = useCallback((width, height) => {\n    if (mode === 'arc') {\n      // Original arc path logic\n      // Start point: somewhere along the top of the canvas with randomization\n      const startX = Math.random() * width * 1.5 - width * 0.25;\n      \n      // Control how far meteors can start from outside the visible area\n      const startY = Math.random() * -100 - 50;\n      \n      // Randomize arc curvature and direction\n      const curveDirection = Math.random() > 0.5 ? 1 : -1;\n      const curveIntensity = Math.random() * 0.4 + 0.2;\n      \n      // Calculate control points for quadratic path\n      // End point: adjusted to complete journey according to journeyCompletion parameter\n      const endX = startX + (curveDirection * width * curveIntensity);\n      const endY = height * journeyCompletion;\n      \n      // Control point: creates the arc shape\n      const controlX = (startX + endX) / 2 + (curveDirection * width * curveIntensity);\n      const controlY = (startY + endY) * 0.5;\n      \n      return {\n        pathType: 'arc',\n        start: { x: startX, y: startY },\n        control: { x: controlX, y: controlY },\n        end: { x: endX, y: endY }\n      };\n    } else if (mode === 'linear') {\n      // Linear path logic for traditional meteor shower\n      \n      // Determine direction (from left, right, top, or random)\n      let meteorDirection = direction;\n      if (direction === 'both') {\n        meteorDirection = Math.random() > 0.5 ? 'left' : 'right';\n      }\n      \n      // Calculate angle with variation (convert to radians)\n      let angle;\n      \n      if (direction === 'top') {\n        // For 'top' direction, maintain consistent 30 degree downward angle to the right\n        // with minimal variation to keep them all falling in a similar direction\n        angle = ((30 + (Math.random() * 2 - 1) * 5) * Math.PI) / 180;\n      } else {\n        angle = ((baseAngle + (Math.random() * 2 - 1) * angleVariation) * Math.PI) / 180;\n      }\n      \n      // Set starting positions based on direction\n      let startX;\n      if (meteorDirection === 'left') {\n        // Start from top-left portion of the screen\n        startX = Math.random() * (width * 0.3) - (width * 0.1);\n      } else if (meteorDirection === 'right') {\n        // Start from top-right portion of the screen\n        startX = width - Math.random() * (width * 0.3) + (width * 0.1);\n      } else if (direction === 'top') {\n        // For 'top' direction, distribute meteors across the top with emphasis on left and center\n        const position = Math.random();\n        if (position < 0.5) {\n          // 50% chance: top-left\n          startX = Math.random() * (width * 0.35);\n        } else if (position < 0.85) {\n          // 35% chance: top-center\n          startX = width * 0.35 + Math.random() * (width * 0.35);\n        } else {\n          // 15% chance: top-right\n          startX = width * 0.7 + Math.random() * (width * 0.3);\n        }\n      }\n      \n      // Start slightly above the screen\n      const startY = Math.random() * -100 - 50;\n      \n      // Calculate distance meteor will travel based on angle and screen dimensions\n      const distanceToTravel = (height * journeyCompletion) / Math.cos(angle);\n      \n      // Calculate end position using angle\n      let endX, endY;\n      if (meteorDirection === 'left' || direction === 'top') {\n        // Meteor moves from left to right (or top to bottom-right for 'top' direction)\n        endX = startX + distanceToTravel * Math.sin(angle);\n        endY = startY + distanceToTravel * Math.cos(angle);\n      } else {\n        // Meteor moves from right to left\n        endX = startX - distanceToTravel * Math.sin(angle);\n        endY = startY + distanceToTravel * Math.cos(angle);\n      }\n      \n      return {\n        pathType: 'linear',\n        start: { x: startX, y: startY },\n        end: { x: endX, y: endY },\n        direction: meteorDirection\n      };\n    }\n  }, [mode, direction, baseAngle, angleVariation, journeyCompletion]);\n  \n  // Calculate position along a path - optimized implementation\n  const getPathPoint = useCallback((t, path, outPoint = { x: 0, y: 0 }) => {\n    if (path.pathType === 'arc') {\n      // Optimized quadratic bezier calculation\n      const invT = 1 - t;\n      const invTSquared = invT * invT;\n      const tSquared = t * t;\n      const termA = invTSquared;\n      const termB = 2 * invT * t;\n      const termC = tSquared;\n      \n      outPoint.x = termA * path.start.x + termB * path.control.x + termC * path.end.x;\n      outPoint.y = termA * path.start.y + termB * path.control.y + termC * path.end.y;\n      return outPoint;\n    } else {\n      // Optimized linear interpolation\n      outPoint.x = path.start.x + (path.end.x - path.start.x) * t;\n      outPoint.y = path.start.y + (path.end.y - path.start.y) * t;\n      return outPoint;\n    }\n  }, []);\n  \n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current || !containerRef.current) return false;\n    \n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    const rect = container.getBoundingClientRect();\n    const pixelRatio = window.devicePixelRatio || 1;\n    \n    // Adjust for pixel density (Retina/high-DPI displays)\n    const displayWidth = rect.width;\n    const displayHeight = typeof height === 'string' && height.endsWith('vh') \n      ? (parseInt(height, 10) / 100) * window.innerHeight\n      : parseInt(height, 10) || window.innerHeight;\n      \n    // Set canvas rendering size (accounting for pixel ratio)\n    canvas.width = displayWidth * pixelRatio;\n    canvas.height = displayHeight * pixelRatio;\n    \n    // Set display size via CSS\n    canvas.style.width = `${displayWidth}px`;\n    canvas.style.height = `${displayHeight}px`;\n    \n    // Get and configure context\n    const ctx = canvas.getContext('2d', {\n      alpha: true,\n      desynchronized: true, // Enable desynchronized context for better performance\n      willReadFrequently: false\n    });\n    \n    // Set high-quality rendering with proper scaling\n    ctx.scale(pixelRatio, pixelRatio);\n    \n    // Enable high-quality anti-aliasing and better gamma handling\n    if (ctx.imageSmoothingEnabled !== undefined) {\n      ctx.imageSmoothingEnabled = true;\n      ctx.imageSmoothingQuality = 'high';\n    }\n    \n    // Store the context for later use\n    ctxRef.current = ctx;\n    \n    setDimensions({\n      width: displayWidth,\n      height: displayHeight,\n      pixelRatio\n    });\n    \n    return true;\n  }, [height]);\n  \n  // Setup canvas resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n    \n    // Create a ResizeObserver to detect container size changes\n    const resizeObserver = new ResizeObserver(() => {\n      // Use requestAnimationFrame to avoid simultaneous layout and rendering\n      requestAnimationFrame(() => {\n        if (setupCanvas()) {\n          setIsInitialized(true);\n        }\n      });\n    });\n    \n    // Start observing the container\n    resizeObserver.observe(containerRef.current);\n    resizeObserverRef.current = resizeObserver;\n    \n    // Initial setup\n    setupCanvas();\n    setIsInitialized(true);\n    \n    return () => {\n      if (resizeObserverRef.current) {\n        resizeObserverRef.current.disconnect();\n      }\n    };\n  }, [setupCanvas]);\n  \n  // Setup intersection observer to only animate when visible\n  useEffect(() => {\n    if (!containerRef.current) return;\n    \n    const observer = new IntersectionObserver(\n      (entries) => {\n        // Use the most recent entry\n        const entry = entries[entries.length - 1];\n        setIsVisible(entry.isIntersecting);\n      },\n      {\n        threshold: 0.01,\n        rootMargin: '100px'\n      }\n    );\n    \n    observer.observe(containerRef.current);\n    \n    return () => {\n      observer.disconnect();\n    };\n  }, []);\n  \n  // Handle parallax effect on scroll if enabled\n  useEffect(() => {\n    if (!enableParallax) return;\n    \n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    \n    window.addEventListener('scroll', handleScroll);\n    \n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [enableParallax]);\n  \n  // Initialize meteor with pooling\n  const initializeMeteor = useCallback(() => {\n    const { width, height } = dimensions;\n    \n    if (!width || !height) return null;\n    \n    // Calculate path based on mode\n    const path = calculateMeteorPath(width, height);\n    \n    // Randomize meteor properties\n    const baseSpeed = meteorSpeed * (Math.random() * 0.5 + 0.75);\n    \n    // Use optimal array for storing positions\n    // Pre-allocate the array with the right size to avoid resizing\n    const positions = Array(adaptedSettings.trailSegments);\n    for (let i = 0; i < adaptedSettings.trailSegments; i++) {\n      positions[i] = { x: path.start.x, y: path.start.y };\n    }\n    \n    return {\n      path,\n      progress: 0,\n      size: Math.random() * (meteorMaxSize - meteorMinSize) + meteorMinSize,\n      speed: baseSpeed,\n      active: true,\n      positions,\n      opacity: Math.random() * 0.3 + 0.7,\n      fadeThreshold: 0.7 + Math.random() * 0.2, // When to start fading (70-90% of journey)\n      pulsePhase: Math.random() * Math.PI * 2,\n      pulseSpeed: Math.random() * 0.01 + 0.005\n    };\n  }, [\n    dimensions,\n    meteorSpeed,\n    meteorMinSize,\n    meteorMaxSize,\n    calculateMeteorPath,\n    adaptedSettings.trailSegments\n  ]);\n  \n  // FPS limiter for consistent animation speed\n  const fpsLimiter = useCallback((timestamp, callback) => {\n    const targetFrameTime = 1000 / maxFPS;\n    const elapsed = timestamp - lastTimestampRef.current;\n    \n    if (elapsed >= targetFrameTime) {\n      lastTimestampRef.current = timestamp - (elapsed % targetFrameTime);\n      callback(elapsed);\n      \n      // FPS calculation for debug and adaptive quality\n      frameCountRef.current++;\n      if (timestamp - fpsTimestampRef.current >= 1000) {\n        currentFpsRef.current = frameCountRef.current;\n        frameCountRef.current = 0;\n        fpsTimestampRef.current = timestamp;\n        \n        // Adjust quality based on FPS if adaptive quality is enabled\n        if (adaptiveQuality && debug) {\n          console.log(`Current FPS: ${currentFpsRef.current}, Quality Factor: ${qualityFactor}`);\n        }\n      }\n    }\n    \n    animationFrameRef.current = requestAnimationFrame((nextTimestamp) => {\n      fpsLimiter(nextTimestamp, callback);\n    });\n  }, [maxFPS, adaptiveQuality, debug, qualityFactor]);\n  \n  // Draw a meteor with optimized rendering\n  const drawMeteor = useCallback((ctx, meteor, timestamp, deltaTime, parallaxOffset) => {\n    // Calculate opacity based on progress\n    // Start fading out after reaching the fadeThreshold\n    let currentOpacity = meteor.opacity;\n    if (meteor.progress > meteor.fadeThreshold) {\n      // Map progress from fadeThreshold-1.0 to 1.0-0.0 for opacity\n      const fadeProgress = (meteor.progress - meteor.fadeThreshold) / (1 - meteor.fadeThreshold);\n      currentOpacity = meteor.opacity * (1 - fadeProgress);\n    }\n    \n    // Apply pulse/flicker effect\n    const timeFactor = timestamp * 0.001;\n    const pulseEffect = Math.sin(timeFactor * meteor.pulseSpeed + meteor.pulsePhase) * 0.2 + 0.8;\n    \n    // Adjust for parallax if enabled\n    const adjustY = enableParallax ? parallaxOffset * (meteor.size / meteorMaxSize) : 0;\n    \n    // Get starting opacity and width for optimization\n    let segmentOpacity, segmentWidth;\n    \n    // Batch shadow operations to improve performance\n    ctx.shadowColor = glowColor;\n    ctx.shadowBlur = meteor.size * 3 * pulseEffect;\n    ctx.lineCap = 'round';\n    \n    // Draw trail segments in reverse for proper layering\n    // This is more efficient than changing globalCompositeOperation\n    for (let i = meteor.positions.length - 2; i >= 0; i--) {\n      const pos1 = meteor.positions[i];\n      const pos2 = meteor.positions[i + 1];\n      \n      if (!pos1 || !pos2) continue;\n      \n      // Calculate segment opacity (decreases along the trail)\n      segmentOpacity = currentOpacity * (1 - i / meteor.positions.length) * pulseEffect;\n      \n      // Skip if nearly invisible\n      if (segmentOpacity < 0.02) continue;\n      \n      // Calculate segment width (decreases along the trail)\n      segmentWidth = meteor.size * (1 - i / meteor.positions.length * 0.7);\n      \n      // Draw line segment\n      ctx.beginPath();\n      ctx.moveTo(pos1.x, pos1.y + adjustY);\n      ctx.lineTo(pos2.x, pos2.y + adjustY);\n      \n      // Set line style\n      ctx.lineWidth = segmentWidth;\n      ctx.strokeStyle = getCachedColor(trailColor, segmentOpacity);\n      ctx.stroke();\n    }\n    \n    // Draw meteor head (brightest part)\n    if (meteor.positions[0]) {\n      const headPos = meteor.positions[0];\n      \n      // Set shadow/glow for head\n      ctx.shadowColor = glowColor;\n      ctx.shadowBlur = meteor.size * 5 * pulseEffect;\n      \n      // Draw outer glow\n      ctx.beginPath();\n      ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 1.5, 0, Math.PI * 2);\n      ctx.fillStyle = getCachedColor(glowColor, currentOpacity * 0.7 * pulseEffect);\n      ctx.fill();\n      \n      // Draw inner core\n      ctx.beginPath();\n      ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 0.7, 0, Math.PI * 2);\n      ctx.fillStyle = getCachedColor(coreColor, currentOpacity * pulseEffect);\n      ctx.fill();\n    }\n  }, [\n    enableParallax, \n    meteorMaxSize, \n    glowColor, \n    trailColor, \n    coreColor,\n    getCachedColor\n  ]);\n  \n  // Main animation loop\n  useEffect(() => {\n    if (!active || !isInitialized || !isVisible || !dimensions.width || !dimensions.height) {\n      return;\n    }\n    \n    if (respectReducedMotion && prefersReducedMotion) {\n      // Skip animation if user prefers reduced motion\n      return;\n    }\n    \n    const ctx = ctxRef.current;\n    if (!ctx) return;\n    \n    // Animation handler function\n    const handleAnimation = (deltaTime) => {\n      const width = dimensions.width;\n      const height = dimensions.height;\n      \n      // Initialize lastTimestamp on first run\n      if (lastTimestampRef.current === 0) {\n        nextSpawnTimeRef.current = performance.now();\n      }\n      \n      // Apply parallax offset\n      let parallaxOffset = 0;\n      if (enableParallax) {\n        parallaxOffset = scrollPositionRef.current * parallaxIntensity;\n      }\n      \n      // Clear canvas - optimize by only clearing the used portion\n      ctx.clearRect(0, 0, width, height);\n      \n      // Debug mode - draw canvas bounds\n      if (debug) {\n        ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n        ctx.lineWidth = 2;\n        ctx.strokeRect(0, 0, width, height);\n        \n        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n        ctx.font = '12px monospace';\n        ctx.fillText(`Canvas: ${width}Ã${height}`, 10, 20);\n        ctx.fillText(`Meteors: ${meteorsRef.current.length}/${adaptedSettings.meteorDensity}`, 10, 40);\n        ctx.fillText(`Mode: ${mode}`, 10, 60);\n        ctx.fillText(`Direction: ${direction}`, 10, 80);\n        ctx.fillText(`FPS: ${currentFpsRef.current}`, 10, 100);\n        ctx.fillText(`Quality: ${qualityFactor.toFixed(2)}`, 10, 120);\n        if (staggered) {\n          ctx.fillText(`Next Spawn: ${Math.max(0, (nextSpawnTimeRef.current - performance.now()) / 1000).toFixed(2)}s`, 10, 140);\n        }\n      }\n      \n      // Spawn new meteors if needed, with staggering if enabled\n      const now = performance.now();\n      if (meteorsRef.current.length < adaptedSettings.meteorDensity) {\n        const canSpawnNow = !staggered || now >= nextSpawnTimeRef.current;\n        \n        if (canSpawnNow) {\n          const newMeteor = initializeMeteor();\n          if (newMeteor) {\n            meteorsRef.current.push(newMeteor);\n            \n            // If staggering is enabled, set the next spawn time\n            if (staggered) {\n              const delay = Math.random() * (maxStaggerDelay - minStaggerDelay) + minStaggerDelay;\n              nextSpawnTimeRef.current = now + delay;\n            }\n          }\n        }\n      }\n      \n      // Object pool for position calculations to reduce garbage collection\n      const segment = { x: 0, y: 0 };\n      \n      // Update and draw meteors\n      let i = 0;\n      while (i < meteorsRef.current.length) {\n        const meteor = meteorsRef.current[i];\n        \n        // Skip if not active\n        if (!meteor.active) {\n          meteorsRef.current.splice(i, 1);\n          continue;\n        }\n        \n        // Update progress based on speed and delta time\n        meteor.progress += meteor.speed * (deltaTime / 1000);\n        \n        // Check if meteor has completed its path\n        if (meteor.progress >= 1) {\n          meteorsRef.current.splice(i, 1);\n          continue;\n        }\n        \n        // Calculate current position along the path\n        const currentPos = getPathPoint(Math.min(1, meteor.progress), meteor.path, segment);\n        \n        // Update position history (for trail) using object pooling\n        // Create a new point object to store the current position\n        const newPos = { x: currentPos.x, y: currentPos.y };\n        \n        // Shift positions array - this is more efficient than splice/unshift\n        for (let j = meteor.positions.length - 1; j > 0; j--) {\n          meteor.positions[j] = meteor.positions[j - 1];\n        }\n        meteor.positions[0] = newPos;\n        \n        // Draw the meteor\n        drawMeteor(ctx, meteor, now, deltaTime, parallaxOffset);\n        \n        // Move to next meteor\n        i++;\n      }\n    };\n    \n    // Start animation with FPS limiter\n    fpsTimestampRef.current = performance.now();\n    frameCountRef.current = 0;\n    lastTimestampRef.current = 0;\n    \n    animationFrameRef.current = requestAnimationFrame((timestamp) => {\n      fpsLimiter(timestamp, handleAnimation);\n    });\n    \n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [\n    active,\n    isInitialized,\n    isVisible,\n    dimensions,\n    mode,\n    direction,\n    enableParallax,\n    parallaxIntensity,\n    staggered,\n    minStaggerDelay,\n    maxStaggerDelay,\n    trailSegments,\n    getPathPoint,\n    initializeMeteor,\n    fpsLimiter,\n    drawMeteor,\n    debug,\n    prefersReducedMotion,\n    respectReducedMotion,\n    adaptedSettings.meteorDensity,\n    qualityFactor\n  ]);\n  \n  return (\n    <div \n      ref={containerRef}\n      style={{ \n        position: 'absolute',\n        top: 0, \n        left: 0, \n        width: '100%', \n        height: height,\n        overflow: 'hidden', \n        pointerEvents: 'none', \n        zIndex: zIndex,\n        // Hardware acceleration\n        backfaceVisibility: 'hidden',\n        transform: 'translateZ(0)',\n        willChange: 'transform'\n      }}\n      aria-hidden=\"true\"\n    >\n      <canvas \n        ref={canvasRef} \n        style={{ \n          position: 'absolute', \n          top: 0, \n          left: 0, \n          width: '100%', \n          height: '100%',\n          // Additional rendering optimizations\n          imageRendering: 'high-quality',\n          // Hardware acceleration\n          backfaceVisibility: 'hidden',\n          transform: 'translateZ(0)',\n          willChange: 'transform'\n        }} \n      />\n    </div>\n  );\n};\n\n/**\n * GoldenMeteorShower Component\n * \n * A preset version of the MeteorShower with a golden/amber color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const GoldenMeteorShower = (props) => {\n  const goldenPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 253, 227, 0.9)',\n    trailColor: 'rgba(191, 173, 127, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 200,\n    maxStaggerDelay: 2000,\n  };\n  \n  return <MeteorShower {...goldenPreset} {...props} />;\n};\n\n/**\n * CelestialMeteorShower Component\n * \n * A preset version of the MeteorShower with a bluish-purple color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const CelestialMeteorShower = (props) => {\n  const celestialPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(220, 225, 255, 0.9)',\n    trailColor: 'rgba(150, 160, 255, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 300,\n    maxStaggerDelay: 1800,\n  };\n  \n  return <MeteorShower {...celestialPreset} {...props} />;\n};\n\n/**\n * EmeraldMeteorShower Component\n * \n * A preset version of the MeteorShower with a green color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const EmeraldMeteorShower = (props) => {\n  const emeraldPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(215, 255, 230, 0.9)',\n    trailColor: 'rgba(100, 220, 150, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 250,\n    maxStaggerDelay: 1500,\n  };\n  \n  return <MeteorShower {...emeraldPreset} {...props} />;\n};\n\n/**\n * RubyMeteorShower Component\n * \n * A preset version of the MeteorShower with a red color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const RubyMeteorShower = (props) => {\n  const rubyPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 200, 200, 0.9)',\n    trailColor: 'rgba(220, 100, 100, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 350,\n    maxStaggerDelay: 2200,\n  };\n  \n  return <MeteorShower {...rubyPreset} {...props} />;\n};\n\n/**\n * ClassicMeteorShower Component\n * \n * A preset version of the MeteorShower with linear paths for a more traditional meteor shower effect.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const ClassicMeteorShower = (props) => {\n  const classicPreset = {\n    mode: 'linear',\n    direction: 'both',\n    baseAngle: 30,\n    angleVariation: 15,\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.12,\n    trailLength: 200,\n    trailSegments: 25,\n    journeyCompletion: 0.95,\n    staggered: true,\n    minStaggerDelay: 100,\n    maxStaggerDelay: 1000,\n  };\n  \n  return <MeteorShower {...classicPreset} {...props} />;\n};\n/**\n * TopMeteorShower Component\n * \n * A preset version of the MeteorShower with meteors falling from the top of the screen\n * at a consistent 30-degree angle, distributed with emphasis on left and center areas.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const TopMeteorShower = (props) => {\n  const topPreset = {\n    mode: 'linear',\n    direction: 'top',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.12,\n    trailLength: 200,\n    trailSegments: 25,\n    journeyCompletion: 0.95,\n    staggered: true,\n    minStaggerDelay: 100,\n    maxStaggerDelay: 1000,\n  };\n  \n  return <MeteorShower {...topPreset} {...props} />;\n};\n\nexport default MeteorShower;"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,SAAS,EAAEC,MAAM,EAAEC,WAAW,EAAEC,OAAO,QAAQ,OAAO;;AAEhF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlCA,SAAAC,MAAA,IAAAC,OAAA;AAmCA,MAAMC,YAAY,GAAGA,CAAC;EACpBC,MAAM,GAAG,OAAO;EAChBC,MAAM,GAAG,CAAC;EACVC,MAAM,GAAG,IAAI;EACbC,aAAa,GAAG,EAAE;EAClBC,aAAa,GAAG,CAAC;EACjBC,aAAa,GAAG,CAAC;EACjBC,WAAW,GAAG,IAAI;EAClBC,WAAW,GAAG,GAAG;EACjBC,aAAa,GAAG,EAAE;EAClBC,SAAS,GAAG,wBAAwB;EACpCC,SAAS,GAAG,0BAA0B;EACtCC,UAAU,GAAG,0BAA0B;EACvCC,cAAc,GAAG,KAAK;EACtBC,iBAAiB,GAAG,GAAG;EACvBC,SAAS,GAAG,IAAI;EAChBC,eAAe,GAAG,GAAG;EACrBC,eAAe,GAAG,IAAI;EACtBC,iBAAiB,GAAG,GAAG;EACvBC,IAAI,GAAG,KAAK;EACZC,SAAS,GAAG,MAAM;EAClBC,SAAS,GAAG,EAAE;EACdC,cAAc,GAAG,EAAE;EACnBC,KAAK,GAAG,KAAK;EACbC,eAAe,GAAG,IAAI;EACtBC,oBAAoB,GAAG,IAAI;EAC3BC,MAAM,GAAG;AACX,CAAC,KAAK;EAAAC,EAAA;EACJ;EACA,MAAMC,YAAY,GAAGjC,MAAM,CAAC,IAAI,CAAC;EACjC,MAAMkC,SAAS,GAAGlC,MAAM,CAAC,IAAI,CAAC;EAC9B,MAAMmC,MAAM,GAAGnC,MAAM,CAAC,IAAI,CAAC;EAC3B,MAAMoC,UAAU,GAAGpC,MAAM,CAAC,EAAE,CAAC;EAC7B,MAAMqC,iBAAiB,GAAGrC,MAAM,CAAC,IAAI,CAAC;EACtC,MAAMsC,gBAAgB,GAAGtC,MAAM,CAAC,CAAC,CAAC;EAClC,MAAMuC,eAAe,GAAGvC,MAAM,CAAC,CAAC,CAAC;EACjC,MAAMwC,aAAa,GAAGxC,MAAM,CAAC,CAAC,CAAC;EAC/B,MAAMyC,aAAa,GAAGzC,MAAM,CAAC,EAAE,CAAC;EAChC,MAAM0C,gBAAgB,GAAG1C,MAAM,CAAC,CAAC,CAAC;EAClC,MAAM2C,iBAAiB,GAAG3C,MAAM,CAAC,CAAC,CAAC;EACnC,MAAM4C,iBAAiB,GAAG5C,MAAM,CAAC,IAAI,CAAC;;EAEtC;EACA,MAAM,CAAC6C,UAAU,EAAEC,aAAa,CAAC,GAAGhD,QAAQ,CAAC;IAAEiD,KAAK,EAAE,CAAC;IAAEzC,MAAM,EAAE,CAAC;IAAE0C,UAAU,EAAE;EAAE,CAAC,CAAC;EACpF,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAGpD,QAAQ,CAAC,KAAK,CAAC;EACzD,MAAM,CAACqD,oBAAoB,EAAEC,uBAAuB,CAAC,GAAGtD,QAAQ,CAAC,KAAK,CAAC;EACvE,MAAM,CAACuD,SAAS,EAAEC,YAAY,CAAC,GAAGxD,QAAQ,CAAC,KAAK,CAAC;EACjD,MAAM,CAACyD,aAAa,EAAEC,gBAAgB,CAAC,GAAG1D,QAAQ,CAAC,CAAC,CAAC;;EAErD;EACA,MAAM2D,UAAU,GAAGzD,MAAM,CAAC;IACxB0D,OAAO,EAAE;MAAEC,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE;IAAE,CAAC;IACvBC,OAAO,EAAE;MAAEF,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE;IAAE;EACxB,CAAC,CAAC,CAACF,OAAO;;EAEV;EACA,MAAMI,aAAa,GAAG9D,MAAM,CAAC,IAAI+D,GAAG,CAAC,CAAC,CAAC;;EAEvC;EACA,MAAMC,cAAc,GAAG/D,WAAW,CAAC,CAACgE,SAAS,EAAEC,OAAO,KAAK;IACzD;IACA,MAAMC,cAAc,GAAGC,IAAI,CAACC,KAAK,CAACH,OAAO,GAAG,GAAG,CAAC,GAAG,GAAG;IACtD,MAAMI,GAAG,GAAG,GAAGL,SAAS,IAAIE,cAAc,EAAE;IAE5C,IAAI,CAACL,aAAa,CAACJ,OAAO,CAACa,GAAG,CAACD,GAAG,CAAC,EAAE;MACnC,MAAME,QAAQ,GAAGP,SAAS,CAACQ,OAAO,CAAC,WAAW,EAAEN,cAAc,GAAG,GAAG,CAAC;MACrEL,aAAa,CAACJ,OAAO,CAACgB,GAAG,CAACJ,GAAG,EAAEE,QAAQ,CAAC;IAC1C;IAEA,OAAOV,aAAa,CAACJ,OAAO,CAACiB,GAAG,CAACL,GAAG,CAAC;EACvC,CAAC,EAAE,EAAE,CAAC;;EAEN;EACAvE,SAAS,CAAC,MAAM;IACd;IACA,MAAM6E,kBAAkB,GAAGC,MAAM,CAACC,UAAU,CAAC,kCAAkC,CAAC;IAChF1B,uBAAuB,CAACwB,kBAAkB,CAACG,OAAO,CAAC;IAEnD,MAAMC,yBAAyB,GAAIC,CAAC,IAAK;MACvC7B,uBAAuB,CAAC6B,CAAC,CAACF,OAAO,CAAC;IACpC,CAAC;IAEDH,kBAAkB,CAACM,gBAAgB,CAAC,QAAQ,EAAEF,yBAAyB,CAAC;;IAExE;IACA,MAAMG,aAAa,GAAGA,CAAA,KAAM;MAC1B;MACA,MAAMC,MAAM,GAAGC,SAAS,CAACC,YAAY,IAAI,CAAC,CAAC,CAAC;MAC5C,MAAMC,KAAK,GAAGF,SAAS,CAACG,mBAAmB,IAAI,CAAC,CAAC,CAAC;MAClD,MAAMxC,UAAU,GAAG6B,MAAM,CAACY,gBAAgB,IAAI,CAAC;;MAE/C;MACA,MAAMC,gBAAgB,GAAIN,MAAM,GAAGG,KAAK,GAAIvC,UAAU;;MAEtD;MACA,IAAI2C,OAAO,GAAG,CAAC;MAEf,IAAID,gBAAgB,GAAG,EAAE,EAAE;QACzBC,OAAO,GAAG,CAAC,CAAC,CAAC;MACf,CAAC,MAAM,IAAID,gBAAgB,GAAG,CAAC,EAAE;QAC/BC,OAAO,GAAG,GAAG,CAAC,CAAC;MACjB,CAAC,MAAM,IAAID,gBAAgB,GAAG,CAAC,EAAE;QAC/BC,OAAO,GAAG,GAAG,CAAC,CAAC;MACjB,CAAC,MAAM;QACLA,OAAO,GAAG,GAAG,CAAC,CAAC;MACjB;;MAEA;MACA,IAAI,gEAAgE,CAACC,IAAI,CAACP,SAAS,CAACQ,SAAS,CAAC,EAAE;QAC9FF,OAAO,IAAI,GAAG;MAChB;MAEA,OAAOA,OAAO;IAChB,CAAC;IAED,IAAI9D,eAAe,EAAE;MACnB2B,gBAAgB,CAAC2B,aAAa,CAAC,CAAC,CAAC;IACnC;IAEA,OAAO,MAAM;MACXP,kBAAkB,CAACkB,mBAAmB,CAAC,QAAQ,EAAEd,yBAAyB,CAAC;IAC7E,CAAC;EACH,CAAC,EAAE,CAACnD,eAAe,CAAC,CAAC;;EAErB;EACA,MAAMkE,eAAe,GAAG7F,OAAO,CAAC,MAAM;IACpC,IAAI,CAAC2B,eAAe,IAAI0B,aAAa,KAAK,CAAC,EAAE;MAC3C,OAAO;QACL9C,aAAa;QACbK;MACF,CAAC;IACH;;IAEA;IACA,OAAO;MACLL,aAAa,EAAE2D,IAAI,CAAC4B,GAAG,CAAC,CAAC,EAAE5B,IAAI,CAAC6B,KAAK,CAACxF,aAAa,GAAG8C,aAAa,CAAC,CAAC;MACrEzC,aAAa,EAAEsD,IAAI,CAAC4B,GAAG,CAAC,CAAC,EAAE5B,IAAI,CAAC6B,KAAK,CAACnF,aAAa,GAAGyC,aAAa,CAAC;IACtE,CAAC;EACH,CAAC,EAAE,CAAC1B,eAAe,EAAE0B,aAAa,EAAE9C,aAAa,EAAEK,aAAa,CAAC,CAAC;;EAElE;EACA,MAAMoF,mBAAmB,GAAGjG,WAAW,CAAC,CAAC8C,KAAK,EAAEzC,MAAM,KAAK;IACzD,IAAIkB,IAAI,KAAK,KAAK,EAAE;MAClB;MACA;MACA,MAAM2E,MAAM,GAAG/B,IAAI,CAACgC,MAAM,CAAC,CAAC,GAAGrD,KAAK,GAAG,GAAG,GAAGA,KAAK,GAAG,IAAI;;MAEzD;MACA,MAAMsD,MAAM,GAAGjC,IAAI,CAACgC,MAAM,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,EAAE;;MAExC;MACA,MAAME,cAAc,GAAGlC,IAAI,CAACgC,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;MACnD,MAAMG,cAAc,GAAGnC,IAAI,CAACgC,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,GAAG;;MAEhD;MACA;MACA,MAAMI,IAAI,GAAGL,MAAM,GAAIG,cAAc,GAAGvD,KAAK,GAAGwD,cAAe;MAC/D,MAAME,IAAI,GAAGnG,MAAM,GAAGiB,iBAAiB;;MAEvC;MACA,MAAMmF,QAAQ,GAAG,CAACP,MAAM,GAAGK,IAAI,IAAI,CAAC,GAAIF,cAAc,GAAGvD,KAAK,GAAGwD,cAAe;MAChF,MAAMI,QAAQ,GAAG,CAACN,MAAM,GAAGI,IAAI,IAAI,GAAG;MAEtC,OAAO;QACLG,QAAQ,EAAE,KAAK;QACfC,KAAK,EAAE;UAAElD,CAAC,EAAEwC,MAAM;UAAEvC,CAAC,EAAEyC;QAAO,CAAC;QAC/BS,OAAO,EAAE;UAAEnD,CAAC,EAAE+C,QAAQ;UAAE9C,CAAC,EAAE+C;QAAS,CAAC;QACrCI,GAAG,EAAE;UAAEpD,CAAC,EAAE6C,IAAI;UAAE5C,CAAC,EAAE6C;QAAK;MAC1B,CAAC;IACH,CAAC,MAAM,IAAIjF,IAAI,KAAK,QAAQ,EAAE;MAC5B;;MAEA;MACA,IAAIwF,eAAe,GAAGvF,SAAS;MAC/B,IAAIA,SAAS,KAAK,MAAM,EAAE;QACxBuF,eAAe,GAAG5C,IAAI,CAACgC,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,MAAM,GAAG,OAAO;MAC1D;;MAEA;MACA,IAAIa,KAAK;MAET,IAAIxF,SAAS,KAAK,KAAK,EAAE;QACvB;QACA;QACAwF,KAAK,GAAI,CAAC,EAAE,GAAG,CAAC7C,IAAI,CAACgC,MAAM,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,IAAIhC,IAAI,CAAC8C,EAAE,GAAI,GAAG;MAC9D,CAAC,MAAM;QACLD,KAAK,GAAI,CAACvF,SAAS,GAAG,CAAC0C,IAAI,CAACgC,MAAM,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,IAAIzE,cAAc,IAAIyC,IAAI,CAAC8C,EAAE,GAAI,GAAG;MAClF;;MAEA;MACA,IAAIf,MAAM;MACV,IAAIa,eAAe,KAAK,MAAM,EAAE;QAC9B;QACAb,MAAM,GAAG/B,IAAI,CAACgC,MAAM,CAAC,CAAC,IAAIrD,KAAK,GAAG,GAAG,CAAC,GAAIA,KAAK,GAAG,GAAI;MACxD,CAAC,MAAM,IAAIiE,eAAe,KAAK,OAAO,EAAE;QACtC;QACAb,MAAM,GAAGpD,KAAK,GAAGqB,IAAI,CAACgC,MAAM,CAAC,CAAC,IAAIrD,KAAK,GAAG,GAAG,CAAC,GAAIA,KAAK,GAAG,GAAI;MAChE,CAAC,MAAM,IAAItB,SAAS,KAAK,KAAK,EAAE;QAC9B;QACA,MAAM0F,QAAQ,GAAG/C,IAAI,CAACgC,MAAM,CAAC,CAAC;QAC9B,IAAIe,QAAQ,GAAG,GAAG,EAAE;UAClB;UACAhB,MAAM,GAAG/B,IAAI,CAACgC,MAAM,CAAC,CAAC,IAAIrD,KAAK,GAAG,IAAI,CAAC;QACzC,CAAC,MAAM,IAAIoE,QAAQ,GAAG,IAAI,EAAE;UAC1B;UACAhB,MAAM,GAAGpD,KAAK,GAAG,IAAI,GAAGqB,IAAI,CAACgC,MAAM,CAAC,CAAC,IAAIrD,KAAK,GAAG,IAAI,CAAC;QACxD,CAAC,MAAM;UACL;UACAoD,MAAM,GAAGpD,KAAK,GAAG,GAAG,GAAGqB,IAAI,CAACgC,MAAM,CAAC,CAAC,IAAIrD,KAAK,GAAG,GAAG,CAAC;QACtD;MACF;;MAEA;MACA,MAAMsD,MAAM,GAAGjC,IAAI,CAACgC,MAAM,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,EAAE;;MAExC;MACA,MAAMgB,gBAAgB,GAAI9G,MAAM,GAAGiB,iBAAiB,GAAI6C,IAAI,CAACiD,GAAG,CAACJ,KAAK,CAAC;;MAEvE;MACA,IAAIT,IAAI,EAAEC,IAAI;MACd,IAAIO,eAAe,KAAK,MAAM,IAAIvF,SAAS,KAAK,KAAK,EAAE;QACrD;QACA+E,IAAI,GAAGL,MAAM,GAAGiB,gBAAgB,GAAGhD,IAAI,CAACkD,GAAG,CAACL,KAAK,CAAC;QAClDR,IAAI,GAAGJ,MAAM,GAAGe,gBAAgB,GAAGhD,IAAI,CAACiD,GAAG,CAACJ,KAAK,CAAC;MACpD,CAAC,MAAM;QACL;QACAT,IAAI,GAAGL,MAAM,GAAGiB,gBAAgB,GAAGhD,IAAI,CAACkD,GAAG,CAACL,KAAK,CAAC;QAClDR,IAAI,GAAGJ,MAAM,GAAGe,gBAAgB,GAAGhD,IAAI,CAACiD,GAAG,CAACJ,KAAK,CAAC;MACpD;MAEA,OAAO;QACLL,QAAQ,EAAE,QAAQ;QAClBC,KAAK,EAAE;UAAElD,CAAC,EAAEwC,MAAM;UAAEvC,CAAC,EAAEyC;QAAO,CAAC;QAC/BU,GAAG,EAAE;UAAEpD,CAAC,EAAE6C,IAAI;UAAE5C,CAAC,EAAE6C;QAAK,CAAC;QACzBhF,SAAS,EAAEuF;MACb,CAAC;IACH;EACF,CAAC,EAAE,CAACxF,IAAI,EAAEC,SAAS,EAAEC,SAAS,EAAEC,cAAc,EAAEJ,iBAAiB,CAAC,CAAC;;EAEnE;EACA,MAAMgG,YAAY,GAAGtH,WAAW,CAAC,CAACuH,CAAC,EAAEC,IAAI,EAAEC,QAAQ,GAAG;IAAE/D,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAE,CAAC,KAAK;IACvE,IAAI6D,IAAI,CAACb,QAAQ,KAAK,KAAK,EAAE;MAC3B;MACA,MAAMe,IAAI,GAAG,CAAC,GAAGH,CAAC;MAClB,MAAMI,WAAW,GAAGD,IAAI,GAAGA,IAAI;MAC/B,MAAME,QAAQ,GAAGL,CAAC,GAAGA,CAAC;MACtB,MAAMM,KAAK,GAAGF,WAAW;MACzB,MAAMG,KAAK,GAAG,CAAC,GAAGJ,IAAI,GAAGH,CAAC;MAC1B,MAAMQ,KAAK,GAAGH,QAAQ;MAEtBH,QAAQ,CAAC/D,CAAC,GAAGmE,KAAK,GAAGL,IAAI,CAACZ,KAAK,CAAClD,CAAC,GAAGoE,KAAK,GAAGN,IAAI,CAACX,OAAO,CAACnD,CAAC,GAAGqE,KAAK,GAAGP,IAAI,CAACV,GAAG,CAACpD,CAAC;MAC/E+D,QAAQ,CAAC9D,CAAC,GAAGkE,KAAK,GAAGL,IAAI,CAACZ,KAAK,CAACjD,CAAC,GAAGmE,KAAK,GAAGN,IAAI,CAACX,OAAO,CAAClD,CAAC,GAAGoE,KAAK,GAAGP,IAAI,CAACV,GAAG,CAACnD,CAAC;MAC/E,OAAO8D,QAAQ;IACjB,CAAC,MAAM;MACL;MACAA,QAAQ,CAAC/D,CAAC,GAAG8D,IAAI,CAACZ,KAAK,CAAClD,CAAC,GAAG,CAAC8D,IAAI,CAACV,GAAG,CAACpD,CAAC,GAAG8D,IAAI,CAACZ,KAAK,CAAClD,CAAC,IAAI6D,CAAC;MAC3DE,QAAQ,CAAC9D,CAAC,GAAG6D,IAAI,CAACZ,KAAK,CAACjD,CAAC,GAAG,CAAC6D,IAAI,CAACV,GAAG,CAACnD,CAAC,GAAG6D,IAAI,CAACZ,KAAK,CAACjD,CAAC,IAAI4D,CAAC;MAC3D,OAAOE,QAAQ;IACjB;EACF,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAMO,WAAW,GAAGhI,WAAW,CAAC,MAAM;IACpC,IAAI,CAACiC,SAAS,CAACwB,OAAO,IAAI,CAACzB,YAAY,CAACyB,OAAO,EAAE,OAAO,KAAK;IAE7D,MAAMwE,MAAM,GAAGhG,SAAS,CAACwB,OAAO;IAChC,MAAMyE,SAAS,GAAGlG,YAAY,CAACyB,OAAO;IACtC,MAAM0E,IAAI,GAAGD,SAAS,CAACE,qBAAqB,CAAC,CAAC;IAC9C,MAAMrF,UAAU,GAAG6B,MAAM,CAACY,gBAAgB,IAAI,CAAC;;IAE/C;IACA,MAAM6C,YAAY,GAAGF,IAAI,CAACrF,KAAK;IAC/B,MAAMwF,aAAa,GAAG,OAAOjI,MAAM,KAAK,QAAQ,IAAIA,MAAM,CAACkI,QAAQ,CAAC,IAAI,CAAC,GACpEC,QAAQ,CAACnI,MAAM,EAAE,EAAE,CAAC,GAAG,GAAG,GAAIuE,MAAM,CAAC6D,WAAW,GACjDD,QAAQ,CAACnI,MAAM,EAAE,EAAE,CAAC,IAAIuE,MAAM,CAAC6D,WAAW;;IAE9C;IACAR,MAAM,CAACnF,KAAK,GAAGuF,YAAY,GAAGtF,UAAU;IACxCkF,MAAM,CAAC5H,MAAM,GAAGiI,aAAa,GAAGvF,UAAU;;IAE1C;IACAkF,MAAM,CAACS,KAAK,CAAC5F,KAAK,GAAG,GAAGuF,YAAY,IAAI;IACxCJ,MAAM,CAACS,KAAK,CAACrI,MAAM,GAAG,GAAGiI,aAAa,IAAI;;IAE1C;IACA,MAAMK,GAAG,GAAGV,MAAM,CAACW,UAAU,CAAC,IAAI,EAAE;MAClCC,KAAK,EAAE,IAAI;MACXC,cAAc,EAAE,IAAI;MAAE;MACtBC,kBAAkB,EAAE;IACtB,CAAC,CAAC;;IAEF;IACAJ,GAAG,CAACK,KAAK,CAACjG,UAAU,EAAEA,UAAU,CAAC;;IAEjC;IACA,IAAI4F,GAAG,CAACM,qBAAqB,KAAKC,SAAS,EAAE;MAC3CP,GAAG,CAACM,qBAAqB,GAAG,IAAI;MAChCN,GAAG,CAACQ,qBAAqB,GAAG,MAAM;IACpC;;IAEA;IACAjH,MAAM,CAACuB,OAAO,GAAGkF,GAAG;IAEpB9F,aAAa,CAAC;MACZC,KAAK,EAAEuF,YAAY;MACnBhI,MAAM,EAAEiI,aAAa;MACrBvF;IACF,CAAC,CAAC;IAEF,OAAO,IAAI;EACb,CAAC,EAAE,CAAC1C,MAAM,CAAC,CAAC;;EAEZ;EACAP,SAAS,CAAC,MAAM;IACd,IAAI,CAACkC,YAAY,CAACyB,OAAO,EAAE;;IAE3B;IACA,MAAM2F,cAAc,GAAG,IAAIC,cAAc,CAAC,MAAM;MAC9C;MACAC,qBAAqB,CAAC,MAAM;QAC1B,IAAItB,WAAW,CAAC,CAAC,EAAE;UACjB/E,gBAAgB,CAAC,IAAI,CAAC;QACxB;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;;IAEF;IACAmG,cAAc,CAACG,OAAO,CAACvH,YAAY,CAACyB,OAAO,CAAC;IAC5Cd,iBAAiB,CAACc,OAAO,GAAG2F,cAAc;;IAE1C;IACApB,WAAW,CAAC,CAAC;IACb/E,gBAAgB,CAAC,IAAI,CAAC;IAEtB,OAAO,MAAM;MACX,IAAIN,iBAAiB,CAACc,OAAO,EAAE;QAC7Bd,iBAAiB,CAACc,OAAO,CAAC+F,UAAU,CAAC,CAAC;MACxC;IACF,CAAC;EACH,CAAC,EAAE,CAACxB,WAAW,CAAC,CAAC;;EAEjB;EACAlI,SAAS,CAAC,MAAM;IACd,IAAI,CAACkC,YAAY,CAACyB,OAAO,EAAE;IAE3B,MAAMgG,QAAQ,GAAG,IAAIC,oBAAoB,CACtCC,OAAO,IAAK;MACX;MACA,MAAMC,KAAK,GAAGD,OAAO,CAACA,OAAO,CAACE,MAAM,GAAG,CAAC,CAAC;MACzCxG,YAAY,CAACuG,KAAK,CAACE,cAAc,CAAC;IACpC,CAAC,EACD;MACEC,SAAS,EAAE,IAAI;MACfC,UAAU,EAAE;IACd,CACF,CAAC;IAEDP,QAAQ,CAACF,OAAO,CAACvH,YAAY,CAACyB,OAAO,CAAC;IAEtC,OAAO,MAAM;MACXgG,QAAQ,CAACD,UAAU,CAAC,CAAC;IACvB,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA1J,SAAS,CAAC,MAAM;IACd,IAAI,CAACmB,cAAc,EAAE;IAErB,MAAMgJ,YAAY,GAAGA,CAAA,KAAM;MACzBvH,iBAAiB,CAACe,OAAO,GAAGmB,MAAM,CAACsF,OAAO;IAC5C,CAAC;IAEDtF,MAAM,CAACK,gBAAgB,CAAC,QAAQ,EAAEgF,YAAY,CAAC;IAE/C,OAAO,MAAM;MACXrF,MAAM,CAACiB,mBAAmB,CAAC,QAAQ,EAAEoE,YAAY,CAAC;IACpD,CAAC;EACH,CAAC,EAAE,CAAChJ,cAAc,CAAC,CAAC;;EAEpB;EACA,MAAMkJ,gBAAgB,GAAGnK,WAAW,CAAC,MAAM;IACzC,MAAM;MAAE8C,KAAK;MAAEzC;IAAO,CAAC,GAAGuC,UAAU;IAEpC,IAAI,CAACE,KAAK,IAAI,CAACzC,MAAM,EAAE,OAAO,IAAI;;IAElC;IACA,MAAMmH,IAAI,GAAGvB,mBAAmB,CAACnD,KAAK,EAAEzC,MAAM,CAAC;;IAE/C;IACA,MAAM+J,SAAS,GAAGzJ,WAAW,IAAIwD,IAAI,CAACgC,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,IAAI,CAAC;;IAE5D;IACA;IACA,MAAMkE,SAAS,GAAGC,KAAK,CAACxE,eAAe,CAACjF,aAAa,CAAC;IACtD,KAAK,IAAI0J,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGzE,eAAe,CAACjF,aAAa,EAAE0J,CAAC,EAAE,EAAE;MACtDF,SAAS,CAACE,CAAC,CAAC,GAAG;QAAE7G,CAAC,EAAE8D,IAAI,CAACZ,KAAK,CAAClD,CAAC;QAAEC,CAAC,EAAE6D,IAAI,CAACZ,KAAK,CAACjD;MAAE,CAAC;IACrD;IAEA,OAAO;MACL6D,IAAI;MACJgD,QAAQ,EAAE,CAAC;MACXC,IAAI,EAAEtG,IAAI,CAACgC,MAAM,CAAC,CAAC,IAAIzF,aAAa,GAAGD,aAAa,CAAC,GAAGA,aAAa;MACrEiK,KAAK,EAAEN,SAAS;MAChB7J,MAAM,EAAE,IAAI;MACZ8J,SAAS;MACTpG,OAAO,EAAEE,IAAI,CAACgC,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,GAAG;MAClCwE,aAAa,EAAE,GAAG,GAAGxG,IAAI,CAACgC,MAAM,CAAC,CAAC,GAAG,GAAG;MAAE;MAC1CyE,UAAU,EAAEzG,IAAI,CAACgC,MAAM,CAAC,CAAC,GAAGhC,IAAI,CAAC8C,EAAE,GAAG,CAAC;MACvC4D,UAAU,EAAE1G,IAAI,CAACgC,MAAM,CAAC,CAAC,GAAG,IAAI,GAAG;IACrC,CAAC;EACH,CAAC,EAAE,CACDvD,UAAU,EACVjC,WAAW,EACXF,aAAa,EACbC,aAAa,EACbuF,mBAAmB,EACnBH,eAAe,CAACjF,aAAa,CAC9B,CAAC;;EAEF;EACA,MAAMiK,UAAU,GAAG9K,WAAW,CAAC,CAAC+K,SAAS,EAAEC,QAAQ,KAAK;IACtD,MAAMC,eAAe,GAAG,IAAI,GAAGnJ,MAAM;IACrC,MAAMoJ,OAAO,GAAGH,SAAS,GAAG1I,gBAAgB,CAACoB,OAAO;IAEpD,IAAIyH,OAAO,IAAID,eAAe,EAAE;MAC9B5I,gBAAgB,CAACoB,OAAO,GAAGsH,SAAS,GAAIG,OAAO,GAAGD,eAAgB;MAClED,QAAQ,CAACE,OAAO,CAAC;;MAEjB;MACA3I,aAAa,CAACkB,OAAO,EAAE;MACvB,IAAIsH,SAAS,GAAGzI,eAAe,CAACmB,OAAO,IAAI,IAAI,EAAE;QAC/CjB,aAAa,CAACiB,OAAO,GAAGlB,aAAa,CAACkB,OAAO;QAC7ClB,aAAa,CAACkB,OAAO,GAAG,CAAC;QACzBnB,eAAe,CAACmB,OAAO,GAAGsH,SAAS;;QAEnC;QACA,IAAInJ,eAAe,IAAID,KAAK,EAAE;UAC5BwJ,OAAO,CAACC,GAAG,CAAC,gBAAgB5I,aAAa,CAACiB,OAAO,qBAAqBH,aAAa,EAAE,CAAC;QACxF;MACF;IACF;IAEAlB,iBAAiB,CAACqB,OAAO,GAAG6F,qBAAqB,CAAE+B,aAAa,IAAK;MACnEP,UAAU,CAACO,aAAa,EAAEL,QAAQ,CAAC;IACrC,CAAC,CAAC;EACJ,CAAC,EAAE,CAAClJ,MAAM,EAAEF,eAAe,EAAED,KAAK,EAAE2B,aAAa,CAAC,CAAC;;EAEnD;EACA,MAAMgI,UAAU,GAAGtL,WAAW,CAAC,CAAC2I,GAAG,EAAE4C,MAAM,EAAER,SAAS,EAAES,SAAS,EAAEC,cAAc,KAAK;IACpF;IACA;IACA,IAAIC,cAAc,GAAGH,MAAM,CAACtH,OAAO;IACnC,IAAIsH,MAAM,CAACf,QAAQ,GAAGe,MAAM,CAACZ,aAAa,EAAE;MAC1C;MACA,MAAMgB,YAAY,GAAG,CAACJ,MAAM,CAACf,QAAQ,GAAGe,MAAM,CAACZ,aAAa,KAAK,CAAC,GAAGY,MAAM,CAACZ,aAAa,CAAC;MAC1Fe,cAAc,GAAGH,MAAM,CAACtH,OAAO,IAAI,CAAC,GAAG0H,YAAY,CAAC;IACtD;;IAEA;IACA,MAAMC,UAAU,GAAGb,SAAS,GAAG,KAAK;IACpC,MAAMc,WAAW,GAAG1H,IAAI,CAACkD,GAAG,CAACuE,UAAU,GAAGL,MAAM,CAACV,UAAU,GAAGU,MAAM,CAACX,UAAU,CAAC,GAAG,GAAG,GAAG,GAAG;;IAE5F;IACA,MAAMkB,OAAO,GAAG7K,cAAc,GAAGwK,cAAc,IAAIF,MAAM,CAACd,IAAI,GAAG/J,aAAa,CAAC,GAAG,CAAC;;IAEnF;IACA,IAAIqL,cAAc,EAAEC,YAAY;;IAEhC;IACArD,GAAG,CAACsD,WAAW,GAAGlL,SAAS;IAC3B4H,GAAG,CAACuD,UAAU,GAAGX,MAAM,CAACd,IAAI,GAAG,CAAC,GAAGoB,WAAW;IAC9ClD,GAAG,CAACwD,OAAO,GAAG,OAAO;;IAErB;IACA;IACA,KAAK,IAAI5B,CAAC,GAAGgB,MAAM,CAAClB,SAAS,CAACR,MAAM,GAAG,CAAC,EAAEU,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACrD,MAAM6B,IAAI,GAAGb,MAAM,CAAClB,SAAS,CAACE,CAAC,CAAC;MAChC,MAAM8B,IAAI,GAAGd,MAAM,CAAClB,SAAS,CAACE,CAAC,GAAG,CAAC,CAAC;MAEpC,IAAI,CAAC6B,IAAI,IAAI,CAACC,IAAI,EAAE;;MAEpB;MACAN,cAAc,GAAGL,cAAc,IAAI,CAAC,GAAGnB,CAAC,GAAGgB,MAAM,CAAClB,SAAS,CAACR,MAAM,CAAC,GAAGgC,WAAW;;MAEjF;MACA,IAAIE,cAAc,GAAG,IAAI,EAAE;;MAE3B;MACAC,YAAY,GAAGT,MAAM,CAACd,IAAI,IAAI,CAAC,GAAGF,CAAC,GAAGgB,MAAM,CAAClB,SAAS,CAACR,MAAM,GAAG,GAAG,CAAC;;MAEpE;MACAlB,GAAG,CAAC2D,SAAS,CAAC,CAAC;MACf3D,GAAG,CAAC4D,MAAM,CAACH,IAAI,CAAC1I,CAAC,EAAE0I,IAAI,CAACzI,CAAC,GAAGmI,OAAO,CAAC;MACpCnD,GAAG,CAAC6D,MAAM,CAACH,IAAI,CAAC3I,CAAC,EAAE2I,IAAI,CAAC1I,CAAC,GAAGmI,OAAO,CAAC;;MAEpC;MACAnD,GAAG,CAAC8D,SAAS,GAAGT,YAAY;MAC5BrD,GAAG,CAAC+D,WAAW,GAAG3I,cAAc,CAAC/C,UAAU,EAAE+K,cAAc,CAAC;MAC5DpD,GAAG,CAACgE,MAAM,CAAC,CAAC;IACd;;IAEA;IACA,IAAIpB,MAAM,CAAClB,SAAS,CAAC,CAAC,CAAC,EAAE;MACvB,MAAMuC,OAAO,GAAGrB,MAAM,CAAClB,SAAS,CAAC,CAAC,CAAC;;MAEnC;MACA1B,GAAG,CAACsD,WAAW,GAAGlL,SAAS;MAC3B4H,GAAG,CAACuD,UAAU,GAAGX,MAAM,CAACd,IAAI,GAAG,CAAC,GAAGoB,WAAW;;MAE9C;MACAlD,GAAG,CAAC2D,SAAS,CAAC,CAAC;MACf3D,GAAG,CAACkE,GAAG,CAACD,OAAO,CAAClJ,CAAC,EAAEkJ,OAAO,CAACjJ,CAAC,GAAGmI,OAAO,EAAEP,MAAM,CAACd,IAAI,GAAG,GAAG,EAAE,CAAC,EAAEtG,IAAI,CAAC8C,EAAE,GAAG,CAAC,CAAC;MAC1E0B,GAAG,CAACmE,SAAS,GAAG/I,cAAc,CAAChD,SAAS,EAAE2K,cAAc,GAAG,GAAG,GAAGG,WAAW,CAAC;MAC7ElD,GAAG,CAACoE,IAAI,CAAC,CAAC;;MAEV;MACApE,GAAG,CAAC2D,SAAS,CAAC,CAAC;MACf3D,GAAG,CAACkE,GAAG,CAACD,OAAO,CAAClJ,CAAC,EAAEkJ,OAAO,CAACjJ,CAAC,GAAGmI,OAAO,EAAEP,MAAM,CAACd,IAAI,GAAG,GAAG,EAAE,CAAC,EAAEtG,IAAI,CAAC8C,EAAE,GAAG,CAAC,CAAC;MAC1E0B,GAAG,CAACmE,SAAS,GAAG/I,cAAc,CAACjD,SAAS,EAAE4K,cAAc,GAAGG,WAAW,CAAC;MACvElD,GAAG,CAACoE,IAAI,CAAC,CAAC;IACZ;EACF,CAAC,EAAE,CACD9L,cAAc,EACdP,aAAa,EACbK,SAAS,EACTC,UAAU,EACVF,SAAS,EACTiD,cAAc,CACf,CAAC;;EAEF;EACAjE,SAAS,CAAC,MAAM;IACd,IAAI,CAACS,MAAM,IAAI,CAACyC,aAAa,IAAI,CAACI,SAAS,IAAI,CAACR,UAAU,CAACE,KAAK,IAAI,CAACF,UAAU,CAACvC,MAAM,EAAE;MACtF;IACF;IAEA,IAAIwB,oBAAoB,IAAIqB,oBAAoB,EAAE;MAChD;MACA;IACF;IAEA,MAAMyF,GAAG,GAAGzG,MAAM,CAACuB,OAAO;IAC1B,IAAI,CAACkF,GAAG,EAAE;;IAEV;IACA,MAAMqE,eAAe,GAAIxB,SAAS,IAAK;MACrC,MAAM1I,KAAK,GAAGF,UAAU,CAACE,KAAK;MAC9B,MAAMzC,MAAM,GAAGuC,UAAU,CAACvC,MAAM;;MAEhC;MACA,IAAIgC,gBAAgB,CAACoB,OAAO,KAAK,CAAC,EAAE;QAClChB,gBAAgB,CAACgB,OAAO,GAAGwJ,WAAW,CAACC,GAAG,CAAC,CAAC;MAC9C;;MAEA;MACA,IAAIzB,cAAc,GAAG,CAAC;MACtB,IAAIxK,cAAc,EAAE;QAClBwK,cAAc,GAAG/I,iBAAiB,CAACe,OAAO,GAAGvC,iBAAiB;MAChE;;MAEA;MACAyH,GAAG,CAACwE,SAAS,CAAC,CAAC,EAAE,CAAC,EAAErK,KAAK,EAAEzC,MAAM,CAAC;;MAElC;MACA,IAAIsB,KAAK,EAAE;QACTgH,GAAG,CAAC+D,WAAW,GAAG,sBAAsB;QACxC/D,GAAG,CAAC8D,SAAS,GAAG,CAAC;QACjB9D,GAAG,CAACyE,UAAU,CAAC,CAAC,EAAE,CAAC,EAAEtK,KAAK,EAAEzC,MAAM,CAAC;QAEnCsI,GAAG,CAACmE,SAAS,GAAG,0BAA0B;QAC1CnE,GAAG,CAAC0E,IAAI,GAAG,gBAAgB;QAC3B1E,GAAG,CAAC2E,QAAQ,CAAC,WAAWxK,KAAK,IAAIzC,MAAM,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;QAClDsI,GAAG,CAAC2E,QAAQ,CAAC,YAAYnL,UAAU,CAACsB,OAAO,CAACoG,MAAM,IAAI/D,eAAe,CAACtF,aAAa,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;QAC9FmI,GAAG,CAAC2E,QAAQ,CAAC,SAAS/L,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;QACrCoH,GAAG,CAAC2E,QAAQ,CAAC,cAAc9L,SAAS,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;QAC/CmH,GAAG,CAAC2E,QAAQ,CAAC,QAAQ9K,aAAa,CAACiB,OAAO,EAAE,EAAE,EAAE,EAAE,GAAG,CAAC;QACtDkF,GAAG,CAAC2E,QAAQ,CAAC,YAAYhK,aAAa,CAACiK,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,GAAG,CAAC;QAC7D,IAAIpM,SAAS,EAAE;UACbwH,GAAG,CAAC2E,QAAQ,CAAC,eAAenJ,IAAI,CAAC4B,GAAG,CAAC,CAAC,EAAE,CAACtD,gBAAgB,CAACgB,OAAO,GAAGwJ,WAAW,CAACC,GAAG,CAAC,CAAC,IAAI,IAAI,CAAC,CAACK,OAAO,CAAC,CAAC,CAAC,GAAG,EAAE,EAAE,EAAE,GAAG,CAAC;QACxH;MACF;;MAEA;MACA,MAAML,GAAG,GAAGD,WAAW,CAACC,GAAG,CAAC,CAAC;MAC7B,IAAI/K,UAAU,CAACsB,OAAO,CAACoG,MAAM,GAAG/D,eAAe,CAACtF,aAAa,EAAE;QAC7D,MAAMgN,WAAW,GAAG,CAACrM,SAAS,IAAI+L,GAAG,IAAIzK,gBAAgB,CAACgB,OAAO;QAEjE,IAAI+J,WAAW,EAAE;UACf,MAAMC,SAAS,GAAGtD,gBAAgB,CAAC,CAAC;UACpC,IAAIsD,SAAS,EAAE;YACbtL,UAAU,CAACsB,OAAO,CAACiK,IAAI,CAACD,SAAS,CAAC;;YAElC;YACA,IAAItM,SAAS,EAAE;cACb,MAAMwM,KAAK,GAAGxJ,IAAI,CAACgC,MAAM,CAAC,CAAC,IAAI9E,eAAe,GAAGD,eAAe,CAAC,GAAGA,eAAe;cACnFqB,gBAAgB,CAACgB,OAAO,GAAGyJ,GAAG,GAAGS,KAAK;YACxC;UACF;QACF;MACF;;MAEA;MACA,MAAM/J,OAAO,GAAG;QAAEF,CAAC,EAAE,CAAC;QAAEC,CAAC,EAAE;MAAE,CAAC;;MAE9B;MACA,IAAI4G,CAAC,GAAG,CAAC;MACT,OAAOA,CAAC,GAAGpI,UAAU,CAACsB,OAAO,CAACoG,MAAM,EAAE;QACpC,MAAM0B,MAAM,GAAGpJ,UAAU,CAACsB,OAAO,CAAC8G,CAAC,CAAC;;QAEpC;QACA,IAAI,CAACgB,MAAM,CAAChL,MAAM,EAAE;UAClB4B,UAAU,CAACsB,OAAO,CAACmK,MAAM,CAACrD,CAAC,EAAE,CAAC,CAAC;UAC/B;QACF;;QAEA;QACAgB,MAAM,CAACf,QAAQ,IAAIe,MAAM,CAACb,KAAK,IAAIc,SAAS,GAAG,IAAI,CAAC;;QAEpD;QACA,IAAID,MAAM,CAACf,QAAQ,IAAI,CAAC,EAAE;UACxBrI,UAAU,CAACsB,OAAO,CAACmK,MAAM,CAACrD,CAAC,EAAE,CAAC,CAAC;UAC/B;QACF;;QAEA;QACA,MAAMsD,UAAU,GAAGvG,YAAY,CAACnD,IAAI,CAAC2J,GAAG,CAAC,CAAC,EAAEvC,MAAM,CAACf,QAAQ,CAAC,EAAEe,MAAM,CAAC/D,IAAI,EAAE5D,OAAO,CAAC;;QAEnF;QACA;QACA,MAAMmK,MAAM,GAAG;UAAErK,CAAC,EAAEmK,UAAU,CAACnK,CAAC;UAAEC,CAAC,EAAEkK,UAAU,CAAClK;QAAE,CAAC;;QAEnD;QACA,KAAK,IAAIqK,CAAC,GAAGzC,MAAM,CAAClB,SAAS,CAACR,MAAM,GAAG,CAAC,EAAEmE,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;UACpDzC,MAAM,CAAClB,SAAS,CAAC2D,CAAC,CAAC,GAAGzC,MAAM,CAAClB,SAAS,CAAC2D,CAAC,GAAG,CAAC,CAAC;QAC/C;QACAzC,MAAM,CAAClB,SAAS,CAAC,CAAC,CAAC,GAAG0D,MAAM;;QAE5B;QACAzC,UAAU,CAAC3C,GAAG,EAAE4C,MAAM,EAAE2B,GAAG,EAAE1B,SAAS,EAAEC,cAAc,CAAC;;QAEvD;QACAlB,CAAC,EAAE;MACL;IACF,CAAC;;IAED;IACAjI,eAAe,CAACmB,OAAO,GAAGwJ,WAAW,CAACC,GAAG,CAAC,CAAC;IAC3C3K,aAAa,CAACkB,OAAO,GAAG,CAAC;IACzBpB,gBAAgB,CAACoB,OAAO,GAAG,CAAC;IAE5BrB,iBAAiB,CAACqB,OAAO,GAAG6F,qBAAqB,CAAEyB,SAAS,IAAK;MAC/DD,UAAU,CAACC,SAAS,EAAEiC,eAAe,CAAC;IACxC,CAAC,CAAC;;IAEF;IACA,OAAO,MAAM;MACX,IAAI5K,iBAAiB,CAACqB,OAAO,EAAE;QAC7BwK,oBAAoB,CAAC7L,iBAAiB,CAACqB,OAAO,CAAC;MACjD;IACF,CAAC;EACH,CAAC,EAAE,CACDlD,MAAM,EACNyC,aAAa,EACbI,SAAS,EACTR,UAAU,EACVrB,IAAI,EACJC,SAAS,EACTP,cAAc,EACdC,iBAAiB,EACjBC,SAAS,EACTC,eAAe,EACfC,eAAe,EACfR,aAAa,EACbyG,YAAY,EACZ6C,gBAAgB,EAChBW,UAAU,EACVQ,UAAU,EACV3J,KAAK,EACLuB,oBAAoB,EACpBrB,oBAAoB,EACpBiE,eAAe,CAACtF,aAAa,EAC7B8C,aAAa,CACd,CAAC;EAEF,oBACEnD,OAAA;IACE+N,GAAG,EAAElM,YAAa;IAClB0G,KAAK,EAAE;MACLxB,QAAQ,EAAE,UAAU;MACpBiH,GAAG,EAAE,CAAC;MACNC,IAAI,EAAE,CAAC;MACPtL,KAAK,EAAE,MAAM;MACbzC,MAAM,EAAEA,MAAM;MACdgO,QAAQ,EAAE,QAAQ;MAClBC,aAAa,EAAE,MAAM;MACrBhO,MAAM,EAAEA,MAAM;MACd;MACAiO,kBAAkB,EAAE,QAAQ;MAC5BC,SAAS,EAAE,eAAe;MAC1BC,UAAU,EAAE;IACd,CAAE;IACF,eAAY,MAAM;IAAAC,QAAA,eAElBvO,OAAA;MACE+N,GAAG,EAAEjM,SAAU;MACfyG,KAAK,EAAE;QACLxB,QAAQ,EAAE,UAAU;QACpBiH,GAAG,EAAE,CAAC;QACNC,IAAI,EAAE,CAAC;QACPtL,KAAK,EAAE,MAAM;QACbzC,MAAM,EAAE,MAAM;QACd;QACAsO,cAAc,EAAE,cAAc;QAC9B;QACAJ,kBAAkB,EAAE,QAAQ;QAC5BC,SAAS,EAAE,eAAe;QAC1BC,UAAU,EAAE;MACd;IAAE;MAAAG,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACH;EAAC;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACC,CAAC;AAEV,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AANAhN,EAAA,CAntBM3B,YAAY;AAAA4O,EAAA,GAAZ5O,YAAY;AA0tBlB,OAAO,MAAM6O,kBAAkB,GAAIC,KAAK,IAAK;EAC3C,MAAMC,YAAY,GAAG;IACnBrO,SAAS,EAAE,wBAAwB;IACnCC,SAAS,EAAE,0BAA0B;IACrCC,UAAU,EAAE,0BAA0B;IACtCP,aAAa,EAAE,CAAC;IAChBC,aAAa,EAAE,CAAC;IAChBC,WAAW,EAAE,IAAI;IACjBC,WAAW,EAAE,GAAG;IAChBC,aAAa,EAAE,EAAE;IACjBS,iBAAiB,EAAE,GAAG;IACtBH,SAAS,EAAE,IAAI;IACfC,eAAe,EAAE,GAAG;IACpBC,eAAe,EAAE;EACnB,CAAC;EAED,oBAAOlB,OAAA,CAACC,YAAY;IAAA,GAAK+O,YAAY;IAAA,GAAMD;EAAK;IAAAN,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAG,CAAC;AACtD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AANAK,GAAA,GAnBaH,kBAAkB;AA0B/B,OAAO,MAAMI,qBAAqB,GAAIH,KAAK,IAAK;EAC9C,MAAMI,eAAe,GAAG;IACtBxO,SAAS,EAAE,wBAAwB;IACnCC,SAAS,EAAE,0BAA0B;IACrCC,UAAU,EAAE,0BAA0B;IACtCP,aAAa,EAAE,CAAC;IAChBC,aAAa,EAAE,CAAC;IAChBC,WAAW,EAAE,IAAI;IACjBC,WAAW,EAAE,GAAG;IAChBC,aAAa,EAAE,EAAE;IACjBS,iBAAiB,EAAE,GAAG;IACtBH,SAAS,EAAE,IAAI;IACfC,eAAe,EAAE,GAAG;IACpBC,eAAe,EAAE;EACnB,CAAC;EAED,oBAAOlB,OAAA,CAACC,YAAY;IAAA,GAAKkP,eAAe;IAAA,GAAMJ;EAAK;IAAAN,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAG,CAAC;AACzD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AANAQ,GAAA,GAnBaF,qBAAqB;AA0BlC,OAAO,MAAMG,mBAAmB,GAAIN,KAAK,IAAK;EAC5C,MAAMO,aAAa,GAAG;IACpB3O,SAAS,EAAE,wBAAwB;IACnCC,SAAS,EAAE,0BAA0B;IACrCC,UAAU,EAAE,0BAA0B;IACtCP,aAAa,EAAE,CAAC;IAChBC,aAAa,EAAE,CAAC;IAChBC,WAAW,EAAE,IAAI;IACjBC,WAAW,EAAE,GAAG;IAChBC,aAAa,EAAE,EAAE;IACjBS,iBAAiB,EAAE,GAAG;IACtBH,SAAS,EAAE,IAAI;IACfC,eAAe,EAAE,GAAG;IACpBC,eAAe,EAAE;EACnB,CAAC;EAED,oBAAOlB,OAAA,CAACC,YAAY;IAAA,GAAKqP,aAAa;IAAA,GAAMP;EAAK;IAAAN,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAG,CAAC;AACvD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AANAW,GAAA,GAnBaF,mBAAmB;AA0BhC,OAAO,MAAMG,gBAAgB,GAAIT,KAAK,IAAK;EACzC,MAAMU,UAAU,GAAG;IACjB9O,SAAS,EAAE,wBAAwB;IACnCC,SAAS,EAAE,0BAA0B;IACrCC,UAAU,EAAE,0BAA0B;IACtCP,aAAa,EAAE,CAAC;IAChBC,aAAa,EAAE,CAAC;IAChBC,WAAW,EAAE,IAAI;IACjBC,WAAW,EAAE,GAAG;IAChBC,aAAa,EAAE,EAAE;IACjBS,iBAAiB,EAAE,GAAG;IACtBH,SAAS,EAAE,IAAI;IACfC,eAAe,EAAE,GAAG;IACpBC,eAAe,EAAE;EACnB,CAAC;EAED,oBAAOlB,OAAA,CAACC,YAAY;IAAA,GAAKwP,UAAU;IAAA,GAAMV;EAAK;IAAAN,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAG,CAAC;AACpD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AANAc,GAAA,GAnBaF,gBAAgB;AA0B7B,OAAO,MAAMG,mBAAmB,GAAIZ,KAAK,IAAK;EAC5C,MAAMa,aAAa,GAAG;IACpBxO,IAAI,EAAE,QAAQ;IACdC,SAAS,EAAE,MAAM;IACjBC,SAAS,EAAE,EAAE;IACbC,cAAc,EAAE,EAAE;IAClBjB,aAAa,EAAE,CAAC;IAChBC,aAAa,EAAE,CAAC;IAChBC,WAAW,EAAE,IAAI;IACjBC,WAAW,EAAE,GAAG;IAChBC,aAAa,EAAE,EAAE;IACjBS,iBAAiB,EAAE,IAAI;IACvBH,SAAS,EAAE,IAAI;IACfC,eAAe,EAAE,GAAG;IACpBC,eAAe,EAAE;EACnB,CAAC;EAED,oBAAOlB,OAAA,CAACC,YAAY;IAAA,GAAK2P,aAAa;IAAA,GAAMb;EAAK;IAAAN,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAG,CAAC;AACvD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPAiB,GAAA,GAnBaF,mBAAmB;AA2BhC,OAAO,MAAMG,eAAe,GAAIf,KAAK,IAAK;EACxC,MAAMgB,SAAS,GAAG;IAChB3O,IAAI,EAAE,QAAQ;IACdC,SAAS,EAAE,KAAK;IAChBf,aAAa,EAAE,CAAC;IAChBC,aAAa,EAAE,CAAC;IAChBC,WAAW,EAAE,IAAI;IACjBC,WAAW,EAAE,GAAG;IAChBC,aAAa,EAAE,EAAE;IACjBS,iBAAiB,EAAE,IAAI;IACvBH,SAAS,EAAE,IAAI;IACfC,eAAe,EAAE,GAAG;IACpBC,eAAe,EAAE;EACnB,CAAC;EAED,oBAAOlB,OAAA,CAACC,YAAY;IAAA,GAAK8P,SAAS;IAAA,GAAMhB;EAAK;IAAAN,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAG,CAAC;AACnD,CAAC;AAACoB,GAAA,GAhBWF,eAAe;AAkB5B,eAAe7P,YAAY;AAAC,IAAA4O,EAAA,EAAAI,GAAA,EAAAG,GAAA,EAAAG,GAAA,EAAAG,GAAA,EAAAG,GAAA,EAAAG,GAAA;AAAAC,YAAA,CAAApB,EAAA;AAAAoB,YAAA,CAAAhB,GAAA;AAAAgB,YAAA,CAAAb,GAAA;AAAAa,YAAA,CAAAV,GAAA;AAAAU,YAAA,CAAAP,GAAA;AAAAO,YAAA,CAAAJ,GAAA;AAAAI,YAAA,CAAAD,GAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}