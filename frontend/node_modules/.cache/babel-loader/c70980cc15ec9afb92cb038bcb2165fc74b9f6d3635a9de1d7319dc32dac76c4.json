{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/MeteorShower.jsx\",\n  _s3 = $RefreshSig$();\nimport React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';\n\n/**\n * MeteorShower Component - Enterprise Performance Optimized Version\n * \n * Creates a highly performant animated meteor shower effect where meteors\n * arc across the sky with comet-like trails and fade away naturally.\n * \n * Features:\n * - Advanced performance optimizations with WebGL acceleration option\n * - Adaptive quality scaling based on device capabilities\n * - Memory and battery-efficient rendering pipeline\n * - Accessibility compliance with reduced motion support\n * - Supports hardware acceleration and high-DPI displays\n * - Enhanced burst effects with realistic particle physics\n * \n * @param {Object} props - Component props\n * @param {string|number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=5] - Z-index for the container\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.meteorDensity=15] - Number of meteors to maintain on screen\n * @param {number} [props.meteorMinSize=1] - Minimum size of meteors\n * @param {number} [props.meteorMaxSize=3] - Maximum size of meteors\n * @param {number} [props.meteorSpeed=0.08] - Base speed of meteors\n * @param {number} [props.trailLength=180] - Length of meteor trails\n * @param {number} [props.trailSegments=20] - Number of segments in each trail\n * @param {string} [props.coreColor='rgba(255, 255, 255, 1)'] - Core color for meteors\n * @param {string} [props.glowColor='rgba(255, 253, 227, 0.9)'] - Glow color for meteors\n * @param {string} [props.trailColor='rgba(191, 173, 127, 0.8)'] - Trail color for meteors\n * @param {boolean} [props.enableParallax=false] - Enable parallax effect on scroll\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of parallax effect\n * @param {boolean} [props.staggered=true] - Enable staggered meteor appearance\n * @param {number} [props.minStaggerDelay=200] - Minimum delay between meteor spawns (ms)\n * @param {number} [props.maxStaggerDelay=2000] - Maximum delay between meteor spawns (ms)\n * @param {number} [props.journeyCompletion=0.9] - When meteors complete their journey (0-1)\n * @param {string} [props.mode='arc'] - Animation mode: 'arc' or 'linear'\n * @param {string} [props.direction='both'] - Direction: 'left', 'right', 'both', or 'top'\n * @param {number} [props.baseAngle=30] - Base angle for linear meteors (degrees)\n * @param {number} [props.angleVariation=15] - Random variation to apply to the base angle\n * @param {boolean} [props.debug=false] - Enable debug visualization\n * @param {boolean} [props.adaptiveQuality=true] - Enable adaptive quality based on device\n * @param {boolean} [props.respectReducedMotion=true] - Respect reduced motion preferences\n * @param {number} [props.maxFPS=60] - Target maximum frames per second\n * @param {boolean} [props.useWebGL=false] - Use WebGL rendering for better performance\n * @param {boolean} [props.enableBursts=true] - Enable meteor burst effects\n * @param {boolean} [props.enableBattery=true] - Enable battery-saving optimizations\n * @param {string} [props.renderingMode='auto'] - Rendering mode: 'auto', '2d', or 'webgl'\n * @param {boolean} [props.enableOffscreenRendering=true] - Enable offscreen canvas when available\n * @param {number} [props.burstParticleCount=12] - Number of particles in each burst\n * @param {number} [props.burstParticleSize=2] - Size of burst particles\n * @param {number} [props.burstProbability=0.4] - Probability of meteor having a burst (0-1)\n * @param {string} [props.burstColorVariation='0.2'] - Amount of color variation in burst particles\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MeteorShower = ({\n  height = '100vh',\n  zIndex = 5,\n  active = true,\n  meteorDensity = 15,\n  meteorMinSize = 1,\n  meteorMaxSize = 3,\n  meteorSpeed = 0.08,\n  trailLength = 180,\n  trailSegments = 20,\n  coreColor = 'rgba(255, 255, 255, 1)',\n  glowColor = 'rgba(255, 245, 158, 0.9)',\n  trailColor = 'rgba(207, 181, 59, 0.8)',\n  enableParallax = false,\n  parallaxIntensity = 0.2,\n  staggered = true,\n  minStaggerDelay = 200,\n  maxStaggerDelay = 2000,\n  journeyCompletion = 0.9,\n  mode = 'arc',\n  direction = 'both',\n  baseAngle = 30,\n  angleVariation = 15,\n  debug = false,\n  adaptiveQuality = true,\n  respectReducedMotion = true,\n  maxFPS = 60,\n  useWebGL = false,\n  enableBursts = true,\n  // Enabled by default now\n  enableBattery = true,\n  renderingMode = 'auto',\n  enableOffscreenRendering = true,\n  burstParticleCount = 12,\n  burstParticleSize = 2,\n  burstProbability = 0.4,\n  burstColorVariation = 0.2\n}) => {\n  _s3();\n  var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const ctxRef = useRef(null);\n  const webGLRef = useRef(null);\n  const offscreenCanvasRef = useRef(null);\n  const workerRef = useRef(null);\n  const meteorsRef = useRef([]);\n  const burstsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const fpsTimestampRef = useRef(0);\n  const frameCountRef = useRef(0);\n  const currentFpsRef = useRef(60);\n  const nextSpawnTimeRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n  const resizeObserverRef = useRef(null);\n  const visibilityObserverRef = useRef(null);\n  const batteryRef = useRef(null);\n  const visibilityChangeTimeRef = useRef(0);\n  const lastBurstCountRef = useRef(0);\n\n  // Component state\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0,\n    pixelRatio: 1\n  });\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [isVisible, setIsVisible] = useState(false);\n  const [qualityFactor, setQualityFactor] = useState(1);\n  const [actualRenderingMode, setActualRenderingMode] = useState('2d');\n  const [deviceCapabilities, setDeviceCapabilities] = useState({\n    memory: 4,\n    cores: 4,\n    batteryLevel: 1,\n    isMobile: false,\n    supportsWebGL: false,\n    supportsOffscreenCanvas: false\n  });\n\n  // Pre-allocate objects to avoid garbage collection during animation\n  const pointCache = useRef({\n    current: {\n      x: 0,\n      y: 0\n    },\n    segment: {\n      x: 0,\n      y: 0\n    }\n  }).current;\n\n  // Precompute color variants to avoid string operations during animation\n  const colorCacheRef = useRef(new Map());\n\n  // WebGL shader programs and buffers\n  const webGLProgramsRef = useRef({\n    meteor: null,\n    trail: null,\n    burst: null\n  });\n\n  // Object pools for efficient memory usage\n  const objectPoolsRef = useRef({\n    meteors: [],\n    bursts: [],\n    vectors: []\n  });\n\n  // Detects device capabilities and sets up optimization strategies\n  const detectCapabilities = useCallback(() => {\n    // Device memory, hardware concurrency, and battery\n    const memory = navigator.deviceMemory || 4;\n    const cores = navigator.hardwareConcurrency || 4;\n    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n\n    // Check WebGL support\n    let supportsWebGL = false;\n    try {\n      const canvas = document.createElement('canvas');\n      supportsWebGL = !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));\n    } catch (e) {\n      supportsWebGL = false;\n    }\n\n    // Check offscreen canvas support\n    const supportsOffscreenCanvas = typeof OffscreenCanvas !== 'undefined';\n\n    // Get battery info if available\n    if (navigator.getBattery && enableBattery) {\n      navigator.getBattery().then(battery => {\n        batteryRef.current = battery;\n        const updateBattery = () => {\n          setDeviceCapabilities(prev => ({\n            ...prev,\n            batteryLevel: battery.level,\n            isCharging: battery.charging\n          }));\n\n          // Reduce quality if on battery and below 30%\n          if (!battery.charging && battery.level < 0.3 && adaptiveQuality) {\n            setQualityFactor(prev => Math.min(prev, 0.6));\n          }\n        };\n\n        // Add battery event listeners\n        battery.addEventListener('levelchange', updateBattery);\n        battery.addEventListener('chargingchange', updateBattery);\n\n        // Initial update\n        updateBattery();\n      }).catch(() => {\n        // Fallback if battery API is not available or fails\n        setDeviceCapabilities(prev => ({\n          ...prev,\n          batteryLevel: 1,\n          isCharging: true\n        }));\n      });\n    }\n\n    // Determine initial rendering mode\n    let initialRenderingMode = '2d';\n    if (renderingMode === 'auto') {\n      if (useWebGL && supportsWebGL) {\n        initialRenderingMode = 'webgl';\n      } else {\n        initialRenderingMode = '2d';\n      }\n    } else {\n      initialRenderingMode = renderingMode === 'webgl' && supportsWebGL ? 'webgl' : '2d';\n    }\n    setActualRenderingMode(initialRenderingMode);\n\n    // Set device capabilities state\n    setDeviceCapabilities({\n      memory,\n      cores,\n      batteryLevel: 1,\n      isCharging: true,\n      isMobile,\n      supportsWebGL,\n      supportsOffscreenCanvas\n    });\n\n    // Calculate quality factor based on capabilities\n    if (adaptiveQuality) {\n      // Base score from hardware\n      const performanceScore = memory * cores / (isMobile ? 2 : 1);\n\n      // Scale quality based on performance score\n      let quality = 1;\n      if (performanceScore > 16) {\n        quality = 1; // High-end devices\n      } else if (performanceScore > 8) {\n        quality = 0.8; // Mid-range devices\n      } else if (performanceScore > 4) {\n        quality = 0.6; // Low-end devices\n      } else {\n        quality = 0.4; // Very low-end devices\n      }\n      setQualityFactor(quality);\n    }\n  }, [useWebGL, renderingMode, adaptiveQuality, enableBattery]);\n\n  // Get cached color with opacity\n  const getCachedColor = useCallback((baseColor, opacity) => {\n    // Round opacity to reduce cache size while maintaining visual quality\n    const roundedOpacity = Math.round(opacity * 100) / 100;\n    const key = `${baseColor}-${roundedOpacity}`;\n    if (!colorCacheRef.current.has(key)) {\n      const newColor = baseColor.replace(/[\\d.]+\\)$/, roundedOpacity + ')');\n      colorCacheRef.current.set(key, newColor);\n    }\n    return colorCacheRef.current.get(key);\n  }, []);\n\n  // Create a color variant based on a base color\n  const createColorVariant = useCallback((baseColor, variation) => {\n    // Parse the rgba values\n    const rgbaMatch = baseColor.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*([\\d.]+))?\\)/);\n    if (!rgbaMatch) return baseColor;\n    const r = parseInt(rgbaMatch[1], 10);\n    const g = parseInt(rgbaMatch[2], 10);\n    const b = parseInt(rgbaMatch[3], 10);\n    const a = rgbaMatch[4] ? parseFloat(rgbaMatch[4]) : 1;\n\n    // Apply random variation to RGB values\n    const vr = Math.max(0, Math.min(255, r + Math.floor((Math.random() * 2 - 1) * variation * 255)));\n    const vg = Math.max(0, Math.min(255, g + Math.floor((Math.random() * 2 - 1) * variation * 255)));\n    const vb = Math.max(0, Math.min(255, b + Math.floor((Math.random() * 2 - 1) * variation * 255)));\n    return `rgba(${vr}, ${vg}, ${vb}, ${a})`;\n  }, []);\n\n  // Adaptive settings based on quality factor\n  const adaptedSettings = useMemo(() => {\n    if (!adaptiveQuality || qualityFactor === 1) {\n      return {\n        meteorDensity,\n        trailSegments,\n        burstParticleCount,\n        useShadow: true,\n        useGlow: true,\n        useHighQualityRendering: true\n      };\n    }\n\n    // Adjust quality-dependent parameters\n    return {\n      meteorDensity: Math.max(3, Math.floor(meteorDensity * qualityFactor)),\n      trailSegments: Math.max(5, Math.floor(trailSegments * qualityFactor)),\n      burstParticleCount: Math.max(4, Math.floor(burstParticleCount * qualityFactor)),\n      useShadow: qualityFactor > 0.5,\n      useGlow: qualityFactor > 0.3,\n      useHighQualityRendering: qualityFactor > 0.7\n    };\n  }, [adaptiveQuality, qualityFactor, meteorDensity, trailSegments, burstParticleCount]);\n\n  // Detect device capabilities and preferences on mount\n  useEffect(() => {\n    // Check for reduced motion preference\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    const handleReducedMotionChange = e => {\n      setPrefersReducedMotion(e.matches);\n    };\n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n\n    // Detect device capabilities\n    detectCapabilities();\n\n    // Setup visibility change detection to pause when tab is inactive\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        visibilityChangeTimeRef.current = performance.now();\n      } else {\n        // Adjust timing references after visibility changes\n        const timeDelta = performance.now() - visibilityChangeTimeRef.current;\n        lastTimestampRef.current += timeDelta;\n        nextSpawnTimeRef.current += timeDelta;\n      }\n    };\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n\n    // Capture current worker ref to avoid closure issues\n    const currentWorker = workerRef.current;\n\n    // Cleanup\n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n\n      // Clean up worker if active\n      if (currentWorker) {\n        currentWorker.terminate();\n      }\n    };\n  }, [detectCapabilities]);\n\n  // Initialize WebGL context and shaders if using WebGL\n  const initWebGL = useCallback(() => {\n    if (!canvasRef.current || actualRenderingMode !== 'webgl') return false;\n    try {\n      // Get WebGL context\n      const gl = canvasRef.current.getContext('webgl', {\n        alpha: true,\n        antialias: true,\n        premultipliedAlpha: false,\n        depth: false\n      });\n      if (!gl) return false;\n      webGLRef.current = gl;\n\n      // Create shader programs, vertex buffers, etc.\n      // This is a simplified placeholder - a real implementation would include\n      // proper shaders, attribute locations, and uniform setup\n\n      // Enable blending for transparency\n      gl.enable(gl.BLEND);\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n      // Set clear color to fully transparent\n      gl.clearColor(0.0, 0.0, 0.0, 0.0);\n\n      // Get current dimensions for viewport\n      const canvasWidth = canvasRef.current.width;\n      const canvasHeight = canvasRef.current.height;\n\n      // Set viewport\n      gl.viewport(0, 0, canvasWidth, canvasHeight);\n\n      // Simple vertex shader for meteor particles\n      const vertexShaderSource = `\n        attribute vec2 aPosition;\n        attribute float aSize;\n        attribute vec4 aColor;\n        \n        varying vec4 vColor;\n        \n        uniform vec2 uResolution;\n        \n        void main() {\n          // Convert to clip space\n          vec2 position = (aPosition / uResolution) * 2.0 - 1.0;\n          position.y = -position.y;\n          \n          gl_Position = vec4(position, 0, 1);\n          gl_PointSize = aSize;\n          vColor = aColor;\n        }\n      `;\n\n      // Simple fragment shader for meteor particles\n      const fragmentShaderSource = `\n        precision mediump float;\n        varying vec4 vColor;\n        \n        void main() {\n          // Calculate distance from center for circular point\n          float distance = length(gl_PointCoord - vec2(0.5, 0.5));\n          if (distance > 0.5) {\n            discard; // Outside circle\n          }\n          \n          // Softer edges\n          float alpha = smoothstep(0.5, 0.4, distance) * vColor.a;\n          gl_FragColor = vec4(vColor.rgb, alpha);\n        }\n      `;\n\n      // Compile shader program\n      const createShader = (gl, type, source) => {\n        const shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n\n        // Check for compilation errors\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n          console.error('Shader compilation error:', gl.getShaderInfoLog(shader));\n          gl.deleteShader(shader);\n          return null;\n        }\n        return shader;\n      };\n      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n      if (!vertexShader || !fragmentShader) {\n        return false;\n      }\n      const program = gl.createProgram();\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n\n      // Check for linking errors\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        console.error('Program linking error:', gl.getProgramInfoLog(program));\n        gl.deleteProgram(program);\n        return false;\n      }\n\n      // Store the program\n      webGLProgramsRef.current.meteor = {\n        program,\n        attributes: {\n          position: gl.getAttribLocation(program, 'aPosition'),\n          size: gl.getAttribLocation(program, 'aSize'),\n          color: gl.getAttribLocation(program, 'aColor')\n        },\n        uniforms: {\n          resolution: gl.getUniformLocation(program, 'uResolution')\n        }\n      };\n\n      // Now create shader program for burst particles\n      // This can be similar to the meteor program but with different parameters\n\n      // Simple vertex shader for burst particles\n      const burstVertexShaderSource = `\n        attribute vec2 aPosition;\n        attribute float aSize;\n        attribute vec4 aColor;\n        \n        varying vec4 vColor;\n        \n        uniform vec2 uResolution;\n        \n        void main() {\n          // Convert to clip space\n          vec2 position = (aPosition / uResolution) * 2.0 - 1.0;\n          position.y = -position.y;\n          \n          gl_Position = vec4(position, 0, 1);\n          gl_PointSize = aSize;\n          vColor = aColor;\n        }\n      `;\n\n      // Simple fragment shader for burst particles with softer edges\n      const burstFragmentShaderSource = `\n        precision mediump float;\n        varying vec4 vColor;\n        \n        void main() {\n          // Calculate distance from center for circular point\n          float distance = length(gl_PointCoord - vec2(0.5, 0.5));\n          if (distance > 0.5) {\n            discard; // Outside circle\n          }\n          \n          // Very soft edges for burst particles\n          float alpha = smoothstep(0.5, 0.2, distance) * vColor.a;\n          gl_FragColor = vec4(vColor.rgb, alpha);\n        }\n      `;\n      const burstVertexShader = createShader(gl, gl.VERTEX_SHADER, burstVertexShaderSource);\n      const burstFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, burstFragmentShaderSource);\n      if (!burstVertexShader || !burstFragmentShader) {\n        return false;\n      }\n      const burstProgram = gl.createProgram();\n      gl.attachShader(burstProgram, burstVertexShader);\n      gl.attachShader(burstProgram, burstFragmentShader);\n      gl.linkProgram(burstProgram);\n\n      // Check for linking errors\n      if (!gl.getProgramParameter(burstProgram, gl.LINK_STATUS)) {\n        console.error('Burst program linking error:', gl.getProgramInfoLog(burstProgram));\n        gl.deleteProgram(burstProgram);\n      } else {\n        // Store the burst program\n        webGLProgramsRef.current.burst = {\n          program: burstProgram,\n          attributes: {\n            position: gl.getAttribLocation(burstProgram, 'aPosition'),\n            size: gl.getAttribLocation(burstProgram, 'aSize'),\n            color: gl.getAttribLocation(burstProgram, 'aColor')\n          },\n          uniforms: {\n            resolution: gl.getUniformLocation(burstProgram, 'uResolution')\n          }\n        };\n      }\n      return true;\n    } catch (error) {\n      console.error('WebGL initialization error:', error);\n      setActualRenderingMode('2d');\n      return false;\n    }\n  }, [actualRenderingMode]);\n\n  // Calculate path parameters for a meteor based on selected mode\n  const calculateMeteorPath = useCallback((width, height) => {\n    if (mode === 'arc') {\n      // Arc path logic with optimized parameters\n      const startX = Math.random() * width * 1.5 - width * 0.25;\n      const startY = Math.random() * -100 - 50;\n      const curveDirection = Math.random() > 0.5 ? 1 : -1;\n      const curveIntensity = Math.random() * 0.4 + 0.2;\n      const endX = startX + curveDirection * width * curveIntensity;\n      const endY = height * journeyCompletion;\n      const controlX = (startX + endX) / 2 + curveDirection * width * curveIntensity;\n      const controlY = (startY + endY) * 0.5;\n      return {\n        pathType: 'arc',\n        start: {\n          x: startX,\n          y: startY\n        },\n        control: {\n          x: controlX,\n          y: controlY\n        },\n        end: {\n          x: endX,\n          y: endY\n        }\n      };\n    } else if (mode === 'linear') {\n      // Linear path logic with enhanced direction control\n      let meteorDirection = direction;\n      if (direction === 'both') {\n        meteorDirection = Math.random() > 0.5 ? 'left' : 'right';\n      }\n      let angle;\n      if (direction === 'top') {\n        angle = (30 + (Math.random() * 2 - 1) * 5) * Math.PI / 180;\n      } else {\n        angle = (baseAngle + (Math.random() * 2 - 1) * angleVariation) * Math.PI / 180;\n      }\n      let startX;\n      if (meteorDirection === 'left') {\n        startX = Math.random() * (width * 0.3) - width * 0.1;\n      } else if (meteorDirection === 'right') {\n        startX = width - Math.random() * (width * 0.3) + width * 0.1;\n      } else if (direction === 'top') {\n        const position = Math.random();\n        if (position < 0.5) {\n          startX = Math.random() * (width * 0.35);\n        } else if (position < 0.85) {\n          startX = width * 0.35 + Math.random() * (width * 0.35);\n        } else {\n          startX = width * 0.7 + Math.random() * (width * 0.3);\n        }\n      }\n      const startY = Math.random() * -100 - 50;\n      const distanceToTravel = height * journeyCompletion / Math.cos(angle);\n      let endX, endY;\n      if (meteorDirection === 'left' || direction === 'top') {\n        endX = startX + distanceToTravel * Math.sin(angle);\n        endY = startY + distanceToTravel * Math.cos(angle);\n      } else {\n        endX = startX - distanceToTravel * Math.sin(angle);\n        endY = startY + distanceToTravel * Math.cos(angle);\n      }\n      return {\n        pathType: 'linear',\n        start: {\n          x: startX,\n          y: startY\n        },\n        end: {\n          x: endX,\n          y: endY\n        },\n        direction: meteorDirection\n      };\n    }\n  }, [mode, direction, baseAngle, angleVariation, journeyCompletion]);\n\n  // Get point along path with highly optimized calculations\n  const getPathPoint = useCallback((t, path, outPoint = {\n    x: 0,\n    y: 0\n  }) => {\n    if (path.pathType === 'arc') {\n      // Optimized quadratic bezier calculation using pre-computed terms\n      const invT = 1 - t;\n      const invTSquared = invT * invT;\n      const tSquared = t * t;\n      const term1 = invTSquared;\n      const term2 = 2 * invT * t;\n      const term3 = tSquared;\n      outPoint.x = term1 * path.start.x + term2 * path.control.x + term3 * path.end.x;\n      outPoint.y = term1 * path.start.y + term2 * path.control.y + term3 * path.end.y;\n    } else {\n      // Linear interpolation with minimal operations\n      outPoint.x = path.start.x + (path.end.x - path.start.x) * t;\n      outPoint.y = path.start.y + (path.end.y - path.start.y) * t;\n    }\n    return outPoint;\n  }, []);\n\n  // Calculate velocity at a point on the path (for trail orientation)\n  const getPathVelocity = useCallback((t, path, outVelocity = {\n    x: 0,\n    y: 0\n  }) => {\n    if (path.pathType === 'arc') {\n      // Derivative of quadratic bezier\n      const term1 = 2 * (1 - t);\n      const term2 = 2 * t;\n      outVelocity.x = term1 * (path.control.x - path.start.x) + term2 * (path.end.x - path.control.x);\n      outVelocity.y = term1 * (path.control.y - path.start.y) + term2 * (path.end.y - path.control.y);\n    } else {\n      // Constant velocity for linear paths\n      outVelocity.x = path.end.x - path.start.x;\n      outVelocity.y = path.end.y - path.start.y;\n\n      // Normalize\n      const length = Math.sqrt(outVelocity.x * outVelocity.x + outVelocity.y * outVelocity.y);\n      if (length > 0) {\n        outVelocity.x /= length;\n        outVelocity.y /= length;\n      }\n    }\n    return outVelocity;\n  }, []);\n\n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current || !containerRef.current) return false;\n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    const rect = container.getBoundingClientRect();\n    const pixelRatio = window.devicePixelRatio || 1;\n\n    // Calculate dimensions\n    const displayWidth = rect.width;\n    const displayHeight = typeof height === 'string' && height.endsWith('vh') ? parseInt(height, 10) / 100 * window.innerHeight : parseInt(height, 10) || window.innerHeight;\n\n    // Set canvas size accounting for pixel ratio\n    canvas.width = displayWidth * pixelRatio;\n    canvas.height = displayHeight * pixelRatio;\n    canvas.style.width = `${displayWidth}px`;\n    canvas.style.height = `${displayHeight}px`;\n\n    // Get appropriate rendering context\n    if (actualRenderingMode === 'webgl') {\n      initWebGL();\n    } else {\n      // 2D Canvas context\n      const ctx = canvas.getContext('2d', {\n        alpha: true,\n        desynchronized: true,\n        willReadFrequently: false\n      });\n      if (!ctx) return false;\n\n      // Scale context for high-DPI displays\n      ctx.scale(pixelRatio, pixelRatio);\n\n      // Configure context for high-quality rendering\n      if (adaptedSettings.useHighQualityRendering) {\n        ctx.imageSmoothingEnabled = true;\n        ctx.imageSmoothingQuality = 'high';\n      }\n      ctxRef.current = ctx;\n    }\n\n    // Initialize offscreen canvas if supported and enabled\n    if (enableOffscreenRendering && typeof OffscreenCanvas !== 'undefined' && deviceCapabilities.supportsOffscreenCanvas) {\n      try {\n        // Create offscreen canvas\n        const offscreen = new OffscreenCanvas(displayWidth * pixelRatio, displayHeight * pixelRatio);\n\n        // Get 2D context for offscreen canvas\n        const offscreenCtx = offscreen.getContext('2d');\n        if (offscreenCtx) {\n          offscreenCtx.scale(pixelRatio, pixelRatio);\n          offscreenCanvasRef.current = {\n            canvas: offscreen,\n            ctx: offscreenCtx\n          };\n        }\n      } catch (error) {\n        console.warn('Offscreen canvas initialization error:', error);\n      }\n    }\n    setDimensions({\n      width: displayWidth,\n      height: displayHeight,\n      pixelRatio\n    });\n    return true;\n  }, [height, actualRenderingMode, initWebGL, enableOffscreenRendering, deviceCapabilities.supportsOffscreenCanvas, adaptedSettings.useHighQualityRendering]);\n\n  // Setup canvas resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Create a ResizeObserver to detect container size changes\n    const resizeObserver = new ResizeObserver(entries => {\n      // Debounce resize operations\n      if (resizeObserverRef.current.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n      resizeObserverRef.current.timeout = setTimeout(() => {\n        requestAnimationFrame(() => {\n          if (setupCanvas()) {\n            setIsInitialized(true);\n          }\n        });\n      }, 100); // 100ms debounce\n    });\n\n    // Capture current reference to avoid closure issues in cleanup\n    const currentContainer = containerRef.current;\n\n    // Start observing the container\n    resizeObserver.observe(currentContainer);\n    resizeObserverRef.current = {\n      observer: resizeObserver\n    };\n\n    // Initial setup\n    setupCanvas();\n    setIsInitialized(true);\n    return () => {\n      if (resizeObserverRef.current.observer) {\n        resizeObserverRef.current.observer.disconnect();\n      }\n      if (resizeObserverRef.current.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n    };\n  }, [setupCanvas]);\n\n  // Setup intersection observer to only animate when visible\n  useEffect(() => {\n    if (!containerRef.current) return;\n    const observer = new IntersectionObserver(entries => {\n      const isIntersecting = entries[0].isIntersecting;\n\n      // Only change state if visibility actually changed\n      if (isIntersecting !== isVisible) {\n        setIsVisible(isIntersecting);\n        if (isIntersecting) {\n          // Reset timing references when becoming visible again\n          lastTimestampRef.current = 0;\n          nextSpawnTimeRef.current = performance.now();\n        }\n      }\n    }, {\n      threshold: 0.01,\n      rootMargin: '100px'\n    });\n\n    // Store current reference to avoid closure issues\n    const currentContainerRef = containerRef.current;\n    observer.observe(currentContainerRef);\n    visibilityObserverRef.current = observer;\n    return () => {\n      if (visibilityObserverRef.current) {\n        visibilityObserverRef.current.disconnect();\n      }\n    };\n  }, [isVisible]);\n\n  // Handle parallax effect on scroll if enabled\n  useEffect(() => {\n    if (!enableParallax) return;\n\n    // Use passive event listener for better performance\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    window.addEventListener('scroll', handleScroll, {\n      passive: true\n    });\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [enableParallax]);\n\n  // Get a meteor from the object pool or create a new one\n  const getMeteor = useCallback(() => {\n    // Try to get from pool first\n    const pool = objectPoolsRef.current.meteors;\n    let meteor;\n    if (pool.length > 0) {\n      meteor = pool.pop();\n      // Reset meteor properties\n      meteor.progress = 0;\n      meteor.active = true;\n    } else {\n      // Create new if pool is empty\n      meteor = {\n        progress: 0,\n        active: true,\n        positions: Array(adaptedSettings.trailSegments)\n      };\n\n      // Pre-allocate position objects\n      for (let i = 0; i < adaptedSettings.trailSegments; i++) {\n        meteor.positions[i] = {\n          x: 0,\n          y: 0\n        };\n      }\n    }\n    return meteor;\n  }, [adaptedSettings.trailSegments]);\n\n  // Initialize a meteor with all required properties\n  const initializeMeteor = useCallback(() => {\n    const {\n      width,\n      height\n    } = dimensions;\n    if (!width || !height) return null;\n\n    // Get meteor from pool\n    const meteor = getMeteor();\n\n    // Calculate path based on mode\n    const path = calculateMeteorPath(width, height);\n\n    // Set path and initial position\n    meteor.path = path;\n    for (let i = 0; i < meteor.positions.length; i++) {\n      meteor.positions[i].x = path.start.x;\n      meteor.positions[i].y = path.start.y;\n    }\n\n    // Set meteor properties\n    meteor.size = Math.random() * (meteorMaxSize - meteorMinSize) + meteorMinSize;\n    meteor.speed = meteorSpeed * (Math.random() * 0.5 + 0.75);\n    meteor.opacity = Math.random() * 0.3 + 0.7;\n    meteor.fadeThreshold = 0.7 + Math.random() * 0.2;\n    meteor.pulsePhase = Math.random() * Math.PI * 2;\n    meteor.pulseSpeed = Math.random() * 0.01 + 0.005;\n\n    // Add burst properties if enabled\n    if (enableBursts && Math.random() < burstProbability) {\n      meteor.hasBurst = true;\n\n      // Vary the burst threshold - occasionally have early bursts for variety\n      const earlyBurst = Math.random() < 0.15; // 15% chance for early burst\n      meteor.burstThreshold = earlyBurst ? 0.3 + Math.random() * 0.4 // Early burst range (0.3-0.7)\n      : 0.85 + Math.random() * 0.13; // Normal late burst range (0.85-0.98)\n\n      meteor.burstTriggered = false;\n\n      // Adjust burst size based on when it occurs\n      meteor.burstSize = earlyBurst ? meteor.size * (3 + Math.random() * 4) // Larger for early bursts\n      : meteor.size * (2 + Math.random() * 2); // More controlled for end bursts\n\n      // Adjust particle count based on when it occurs\n      meteor.burstParticles = Math.floor(adaptedSettings.burstParticleCount * (earlyBurst ? 1.2 : 0.8) * (\n      // More particles for early bursts\n      0.8 + Math.random() * 0.4));\n\n      // Use custom gold-centric colors for dark fantasy aesthetic\n      // No need to use createColorVariant here since we're using specific themed colors\n      meteor.burstColors = ['rgba(255, 215, 0, 1)',\n      // Gold\n      'rgba(218, 165, 32, 1)',\n      // Goldenrod\n      'rgba(212, 175, 55, 1)',\n      // Metallic gold\n      'rgba(207, 181, 59, 1)',\n      // Old gold\n      earlyBurst ? 'rgba(255, 255, 220, 1)' : 'rgba(192, 192, 192, 1)' // Bright for early, silver for late\n      ];\n    } else {\n      meteor.hasBurst = false;\n    }\n    return meteor;\n  }, [dimensions, calculateMeteorPath, meteorMinSize, meteorMaxSize, meteorSpeed, enableBursts, burstProbability, adaptedSettings.burstParticleCount, getMeteor]);\n\n  // Get a burst particle from the object pool or create a new one\n  const getBurstParticle = useCallback(() => {\n    const pool = objectPoolsRef.current.bursts;\n    if (pool.length > 0) {\n      const burst = pool.pop();\n      // Reset properties\n      burst.life = 1.0;\n      return burst;\n    }\n\n    // Create new if pool is empty\n    return {};\n  }, []);\n\n  // Create a burst effect at a specified position\n  const createBurst = useCallback((x, y, size, colors, particleCount, velocityInfluence = {\n    x: 0,\n    y: 0\n  }) => {\n    // Skip if bursts are not enabled\n    if (!enableBursts) return;\n\n    // Limit the number of active burst particles to avoid performance issues\n    const maxBurstParticles = adaptedSettings.useHighQualityRendering ? 300 : 150;\n\n    // If we're already close to the limit, reduce the number of particles\n    let actualParticleCount = particleCount;\n    if (burstsRef.current.length > maxBurstParticles - particleCount) {\n      actualParticleCount = Math.max(4, Math.floor(particleCount * 0.5));\n    }\n\n    // Skip burst creation completely if we're already over the limit\n    if (burstsRef.current.length > maxBurstParticles) {\n      // Remove older bursts to make room\n      const toRemove = Math.min(20, burstsRef.current.length - maxBurstParticles + actualParticleCount);\n      for (let i = 0; i < toRemove; i++) {\n        const oldBurst = burstsRef.current.shift();\n        if (oldBurst) {\n          objectPoolsRef.current.bursts.push(oldBurst);\n        }\n      }\n    }\n\n    // Track burst counts for debug\n    lastBurstCountRef.current = actualParticleCount;\n\n    // Create fragments that look like pieces of the meteor breaking apart\n    for (let i = 0; i < actualParticleCount; i++) {\n      // Create directional burst effect following the meteor's trajectory\n      const baseAngle = Math.atan2(velocityInfluence.y, velocityInfluence.x);\n\n      // Calculate particle direction - within a forward-facing cone\n      const angleSpread = 1.2; // Narrower spread for more focused effect\n      const angleVariance = Math.random() * angleSpread - angleSpread / 2;\n      const angle = baseAngle + angleVariance;\n\n      // Speed - slower for a more elegant effect\n      const speedVariance = Math.random() * 0.4 + 0.7;\n      const baseSpeed = 0.4 + Math.random() * 0.8; // Slower overall\n      const speed = baseSpeed * speedVariance;\n\n      // Calculate velocity components\n      const vx = Math.cos(angle) * speed + velocityInfluence.x * 0.4;\n      const vy = Math.sin(angle) * speed + velocityInfluence.y * 0.4;\n\n      // Create fragments of different sizes\n      const sizeVariance = 0.2 + Math.random() * 0.8;\n      const particleSize = size * sizeVariance * burstParticleSize * 0.6;\n\n      // Use meteor's colors for the fragments\n      const colorIndex = Math.random() < 0.7 ? 0 : 1; // 70% core color, 30% glow color\n      const color = colorIndex === 0 ? coreColor : glowColor;\n\n      // Create the burst particle\n      const burst = getBurstParticle();\n\n      // Set properties\n      burst.x = x;\n      burst.y = y;\n      burst.vx = vx;\n      burst.vy = vy;\n      burst.size = particleSize;\n      burst.life = 1.0;\n      burst.decay = 0.006 + Math.random() * 0.01; // Slower decay\n      burst.color = color;\n      burst.trailLength = 2 + Math.random() * 6; // Length of trail behind fragment\n\n      // More elegantly diminishing velocity\n      burst.damping = 0.95 + Math.random() * 0.03;\n\n      // Add to active bursts\n      burstsRef.current.push(burst);\n    }\n  }, [enableBursts, adaptedSettings.useHighQualityRendering, getBurstParticle, burstParticleSize, coreColor, glowColor]);\n\n  // Render burst particles with WebGL\n  const renderBurstsWebGL = _s(useCallback(_s((gl, deltaTime) => {\n    _s();\n    if (!enableBursts || burstsRef.current.length === 0 || !webGLProgramsRef.current.burst) return;\n    const burstProgram = webGLProgramsRef.current.burst;\n\n    // Use burst shader program\n    gl.useProgram(burstProgram.program);\n\n    // Set resolution uniform\n    gl.uniform2f(burstProgram.uniforms.resolution, canvasRef.current.width, canvasRef.current.height);\n\n    // Create float32 arrays to hold position, size, and color data\n    // 2 floats per position (x, y)\n    const positions = new Float32Array(burstsRef.current.length * 2);\n    // 1 float per size\n    const sizes = new Float32Array(burstsRef.current.length);\n    // 4 floats per color (r, g, b, a)\n    const colors = new Float32Array(burstsRef.current.length * 4);\n\n    // Process each burst particle and update its data\n    for (let i = 0; i < burstsRef.current.length; i++) {\n      const burst = burstsRef.current[i];\n\n      // Update position\n      burst.x += burst.vx * (deltaTime / 16);\n      burst.y += burst.vy * (deltaTime / 16);\n\n      // Apply gravity if present\n      if (burst.gravity) {\n        burst.vy += burst.gravity * (deltaTime / 16);\n      }\n\n      // Apply damping to velocity\n      burst.vx *= burst.damping;\n      burst.vy *= burst.damping;\n\n      // Update rotation\n      burst.rotation += burst.rotationSpeed * (deltaTime / 16);\n\n      // Reduce life\n      burst.life -= burst.decay * (deltaTime / 16);\n\n      // Map burst data to arrays\n      const posIndex = i * 2;\n      positions[posIndex] = burst.x;\n      positions[posIndex + 1] = burst.y;\n      sizes[i] = burst.size * Math.pow(burst.life, 0.7) * dimensions.pixelRatio;\n\n      // Parse color components from rgba string\n      // This is a simplified placeholder - you'd need proper color parsing\n      const colorIndex = i * 4;\n      colors[colorIndex] = 1.0; // r\n      colors[colorIndex + 1] = 0.9; // g\n      colors[colorIndex + 2] = 0.7; // b\n      colors[colorIndex + 3] = burst.life * 0.7; // a\n    }\n\n    // Create and bind position buffer\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(burstProgram.attributes.position);\n    gl.vertexAttribPointer(burstProgram.attributes.position, 2, gl.FLOAT, false, 0, 0);\n\n    // Create and bind size buffer\n    const sizeBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, sizes, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(burstProgram.attributes.size);\n    gl.vertexAttribPointer(burstProgram.attributes.size, 1, gl.FLOAT, false, 0, 0);\n\n    // Create and bind color buffer\n    const colorBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(burstProgram.attributes.color);\n    gl.vertexAttribPointer(burstProgram.attributes.color, 4, gl.FLOAT, false, 0, 0);\n\n    // Draw points\n    gl.drawArrays(gl.POINTS, 0, burstsRef.current.length);\n\n    // Clean up\n    gl.disableVertexAttribArray(burstProgram.attributes.position);\n    gl.disableVertexAttribArray(burstProgram.attributes.size);\n    gl.disableVertexAttribArray(burstProgram.attributes.color);\n    gl.deleteBuffer(positionBuffer);\n    gl.deleteBuffer(sizeBuffer);\n    gl.deleteBuffer(colorBuffer);\n\n    // Filter out dead particles\n    let j = 0;\n    for (let i = 0; i < burstsRef.current.length; i++) {\n      const burst = burstsRef.current[i];\n      if (burst.life > 0) {\n        // Keep alive particles, compact array\n        if (i !== j) {\n          burstsRef.current[j] = burst;\n        }\n        j++;\n      } else {\n        // Return to object pool\n        objectPoolsRef.current.bursts.push(burst);\n      }\n    }\n\n    // Truncate array to remove dead particles\n    if (j < burstsRef.current.length) {\n      burstsRef.current.length = j;\n    }\n  }, \"ZdQBZ3rq7bWAAMQq6hlVCmYF0jM=\", false, function () {\n    return [gl.useProgram];\n  }), [enableBursts, dimensions.pixelRatio]), \"ZdQBZ3rq7bWAAMQq6hlVCmYF0jM=\", true);\n\n  // Render burst particles with Canvas 2D\n  const renderBursts2D = useCallback((ctx, deltaTime) => {\n    if (!enableBursts || burstsRef.current.length === 0) return;\n\n    // Process and render each burst particle\n    let j = 0;\n    for (let i = 0; i < burstsRef.current.length; i++) {\n      const burst = burstsRef.current[i];\n\n      // Update position\n      burst.x += burst.vx * (deltaTime / 16);\n      burst.y += burst.vy * (deltaTime / 16);\n\n      // Apply damping to velocity\n      burst.vx *= burst.damping;\n      burst.vy *= burst.damping;\n\n      // Reduce life\n      burst.life -= burst.decay * (deltaTime / 16);\n\n      // Keep alive particles\n      if (burst.life > 0) {\n        // Draw particle\n        ctx.save();\n\n        // Get velocity direction for trail orientation\n        const angle = Math.atan2(burst.vy, burst.vx);\n        if (adaptedSettings.useHighQualityRendering) {\n          // Draw trail behind fragment\n          const trailLength = (burst.trailLength || 4) * burst.life;\n          const fragmentSize = burst.size * burst.life;\n\n          // Create trail gradient\n          const trailGradient = ctx.createLinearGradient(burst.x, burst.y, burst.x - Math.cos(angle) * trailLength, burst.y - Math.sin(angle) * trailLength);\n\n          // Get the base color with varying opacity\n          trailGradient.addColorStop(0, getCachedColor(burst.color, burst.life * 0.8));\n          trailGradient.addColorStop(0.5, getCachedColor(burst.color, burst.life * 0.4));\n          trailGradient.addColorStop(1, getCachedColor(burst.color, 0));\n\n          // Draw trail\n          ctx.beginPath();\n          ctx.moveTo(burst.x, burst.y);\n          ctx.lineTo(burst.x - Math.cos(angle) * trailLength, burst.y - Math.sin(angle) * trailLength);\n          ctx.lineWidth = fragmentSize * 0.8;\n          ctx.lineCap = 'round';\n          ctx.strokeStyle = trailGradient;\n          ctx.stroke();\n\n          // Draw fragment\n          if (adaptedSettings.useGlow) {\n            ctx.shadowColor = burst.color;\n            ctx.shadowBlur = fragmentSize * 2;\n          }\n          ctx.beginPath();\n          ctx.arc(burst.x, burst.y, fragmentSize * 0.5, 0, Math.PI * 2);\n          ctx.fillStyle = getCachedColor(burst.color, burst.life);\n          ctx.fill();\n        } else {\n          // Simplified rendering for lower performance devices\n          const trailLength = (burst.trailLength || 3) * burst.life;\n          const fragmentSize = burst.size * burst.life;\n\n          // Draw simple tapered line\n          ctx.beginPath();\n          ctx.moveTo(burst.x, burst.y);\n          ctx.lineTo(burst.x - Math.cos(angle) * trailLength, burst.y - Math.sin(angle) * trailLength);\n          ctx.lineWidth = fragmentSize * 0.7;\n          ctx.lineCap = 'round';\n          ctx.strokeStyle = getCachedColor(burst.color, burst.life * 0.6);\n          ctx.stroke();\n        }\n        ctx.restore();\n\n        // Compact alive particles\n        if (i !== j) {\n          burstsRef.current[j] = burst;\n        }\n        j++;\n      } else {\n        // Return to object pool\n        objectPoolsRef.current.bursts.push(burst);\n      }\n    }\n\n    // Truncate array to remove dead particles\n    if (j < burstsRef.current.length) {\n      burstsRef.current.length = j;\n    }\n  }, [enableBursts, adaptedSettings.useHighQualityRendering, adaptedSettings.useGlow, getCachedColor]);\n\n  // 2D Canvas rendering method for meteors\n  const renderMeteors2D = useCallback((ctx, parallaxOffset, timestamp) => {\n    // Process and render each meteor\n    meteorsRef.current.forEach(meteor => {\n      // Calculate opacity based on progress\n      let currentOpacity = meteor.opacity;\n      if (meteor.progress > meteor.fadeThreshold) {\n        const fadeProgress = (meteor.progress - meteor.fadeThreshold) / (1 - meteor.fadeThreshold);\n        currentOpacity = meteor.opacity * (1 - fadeProgress);\n      }\n\n      // Apply pulse effect\n      const timeFactor = timestamp * 0.001;\n      const pulseEffect = Math.sin(timeFactor * meteor.pulseSpeed + meteor.pulsePhase) * 0.2 + 0.8;\n\n      // Parallax offset adjustment\n      const adjustY = enableParallax ? parallaxOffset * (meteor.size / meteorMaxSize) : 0;\n\n      // Check if we should create a burst effect\n      if (meteor.hasBurst && !meteor.burstTriggered && meteor.progress >= meteor.burstThreshold) {\n        meteor.burstTriggered = true;\n        const burstPosition = meteor.positions[0];\n\n        // Get velocity at burst point for influence on particles\n        const velocityPoint = {\n          x: 0,\n          y: 0\n        };\n        getPathVelocity(meteor.progress, meteor.path, velocityPoint);\n\n        // Scale velocity for better visual effect\n        velocityPoint.x *= 0.8;\n        velocityPoint.y *= 0.8;\n\n        // Create burst with velocity influence\n        createBurst(burstPosition.x, burstPosition.y + adjustY, meteor.burstSize, meteor.burstColors, meteor.burstParticles, velocityPoint);\n      }\n\n      // Optimized rendering approach\n      if (adaptedSettings.useHighQualityRendering) {\n        // High-quality rendering with shadows\n        // Set shadow for glow effect if enabled\n        if (adaptedSettings.useGlow) {\n          ctx.shadowColor = glowColor;\n          ctx.shadowBlur = meteor.size * 3 * pulseEffect;\n        }\n\n        // Draw trail segments\n        ctx.lineCap = 'round';\n        for (let i = meteor.positions.length - 2; i >= 0; i--) {\n          const pos1 = meteor.positions[i];\n          const pos2 = meteor.positions[i + 1];\n          if (!pos1 || !pos2) continue;\n\n          // Calculate segment opacity (decreases along the trail)\n          const segmentOpacity = currentOpacity * (1 - i / meteor.positions.length) * pulseEffect;\n\n          // Skip if nearly invisible\n          if (segmentOpacity < 0.02) continue;\n\n          // Calculate segment width (decreases along the trail)\n          const segmentWidth = meteor.size * (1 - i / meteor.positions.length * 0.7);\n\n          // Draw line segment\n          ctx.beginPath();\n          ctx.moveTo(pos1.x, pos1.y + adjustY);\n          ctx.lineTo(pos2.x, pos2.y + adjustY);\n\n          // Set line style\n          ctx.lineWidth = segmentWidth;\n          ctx.strokeStyle = getCachedColor(trailColor, segmentOpacity);\n          ctx.stroke();\n        }\n\n        // Draw meteor head\n        if (meteor.positions[0]) {\n          const headPos = meteor.positions[0];\n\n          // Set shadow for head\n          if (adaptedSettings.useShadow) {\n            ctx.shadowColor = glowColor;\n            ctx.shadowBlur = meteor.size * 5 * pulseEffect;\n          }\n\n          // Draw outer glow\n          ctx.beginPath();\n          ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 1.5, 0, Math.PI * 2);\n          ctx.fillStyle = getCachedColor(glowColor, currentOpacity * 0.7 * pulseEffect);\n          ctx.fill();\n\n          // Draw inner core\n          ctx.beginPath();\n          ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 0.7, 0, Math.PI * 2);\n          ctx.fillStyle = getCachedColor(coreColor, currentOpacity * pulseEffect);\n          ctx.fill();\n        }\n      } else {\n        // Performance-optimized rendering for lower-end devices\n        // Draw simplified trail\n        ctx.beginPath();\n        const headPos = meteor.positions[0];\n        if (!headPos) return;\n        ctx.moveTo(headPos.x, headPos.y + adjustY);\n        for (let i = 1; i < meteor.positions.length; i += 2) {\n          const pos = meteor.positions[i];\n          if (!pos) continue;\n          ctx.lineTo(pos.x, pos.y + adjustY);\n        }\n\n        // Gradient trail\n        const gradient = ctx.createLinearGradient(headPos.x, headPos.y + adjustY, meteor.positions[meteor.positions.length - 1].x, meteor.positions[meteor.positions.length - 1].y + adjustY);\n        gradient.addColorStop(0, getCachedColor(coreColor, currentOpacity * pulseEffect));\n        gradient.addColorStop(0.3, getCachedColor(glowColor, currentOpacity * 0.7 * pulseEffect));\n        gradient.addColorStop(1, getCachedColor(trailColor, 0));\n        ctx.strokeStyle = gradient;\n        ctx.lineWidth = meteor.size;\n        ctx.lineCap = 'round';\n        ctx.stroke();\n\n        // Simple head\n        ctx.beginPath();\n        ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 0.7, 0, Math.PI * 2);\n        ctx.fillStyle = getCachedColor(coreColor, currentOpacity * pulseEffect);\n        ctx.fill();\n      }\n    });\n  }, [adaptedSettings.useHighQualityRendering, adaptedSettings.useGlow, adaptedSettings.useShadow, enableParallax, meteorMaxSize, glowColor, trailColor, coreColor, getCachedColor, createBurst, getPathVelocity]);\n\n  // WebGL rendering method\n  const renderMeteorsWebGL = _s2(useCallback(_s2((gl, timestamp) => {\n    _s2();\n    // This is a simplified placeholder for WebGL rendering\n    // A full implementation would use the shaders and buffers set up earlier\n\n    if (!gl || !webGLProgramsRef.current.meteor) return;\n\n    // Clear canvas\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    // Use meteor shader program\n    const meteorProgram = webGLProgramsRef.current.meteor;\n    gl.useProgram(meteorProgram.program);\n\n    // Set uniforms\n    gl.uniform2f(meteorProgram.uniforms.resolution, canvasRef.current.width, canvasRef.current.height);\n\n    // This is where we would bind vertex buffers and render particles\n    // For a real implementation, you would:\n    // 1. Update vertex buffer with current meteor positions\n    // 2. Set attributes for position, size, color\n    // 3. Draw using gl.POINTS or other appropriate primitives\n\n    // Check for burst triggers in WebGL mode too\n    meteorsRef.current.forEach(meteor => {\n      if (meteor.hasBurst && !meteor.burstTriggered && meteor.progress >= meteor.burstThreshold) {\n        meteor.burstTriggered = true;\n        const burstPosition = meteor.positions[0];\n\n        // Get velocity at burst point for influence on particles\n        const velocityPoint = {\n          x: 0,\n          y: 0\n        };\n        getPathVelocity(meteor.progress, meteor.path, velocityPoint);\n\n        // Create burst with velocity influence\n        // This will add particles to be rendered by renderBurstsWebGL\n        createBurst(burstPosition.x, burstPosition.y, meteor.burstSize, meteor.burstColors, meteor.burstParticles, velocityPoint);\n      }\n    });\n  }, \"ZdQBZ3rq7bWAAMQq6hlVCmYF0jM=\", false, function () {\n    return [gl.useProgram];\n  }), [createBurst, getPathVelocity]), \"ZdQBZ3rq7bWAAMQq6hlVCmYF0jM=\", true);\n\n  // Update meteor positions\n  const updateMeteors = useCallback(deltaTime => {\n    // Process meteors without destructuring unused width/height\n    for (let i = meteorsRef.current.length - 1; i >= 0; i--) {\n      const meteor = meteorsRef.current[i];\n\n      // Update progress based on speed and delta time\n      meteor.progress += meteor.speed * (deltaTime / 1000);\n\n      // Check if meteor has completed its path\n      if (meteor.progress >= 1) {\n        // Return to object pool\n        meteor.active = false;\n        objectPoolsRef.current.meteors.push(meteor);\n        meteorsRef.current.splice(i, 1);\n        continue;\n      }\n\n      // Calculate current position along the path\n      const currentPos = getPathPoint(Math.min(1, meteor.progress), meteor.path, pointCache.current);\n\n      // Update position history (for trail) using optimized array management\n      // Shift positions array - this is more efficient than splice/unshift for small arrays\n      for (let j = meteor.positions.length - 1; j > 0; j--) {\n        const current = meteor.positions[j];\n        const prev = meteor.positions[j - 1];\n        current.x = prev.x;\n        current.y = prev.y;\n      }\n\n      // Update head position\n      meteor.positions[0].x = currentPos.x;\n      meteor.positions[0].y = currentPos.y;\n    }\n\n    // Spawn new meteors if needed\n    const now = performance.now();\n    const spawnNeeded = meteorsRef.current.length < adaptedSettings.meteorDensity;\n    const canSpawnNow = !staggered || now >= nextSpawnTimeRef.current;\n    if (spawnNeeded && canSpawnNow) {\n      const newMeteor = initializeMeteor();\n      if (newMeteor) {\n        meteorsRef.current.push(newMeteor);\n\n        // Set next spawn time if staggering is enabled\n        if (staggered) {\n          const delay = Math.random() * (maxStaggerDelay - minStaggerDelay) + minStaggerDelay;\n          nextSpawnTimeRef.current = now + delay;\n        }\n      }\n    }\n    // Dependencies for updateMeteors\n  }, [adaptedSettings.meteorDensity, staggered, minStaggerDelay, maxStaggerDelay, initializeMeteor, getPathPoint, pointCache]);\n\n  // FPS limiter for consistent animation speed\n  const fpsLimiter = useCallback((timestamp, callback) => {\n    // Skip animation if hidden, inactive, or reduced motion\n    if (!isVisible || !active || respectReducedMotion && prefersReducedMotion || document.hidden) {\n      animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n      return;\n    }\n    const targetFrameTime = 1000 / maxFPS;\n    const elapsed = timestamp - lastTimestampRef.current;\n    if (elapsed >= targetFrameTime || lastTimestampRef.current === 0) {\n      // Calculate correct delta\n      const delta = lastTimestampRef.current === 0 ? 16 : elapsed;\n\n      // Update timestamp, limiting delta to avoid jumps after inactivity\n      lastTimestampRef.current = timestamp - elapsed % targetFrameTime;\n\n      // Run animation callback with capped delta time\n      callback(Math.min(delta, 50));\n\n      // FPS tracking for debug and adaptive quality\n      frameCountRef.current++;\n      if (timestamp - fpsTimestampRef.current >= 1000) {\n        currentFpsRef.current = frameCountRef.current;\n        frameCountRef.current = 0;\n        fpsTimestampRef.current = timestamp;\n\n        // Log FPS in debug mode\n        if (debug) {\n          console.log(`MeteorShower FPS: ${currentFpsRef.current}, Quality: ${qualityFactor.toFixed(2)}`);\n        }\n\n        // Dynamic quality adjustment based on performance\n        if (adaptiveQuality && currentFpsRef.current < maxFPS * 0.7) {\n          // If FPS is below 70% of target, reduce quality\n          setQualityFactor(prev => Math.max(0.4, prev * 0.9));\n        } else if (adaptiveQuality && currentFpsRef.current >= maxFPS * 0.95 && qualityFactor < 1) {\n          // If FPS is near target and quality is reduced, gradually increase\n          setQualityFactor(prev => Math.min(1, prev * 1.05));\n        }\n      }\n    }\n\n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n  }, [isVisible, active, respectReducedMotion, prefersReducedMotion, maxFPS, debug, adaptiveQuality, qualityFactor]);\n\n  // Main animation handler\n  const handleAnimation = useCallback(deltaTime => {\n    // Skip if component is not ready\n    if (!canvasRef.current || !isInitialized) return;\n    const now = performance.now();\n\n    // Calculate parallax offset if enabled\n    let parallaxOffset = 0;\n    if (enableParallax) {\n      parallaxOffset = scrollPositionRef.current * parallaxIntensity;\n    }\n\n    // Update meteor positions\n    updateMeteors(deltaTime);\n\n    // Render based on selected mode\n    if (actualRenderingMode === 'webgl' && webGLRef.current) {\n      // WebGL rendering path\n      renderMeteorsWebGL(webGLRef.current, now);\n\n      // Render burst particles with WebGL\n      if (enableBursts) {\n        renderBurstsWebGL(webGLRef.current, deltaTime);\n      }\n    } else {\n      // Canvas 2D rendering path\n      const ctx = ctxRef.current;\n      if (!ctx) return;\n\n      // Clear canvas with optimized clear (only clear used area)\n      ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n\n      // Render meteors\n      renderMeteors2D(ctx, parallaxOffset, now);\n\n      // Render burst particles\n      if (enableBursts) {\n        renderBursts2D(ctx, deltaTime);\n      }\n\n      // Debug visualization\n      if (debug) {\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n        ctx.font = '12px monospace';\n        ctx.fillText(`FPS: ${currentFpsRef.current}`, 10, 20);\n        ctx.fillText(`Meteors: ${meteorsRef.current.length}/${adaptedSettings.meteorDensity}`, 10, 40);\n        ctx.fillText(`Quality: ${qualityFactor.toFixed(2)}`, 10, 60);\n        ctx.fillText(`Rendering: ${actualRenderingMode}`, 10, 80);\n        if (enableBursts) {\n          ctx.fillText(`Bursts: ${burstsRef.current.length}`, 10, 100);\n          ctx.fillText(`Last Burst: ${lastBurstCountRef.current}`, 10, 120);\n        }\n      }\n    }\n  }, [isInitialized, dimensions, adaptedSettings.meteorDensity, enableParallax, parallaxIntensity, actualRenderingMode, debug, updateMeteors, renderMeteors2D, renderMeteorsWebGL, enableBursts, renderBursts2D, renderBurstsWebGL, qualityFactor]);\n\n  // Main animation loop\n  useEffect(() => {\n    if (!active || !isInitialized || !dimensions.width || !dimensions.height) {\n      return;\n    }\n\n    // Start animation with FPS limiter\n    fpsTimestampRef.current = performance.now();\n    frameCountRef.current = 0;\n    lastTimestampRef.current = 0;\n    animationFrameRef.current = requestAnimationFrame(timestamp => {\n      fpsLimiter(timestamp, handleAnimation);\n    });\n\n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [active, isInitialized, dimensions, fpsLimiter, handleAnimation]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: height,\n      overflow: 'hidden',\n      pointerEvents: 'none',\n      zIndex: zIndex,\n      // Hardware acceleration\n      backfaceVisibility: 'hidden',\n      transform: 'translateZ(0)',\n      willChange: 'transform'\n    },\n    \"aria-hidden\": \"true\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        // Additional rendering optimizations\n        imageRendering: 'high-quality',\n        // Hardware acceleration\n        backfaceVisibility: 'hidden',\n        transform: 'translateZ(0)',\n        willChange: 'transform',\n        // Ensures proper subpixel rendering\n        filter: 'none'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1718,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1700,\n    columnNumber: 5\n  }, this);\n};\n\n/**\n * GoldenMeteorShower Component\n * \n * A preset version of the MeteorShower with a golden/amber color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_s3(MeteorShower, \"GxHs95kq1Kx5YXuhQ9Pe0SNDn48=\");\n_c = MeteorShower;\nexport const GoldenMeteorShower = props => {\n  const goldenPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 245, 158, 0.9)',\n    trailColor: 'rgba(207, 181, 59, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 200,\n    maxStaggerDelay: 2000,\n    enableBursts: true,\n    burstProbability: 0.4,\n    burstParticleSize: 1.8,\n    burstParticleCount: 14\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...goldenPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1767,\n    columnNumber: 10\n  }, this);\n};\n\n/**\n * CelestialMeteorShower Component\n * \n * A preset version of the MeteorShower with a bluish-purple color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c2 = GoldenMeteorShower;\nexport const CelestialMeteorShower = props => {\n  const celestialPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(220, 225, 255, 0.9)',\n    trailColor: 'rgba(150, 160, 255, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 300,\n    maxStaggerDelay: 1800,\n    enableBursts: true,\n    burstProbability: 0.35\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...celestialPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1795,\n    columnNumber: 10\n  }, this);\n};\n\n/**\n * RubyMeteorShower Component\n * \n * A preset version of the MeteorShower with a red color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c3 = CelestialMeteorShower;\nexport const RubyMeteorShower = props => {\n  const rubyPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 200, 200, 0.9)',\n    trailColor: 'rgba(220, 100, 100, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 350,\n    maxStaggerDelay: 2200,\n    enableBursts: true,\n    burstProbability: 0.45\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...rubyPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1823,\n    columnNumber: 10\n  }, this);\n};\n\n/**\n * TopMeteorShower Component\n * \n * A preset version of the MeteorShower with meteors falling from the top of the screen\n * at a consistent 30-degree angle, distributed with emphasis on left and center areas.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\n_c4 = RubyMeteorShower;\nexport const TopMeteorShower = props => {\n  const topPreset = {\n    mode: 'linear',\n    direction: 'top',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.12,\n    trailLength: 200,\n    trailSegments: 25,\n    journeyCompletion: 0.95,\n    staggered: true,\n    minStaggerDelay: 100,\n    maxStaggerDelay: 1000,\n    enableBursts: true,\n    burstProbability: 0.5,\n    burstParticleCount: 15\n  };\n  return /*#__PURE__*/_jsxDEV(MeteorShower, {\n    ...topPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1852,\n    columnNumber: 10\n  }, this);\n};\n_c5 = TopMeteorShower;\nexport default MeteorShower;\nvar _c, _c2, _c3, _c4, _c5;\n$RefreshReg$(_c, \"MeteorShower\");\n$RefreshReg$(_c2, \"GoldenMeteorShower\");\n$RefreshReg$(_c3, \"CelestialMeteorShower\");\n$RefreshReg$(_c4, \"RubyMeteorShower\");\n$RefreshReg$(_c5, \"TopMeteorShower\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useCallback","useMemo","jsxDEV","_jsxDEV","MeteorShower","height","zIndex","active","meteorDensity","meteorMinSize","meteorMaxSize","meteorSpeed","trailLength","trailSegments","coreColor","glowColor","trailColor","enableParallax","parallaxIntensity","staggered","minStaggerDelay","maxStaggerDelay","journeyCompletion","mode","direction","baseAngle","angleVariation","debug","adaptiveQuality","respectReducedMotion","maxFPS","useWebGL","enableBursts","enableBattery","renderingMode","enableOffscreenRendering","burstParticleCount","burstParticleSize","burstProbability","burstColorVariation","_s3","_s","$RefreshSig$","_s2","containerRef","canvasRef","ctxRef","webGLRef","offscreenCanvasRef","workerRef","meteorsRef","burstsRef","animationFrameRef","lastTimestampRef","fpsTimestampRef","frameCountRef","currentFpsRef","nextSpawnTimeRef","scrollPositionRef","resizeObserverRef","visibilityObserverRef","batteryRef","visibilityChangeTimeRef","lastBurstCountRef","dimensions","setDimensions","width","pixelRatio","isInitialized","setIsInitialized","prefersReducedMotion","setPrefersReducedMotion","isVisible","setIsVisible","qualityFactor","setQualityFactor","actualRenderingMode","setActualRenderingMode","deviceCapabilities","setDeviceCapabilities","memory","cores","batteryLevel","isMobile","supportsWebGL","supportsOffscreenCanvas","pointCache","current","x","y","segment","colorCacheRef","Map","webGLProgramsRef","meteor","trail","burst","objectPoolsRef","meteors","bursts","vectors","detectCapabilities","navigator","deviceMemory","hardwareConcurrency","test","userAgent","canvas","document","createElement","window","WebGLRenderingContext","getContext","e","OffscreenCanvas","getBattery","then","battery","updateBattery","prev","level","isCharging","charging","Math","min","addEventListener","catch","initialRenderingMode","performanceScore","quality","getCachedColor","baseColor","opacity","roundedOpacity","round","key","has","newColor","replace","set","get","createColorVariant","variation","rgbaMatch","match","r","parseInt","g","b","a","parseFloat","vr","max","floor","random","vg","vb","adaptedSettings","useShadow","useGlow","useHighQualityRendering","reducedMotionQuery","matchMedia","matches","handleReducedMotionChange","handleVisibilityChange","hidden","performance","now","timeDelta","currentWorker","removeEventListener","terminate","initWebGL","gl","alpha","antialias","premultipliedAlpha","depth","enable","BLEND","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","clearColor","canvasWidth","canvasHeight","viewport","vertexShaderSource","fragmentShaderSource","createShader","type","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","error","getShaderInfoLog","deleteShader","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","program","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","attributes","position","getAttribLocation","size","color","uniforms","resolution","getUniformLocation","burstVertexShaderSource","burstFragmentShaderSource","burstVertexShader","burstFragmentShader","burstProgram","calculateMeteorPath","startX","startY","curveDirection","curveIntensity","endX","endY","controlX","controlY","pathType","start","control","end","meteorDirection","angle","PI","distanceToTravel","cos","sin","getPathPoint","t","path","outPoint","invT","invTSquared","tSquared","term1","term2","term3","getPathVelocity","outVelocity","length","sqrt","setupCanvas","container","rect","getBoundingClientRect","devicePixelRatio","displayWidth","displayHeight","endsWith","innerHeight","style","ctx","desynchronized","willReadFrequently","scale","imageSmoothingEnabled","imageSmoothingQuality","offscreen","offscreenCtx","warn","resizeObserver","ResizeObserver","entries","timeout","clearTimeout","setTimeout","requestAnimationFrame","currentContainer","observe","observer","disconnect","IntersectionObserver","isIntersecting","threshold","rootMargin","currentContainerRef","handleScroll","scrollY","passive","getMeteor","pool","pop","progress","positions","Array","i","initializeMeteor","speed","fadeThreshold","pulsePhase","pulseSpeed","hasBurst","earlyBurst","burstThreshold","burstTriggered","burstSize","burstParticles","burstColors","getBurstParticle","life","createBurst","colors","particleCount","velocityInfluence","maxBurstParticles","actualParticleCount","toRemove","oldBurst","shift","push","atan2","angleSpread","angleVariance","speedVariance","baseSpeed","vx","vy","sizeVariance","particleSize","colorIndex","decay","damping","renderBurstsWebGL","deltaTime","useProgram","uniform2f","Float32Array","sizes","gravity","rotation","rotationSpeed","posIndex","pow","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","enableVertexAttribArray","vertexAttribPointer","FLOAT","sizeBuffer","colorBuffer","drawArrays","POINTS","disableVertexAttribArray","deleteBuffer","j","renderBursts2D","save","fragmentSize","trailGradient","createLinearGradient","addColorStop","beginPath","moveTo","lineTo","lineWidth","lineCap","strokeStyle","stroke","shadowColor","shadowBlur","arc","fillStyle","fill","restore","renderMeteors2D","parallaxOffset","timestamp","forEach","currentOpacity","fadeProgress","timeFactor","pulseEffect","adjustY","burstPosition","velocityPoint","pos1","pos2","segmentOpacity","segmentWidth","headPos","pos","gradient","renderMeteorsWebGL","clear","COLOR_BUFFER_BIT","meteorProgram","updateMeteors","splice","currentPos","spawnNeeded","canSpawnNow","newMeteor","delay","fpsLimiter","callback","time","targetFrameTime","elapsed","delta","log","toFixed","handleAnimation","clearRect","font","fillText","cancelAnimationFrame","ref","top","left","overflow","pointerEvents","backfaceVisibility","transform","willChange","children","imageRendering","filter","fileName","_jsxFileName","lineNumber","columnNumber","_c","GoldenMeteorShower","props","goldenPreset","_c2","CelestialMeteorShower","celestialPreset","_c3","RubyMeteorShower","rubyPreset","_c4","TopMeteorShower","topPreset","_c5","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/effects/cosmiceffects/MeteorShower.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';\n\n/**\n * MeteorShower Component - Enterprise Performance Optimized Version\n * \n * Creates a highly performant animated meteor shower effect where meteors\n * arc across the sky with comet-like trails and fade away naturally.\n * \n * Features:\n * - Advanced performance optimizations with WebGL acceleration option\n * - Adaptive quality scaling based on device capabilities\n * - Memory and battery-efficient rendering pipeline\n * - Accessibility compliance with reduced motion support\n * - Supports hardware acceleration and high-DPI displays\n * - Enhanced burst effects with realistic particle physics\n * \n * @param {Object} props - Component props\n * @param {string|number} [props.height='100vh'] - Height of the container\n * @param {number} [props.zIndex=5] - Z-index for the container\n * @param {boolean} [props.active=true] - Whether the animation is active\n * @param {number} [props.meteorDensity=15] - Number of meteors to maintain on screen\n * @param {number} [props.meteorMinSize=1] - Minimum size of meteors\n * @param {number} [props.meteorMaxSize=3] - Maximum size of meteors\n * @param {number} [props.meteorSpeed=0.08] - Base speed of meteors\n * @param {number} [props.trailLength=180] - Length of meteor trails\n * @param {number} [props.trailSegments=20] - Number of segments in each trail\n * @param {string} [props.coreColor='rgba(255, 255, 255, 1)'] - Core color for meteors\n * @param {string} [props.glowColor='rgba(255, 253, 227, 0.9)'] - Glow color for meteors\n * @param {string} [props.trailColor='rgba(191, 173, 127, 0.8)'] - Trail color for meteors\n * @param {boolean} [props.enableParallax=false] - Enable parallax effect on scroll\n * @param {number} [props.parallaxIntensity=0.2] - Intensity of parallax effect\n * @param {boolean} [props.staggered=true] - Enable staggered meteor appearance\n * @param {number} [props.minStaggerDelay=200] - Minimum delay between meteor spawns (ms)\n * @param {number} [props.maxStaggerDelay=2000] - Maximum delay between meteor spawns (ms)\n * @param {number} [props.journeyCompletion=0.9] - When meteors complete their journey (0-1)\n * @param {string} [props.mode='arc'] - Animation mode: 'arc' or 'linear'\n * @param {string} [props.direction='both'] - Direction: 'left', 'right', 'both', or 'top'\n * @param {number} [props.baseAngle=30] - Base angle for linear meteors (degrees)\n * @param {number} [props.angleVariation=15] - Random variation to apply to the base angle\n * @param {boolean} [props.debug=false] - Enable debug visualization\n * @param {boolean} [props.adaptiveQuality=true] - Enable adaptive quality based on device\n * @param {boolean} [props.respectReducedMotion=true] - Respect reduced motion preferences\n * @param {number} [props.maxFPS=60] - Target maximum frames per second\n * @param {boolean} [props.useWebGL=false] - Use WebGL rendering for better performance\n * @param {boolean} [props.enableBursts=true] - Enable meteor burst effects\n * @param {boolean} [props.enableBattery=true] - Enable battery-saving optimizations\n * @param {string} [props.renderingMode='auto'] - Rendering mode: 'auto', '2d', or 'webgl'\n * @param {boolean} [props.enableOffscreenRendering=true] - Enable offscreen canvas when available\n * @param {number} [props.burstParticleCount=12] - Number of particles in each burst\n * @param {number} [props.burstParticleSize=2] - Size of burst particles\n * @param {number} [props.burstProbability=0.4] - Probability of meteor having a burst (0-1)\n * @param {string} [props.burstColorVariation='0.2'] - Amount of color variation in burst particles\n */\nconst MeteorShower = ({\n  height = '100vh',\n  zIndex = 5,\n  active = true,\n  meteorDensity = 15,\n  meteorMinSize = 1,\n  meteorMaxSize = 3,\n  meteorSpeed = 0.08,\n  trailLength = 180,\n  trailSegments = 20,\n  coreColor = 'rgba(255, 255, 255, 1)',\n  glowColor = 'rgba(255, 245, 158, 0.9)',\n  trailColor = 'rgba(207, 181, 59, 0.8)',\n  enableParallax = false,\n  parallaxIntensity = 0.2,\n  staggered = true,\n  minStaggerDelay = 200,\n  maxStaggerDelay = 2000,\n  journeyCompletion = 0.9,\n  mode = 'arc',\n  direction = 'both',\n  baseAngle = 30,\n  angleVariation = 15,\n  debug = false,\n  adaptiveQuality = true,\n  respectReducedMotion = true,\n  maxFPS = 60,\n  useWebGL = false,\n  enableBursts = true, // Enabled by default now\n  enableBattery = true,\n  renderingMode = 'auto',\n  enableOffscreenRendering = true,\n  burstParticleCount = 12,\n  burstParticleSize = 2,\n  burstProbability = 0.4,\n  burstColorVariation = 0.2\n}) => {\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const ctxRef = useRef(null);\n  const webGLRef = useRef(null);\n  const offscreenCanvasRef = useRef(null);\n  const workerRef = useRef(null);\n  const meteorsRef = useRef([]);\n  const burstsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const fpsTimestampRef = useRef(0);\n  const frameCountRef = useRef(0);\n  const currentFpsRef = useRef(60);\n  const nextSpawnTimeRef = useRef(0);\n  const scrollPositionRef = useRef(0);\n  const resizeObserverRef = useRef(null);\n  const visibilityObserverRef = useRef(null);\n  const batteryRef = useRef(null);\n  const visibilityChangeTimeRef = useRef(0);\n  const lastBurstCountRef = useRef(0);\n  \n  // Component state\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0, pixelRatio: 1 });\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [isVisible, setIsVisible] = useState(false);\n  const [qualityFactor, setQualityFactor] = useState(1);\n  const [actualRenderingMode, setActualRenderingMode] = useState('2d');\n  const [deviceCapabilities, setDeviceCapabilities] = useState({\n    memory: 4,\n    cores: 4,\n    batteryLevel: 1,\n    isMobile: false,\n    supportsWebGL: false,\n    supportsOffscreenCanvas: false\n  });\n  \n  // Pre-allocate objects to avoid garbage collection during animation\n  const pointCache = useRef({\n    current: { x: 0, y: 0 },\n    segment: { x: 0, y: 0 }\n  }).current;\n  \n  // Precompute color variants to avoid string operations during animation\n  const colorCacheRef = useRef(new Map());\n  \n  // WebGL shader programs and buffers\n  const webGLProgramsRef = useRef({\n    meteor: null,\n    trail: null,\n    burst: null\n  });\n  \n  // Object pools for efficient memory usage\n  const objectPoolsRef = useRef({\n    meteors: [],\n    bursts: [],\n    vectors: []\n  });\n  \n  // Detects device capabilities and sets up optimization strategies\n  const detectCapabilities = useCallback(() => {\n    // Device memory, hardware concurrency, and battery\n    const memory = navigator.deviceMemory || 4;\n    const cores = navigator.hardwareConcurrency || 4;\n    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n    \n    // Check WebGL support\n    let supportsWebGL = false;\n    try {\n      const canvas = document.createElement('canvas');\n      supportsWebGL = !!(window.WebGLRenderingContext && \n        (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));\n    } catch (e) {\n      supportsWebGL = false;\n    }\n    \n    // Check offscreen canvas support\n    const supportsOffscreenCanvas = typeof OffscreenCanvas !== 'undefined';\n    \n    // Get battery info if available\n    if (navigator.getBattery && enableBattery) {\n      navigator.getBattery().then(battery => {\n        batteryRef.current = battery;\n        \n        const updateBattery = () => {\n          setDeviceCapabilities(prev => ({\n            ...prev,\n            batteryLevel: battery.level,\n            isCharging: battery.charging\n          }));\n          \n          // Reduce quality if on battery and below 30%\n          if (!battery.charging && battery.level < 0.3 && adaptiveQuality) {\n            setQualityFactor(prev => Math.min(prev, 0.6));\n          }\n        };\n        \n        // Add battery event listeners\n        battery.addEventListener('levelchange', updateBattery);\n        battery.addEventListener('chargingchange', updateBattery);\n        \n        // Initial update\n        updateBattery();\n      }).catch(() => {\n        // Fallback if battery API is not available or fails\n        setDeviceCapabilities(prev => ({\n          ...prev,\n          batteryLevel: 1,\n          isCharging: true\n        }));\n      });\n    }\n    \n    // Determine initial rendering mode\n    let initialRenderingMode = '2d';\n    if (renderingMode === 'auto') {\n      if (useWebGL && supportsWebGL) {\n        initialRenderingMode = 'webgl';\n      } else {\n        initialRenderingMode = '2d';\n      }\n    } else {\n      initialRenderingMode = renderingMode === 'webgl' && supportsWebGL ? 'webgl' : '2d';\n    }\n    \n    setActualRenderingMode(initialRenderingMode);\n    \n    // Set device capabilities state\n    setDeviceCapabilities({\n      memory,\n      cores,\n      batteryLevel: 1,\n      isCharging: true,\n      isMobile,\n      supportsWebGL,\n      supportsOffscreenCanvas\n    });\n    \n    // Calculate quality factor based on capabilities\n    if (adaptiveQuality) {\n      // Base score from hardware\n      const performanceScore = (memory * cores) / (isMobile ? 2 : 1);\n      \n      // Scale quality based on performance score\n      let quality = 1;\n      \n      if (performanceScore > 16) {\n        quality = 1; // High-end devices\n      } else if (performanceScore > 8) {\n        quality = 0.8; // Mid-range devices\n      } else if (performanceScore > 4) {\n        quality = 0.6; // Low-end devices\n      } else {\n        quality = 0.4; // Very low-end devices\n      }\n      \n      setQualityFactor(quality);\n    }\n  }, [useWebGL, renderingMode, adaptiveQuality, enableBattery]);\n  \n  // Get cached color with opacity\n  const getCachedColor = useCallback((baseColor, opacity) => {\n    // Round opacity to reduce cache size while maintaining visual quality\n    const roundedOpacity = Math.round(opacity * 100) / 100;\n    const key = `${baseColor}-${roundedOpacity}`;\n    \n    if (!colorCacheRef.current.has(key)) {\n      const newColor = baseColor.replace(/[\\d.]+\\)$/, roundedOpacity + ')');\n      colorCacheRef.current.set(key, newColor);\n    }\n    \n    return colorCacheRef.current.get(key);\n  }, []);\n  \n  // Create a color variant based on a base color\n  const createColorVariant = useCallback((baseColor, variation) => {\n    // Parse the rgba values\n    const rgbaMatch = baseColor.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*([\\d.]+))?\\)/);\n    if (!rgbaMatch) return baseColor;\n    \n    const r = parseInt(rgbaMatch[1], 10);\n    const g = parseInt(rgbaMatch[2], 10);\n    const b = parseInt(rgbaMatch[3], 10);\n    const a = rgbaMatch[4] ? parseFloat(rgbaMatch[4]) : 1;\n    \n    // Apply random variation to RGB values\n    const vr = Math.max(0, Math.min(255, r + Math.floor((Math.random() * 2 - 1) * variation * 255)));\n    const vg = Math.max(0, Math.min(255, g + Math.floor((Math.random() * 2 - 1) * variation * 255)));\n    const vb = Math.max(0, Math.min(255, b + Math.floor((Math.random() * 2 - 1) * variation * 255)));\n    \n    return `rgba(${vr}, ${vg}, ${vb}, ${a})`;\n  }, []);\n  \n  // Adaptive settings based on quality factor\n  const adaptedSettings = useMemo(() => {\n    if (!adaptiveQuality || qualityFactor === 1) {\n      return {\n        meteorDensity,\n        trailSegments,\n        burstParticleCount,\n        useShadow: true,\n        useGlow: true,\n        useHighQualityRendering: true\n      };\n    }\n    \n    // Adjust quality-dependent parameters\n    return {\n      meteorDensity: Math.max(3, Math.floor(meteorDensity * qualityFactor)),\n      trailSegments: Math.max(5, Math.floor(trailSegments * qualityFactor)),\n      burstParticleCount: Math.max(4, Math.floor(burstParticleCount * qualityFactor)),\n      useShadow: qualityFactor > 0.5,\n      useGlow: qualityFactor > 0.3,\n      useHighQualityRendering: qualityFactor > 0.7\n    };\n  }, [adaptiveQuality, qualityFactor, meteorDensity, trailSegments, burstParticleCount]);\n  \n  // Detect device capabilities and preferences on mount\n  useEffect(() => {\n    // Check for reduced motion preference\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    \n    const handleReducedMotionChange = (e) => {\n      setPrefersReducedMotion(e.matches);\n    };\n    \n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n    \n    // Detect device capabilities\n    detectCapabilities();\n    \n    // Setup visibility change detection to pause when tab is inactive\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        visibilityChangeTimeRef.current = performance.now();\n      } else {\n        // Adjust timing references after visibility changes\n        const timeDelta = performance.now() - visibilityChangeTimeRef.current;\n        lastTimestampRef.current += timeDelta;\n        nextSpawnTimeRef.current += timeDelta;\n      }\n    };\n    \n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    \n    // Capture current worker ref to avoid closure issues\n    const currentWorker = workerRef.current;\n    \n    // Cleanup\n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n      \n      // Clean up worker if active\n      if (currentWorker) {\n        currentWorker.terminate();\n      }\n    };\n  }, [detectCapabilities]);\n  \n  // Initialize WebGL context and shaders if using WebGL\n  const initWebGL = useCallback(() => {\n    if (!canvasRef.current || actualRenderingMode !== 'webgl') return false;\n    \n    try {\n      // Get WebGL context\n      const gl = canvasRef.current.getContext('webgl', {\n        alpha: true,\n        antialias: true,\n        premultipliedAlpha: false,\n        depth: false\n      });\n      \n      if (!gl) return false;\n      \n      webGLRef.current = gl;\n      \n      // Create shader programs, vertex buffers, etc.\n      // This is a simplified placeholder - a real implementation would include\n      // proper shaders, attribute locations, and uniform setup\n      \n      // Enable blending for transparency\n      gl.enable(gl.BLEND);\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n      \n      // Set clear color to fully transparent\n      gl.clearColor(0.0, 0.0, 0.0, 0.0);\n      \n      // Get current dimensions for viewport\n      const canvasWidth = canvasRef.current.width;\n      const canvasHeight = canvasRef.current.height;\n      \n      // Set viewport\n      gl.viewport(0, 0, canvasWidth, canvasHeight);\n      \n      // Simple vertex shader for meteor particles\n      const vertexShaderSource = `\n        attribute vec2 aPosition;\n        attribute float aSize;\n        attribute vec4 aColor;\n        \n        varying vec4 vColor;\n        \n        uniform vec2 uResolution;\n        \n        void main() {\n          // Convert to clip space\n          vec2 position = (aPosition / uResolution) * 2.0 - 1.0;\n          position.y = -position.y;\n          \n          gl_Position = vec4(position, 0, 1);\n          gl_PointSize = aSize;\n          vColor = aColor;\n        }\n      `;\n      \n      // Simple fragment shader for meteor particles\n      const fragmentShaderSource = `\n        precision mediump float;\n        varying vec4 vColor;\n        \n        void main() {\n          // Calculate distance from center for circular point\n          float distance = length(gl_PointCoord - vec2(0.5, 0.5));\n          if (distance > 0.5) {\n            discard; // Outside circle\n          }\n          \n          // Softer edges\n          float alpha = smoothstep(0.5, 0.4, distance) * vColor.a;\n          gl_FragColor = vec4(vColor.rgb, alpha);\n        }\n      `;\n      \n      // Compile shader program\n      const createShader = (gl, type, source) => {\n        const shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        \n        // Check for compilation errors\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n          console.error('Shader compilation error:', gl.getShaderInfoLog(shader));\n          gl.deleteShader(shader);\n          return null;\n        }\n        \n        return shader;\n      };\n      \n      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n      \n      if (!vertexShader || !fragmentShader) {\n        return false;\n      }\n      \n      const program = gl.createProgram();\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n      \n      // Check for linking errors\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        console.error('Program linking error:', gl.getProgramInfoLog(program));\n        gl.deleteProgram(program);\n        return false;\n      }\n      \n      // Store the program\n      webGLProgramsRef.current.meteor = {\n        program,\n        attributes: {\n          position: gl.getAttribLocation(program, 'aPosition'),\n          size: gl.getAttribLocation(program, 'aSize'),\n          color: gl.getAttribLocation(program, 'aColor')\n        },\n        uniforms: {\n          resolution: gl.getUniformLocation(program, 'uResolution')\n        }\n      };\n      \n      // Now create shader program for burst particles\n      // This can be similar to the meteor program but with different parameters\n      \n      // Simple vertex shader for burst particles\n      const burstVertexShaderSource = `\n        attribute vec2 aPosition;\n        attribute float aSize;\n        attribute vec4 aColor;\n        \n        varying vec4 vColor;\n        \n        uniform vec2 uResolution;\n        \n        void main() {\n          // Convert to clip space\n          vec2 position = (aPosition / uResolution) * 2.0 - 1.0;\n          position.y = -position.y;\n          \n          gl_Position = vec4(position, 0, 1);\n          gl_PointSize = aSize;\n          vColor = aColor;\n        }\n      `;\n      \n      // Simple fragment shader for burst particles with softer edges\n      const burstFragmentShaderSource = `\n        precision mediump float;\n        varying vec4 vColor;\n        \n        void main() {\n          // Calculate distance from center for circular point\n          float distance = length(gl_PointCoord - vec2(0.5, 0.5));\n          if (distance > 0.5) {\n            discard; // Outside circle\n          }\n          \n          // Very soft edges for burst particles\n          float alpha = smoothstep(0.5, 0.2, distance) * vColor.a;\n          gl_FragColor = vec4(vColor.rgb, alpha);\n        }\n      `;\n      \n      const burstVertexShader = createShader(gl, gl.VERTEX_SHADER, burstVertexShaderSource);\n      const burstFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, burstFragmentShaderSource);\n      \n      if (!burstVertexShader || !burstFragmentShader) {\n        return false;\n      }\n      \n      const burstProgram = gl.createProgram();\n      gl.attachShader(burstProgram, burstVertexShader);\n      gl.attachShader(burstProgram, burstFragmentShader);\n      gl.linkProgram(burstProgram);\n      \n      // Check for linking errors\n      if (!gl.getProgramParameter(burstProgram, gl.LINK_STATUS)) {\n        console.error('Burst program linking error:', gl.getProgramInfoLog(burstProgram));\n        gl.deleteProgram(burstProgram);\n      } else {\n        // Store the burst program\n        webGLProgramsRef.current.burst = {\n          program: burstProgram,\n          attributes: {\n            position: gl.getAttribLocation(burstProgram, 'aPosition'),\n            size: gl.getAttribLocation(burstProgram, 'aSize'),\n            color: gl.getAttribLocation(burstProgram, 'aColor')\n          },\n          uniforms: {\n            resolution: gl.getUniformLocation(burstProgram, 'uResolution')\n          }\n        };\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('WebGL initialization error:', error);\n      setActualRenderingMode('2d');\n      return false;\n    }\n  }, [actualRenderingMode]);\n  \n  // Calculate path parameters for a meteor based on selected mode\n  const calculateMeteorPath = useCallback((width, height) => {\n    if (mode === 'arc') {\n      // Arc path logic with optimized parameters\n      const startX = Math.random() * width * 1.5 - width * 0.25;\n      const startY = Math.random() * -100 - 50;\n      \n      const curveDirection = Math.random() > 0.5 ? 1 : -1;\n      const curveIntensity = Math.random() * 0.4 + 0.2;\n      \n      const endX = startX + (curveDirection * width * curveIntensity);\n      const endY = height * journeyCompletion;\n      \n      const controlX = (startX + endX) / 2 + (curveDirection * width * curveIntensity);\n      const controlY = (startY + endY) * 0.5;\n      \n      return {\n        pathType: 'arc',\n        start: { x: startX, y: startY },\n        control: { x: controlX, y: controlY },\n        end: { x: endX, y: endY }\n      };\n    } else if (mode === 'linear') {\n      // Linear path logic with enhanced direction control\n      let meteorDirection = direction;\n      if (direction === 'both') {\n        meteorDirection = Math.random() > 0.5 ? 'left' : 'right';\n      }\n      \n      let angle;\n      if (direction === 'top') {\n        angle = ((30 + (Math.random() * 2 - 1) * 5) * Math.PI) / 180;\n      } else {\n        angle = ((baseAngle + (Math.random() * 2 - 1) * angleVariation) * Math.PI) / 180;\n      }\n      \n      let startX;\n      if (meteorDirection === 'left') {\n        startX = Math.random() * (width * 0.3) - (width * 0.1);\n      } else if (meteorDirection === 'right') {\n        startX = width - Math.random() * (width * 0.3) + (width * 0.1);\n      } else if (direction === 'top') {\n        const position = Math.random();\n        if (position < 0.5) {\n          startX = Math.random() * (width * 0.35);\n        } else if (position < 0.85) {\n          startX = width * 0.35 + Math.random() * (width * 0.35);\n        } else {\n          startX = width * 0.7 + Math.random() * (width * 0.3);\n        }\n      }\n      \n      const startY = Math.random() * -100 - 50;\n      const distanceToTravel = (height * journeyCompletion) / Math.cos(angle);\n      \n      let endX, endY;\n      if (meteorDirection === 'left' || direction === 'top') {\n        endX = startX + distanceToTravel * Math.sin(angle);\n        endY = startY + distanceToTravel * Math.cos(angle);\n      } else {\n        endX = startX - distanceToTravel * Math.sin(angle);\n        endY = startY + distanceToTravel * Math.cos(angle);\n      }\n      \n      return {\n        pathType: 'linear',\n        start: { x: startX, y: startY },\n        end: { x: endX, y: endY },\n        direction: meteorDirection\n      };\n    }\n  }, [mode, direction, baseAngle, angleVariation, journeyCompletion]);\n  \n  // Get point along path with highly optimized calculations\n  const getPathPoint = useCallback((t, path, outPoint = { x: 0, y: 0 }) => {\n    if (path.pathType === 'arc') {\n      // Optimized quadratic bezier calculation using pre-computed terms\n      const invT = 1 - t;\n      const invTSquared = invT * invT;\n      const tSquared = t * t;\n      const term1 = invTSquared;\n      const term2 = 2 * invT * t;\n      const term3 = tSquared;\n      \n      outPoint.x = term1 * path.start.x + term2 * path.control.x + term3 * path.end.x;\n      outPoint.y = term1 * path.start.y + term2 * path.control.y + term3 * path.end.y;\n    } else {\n      // Linear interpolation with minimal operations\n      outPoint.x = path.start.x + (path.end.x - path.start.x) * t;\n      outPoint.y = path.start.y + (path.end.y - path.start.y) * t;\n    }\n    \n    return outPoint;\n  }, []);\n  \n  // Calculate velocity at a point on the path (for trail orientation)\n  const getPathVelocity = useCallback((t, path, outVelocity = { x: 0, y: 0 }) => {\n    if (path.pathType === 'arc') {\n      // Derivative of quadratic bezier\n      const term1 = 2 * (1 - t);\n      const term2 = 2 * t;\n      \n      outVelocity.x = term1 * (path.control.x - path.start.x) + term2 * (path.end.x - path.control.x);\n      outVelocity.y = term1 * (path.control.y - path.start.y) + term2 * (path.end.y - path.control.y);\n    } else {\n      // Constant velocity for linear paths\n      outVelocity.x = path.end.x - path.start.x;\n      outVelocity.y = path.end.y - path.start.y;\n      \n      // Normalize\n      const length = Math.sqrt(outVelocity.x * outVelocity.x + outVelocity.y * outVelocity.y);\n      if (length > 0) {\n        outVelocity.x /= length;\n        outVelocity.y /= length;\n      }\n    }\n    \n    return outVelocity;\n  }, []);\n  \n  // Initialize canvas with proper resolution\n  const setupCanvas = useCallback(() => {\n    if (!canvasRef.current || !containerRef.current) return false;\n    \n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    const rect = container.getBoundingClientRect();\n    const pixelRatio = window.devicePixelRatio || 1;\n    \n    // Calculate dimensions\n    const displayWidth = rect.width;\n    const displayHeight = typeof height === 'string' && height.endsWith('vh') \n      ? (parseInt(height, 10) / 100) * window.innerHeight\n      : parseInt(height, 10) || window.innerHeight;\n    \n    // Set canvas size accounting for pixel ratio\n    canvas.width = displayWidth * pixelRatio;\n    canvas.height = displayHeight * pixelRatio;\n    canvas.style.width = `${displayWidth}px`;\n    canvas.style.height = `${displayHeight}px`;\n    \n    // Get appropriate rendering context\n    if (actualRenderingMode === 'webgl') {\n      initWebGL();\n    } else {\n      // 2D Canvas context\n      const ctx = canvas.getContext('2d', {\n        alpha: true,\n        desynchronized: true,\n        willReadFrequently: false\n      });\n      \n      if (!ctx) return false;\n      \n      // Scale context for high-DPI displays\n      ctx.scale(pixelRatio, pixelRatio);\n      \n      // Configure context for high-quality rendering\n      if (adaptedSettings.useHighQualityRendering) {\n        ctx.imageSmoothingEnabled = true;\n        ctx.imageSmoothingQuality = 'high';\n      }\n      \n      ctxRef.current = ctx;\n    }\n    \n    // Initialize offscreen canvas if supported and enabled\n    if (enableOffscreenRendering && typeof OffscreenCanvas !== 'undefined' &&\n        deviceCapabilities.supportsOffscreenCanvas) {\n      try {\n        // Create offscreen canvas\n        const offscreen = new OffscreenCanvas(\n          displayWidth * pixelRatio,\n          displayHeight * pixelRatio\n        );\n        \n        // Get 2D context for offscreen canvas\n        const offscreenCtx = offscreen.getContext('2d');\n        if (offscreenCtx) {\n          offscreenCtx.scale(pixelRatio, pixelRatio);\n          offscreenCanvasRef.current = {\n            canvas: offscreen,\n            ctx: offscreenCtx\n          };\n        }\n      } catch (error) {\n        console.warn('Offscreen canvas initialization error:', error);\n      }\n    }\n    \n    setDimensions({\n      width: displayWidth,\n      height: displayHeight,\n      pixelRatio\n    });\n    \n    return true;\n  }, [height, actualRenderingMode, initWebGL, enableOffscreenRendering, deviceCapabilities.supportsOffscreenCanvas, adaptedSettings.useHighQualityRendering]);\n  \n  // Setup canvas resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n    \n    // Create a ResizeObserver to detect container size changes\n    const resizeObserver = new ResizeObserver(entries => {\n      // Debounce resize operations\n      if (resizeObserverRef.current.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n      \n      resizeObserverRef.current.timeout = setTimeout(() => {\n        requestAnimationFrame(() => {\n          if (setupCanvas()) {\n            setIsInitialized(true);\n          }\n        });\n      }, 100); // 100ms debounce\n    });\n    \n    // Capture current reference to avoid closure issues in cleanup\n    const currentContainer = containerRef.current;\n    \n    // Start observing the container\n    resizeObserver.observe(currentContainer);\n    resizeObserverRef.current = { observer: resizeObserver };\n    \n    // Initial setup\n    setupCanvas();\n    setIsInitialized(true);\n    \n    return () => {\n      if (resizeObserverRef.current.observer) {\n        resizeObserverRef.current.observer.disconnect();\n      }\n      if (resizeObserverRef.current.timeout) {\n        clearTimeout(resizeObserverRef.current.timeout);\n      }\n    };\n  }, [setupCanvas]);\n  \n  // Setup intersection observer to only animate when visible\n  useEffect(() => {\n    if (!containerRef.current) return;\n    \n    const observer = new IntersectionObserver(\n      entries => {\n        const isIntersecting = entries[0].isIntersecting;\n        \n        // Only change state if visibility actually changed\n        if (isIntersecting !== isVisible) {\n          setIsVisible(isIntersecting);\n          \n          if (isIntersecting) {\n            // Reset timing references when becoming visible again\n            lastTimestampRef.current = 0;\n            nextSpawnTimeRef.current = performance.now();\n          }\n        }\n      },\n      {\n        threshold: 0.01,\n        rootMargin: '100px'\n      }\n    );\n    \n    // Store current reference to avoid closure issues\n    const currentContainerRef = containerRef.current;\n    observer.observe(currentContainerRef);\n    visibilityObserverRef.current = observer;\n    \n    return () => {\n      if (visibilityObserverRef.current) {\n        visibilityObserverRef.current.disconnect();\n      }\n    };\n  }, [isVisible]);\n  \n  // Handle parallax effect on scroll if enabled\n  useEffect(() => {\n    if (!enableParallax) return;\n    \n    // Use passive event listener for better performance\n    const handleScroll = () => {\n      scrollPositionRef.current = window.scrollY;\n    };\n    \n    window.addEventListener('scroll', handleScroll, { passive: true });\n    \n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [enableParallax]);\n  \n  // Get a meteor from the object pool or create a new one\n  const getMeteor = useCallback(() => {\n    // Try to get from pool first\n    const pool = objectPoolsRef.current.meteors;\n    let meteor;\n    \n    if (pool.length > 0) {\n      meteor = pool.pop();\n      // Reset meteor properties\n      meteor.progress = 0;\n      meteor.active = true;\n    } else {\n      // Create new if pool is empty\n      meteor = {\n        progress: 0,\n        active: true,\n        positions: Array(adaptedSettings.trailSegments)\n      };\n      \n      // Pre-allocate position objects\n      for (let i = 0; i < adaptedSettings.trailSegments; i++) {\n        meteor.positions[i] = { x: 0, y: 0 };\n      }\n    }\n    \n    return meteor;\n  }, [adaptedSettings.trailSegments]);\n  \n  // Initialize a meteor with all required properties\n  const initializeMeteor = useCallback(() => {\n    const { width, height } = dimensions;\n    \n    if (!width || !height) return null;\n    \n    // Get meteor from pool\n    const meteor = getMeteor();\n    \n    // Calculate path based on mode\n    const path = calculateMeteorPath(width, height);\n    \n    // Set path and initial position\n    meteor.path = path;\n    for (let i = 0; i < meteor.positions.length; i++) {\n      meteor.positions[i].x = path.start.x;\n      meteor.positions[i].y = path.start.y;\n    }\n    \n    // Set meteor properties\n    meteor.size = Math.random() * (meteorMaxSize - meteorMinSize) + meteorMinSize;\n    meteor.speed = meteorSpeed * (Math.random() * 0.5 + 0.75);\n    meteor.opacity = Math.random() * 0.3 + 0.7;\n    meteor.fadeThreshold = 0.7 + Math.random() * 0.2;\n    meteor.pulsePhase = Math.random() * Math.PI * 2;\n    meteor.pulseSpeed = Math.random() * 0.01 + 0.005;\n    \n    // Add burst properties if enabled\n    if (enableBursts && Math.random() < burstProbability) {\n      meteor.hasBurst = true;\n      \n      // Vary the burst threshold - occasionally have early bursts for variety\n      const earlyBurst = Math.random() < 0.15; // 15% chance for early burst\n      meteor.burstThreshold = earlyBurst \n        ? 0.3 + Math.random() * 0.4 // Early burst range (0.3-0.7)\n        : 0.85 + Math.random() * 0.13; // Normal late burst range (0.85-0.98)\n      \n      meteor.burstTriggered = false;\n      \n      // Adjust burst size based on when it occurs\n      meteor.burstSize = earlyBurst\n        ? meteor.size * (3 + Math.random() * 4) // Larger for early bursts\n        : meteor.size * (2 + Math.random() * 2); // More controlled for end bursts\n      \n      // Adjust particle count based on when it occurs\n      meteor.burstParticles = Math.floor(\n        adaptedSettings.burstParticleCount * \n        (earlyBurst ? 1.2 : 0.8) * // More particles for early bursts\n        (0.8 + Math.random() * 0.4)\n      );\n      \n      // Use custom gold-centric colors for dark fantasy aesthetic\n      // No need to use createColorVariant here since we're using specific themed colors\n      meteor.burstColors = [\n        'rgba(255, 215, 0, 1)', // Gold\n        'rgba(218, 165, 32, 1)', // Goldenrod\n        'rgba(212, 175, 55, 1)', // Metallic gold\n        'rgba(207, 181, 59, 1)', // Old gold\n        earlyBurst ? 'rgba(255, 255, 220, 1)' : 'rgba(192, 192, 192, 1)' // Bright for early, silver for late\n      ];\n    } else {\n      meteor.hasBurst = false;\n    }\n    \n    return meteor;\n  }, [\n    dimensions,\n    calculateMeteorPath,\n    meteorMinSize,\n    meteorMaxSize,\n    meteorSpeed,\n    enableBursts,\n    burstProbability,\n    adaptedSettings.burstParticleCount,\n    getMeteor\n  ]);\n  \n  // Get a burst particle from the object pool or create a new one\n  const getBurstParticle = useCallback(() => {\n    const pool = objectPoolsRef.current.bursts;\n    \n    if (pool.length > 0) {\n      const burst = pool.pop();\n      // Reset properties\n      burst.life = 1.0;\n      return burst;\n    }\n    \n    // Create new if pool is empty\n    return {};\n  }, []);\n  \n  // Create a burst effect at a specified position\n  const createBurst = useCallback((x, y, size, colors, particleCount, velocityInfluence = { x: 0, y: 0 }) => {\n    // Skip if bursts are not enabled\n    if (!enableBursts) return;\n    \n    // Limit the number of active burst particles to avoid performance issues\n    const maxBurstParticles = adaptedSettings.useHighQualityRendering ? 300 : 150;\n    \n    // If we're already close to the limit, reduce the number of particles\n    let actualParticleCount = particleCount;\n    if (burstsRef.current.length > maxBurstParticles - particleCount) {\n      actualParticleCount = Math.max(4, Math.floor(particleCount * 0.5));\n    }\n    \n    // Skip burst creation completely if we're already over the limit\n    if (burstsRef.current.length > maxBurstParticles) {\n      // Remove older bursts to make room\n      const toRemove = Math.min(20, burstsRef.current.length - maxBurstParticles + actualParticleCount);\n      for (let i = 0; i < toRemove; i++) {\n        const oldBurst = burstsRef.current.shift();\n        if (oldBurst) {\n          objectPoolsRef.current.bursts.push(oldBurst);\n        }\n      }\n    }\n    \n    // Track burst counts for debug\n    lastBurstCountRef.current = actualParticleCount;\n    \n    // Create fragments that look like pieces of the meteor breaking apart\n    for (let i = 0; i < actualParticleCount; i++) {\n      // Create directional burst effect following the meteor's trajectory\n      const baseAngle = Math.atan2(velocityInfluence.y, velocityInfluence.x);\n      \n      // Calculate particle direction - within a forward-facing cone\n      const angleSpread = 1.2; // Narrower spread for more focused effect\n      const angleVariance = (Math.random() * angleSpread - angleSpread/2);\n      const angle = baseAngle + angleVariance;\n      \n      // Speed - slower for a more elegant effect\n      const speedVariance = Math.random() * 0.4 + 0.7;\n      const baseSpeed = 0.4 + Math.random() * 0.8; // Slower overall\n      const speed = baseSpeed * speedVariance;\n      \n      // Calculate velocity components\n      const vx = Math.cos(angle) * speed + velocityInfluence.x * 0.4;\n      const vy = Math.sin(angle) * speed + velocityInfluence.y * 0.4;\n      \n      // Create fragments of different sizes\n      const sizeVariance = 0.2 + Math.random() * 0.8;\n      const particleSize = size * sizeVariance * burstParticleSize * 0.6;\n      \n      // Use meteor's colors for the fragments\n      const colorIndex = Math.random() < 0.7 ? 0 : 1; // 70% core color, 30% glow color\n      const color = colorIndex === 0 ? coreColor : glowColor;\n      \n      // Create the burst particle\n      const burst = getBurstParticle();\n      \n      // Set properties\n      burst.x = x;\n      burst.y = y;\n      burst.vx = vx;\n      burst.vy = vy;\n      burst.size = particleSize;\n      burst.life = 1.0;\n      burst.decay = 0.006 + Math.random() * 0.01; // Slower decay\n      burst.color = color;\n      burst.trailLength = 2 + Math.random() * 6; // Length of trail behind fragment\n      \n      // More elegantly diminishing velocity\n      burst.damping = 0.95 + Math.random() * 0.03;\n      \n      // Add to active bursts\n      burstsRef.current.push(burst);\n    }\n  }, [enableBursts, adaptedSettings.useHighQualityRendering, getBurstParticle, burstParticleSize, coreColor, glowColor]);\n  \n  // Render burst particles with WebGL\n  const renderBurstsWebGL = useCallback((gl, deltaTime) => {\n    if (!enableBursts || burstsRef.current.length === 0 || !webGLProgramsRef.current.burst) return;\n    \n    const burstProgram = webGLProgramsRef.current.burst;\n    \n    // Use burst shader program\n    gl.useProgram(burstProgram.program);\n    \n    // Set resolution uniform\n    gl.uniform2f(\n      burstProgram.uniforms.resolution,\n      canvasRef.current.width,\n      canvasRef.current.height\n    );\n    \n    // Create float32 arrays to hold position, size, and color data\n    // 2 floats per position (x, y)\n    const positions = new Float32Array(burstsRef.current.length * 2);\n    // 1 float per size\n    const sizes = new Float32Array(burstsRef.current.length);\n    // 4 floats per color (r, g, b, a)\n    const colors = new Float32Array(burstsRef.current.length * 4);\n    \n    // Process each burst particle and update its data\n    for (let i = 0; i < burstsRef.current.length; i++) {\n      const burst = burstsRef.current[i];\n      \n      // Update position\n      burst.x += burst.vx * (deltaTime / 16);\n      burst.y += burst.vy * (deltaTime / 16);\n      \n      // Apply gravity if present\n      if (burst.gravity) {\n        burst.vy += burst.gravity * (deltaTime / 16);\n      }\n      \n      // Apply damping to velocity\n      burst.vx *= burst.damping;\n      burst.vy *= burst.damping;\n      \n      // Update rotation\n      burst.rotation += burst.rotationSpeed * (deltaTime / 16);\n      \n      // Reduce life\n      burst.life -= burst.decay * (deltaTime / 16);\n      \n      // Map burst data to arrays\n      const posIndex = i * 2;\n      positions[posIndex] = burst.x;\n      positions[posIndex + 1] = burst.y;\n      \n      sizes[i] = burst.size * Math.pow(burst.life, 0.7) * dimensions.pixelRatio;\n      \n      // Parse color components from rgba string\n      // This is a simplified placeholder - you'd need proper color parsing\n      const colorIndex = i * 4;\n      colors[colorIndex] = 1.0;     // r\n      colors[colorIndex + 1] = 0.9; // g\n      colors[colorIndex + 2] = 0.7; // b\n      colors[colorIndex + 3] = burst.life * 0.7; // a\n    }\n    \n    // Create and bind position buffer\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(burstProgram.attributes.position);\n    gl.vertexAttribPointer(burstProgram.attributes.position, 2, gl.FLOAT, false, 0, 0);\n    \n    // Create and bind size buffer\n    const sizeBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, sizes, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(burstProgram.attributes.size);\n    gl.vertexAttribPointer(burstProgram.attributes.size, 1, gl.FLOAT, false, 0, 0);\n    \n    // Create and bind color buffer\n    const colorBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(burstProgram.attributes.color);\n    gl.vertexAttribPointer(burstProgram.attributes.color, 4, gl.FLOAT, false, 0, 0);\n    \n    // Draw points\n    gl.drawArrays(gl.POINTS, 0, burstsRef.current.length);\n    \n    // Clean up\n    gl.disableVertexAttribArray(burstProgram.attributes.position);\n    gl.disableVertexAttribArray(burstProgram.attributes.size);\n    gl.disableVertexAttribArray(burstProgram.attributes.color);\n    gl.deleteBuffer(positionBuffer);\n    gl.deleteBuffer(sizeBuffer);\n    gl.deleteBuffer(colorBuffer);\n    \n    // Filter out dead particles\n    let j = 0;\n    for (let i = 0; i < burstsRef.current.length; i++) {\n      const burst = burstsRef.current[i];\n      if (burst.life > 0) {\n        // Keep alive particles, compact array\n        if (i !== j) {\n          burstsRef.current[j] = burst;\n        }\n        j++;\n      } else {\n        // Return to object pool\n        objectPoolsRef.current.bursts.push(burst);\n      }\n    }\n    \n    // Truncate array to remove dead particles\n    if (j < burstsRef.current.length) {\n      burstsRef.current.length = j;\n    }\n  }, [enableBursts, dimensions.pixelRatio]);\n  \n  // Render burst particles with Canvas 2D\n  const renderBursts2D = useCallback((ctx, deltaTime) => {\n    if (!enableBursts || burstsRef.current.length === 0) return;\n    \n    // Process and render each burst particle\n    let j = 0;\n    for (let i = 0; i < burstsRef.current.length; i++) {\n      const burst = burstsRef.current[i];\n      \n      // Update position\n      burst.x += burst.vx * (deltaTime / 16);\n      burst.y += burst.vy * (deltaTime / 16);\n      \n      // Apply damping to velocity\n      burst.vx *= burst.damping;\n      burst.vy *= burst.damping;\n      \n      // Reduce life\n      burst.life -= burst.decay * (deltaTime / 16);\n      \n      // Keep alive particles\n      if (burst.life > 0) {\n        // Draw particle\n        ctx.save();\n        \n        // Get velocity direction for trail orientation\n        const angle = Math.atan2(burst.vy, burst.vx);\n        \n        if (adaptedSettings.useHighQualityRendering) {\n          // Draw trail behind fragment\n          const trailLength = (burst.trailLength || 4) * burst.life;\n          const fragmentSize = burst.size * burst.life;\n          \n          // Create trail gradient\n          const trailGradient = ctx.createLinearGradient(\n            burst.x, \n            burst.y,\n            burst.x - Math.cos(angle) * trailLength,\n            burst.y - Math.sin(angle) * trailLength\n          );\n          \n          // Get the base color with varying opacity\n          trailGradient.addColorStop(0, getCachedColor(burst.color, burst.life * 0.8));\n          trailGradient.addColorStop(0.5, getCachedColor(burst.color, burst.life * 0.4));\n          trailGradient.addColorStop(1, getCachedColor(burst.color, 0));\n          \n          // Draw trail\n          ctx.beginPath();\n          ctx.moveTo(burst.x, burst.y);\n          ctx.lineTo(\n            burst.x - Math.cos(angle) * trailLength,\n            burst.y - Math.sin(angle) * trailLength\n          );\n          ctx.lineWidth = fragmentSize * 0.8;\n          ctx.lineCap = 'round';\n          ctx.strokeStyle = trailGradient;\n          ctx.stroke();\n          \n          // Draw fragment\n          if (adaptedSettings.useGlow) {\n            ctx.shadowColor = burst.color;\n            ctx.shadowBlur = fragmentSize * 2;\n          }\n          \n          ctx.beginPath();\n          ctx.arc(burst.x, burst.y, fragmentSize * 0.5, 0, Math.PI * 2);\n          ctx.fillStyle = getCachedColor(burst.color, burst.life);\n          ctx.fill();\n        } else {\n          // Simplified rendering for lower performance devices\n          const trailLength = (burst.trailLength || 3) * burst.life;\n          const fragmentSize = burst.size * burst.life;\n          \n          // Draw simple tapered line\n          ctx.beginPath();\n          ctx.moveTo(burst.x, burst.y);\n          ctx.lineTo(\n            burst.x - Math.cos(angle) * trailLength,\n            burst.y - Math.sin(angle) * trailLength\n          );\n          ctx.lineWidth = fragmentSize * 0.7;\n          ctx.lineCap = 'round';\n          ctx.strokeStyle = getCachedColor(burst.color, burst.life * 0.6);\n          ctx.stroke();\n        }\n        \n        ctx.restore();\n        \n        // Compact alive particles\n        if (i !== j) {\n          burstsRef.current[j] = burst;\n        }\n        j++;\n      } else {\n        // Return to object pool\n        objectPoolsRef.current.bursts.push(burst);\n      }\n    }\n    \n    // Truncate array to remove dead particles\n    if (j < burstsRef.current.length) {\n      burstsRef.current.length = j;\n    }\n  }, [enableBursts, adaptedSettings.useHighQualityRendering, adaptedSettings.useGlow, getCachedColor]);\n  \n  // 2D Canvas rendering method for meteors\n  const renderMeteors2D = useCallback((ctx, parallaxOffset, timestamp) => {\n    // Process and render each meteor\n    meteorsRef.current.forEach(meteor => {\n      // Calculate opacity based on progress\n      let currentOpacity = meteor.opacity;\n      if (meteor.progress > meteor.fadeThreshold) {\n        const fadeProgress = (meteor.progress - meteor.fadeThreshold) / (1 - meteor.fadeThreshold);\n        currentOpacity = meteor.opacity * (1 - fadeProgress);\n      }\n      \n      // Apply pulse effect\n      const timeFactor = timestamp * 0.001;\n      const pulseEffect = Math.sin(timeFactor * meteor.pulseSpeed + meteor.pulsePhase) * 0.2 + 0.8;\n      \n      // Parallax offset adjustment\n      const adjustY = enableParallax ? parallaxOffset * (meteor.size / meteorMaxSize) : 0;\n      \n      // Check if we should create a burst effect\n      if (meteor.hasBurst && !meteor.burstTriggered && meteor.progress >= meteor.burstThreshold) {\n        meteor.burstTriggered = true;\n        const burstPosition = meteor.positions[0];\n        \n        // Get velocity at burst point for influence on particles\n        const velocityPoint = { x: 0, y: 0 };\n        getPathVelocity(meteor.progress, meteor.path, velocityPoint);\n        \n        // Scale velocity for better visual effect\n        velocityPoint.x *= 0.8;\n        velocityPoint.y *= 0.8;\n        \n        // Create burst with velocity influence\n        createBurst(\n          burstPosition.x,\n          burstPosition.y + adjustY,\n          meteor.burstSize,\n          meteor.burstColors,\n          meteor.burstParticles,\n          velocityPoint\n        );\n      }\n      \n      // Optimized rendering approach\n      if (adaptedSettings.useHighQualityRendering) {\n        // High-quality rendering with shadows\n        // Set shadow for glow effect if enabled\n        if (adaptedSettings.useGlow) {\n          ctx.shadowColor = glowColor;\n          ctx.shadowBlur = meteor.size * 3 * pulseEffect;\n        }\n        \n        // Draw trail segments\n        ctx.lineCap = 'round';\n        \n        for (let i = meteor.positions.length - 2; i >= 0; i--) {\n          const pos1 = meteor.positions[i];\n          const pos2 = meteor.positions[i + 1];\n          \n          if (!pos1 || !pos2) continue;\n          \n          // Calculate segment opacity (decreases along the trail)\n          const segmentOpacity = currentOpacity * (1 - i / meteor.positions.length) * pulseEffect;\n          \n          // Skip if nearly invisible\n          if (segmentOpacity < 0.02) continue;\n          \n          // Calculate segment width (decreases along the trail)\n          const segmentWidth = meteor.size * (1 - i / meteor.positions.length * 0.7);\n          \n          // Draw line segment\n          ctx.beginPath();\n          ctx.moveTo(pos1.x, pos1.y + adjustY);\n          ctx.lineTo(pos2.x, pos2.y + adjustY);\n          \n          // Set line style\n          ctx.lineWidth = segmentWidth;\n          ctx.strokeStyle = getCachedColor(trailColor, segmentOpacity);\n          ctx.stroke();\n        }\n        \n        // Draw meteor head\n        if (meteor.positions[0]) {\n          const headPos = meteor.positions[0];\n          \n          // Set shadow for head\n          if (adaptedSettings.useShadow) {\n            ctx.shadowColor = glowColor;\n            ctx.shadowBlur = meteor.size * 5 * pulseEffect;\n          }\n          \n          // Draw outer glow\n          ctx.beginPath();\n          ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 1.5, 0, Math.PI * 2);\n          ctx.fillStyle = getCachedColor(glowColor, currentOpacity * 0.7 * pulseEffect);\n          ctx.fill();\n          \n          // Draw inner core\n          ctx.beginPath();\n          ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 0.7, 0, Math.PI * 2);\n          ctx.fillStyle = getCachedColor(coreColor, currentOpacity * pulseEffect);\n          ctx.fill();\n        }\n      } else {\n        // Performance-optimized rendering for lower-end devices\n        // Draw simplified trail\n        ctx.beginPath();\n        const headPos = meteor.positions[0];\n        if (!headPos) return;\n        \n        ctx.moveTo(headPos.x, headPos.y + adjustY);\n        \n        for (let i = 1; i < meteor.positions.length; i += 2) {\n          const pos = meteor.positions[i];\n          if (!pos) continue;\n          ctx.lineTo(pos.x, pos.y + adjustY);\n        }\n        \n        // Gradient trail\n        const gradient = ctx.createLinearGradient(\n          headPos.x, headPos.y + adjustY,\n          meteor.positions[meteor.positions.length - 1].x,\n          meteor.positions[meteor.positions.length - 1].y + adjustY\n        );\n        \n        gradient.addColorStop(0, getCachedColor(coreColor, currentOpacity * pulseEffect));\n        gradient.addColorStop(0.3, getCachedColor(glowColor, currentOpacity * 0.7 * pulseEffect));\n        gradient.addColorStop(1, getCachedColor(trailColor, 0));\n        \n        ctx.strokeStyle = gradient;\n        ctx.lineWidth = meteor.size;\n        ctx.lineCap = 'round';\n        ctx.stroke();\n        \n        // Simple head\n        ctx.beginPath();\n        ctx.arc(headPos.x, headPos.y + adjustY, meteor.size * 0.7, 0, Math.PI * 2);\n        ctx.fillStyle = getCachedColor(coreColor, currentOpacity * pulseEffect);\n        ctx.fill();\n      }\n    });\n  }, [\n    adaptedSettings.useHighQualityRendering,\n    adaptedSettings.useGlow,\n    adaptedSettings.useShadow,\n    enableParallax,\n    meteorMaxSize,\n    glowColor,\n    trailColor,\n    coreColor,\n    getCachedColor,\n    createBurst,\n    getPathVelocity\n  ]);\n  \n  // WebGL rendering method\n  const renderMeteorsWebGL = useCallback((gl, timestamp) => {\n    // This is a simplified placeholder for WebGL rendering\n    // A full implementation would use the shaders and buffers set up earlier\n    \n    if (!gl || !webGLProgramsRef.current.meteor) return;\n    \n    // Clear canvas\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    \n    // Use meteor shader program\n    const meteorProgram = webGLProgramsRef.current.meteor;\n    gl.useProgram(meteorProgram.program);\n    \n    // Set uniforms\n    gl.uniform2f(\n      meteorProgram.uniforms.resolution,\n      canvasRef.current.width,\n      canvasRef.current.height\n    );\n    \n    // This is where we would bind vertex buffers and render particles\n    // For a real implementation, you would:\n    // 1. Update vertex buffer with current meteor positions\n    // 2. Set attributes for position, size, color\n    // 3. Draw using gl.POINTS or other appropriate primitives\n    \n    // Check for burst triggers in WebGL mode too\n    meteorsRef.current.forEach(meteor => {\n      if (meteor.hasBurst && !meteor.burstTriggered && meteor.progress >= meteor.burstThreshold) {\n        meteor.burstTriggered = true;\n        const burstPosition = meteor.positions[0];\n        \n        // Get velocity at burst point for influence on particles\n        const velocityPoint = { x: 0, y: 0 };\n        getPathVelocity(meteor.progress, meteor.path, velocityPoint);\n        \n        // Create burst with velocity influence\n        // This will add particles to be rendered by renderBurstsWebGL\n        createBurst(\n          burstPosition.x,\n          burstPosition.y,\n          meteor.burstSize,\n          meteor.burstColors,\n          meteor.burstParticles,\n          velocityPoint\n        );\n      }\n    });\n    \n  }, [createBurst, getPathVelocity]);\n  \n  // Update meteor positions\n  const updateMeteors = useCallback((deltaTime) => {\n    // Process meteors without destructuring unused width/height\n    for (let i = meteorsRef.current.length - 1; i >= 0; i--) {\n      const meteor = meteorsRef.current[i];\n      \n      // Update progress based on speed and delta time\n      meteor.progress += meteor.speed * (deltaTime / 1000);\n      \n      // Check if meteor has completed its path\n      if (meteor.progress >= 1) {\n        // Return to object pool\n        meteor.active = false;\n        objectPoolsRef.current.meteors.push(meteor);\n        meteorsRef.current.splice(i, 1);\n        continue;\n      }\n      \n      // Calculate current position along the path\n      const currentPos = getPathPoint(Math.min(1, meteor.progress), meteor.path, pointCache.current);\n      \n      // Update position history (for trail) using optimized array management\n      // Shift positions array - this is more efficient than splice/unshift for small arrays\n      for (let j = meteor.positions.length - 1; j > 0; j--) {\n        const current = meteor.positions[j];\n        const prev = meteor.positions[j - 1];\n        \n        current.x = prev.x;\n        current.y = prev.y;\n      }\n      \n      // Update head position\n      meteor.positions[0].x = currentPos.x;\n      meteor.positions[0].y = currentPos.y;\n    }\n    \n    // Spawn new meteors if needed\n    const now = performance.now();\n    const spawnNeeded = meteorsRef.current.length < adaptedSettings.meteorDensity;\n    const canSpawnNow = !staggered || now >= nextSpawnTimeRef.current;\n    \n    if (spawnNeeded && canSpawnNow) {\n      const newMeteor = initializeMeteor();\n      if (newMeteor) {\n        meteorsRef.current.push(newMeteor);\n        \n        // Set next spawn time if staggering is enabled\n        if (staggered) {\n          const delay = Math.random() * (maxStaggerDelay - minStaggerDelay) + minStaggerDelay;\n          nextSpawnTimeRef.current = now + delay;\n        }\n      }\n    }\n  // Dependencies for updateMeteors\n  }, [\n    adaptedSettings.meteorDensity,\n    staggered,\n    minStaggerDelay,\n    maxStaggerDelay,\n    initializeMeteor,\n    getPathPoint,\n    pointCache\n  ]);\n  \n  // FPS limiter for consistent animation speed\n  const fpsLimiter = useCallback((timestamp, callback) => {\n    // Skip animation if hidden, inactive, or reduced motion\n    if (!isVisible || !active || (respectReducedMotion && prefersReducedMotion) || document.hidden) {\n      animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n      return;\n    }\n    \n    const targetFrameTime = 1000 / maxFPS;\n    const elapsed = timestamp - lastTimestampRef.current;\n    \n    if (elapsed >= targetFrameTime || lastTimestampRef.current === 0) {\n      // Calculate correct delta\n      const delta = lastTimestampRef.current === 0 ? 16 : elapsed;\n      \n      // Update timestamp, limiting delta to avoid jumps after inactivity\n      lastTimestampRef.current = timestamp - (elapsed % targetFrameTime);\n      \n      // Run animation callback with capped delta time\n      callback(Math.min(delta, 50));\n      \n      // FPS tracking for debug and adaptive quality\n      frameCountRef.current++;\n      if (timestamp - fpsTimestampRef.current >= 1000) {\n        currentFpsRef.current = frameCountRef.current;\n        frameCountRef.current = 0;\n        fpsTimestampRef.current = timestamp;\n        \n        // Log FPS in debug mode\n        if (debug) {\n          console.log(`MeteorShower FPS: ${currentFpsRef.current}, Quality: ${qualityFactor.toFixed(2)}`);\n        }\n        \n        // Dynamic quality adjustment based on performance\n        if (adaptiveQuality && currentFpsRef.current < maxFPS * 0.7) {\n          // If FPS is below 70% of target, reduce quality\n          setQualityFactor(prev => Math.max(0.4, prev * 0.9));\n        } else if (adaptiveQuality && currentFpsRef.current >= maxFPS * 0.95 && qualityFactor < 1) {\n          // If FPS is near target and quality is reduced, gradually increase\n          setQualityFactor(prev => Math.min(1, prev * 1.05));\n        }\n      }\n    }\n    \n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n  }, [\n    isVisible,\n    active,\n    respectReducedMotion,\n    prefersReducedMotion,\n    maxFPS,\n    debug,\n    adaptiveQuality,\n    qualityFactor\n  ]);\n  \n  // Main animation handler\n  const handleAnimation = useCallback((deltaTime) => {\n    // Skip if component is not ready\n    if (!canvasRef.current || !isInitialized) return;\n    \n    const now = performance.now();\n    \n    // Calculate parallax offset if enabled\n    let parallaxOffset = 0;\n    if (enableParallax) {\n      parallaxOffset = scrollPositionRef.current * parallaxIntensity;\n    }\n    \n    // Update meteor positions\n    updateMeteors(deltaTime);\n    \n    // Render based on selected mode\n    if (actualRenderingMode === 'webgl' && webGLRef.current) {\n      // WebGL rendering path\n      renderMeteorsWebGL(webGLRef.current, now);\n      \n      // Render burst particles with WebGL\n      if (enableBursts) {\n        renderBurstsWebGL(webGLRef.current, deltaTime);\n      }\n    } else {\n      // Canvas 2D rendering path\n      const ctx = ctxRef.current;\n      if (!ctx) return;\n      \n      // Clear canvas with optimized clear (only clear used area)\n      ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n      \n      // Render meteors\n      renderMeteors2D(ctx, parallaxOffset, now);\n      \n      // Render burst particles\n      if (enableBursts) {\n        renderBursts2D(ctx, deltaTime);\n      }\n      \n      // Debug visualization\n      if (debug) {\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n        ctx.font = '12px monospace';\n        ctx.fillText(`FPS: ${currentFpsRef.current}`, 10, 20);\n        ctx.fillText(`Meteors: ${meteorsRef.current.length}/${adaptedSettings.meteorDensity}`, 10, 40);\n        ctx.fillText(`Quality: ${qualityFactor.toFixed(2)}`, 10, 60);\n        ctx.fillText(`Rendering: ${actualRenderingMode}`, 10, 80);\n        \n        if (enableBursts) {\n          ctx.fillText(`Bursts: ${burstsRef.current.length}`, 10, 100);\n          ctx.fillText(`Last Burst: ${lastBurstCountRef.current}`, 10, 120);\n        }\n      }\n    }\n  }, [\n    isInitialized,\n    dimensions,\n    adaptedSettings.meteorDensity,\n    enableParallax,\n    parallaxIntensity,\n    actualRenderingMode,\n    debug,\n    updateMeteors,\n    renderMeteors2D,\n    renderMeteorsWebGL,\n    enableBursts,\n    renderBursts2D,\n    renderBurstsWebGL,\n    qualityFactor\n  ]);\n  \n  // Main animation loop\n  useEffect(() => {\n    if (!active || !isInitialized || !dimensions.width || !dimensions.height) {\n      return;\n    }\n    \n    // Start animation with FPS limiter\n    fpsTimestampRef.current = performance.now();\n    frameCountRef.current = 0;\n    lastTimestampRef.current = 0;\n    \n    animationFrameRef.current = requestAnimationFrame(timestamp => {\n      fpsLimiter(timestamp, handleAnimation);\n    });\n    \n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [\n    active,\n    isInitialized,\n    dimensions,\n    fpsLimiter,\n    handleAnimation\n  ]);\n  \n  return (\n    <div \n      ref={containerRef}\n      style={{ \n        position: 'absolute',\n        top: 0, \n        left: 0, \n        width: '100%', \n        height: height,\n        overflow: 'hidden', \n        pointerEvents: 'none', \n        zIndex: zIndex,\n        // Hardware acceleration\n        backfaceVisibility: 'hidden',\n        transform: 'translateZ(0)',\n        willChange: 'transform'\n      }}\n      aria-hidden=\"true\"\n    >\n      <canvas \n        ref={canvasRef} \n        style={{ \n          position: 'absolute', \n          top: 0, \n          left: 0, \n          width: '100%', \n          height: '100%',\n          // Additional rendering optimizations\n          imageRendering: 'high-quality',\n          // Hardware acceleration\n          backfaceVisibility: 'hidden',\n          transform: 'translateZ(0)',\n          willChange: 'transform',\n          // Ensures proper subpixel rendering\n          filter: 'none'\n        }} \n      />\n    </div>\n  );\n};\n\n/**\n * GoldenMeteorShower Component\n * \n * A preset version of the MeteorShower with a golden/amber color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const GoldenMeteorShower = (props) => {\n  const goldenPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 245, 158, 0.9)',\n    trailColor: 'rgba(207, 181, 59, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 200,\n    maxStaggerDelay: 2000,\n    enableBursts: true,\n    burstProbability: 0.4,\n    burstParticleSize: 1.8,\n    burstParticleCount: 14\n  };\n  \n  return <MeteorShower {...goldenPreset} {...props} />;\n};\n\n/**\n * CelestialMeteorShower Component\n * \n * A preset version of the MeteorShower with a bluish-purple color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const CelestialMeteorShower = (props) => {\n  const celestialPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(220, 225, 255, 0.9)',\n    trailColor: 'rgba(150, 160, 255, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 300,\n    maxStaggerDelay: 1800,\n    enableBursts: true,\n    burstProbability: 0.35\n  };\n  \n  return <MeteorShower {...celestialPreset} {...props} />;\n};\n\n/**\n * RubyMeteorShower Component\n * \n * A preset version of the MeteorShower with a red color scheme.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const RubyMeteorShower = (props) => {\n  const rubyPreset = {\n    coreColor: 'rgba(255, 255, 255, 1)',\n    glowColor: 'rgba(255, 200, 200, 0.9)',\n    trailColor: 'rgba(220, 100, 100, 0.8)',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.08,\n    trailLength: 180,\n    trailSegments: 20,\n    journeyCompletion: 0.9,\n    staggered: true,\n    minStaggerDelay: 350,\n    maxStaggerDelay: 2200,\n    enableBursts: true,\n    burstProbability: 0.45\n  };\n  \n  return <MeteorShower {...rubyPreset} {...props} />;\n};\n\n/**\n * TopMeteorShower Component\n * \n * A preset version of the MeteorShower with meteors falling from the top of the screen\n * at a consistent 30-degree angle, distributed with emphasis on left and center areas.\n * \n * @param {Object} props - Same props as MeteorShower with presets\n */\nexport const TopMeteorShower = (props) => {\n  const topPreset = {\n    mode: 'linear',\n    direction: 'top',\n    meteorMinSize: 1,\n    meteorMaxSize: 3,\n    meteorSpeed: 0.12,\n    trailLength: 200,\n    trailSegments: 25,\n    journeyCompletion: 0.95,\n    staggered: true,\n    minStaggerDelay: 100,\n    maxStaggerDelay: 1000,\n    enableBursts: true,\n    burstProbability: 0.5,\n    burstParticleCount: 15\n  };\n  \n  return <MeteorShower {...topPreset} {...props} />;\n};\n\nexport default MeteorShower;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}