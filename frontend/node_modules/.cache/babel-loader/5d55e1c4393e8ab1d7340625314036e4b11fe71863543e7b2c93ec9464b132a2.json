{"ast":null,"code":"var _jsxFileName = \"/home/valeria/Documents/Crucible/frontend/src/components/core/Background.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect, useMemo } from 'react';\n\n/**\n * StellarBackground Component\n * \n * Creates a refined animated stellar background with elegant constellations,\n * subtle star movement, and occasional gentle effects.\n * \n * Features:\n * - Smooth, cohesive constellation movement\n * - Refined star aesthetics with subtle animation\n * - Performant rendering with adaptive quality\n * - Elegant visual effects that respect the overall aesthetic\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst StellarBackground = ({\n  height = '100vh',\n  width = '100vw',\n  zIndex = 0,\n  active = true,\n  starDensity = 150,\n  constellationCount = 3,\n  starMaxSize = 1.8,\n  starMinSize = 0.4,\n  horizontalMovementSpeed = 0.05,\n  verticalMovementSpeed = 0.02,\n  starTwinkleFrequency = 0.003,\n  rareEffectProbability = 0.0005,\n  starColor = 'rgba(255, 255, 255, 0.8)',\n  starGlowColor = 'rgba(255, 255, 255, 0.3)',\n  constellationLineColor = 'rgba(191, 173, 127, 0.15)',\n  constellationVertexColor = 'rgba(191, 173, 127, 0.4)',\n  burstColor = 'rgba(207, 181, 59, 0.7)',\n  respectReducedMotion = true,\n  maxFPS = 30\n}) => {\n  _s();\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const starsRef = useRef([]);\n  const constellationsRef = useRef([]);\n  const twinkleEffectsRef = useRef([]);\n  const burstEffectsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const fpsTimestampRef = useRef(0);\n  const frameCountRef = useRef(0);\n  const worldPositionRef = useRef({\n    x: 0,\n    y: 0\n  });\n\n  // Component state\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0\n  });\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [isVisible, setIsVisible] = useState(false);\n\n  // Color cache for better performance\n  const colorCache = useRef(new Map());\n\n  // Get a cached color with opacity\n  const getCachedColor = (baseColor, opacity) => {\n    // Ensure opacity is always valid\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n\n    // Round opacity to reduce cache size while maintaining visual quality\n    const roundedOpacity = Math.round(safeOpacity * 100) / 100;\n    const key = `${baseColor}-${roundedOpacity}`;\n    if (!colorCache.current.has(key)) {\n      const newColor = baseColor.replace(/[\\d.]+\\)$/, roundedOpacity + ')');\n      colorCache.current.set(key, newColor);\n    }\n    return colorCache.current.get(key);\n  };\n\n  // Check for reduced motion preference\n  useEffect(() => {\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    const handleReducedMotionChange = e => {\n      setPrefersReducedMotion(e.matches);\n    };\n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n    };\n  }, []);\n\n  // Initialize canvas with proper resolution\n  const setupCanvas = () => {\n    if (!canvasRef.current || !containerRef.current) return false;\n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    const rect = container.getBoundingClientRect();\n    const pixelRatio = window.devicePixelRatio || 1;\n\n    // Calculate dimensions\n    const displayWidth = rect.width;\n    const displayHeight = rect.height;\n\n    // Set canvas size accounting for pixel ratio\n    canvas.width = displayWidth * pixelRatio;\n    canvas.height = displayHeight * pixelRatio;\n    canvas.style.width = `${displayWidth}px`;\n    canvas.style.height = `${displayHeight}px`;\n\n    // Get 2D Canvas context\n    const ctx = canvas.getContext('2d', {\n      alpha: true,\n      desynchronized: true,\n      willReadFrequently: false\n    });\n    if (!ctx) return false;\n\n    // Scale context for high-DPI displays\n    ctx.scale(pixelRatio, pixelRatio);\n\n    // Update dimensions state\n    setDimensions({\n      width: displayWidth,\n      height: displayHeight,\n      pixelRatio\n    });\n    return true;\n  };\n\n  // Setup canvas resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Create a ResizeObserver to detect container size changes\n    const resizeObserver = new ResizeObserver(() => {\n      // Debounce resize operations\n      if (resizeTimeoutRef.current) {\n        clearTimeout(resizeTimeoutRef.current);\n      }\n\n      // Use a ref to avoid dependency issues\n      const resizeTimeoutRef = {\n        current: null\n      };\n      resizeTimeoutRef.current = setTimeout(() => {\n        if (setupCanvas()) {\n          // Only initialize once when dimensions are first set\n          if (!isInitialized && dimensions.width > 0 && dimensions.height > 0) {\n            setIsInitialized(true);\n          }\n        }\n      }, 100);\n    });\n\n    // Start observing the container\n    resizeObserver.observe(containerRef.current);\n\n    // Initial setup\n    setupCanvas();\n    return () => {\n      if (resizeObserver) {\n        resizeObserver.disconnect();\n      }\n    };\n  }, [isInitialized, dimensions]);\n\n  // Setup intersection observer to only animate when visible\n  useEffect(() => {\n    if (!containerRef.current) return;\n    const observer = new IntersectionObserver(entries => {\n      const isIntersecting = entries[0].isIntersecting;\n\n      // Only change state if visibility actually changed\n      if (isIntersecting !== isVisible) {\n        setIsVisible(isIntersecting);\n        if (isIntersecting) {\n          // Reset timing references when becoming visible again\n          lastTimestampRef.current = 0;\n        }\n      }\n    }, {\n      threshold: 0.01,\n      rootMargin: '100px'\n    });\n    observer.observe(containerRef.current);\n    return () => {\n      observer.disconnect();\n    };\n  }, [isVisible]);\n\n  // Initialize stars and constellations when dimensions are available\n  useEffect(() => {\n    if (!dimensions.width || !dimensions.height) return;\n\n    // Create stars\n    const stars = [];\n    const starCount = starDensity;\n    for (let i = 0; i < starCount; i++) {\n      // Generate star positions in a slightly larger area to allow for movement\n      const margin = 100; // Extra margin to allow stars to move in\n\n      stars.push({\n        x: Math.random() * (dimensions.width + 2 * margin) - margin,\n        y: Math.random() * (dimensions.height + 2 * margin) - margin,\n        size: Math.random() * (starMaxSize - starMinSize) + starMinSize,\n        brightness: 0.3 + Math.random() * 0.7,\n        twinkleSpeed: 0.002 + Math.random() * 0.008,\n        twinklePhase: Math.random() * Math.PI * 2,\n        flareProb: Math.random() * 0.005 // Probability for this star to flare\n      });\n    }\n    starsRef.current = stars;\n\n    // Create constellations\n    const constellations = [];\n    const constellationStarIndices = new Set(); // Track used stars\n\n    for (let i = 0; i < constellationCount; i++) {\n      // Pick a random center star not already in a constellation\n      let availableStars = stars.filter((_, index) => !constellationStarIndices.has(index));\n\n      // If no available stars, break\n      if (availableStars.length === 0) break;\n\n      // Choose center star near the middle of the visible area\n      const centerIndex = stars.indexOf(availableStars[Math.floor(Math.random() * Math.min(availableStars.length, 30))]);\n      constellationStarIndices.add(centerIndex);\n      const centerStar = stars[centerIndex];\n      const constPoints = [centerIndex];\n      const constConnections = [];\n\n      // Find nearby stars for this constellation (4-7 stars)\n      const numStars = 4 + Math.floor(Math.random() * 4);\n      const maxDist = Math.min(dimensions.width, dimensions.height) * 0.2;\n\n      // Find candidates\n      const candidates = [];\n      for (let j = 0; j < stars.length; j++) {\n        if (constellationStarIndices.has(j)) continue;\n        const star = stars[j];\n        const dist = Math.hypot(star.x - centerStar.x, star.y - centerStar.y);\n        if (dist < maxDist) {\n          candidates.push({\n            index: j,\n            distance: dist\n          });\n        }\n      }\n\n      // Sort by distance and take closest ones\n      candidates.sort((a, b) => a.distance - b.distance);\n\n      // Create a more natural constellation pattern\n      const usedStars = candidates.slice(0, numStars);\n      for (const starData of usedStars) {\n        constPoints.push(starData.index);\n        constellationStarIndices.add(starData.index);\n\n        // Connect to closest star that's already in the constellation\n        let minDist = Infinity;\n        let closestPoint = centerIndex;\n        for (const pointIndex of constPoints) {\n          if (pointIndex === starData.index) continue;\n          const pointStar = stars[pointIndex];\n          const currentStar = stars[starData.index];\n          const dist = Math.hypot(pointStar.x - currentStar.x, pointStar.y - currentStar.y);\n          if (dist < minDist) {\n            minDist = dist;\n            closestPoint = pointIndex;\n          }\n        }\n        constConnections.push([closestPoint, starData.index]);\n\n        // Occasionally add a second connection for more interesting shapes\n        if (Math.random() < 0.3 && constPoints.length > 3) {\n          let secondConnections = constPoints.filter(p => p !== starData.index && p !== closestPoint);\n          if (secondConnections.length > 0) {\n            const secondPoint = secondConnections[Math.floor(Math.random() * secondConnections.length)];\n            constConnections.push([secondPoint, starData.index]);\n          }\n        }\n      }\n\n      // Create constellation with fixed offset to maintain shape\n      const offsets = [];\n      for (const pointIndex of constPoints) {\n        const star = stars[pointIndex];\n        offsets.push({\n          x: star.x - centerStar.x,\n          y: star.y - centerStar.y\n        });\n      }\n      constellations.push({\n        centerIndex,\n        points: constPoints,\n        connections: constConnections,\n        offsets,\n        opacity: Math.random() * 0.3 + 0.4,\n        // Varying base opacity\n        pulseSpeed: 0.0002 + Math.random() * 0.0003,\n        pulsePhase: Math.random() * Math.PI * 2\n      });\n    }\n    constellationsRef.current = constellations;\n  }, [dimensions, starDensity, starMaxSize, starMinSize, constellationCount]);\n\n  // Create a twinkle effect\n  const createTwinkleEffect = star => {\n    if (twinkleEffectsRef.current.length > 15) return; // Limit concurrent effects\n\n    twinkleEffectsRef.current.push({\n      x: star.x,\n      y: star.y,\n      size: star.size * (1.2 + Math.random() * 0.5),\n      brightness: star.brightness * (1.3 + Math.random()),\n      life: 1.0,\n      decay: 0.01 + Math.random() * 0.02\n    });\n  };\n\n  // Create a burst effect\n  const createBurstEffect = (x, y, size) => {\n    if (burstEffectsRef.current.length > 10) return; // Limit concurrent effects\n\n    const particleCount = Math.floor(4 + Math.random() * 6);\n    for (let i = 0; i < particleCount; i++) {\n      const angle = Math.random() * Math.PI * 2;\n      const speed = 0.05 + Math.random() * 0.15;\n      burstEffectsRef.current.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        size: size * (0.3 + Math.random() * 0.3),\n        life: 1.0,\n        decay: 0.006 + Math.random() * 0.008,\n        damping: 0.98 + Math.random() * 0.01\n      });\n    }\n  };\n\n  // FPS limiter for consistent animation speed\n  const fpsLimiter = (timestamp, callback) => {\n    // Skip animation if hidden, inactive, or reduced motion\n    if (!isVisible || !active || respectReducedMotion && prefersReducedMotion) {\n      animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n      return;\n    }\n    const targetFrameTime = 1000 / maxFPS;\n    const elapsed = timestamp - lastTimestampRef.current;\n    if (elapsed >= targetFrameTime || lastTimestampRef.current === 0) {\n      // Calculate delta time\n      const delta = lastTimestampRef.current === 0 ? 16 : elapsed;\n\n      // Update timestamp\n      lastTimestampRef.current = timestamp;\n\n      // Run animation callback with capped delta time\n      callback(Math.min(delta, 50));\n\n      // FPS tracking\n      frameCountRef.current++;\n      if (timestamp - fpsTimestampRef.current >= 1000) {\n        frameCountRef.current = 0;\n        fpsTimestampRef.current = timestamp;\n      }\n    }\n\n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n  };\n\n  // Update star and constellation positions\n  const updatePositions = deltaTime => {\n    // Normalize time delta for consistent speed across devices\n    const timeScale = deltaTime / 16;\n\n    // Update world position\n    worldPositionRef.current.x += horizontalMovementSpeed * timeScale;\n    worldPositionRef.current.y += verticalMovementSpeed * timeScale;\n\n    // Update stars\n    for (const star of starsRef.current) {\n      // Apply twinkle effect\n      const time = performance.now() * 0.001;\n      star.currentBrightness = star.brightness * (0.7 + 0.3 * Math.pow(Math.sin(time * star.twinkleSpeed + star.twinklePhase) * 0.5 + 0.5, 1.5));\n\n      // Random chance for twinkle effect\n      if (Math.random() < star.flareProb * timeScale) {\n        createTwinkleEffect(star);\n      }\n\n      // Very rare chance for burst effect\n      if (Math.random() < rareEffectProbability * timeScale) {\n        createBurstEffect(star.x, star.y, star.size * 2);\n      }\n    }\n\n    // Update twinkle effects\n    for (let i = twinkleEffectsRef.current.length - 1; i >= 0; i--) {\n      const twinkle = twinkleEffectsRef.current[i];\n\n      // Update life\n      twinkle.life -= twinkle.decay * timeScale;\n\n      // Remove expired effects\n      if (twinkle.life <= 0) {\n        twinkleEffectsRef.current.splice(i, 1);\n      }\n    }\n\n    // Update burst effects\n    for (let i = burstEffectsRef.current.length - 1; i >= 0; i--) {\n      const burst = burstEffectsRef.current[i];\n\n      // Update position\n      burst.x += burst.vx * timeScale;\n      burst.y += burst.vy * timeScale;\n\n      // Apply damping\n      burst.vx *= burst.damping;\n      burst.vy *= burst.damping;\n\n      // Update life\n      burst.life -= burst.decay * timeScale;\n\n      // Remove expired effects\n      if (burst.life <= 0) {\n        burstEffectsRef.current.splice(i, 1);\n      }\n    }\n\n    // Update constellations\n    for (const constellation of constellationsRef.current) {\n      // Update pulsing opacity\n      const time = performance.now() * 0.001;\n      const pulseFactor = Math.sin(time * constellation.pulseSpeed + constellation.pulsePhase) * 0.1 + 0.9;\n      constellation.currentOpacity = constellation.opacity * pulseFactor;\n    }\n  };\n\n  // Render stars and constellations\n  const renderScene = () => {\n    if (!canvasRef.current) return;\n    const ctx = canvasRef.current.getContext('2d');\n    if (!ctx) return;\n    const {\n      width,\n      height\n    } = dimensions;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n\n    // Get stars and constellations\n    const stars = starsRef.current;\n    const constellations = constellationsRef.current;\n\n    // Apply global offset to everything\n    const globalOffsetX = worldPositionRef.current.x;\n    const globalOffsetY = worldPositionRef.current.y;\n\n    // Render constellations first (behind stars)\n    for (const constellation of constellations) {\n      const centerStar = stars[constellation.centerIndex];\n      if (!centerStar) continue;\n\n      // Calculate constellation center with global movement\n      const centerX = (centerStar.x - globalOffsetX) % width;\n      const centerY = (centerStar.y - globalOffsetY) % height;\n\n      // Adjust for wrap-around\n      const constCenterX = centerX < 0 ? centerX + width : centerX;\n      const constCenterY = centerY < 0 ? centerY + height : centerY;\n\n      // Draw constellation lines\n      ctx.strokeStyle = getCachedColor(constellationLineColor, constellation.currentOpacity);\n      ctx.lineWidth = 0.5;\n\n      // Enable glow effect\n      ctx.shadowColor = getCachedColor(constellationLineColor, constellation.currentOpacity * 0.5);\n      ctx.shadowBlur = 3;\n\n      // Render each connection\n      ctx.beginPath();\n      for (const [fromIdx, toIdx] of constellation.connections) {\n        const fromPointIndex = constellation.points.indexOf(fromIdx);\n        const toPointIndex = constellation.points.indexOf(toIdx);\n        if (fromPointIndex === -1 || toPointIndex === -1) continue;\n\n        // Calculate positions based on offsets from center to maintain shape\n        const fromOffset = constellation.offsets[fromPointIndex];\n        const toOffset = constellation.offsets[toPointIndex];\n        const fromX = constCenterX + fromOffset.x;\n        const fromY = constCenterY + fromOffset.y;\n        const toX = constCenterX + toOffset.x;\n        const toY = constCenterY + toOffset.y;\n        ctx.moveTo(fromX, fromY);\n        ctx.lineTo(toX, toY);\n      }\n      ctx.stroke();\n\n      // Reset shadow for better performance\n      ctx.shadowBlur = 0;\n\n      // Draw constellation vertices with a subtle glow\n      ctx.fillStyle = getCachedColor(constellationVertexColor, constellation.currentOpacity);\n      for (let i = 0; i < constellation.points.length; i++) {\n        const offset = constellation.offsets[i];\n        const x = constCenterX + offset.x;\n        const y = constCenterY + offset.y;\n        ctx.beginPath();\n        ctx.arc(x, y, 1, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n\n    // Render stars\n    for (const star of stars) {\n      // Apply global movement to star position\n      const x = (star.x - globalOffsetX) % width;\n      const y = (star.y - globalOffsetY) % height;\n\n      // Adjust for wrap-around\n      const renderX = x < 0 ? x + width : x;\n      const renderY = y < 0 ? y + height : y;\n\n      // Skip if not visible\n      if (renderX < -10 || renderX > width + 10 || renderY < -10 || renderY > height + 10) {\n        continue;\n      }\n\n      // Draw star with glow\n      // Star glow\n      ctx.beginPath();\n      ctx.fillStyle = getCachedColor(starGlowColor, star.currentBrightness * 0.5);\n      ctx.arc(renderX, renderY, star.size * 1.5, 0, Math.PI * 2);\n      ctx.fill();\n\n      // Star core\n      ctx.beginPath();\n      ctx.fillStyle = getCachedColor(starColor, star.currentBrightness);\n      ctx.arc(renderX, renderY, star.size * 0.6, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // Render twinkle effects\n    ctx.shadowColor = starGlowColor;\n    for (const twinkle of twinkleEffectsRef.current) {\n      const x = (twinkle.x - globalOffsetX) % width;\n      const y = (twinkle.y - globalOffsetY) % height;\n\n      // Adjust for wrap-around\n      const renderX = x < 0 ? x + width : x;\n      const renderY = y < 0 ? y + height : y;\n\n      // Skip if not visible\n      if (renderX < -10 || renderX > width + 10 || renderY < -10 || renderY > height + 10) {\n        continue;\n      }\n\n      // Draw twinkle with glow\n      ctx.shadowBlur = twinkle.size * 2 * twinkle.life;\n\n      // Outer glow\n      ctx.beginPath();\n      ctx.fillStyle = getCachedColor(starGlowColor, twinkle.brightness * 0.4 * twinkle.life);\n      ctx.arc(renderX, renderY, twinkle.size * 1.5 * twinkle.life, 0, Math.PI * 2);\n      ctx.fill();\n\n      // Inner bright core\n      ctx.beginPath();\n      ctx.fillStyle = getCachedColor(starColor, twinkle.brightness * twinkle.life);\n      ctx.arc(renderX, renderY, twinkle.size * 0.7 * twinkle.life, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // Render burst effects (golden particles)\n    ctx.shadowColor = burstColor;\n    for (const burst of burstEffectsRef.current) {\n      // Draw burst particle with gold color\n      ctx.shadowBlur = burst.size * 1.5 * burst.life;\n      ctx.beginPath();\n      ctx.fillStyle = getCachedColor(burstColor, 0.7 * burst.life);\n      ctx.arc(burst.x, burst.y, burst.size * burst.life, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // Reset shadow\n    ctx.shadowBlur = 0;\n  };\n\n  // Main animation handler\n  const handleAnimation = deltaTime => {\n    // Skip if component is not ready\n    if (!canvasRef.current || !isInitialized || !dimensions.width || !dimensions.height) return;\n\n    // Update positions\n    updatePositions(deltaTime);\n\n    // Render the scene\n    renderScene();\n  };\n\n  // Main animation loop\n  useEffect(() => {\n    if (!active || !isInitialized || !dimensions.width || !dimensions.height) {\n      return;\n    }\n\n    // Start animation\n    animationFrameRef.current = requestAnimationFrame(timestamp => {\n      fpsLimiter(timestamp, handleAnimation);\n    });\n\n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [active, isInitialized, dimensions]);\n\n  // Apply reduced motion adjustments\n  const reducedMotionStyles = useMemo(() => {\n    if (prefersReducedMotion && respectReducedMotion) {\n      return {\n        animation: 'none',\n        transition: 'none'\n      };\n    }\n    return {};\n  }, [prefersReducedMotion, respectReducedMotion]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width,\n      height,\n      overflow: 'hidden',\n      pointerEvents: 'none',\n      zIndex,\n      ...reducedMotionStyles,\n      // Hardware acceleration\n      transform: 'translateZ(0)'\n    },\n    \"aria-hidden\": \"true\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        // Hardware acceleration\n        transform: 'translateZ(0)'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 690,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 673,\n    columnNumber: 5\n  }, this);\n};\n\n/**\n * Gold-themed Stellar Background Preset\n */\n_s(StellarBackground, \"YicvsEu0mrvgdaYRLN5GYeXz5lI=\");\n_c = StellarBackground;\nexport const GoldenStellarBackground = props => {\n  const goldenPreset = {\n    starDensity: 170,\n    starMaxSize: 1.8,\n    starMinSize: 0.4,\n    constellationCount: 4,\n    horizontalMovementSpeed: 0.04,\n    verticalMovementSpeed: 0.01,\n    starColor: 'rgba(255, 250, 240, 0.85)',\n    starGlowColor: 'rgba(255, 250, 220, 0.3)',\n    constellationLineColor: 'rgba(207, 181, 59, 0.15)',\n    constellationVertexColor: 'rgba(207, 181, 59, 0.4)',\n    burstColor: 'rgba(207, 181, 59, 0.7)'\n  };\n  return /*#__PURE__*/_jsxDEV(StellarBackground, {\n    ...goldenPreset,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 724,\n    columnNumber: 10\n  }, this);\n};\n_c2 = GoldenStellarBackground;\nexport default StellarBackground;\nvar _c, _c2;\n$RefreshReg$(_c, \"StellarBackground\");\n$RefreshReg$(_c2, \"GoldenStellarBackground\");","map":{"version":3,"names":["React","useRef","useState","useEffect","useMemo","jsxDEV","_jsxDEV","StellarBackground","height","width","zIndex","active","starDensity","constellationCount","starMaxSize","starMinSize","horizontalMovementSpeed","verticalMovementSpeed","starTwinkleFrequency","rareEffectProbability","starColor","starGlowColor","constellationLineColor","constellationVertexColor","burstColor","respectReducedMotion","maxFPS","_s","containerRef","canvasRef","starsRef","constellationsRef","twinkleEffectsRef","burstEffectsRef","animationFrameRef","lastTimestampRef","fpsTimestampRef","frameCountRef","worldPositionRef","x","y","dimensions","setDimensions","isInitialized","setIsInitialized","prefersReducedMotion","setPrefersReducedMotion","isVisible","setIsVisible","colorCache","Map","getCachedColor","baseColor","opacity","safeOpacity","Math","max","min","roundedOpacity","round","key","current","has","newColor","replace","set","get","reducedMotionQuery","window","matchMedia","matches","handleReducedMotionChange","e","addEventListener","removeEventListener","setupCanvas","canvas","container","rect","getBoundingClientRect","pixelRatio","devicePixelRatio","displayWidth","displayHeight","style","ctx","getContext","alpha","desynchronized","willReadFrequently","scale","resizeObserver","ResizeObserver","resizeTimeoutRef","clearTimeout","setTimeout","observe","disconnect","observer","IntersectionObserver","entries","isIntersecting","threshold","rootMargin","stars","starCount","i","margin","push","random","size","brightness","twinkleSpeed","twinklePhase","PI","flareProb","constellations","constellationStarIndices","Set","availableStars","filter","_","index","length","centerIndex","indexOf","floor","add","centerStar","constPoints","constConnections","numStars","maxDist","candidates","j","star","dist","hypot","distance","sort","a","b","usedStars","slice","starData","minDist","Infinity","closestPoint","pointIndex","pointStar","currentStar","secondConnections","p","secondPoint","offsets","points","connections","pulseSpeed","pulsePhase","createTwinkleEffect","life","decay","createBurstEffect","particleCount","angle","speed","vx","cos","vy","sin","damping","fpsLimiter","timestamp","callback","requestAnimationFrame","time","targetFrameTime","elapsed","delta","updatePositions","deltaTime","timeScale","performance","now","currentBrightness","pow","twinkle","splice","burst","constellation","pulseFactor","currentOpacity","renderScene","clearRect","globalOffsetX","globalOffsetY","centerX","centerY","constCenterX","constCenterY","strokeStyle","lineWidth","shadowColor","shadowBlur","beginPath","fromIdx","toIdx","fromPointIndex","toPointIndex","fromOffset","toOffset","fromX","fromY","toX","toY","moveTo","lineTo","stroke","fillStyle","offset","arc","fill","renderX","renderY","handleAnimation","cancelAnimationFrame","reducedMotionStyles","animation","transition","ref","position","top","left","overflow","pointerEvents","transform","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","GoldenStellarBackground","props","goldenPreset","_c2","$RefreshReg$"],"sources":["/home/valeria/Documents/Crucible/frontend/src/components/core/Background.jsx"],"sourcesContent":["import React, { useRef, useState, useEffect, useMemo } from 'react';\n\n/**\n * StellarBackground Component\n * \n * Creates a refined animated stellar background with elegant constellations,\n * subtle star movement, and occasional gentle effects.\n * \n * Features:\n * - Smooth, cohesive constellation movement\n * - Refined star aesthetics with subtle animation\n * - Performant rendering with adaptive quality\n * - Elegant visual effects that respect the overall aesthetic\n */\nconst StellarBackground = ({\n  height = '100vh',\n  width = '100vw',\n  zIndex = 0,\n  active = true,\n  starDensity = 150,\n  constellationCount = 3,\n  starMaxSize = 1.8,\n  starMinSize = 0.4,\n  horizontalMovementSpeed = 0.05,\n  verticalMovementSpeed = 0.02,\n  starTwinkleFrequency = 0.003,\n  rareEffectProbability = 0.0005,\n  starColor = 'rgba(255, 255, 255, 0.8)',\n  starGlowColor = 'rgba(255, 255, 255, 0.3)',\n  constellationLineColor = 'rgba(191, 173, 127, 0.15)',\n  constellationVertexColor = 'rgba(191, 173, 127, 0.4)',\n  burstColor = 'rgba(207, 181, 59, 0.7)',\n  respectReducedMotion = true,\n  maxFPS = 30\n}) => {\n  // Refs for DOM elements and animation state\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const starsRef = useRef([]);\n  const constellationsRef = useRef([]);\n  const twinkleEffectsRef = useRef([]);\n  const burstEffectsRef = useRef([]);\n  const animationFrameRef = useRef(null);\n  const lastTimestampRef = useRef(0);\n  const fpsTimestampRef = useRef(0);\n  const frameCountRef = useRef(0);\n  const worldPositionRef = useRef({ x: 0, y: 0 });\n  \n  // Component state\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [isVisible, setIsVisible] = useState(false);\n  \n  // Color cache for better performance\n  const colorCache = useRef(new Map());\n  \n  // Get a cached color with opacity\n  const getCachedColor = (baseColor, opacity) => {\n    // Ensure opacity is always valid\n    const safeOpacity = Math.max(0, Math.min(1, opacity || 0));\n    \n    // Round opacity to reduce cache size while maintaining visual quality\n    const roundedOpacity = Math.round(safeOpacity * 100) / 100;\n    const key = `${baseColor}-${roundedOpacity}`;\n    \n    if (!colorCache.current.has(key)) {\n      const newColor = baseColor.replace(/[\\d.]+\\)$/, roundedOpacity + ')');\n      colorCache.current.set(key, newColor);\n    }\n    \n    return colorCache.current.get(key);\n  };\n  \n  // Check for reduced motion preference\n  useEffect(() => {\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    \n    const handleReducedMotionChange = (e) => {\n      setPrefersReducedMotion(e.matches);\n    };\n    \n    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);\n    \n    return () => {\n      reducedMotionQuery.removeEventListener('change', handleReducedMotionChange);\n    };\n  }, []);\n  \n  // Initialize canvas with proper resolution\n  const setupCanvas = () => {\n    if (!canvasRef.current || !containerRef.current) return false;\n    \n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    const rect = container.getBoundingClientRect();\n    const pixelRatio = window.devicePixelRatio || 1;\n    \n    // Calculate dimensions\n    const displayWidth = rect.width;\n    const displayHeight = rect.height;\n    \n    // Set canvas size accounting for pixel ratio\n    canvas.width = displayWidth * pixelRatio;\n    canvas.height = displayHeight * pixelRatio;\n    canvas.style.width = `${displayWidth}px`;\n    canvas.style.height = `${displayHeight}px`;\n    \n    // Get 2D Canvas context\n    const ctx = canvas.getContext('2d', {\n      alpha: true,\n      desynchronized: true,\n      willReadFrequently: false\n    });\n    \n    if (!ctx) return false;\n    \n    // Scale context for high-DPI displays\n    ctx.scale(pixelRatio, pixelRatio);\n    \n    // Update dimensions state\n    setDimensions({\n      width: displayWidth,\n      height: displayHeight,\n      pixelRatio\n    });\n    \n    return true;\n  };\n  \n  // Setup canvas resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n    \n    // Create a ResizeObserver to detect container size changes\n    const resizeObserver = new ResizeObserver(() => {\n      // Debounce resize operations\n      if (resizeTimeoutRef.current) {\n        clearTimeout(resizeTimeoutRef.current);\n      }\n      \n      // Use a ref to avoid dependency issues\n      const resizeTimeoutRef = { current: null };\n      \n      resizeTimeoutRef.current = setTimeout(() => {\n        if (setupCanvas()) {\n          // Only initialize once when dimensions are first set\n          if (!isInitialized && dimensions.width > 0 && dimensions.height > 0) {\n            setIsInitialized(true);\n          }\n        }\n      }, 100);\n    });\n    \n    // Start observing the container\n    resizeObserver.observe(containerRef.current);\n    \n    // Initial setup\n    setupCanvas();\n    \n    return () => {\n      if (resizeObserver) {\n        resizeObserver.disconnect();\n      }\n    };\n  }, [isInitialized, dimensions]);\n  \n  // Setup intersection observer to only animate when visible\n  useEffect(() => {\n    if (!containerRef.current) return;\n    \n    const observer = new IntersectionObserver(\n      entries => {\n        const isIntersecting = entries[0].isIntersecting;\n        \n        // Only change state if visibility actually changed\n        if (isIntersecting !== isVisible) {\n          setIsVisible(isIntersecting);\n          \n          if (isIntersecting) {\n            // Reset timing references when becoming visible again\n            lastTimestampRef.current = 0;\n          }\n        }\n      },\n      {\n        threshold: 0.01,\n        rootMargin: '100px'\n      }\n    );\n    \n    observer.observe(containerRef.current);\n    \n    return () => {\n      observer.disconnect();\n    };\n  }, [isVisible]);\n  \n  // Initialize stars and constellations when dimensions are available\n  useEffect(() => {\n    if (!dimensions.width || !dimensions.height) return;\n    \n    // Create stars\n    const stars = [];\n    const starCount = starDensity;\n    \n    for (let i = 0; i < starCount; i++) {\n      // Generate star positions in a slightly larger area to allow for movement\n      const margin = 100; // Extra margin to allow stars to move in\n      \n      stars.push({\n        x: Math.random() * (dimensions.width + 2 * margin) - margin,\n        y: Math.random() * (dimensions.height + 2 * margin) - margin,\n        size: Math.random() * (starMaxSize - starMinSize) + starMinSize,\n        brightness: 0.3 + Math.random() * 0.7,\n        twinkleSpeed: 0.002 + Math.random() * 0.008,\n        twinklePhase: Math.random() * Math.PI * 2,\n        flareProb: Math.random() * 0.005 // Probability for this star to flare\n      });\n    }\n    \n    starsRef.current = stars;\n    \n    // Create constellations\n    const constellations = [];\n    const constellationStarIndices = new Set(); // Track used stars\n    \n    for (let i = 0; i < constellationCount; i++) {\n      // Pick a random center star not already in a constellation\n      let availableStars = stars.filter((_, index) => !constellationStarIndices.has(index));\n      \n      // If no available stars, break\n      if (availableStars.length === 0) break;\n      \n      // Choose center star near the middle of the visible area\n      const centerIndex = stars.indexOf(\n        availableStars[Math.floor(Math.random() * Math.min(availableStars.length, 30))]\n      );\n      \n      constellationStarIndices.add(centerIndex);\n      \n      const centerStar = stars[centerIndex];\n      const constPoints = [centerIndex];\n      const constConnections = [];\n      \n      // Find nearby stars for this constellation (4-7 stars)\n      const numStars = 4 + Math.floor(Math.random() * 4);\n      const maxDist = Math.min(dimensions.width, dimensions.height) * 0.2;\n      \n      // Find candidates\n      const candidates = [];\n      for (let j = 0; j < stars.length; j++) {\n        if (constellationStarIndices.has(j)) continue;\n        \n        const star = stars[j];\n        const dist = Math.hypot(star.x - centerStar.x, star.y - centerStar.y);\n        \n        if (dist < maxDist) {\n          candidates.push({ index: j, distance: dist });\n        }\n      }\n      \n      // Sort by distance and take closest ones\n      candidates.sort((a, b) => a.distance - b.distance);\n      \n      // Create a more natural constellation pattern\n      const usedStars = candidates.slice(0, numStars);\n      for (const starData of usedStars) {\n        constPoints.push(starData.index);\n        constellationStarIndices.add(starData.index);\n        \n        // Connect to closest star that's already in the constellation\n        let minDist = Infinity;\n        let closestPoint = centerIndex;\n        \n        for (const pointIndex of constPoints) {\n          if (pointIndex === starData.index) continue;\n          \n          const pointStar = stars[pointIndex];\n          const currentStar = stars[starData.index];\n          const dist = Math.hypot(pointStar.x - currentStar.x, pointStar.y - currentStar.y);\n          \n          if (dist < minDist) {\n            minDist = dist;\n            closestPoint = pointIndex;\n          }\n        }\n        \n        constConnections.push([closestPoint, starData.index]);\n        \n        // Occasionally add a second connection for more interesting shapes\n        if (Math.random() < 0.3 && constPoints.length > 3) {\n          let secondConnections = constPoints.filter(p => \n            p !== starData.index && p !== closestPoint);\n          \n          if (secondConnections.length > 0) {\n            const secondPoint = secondConnections[\n              Math.floor(Math.random() * secondConnections.length)\n            ];\n            \n            constConnections.push([secondPoint, starData.index]);\n          }\n        }\n      }\n      \n      // Create constellation with fixed offset to maintain shape\n      const offsets = [];\n      for (const pointIndex of constPoints) {\n        const star = stars[pointIndex];\n        offsets.push({\n          x: star.x - centerStar.x,\n          y: star.y - centerStar.y\n        });\n      }\n      \n      constellations.push({\n        centerIndex,\n        points: constPoints,\n        connections: constConnections,\n        offsets,\n        opacity: Math.random() * 0.3 + 0.4, // Varying base opacity\n        pulseSpeed: 0.0002 + Math.random() * 0.0003,\n        pulsePhase: Math.random() * Math.PI * 2\n      });\n    }\n    \n    constellationsRef.current = constellations;\n  }, [dimensions, starDensity, starMaxSize, starMinSize, constellationCount]);\n  \n  // Create a twinkle effect\n  const createTwinkleEffect = (star) => {\n    if (twinkleEffectsRef.current.length > 15) return; // Limit concurrent effects\n    \n    twinkleEffectsRef.current.push({\n      x: star.x,\n      y: star.y,\n      size: star.size * (1.2 + Math.random() * 0.5),\n      brightness: star.brightness * (1.3 + Math.random()),\n      life: 1.0,\n      decay: 0.01 + Math.random() * 0.02\n    });\n  };\n  \n  // Create a burst effect\n  const createBurstEffect = (x, y, size) => {\n    if (burstEffectsRef.current.length > 10) return; // Limit concurrent effects\n    \n    const particleCount = Math.floor(4 + Math.random() * 6);\n    \n    for (let i = 0; i < particleCount; i++) {\n      const angle = Math.random() * Math.PI * 2;\n      const speed = 0.05 + Math.random() * 0.15;\n      \n      burstEffectsRef.current.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        size: size * (0.3 + Math.random() * 0.3),\n        life: 1.0,\n        decay: 0.006 + Math.random() * 0.008,\n        damping: 0.98 + Math.random() * 0.01\n      });\n    }\n  };\n  \n  // FPS limiter for consistent animation speed\n  const fpsLimiter = (timestamp, callback) => {\n    // Skip animation if hidden, inactive, or reduced motion\n    if (!isVisible || !active || (respectReducedMotion && prefersReducedMotion)) {\n      animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n      return;\n    }\n    \n    const targetFrameTime = 1000 / maxFPS;\n    const elapsed = timestamp - lastTimestampRef.current;\n    \n    if (elapsed >= targetFrameTime || lastTimestampRef.current === 0) {\n      // Calculate delta time\n      const delta = lastTimestampRef.current === 0 ? 16 : elapsed;\n      \n      // Update timestamp\n      lastTimestampRef.current = timestamp;\n      \n      // Run animation callback with capped delta time\n      callback(Math.min(delta, 50));\n      \n      // FPS tracking\n      frameCountRef.current++;\n      if (timestamp - fpsTimestampRef.current >= 1000) {\n        frameCountRef.current = 0;\n        fpsTimestampRef.current = timestamp;\n      }\n    }\n    \n    // Schedule next frame\n    animationFrameRef.current = requestAnimationFrame(time => fpsLimiter(time, callback));\n  };\n  \n  // Update star and constellation positions\n  const updatePositions = (deltaTime) => {\n    // Normalize time delta for consistent speed across devices\n    const timeScale = deltaTime / 16;\n    \n    // Update world position\n    worldPositionRef.current.x += horizontalMovementSpeed * timeScale;\n    worldPositionRef.current.y += verticalMovementSpeed * timeScale;\n    \n    // Update stars\n    for (const star of starsRef.current) {\n      // Apply twinkle effect\n      const time = performance.now() * 0.001;\n      star.currentBrightness = star.brightness * \n        (0.7 + 0.3 * Math.pow(Math.sin(time * star.twinkleSpeed + star.twinklePhase) * 0.5 + 0.5, 1.5));\n      \n      // Random chance for twinkle effect\n      if (Math.random() < star.flareProb * timeScale) {\n        createTwinkleEffect(star);\n      }\n      \n      // Very rare chance for burst effect\n      if (Math.random() < rareEffectProbability * timeScale) {\n        createBurstEffect(star.x, star.y, star.size * 2);\n      }\n    }\n    \n    // Update twinkle effects\n    for (let i = twinkleEffectsRef.current.length - 1; i >= 0; i--) {\n      const twinkle = twinkleEffectsRef.current[i];\n      \n      // Update life\n      twinkle.life -= twinkle.decay * timeScale;\n      \n      // Remove expired effects\n      if (twinkle.life <= 0) {\n        twinkleEffectsRef.current.splice(i, 1);\n      }\n    }\n    \n    // Update burst effects\n    for (let i = burstEffectsRef.current.length - 1; i >= 0; i--) {\n      const burst = burstEffectsRef.current[i];\n      \n      // Update position\n      burst.x += burst.vx * timeScale;\n      burst.y += burst.vy * timeScale;\n      \n      // Apply damping\n      burst.vx *= burst.damping;\n      burst.vy *= burst.damping;\n      \n      // Update life\n      burst.life -= burst.decay * timeScale;\n      \n      // Remove expired effects\n      if (burst.life <= 0) {\n        burstEffectsRef.current.splice(i, 1);\n      }\n    }\n    \n    // Update constellations\n    for (const constellation of constellationsRef.current) {\n      // Update pulsing opacity\n      const time = performance.now() * 0.001;\n      const pulseFactor = Math.sin(time * constellation.pulseSpeed + constellation.pulsePhase) * 0.1 + 0.9;\n      constellation.currentOpacity = constellation.opacity * pulseFactor;\n    }\n  };\n  \n  // Render stars and constellations\n  const renderScene = () => {\n    if (!canvasRef.current) return;\n    \n    const ctx = canvasRef.current.getContext('2d');\n    if (!ctx) return;\n    \n    const { width, height } = dimensions;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    // Get stars and constellations\n    const stars = starsRef.current;\n    const constellations = constellationsRef.current;\n    \n    // Apply global offset to everything\n    const globalOffsetX = worldPositionRef.current.x;\n    const globalOffsetY = worldPositionRef.current.y;\n    \n    // Render constellations first (behind stars)\n    for (const constellation of constellations) {\n      const centerStar = stars[constellation.centerIndex];\n      if (!centerStar) continue;\n      \n      // Calculate constellation center with global movement\n      const centerX = (centerStar.x - globalOffsetX) % width;\n      const centerY = (centerStar.y - globalOffsetY) % height;\n      \n      // Adjust for wrap-around\n      const constCenterX = centerX < 0 ? centerX + width : centerX;\n      const constCenterY = centerY < 0 ? centerY + height : centerY;\n      \n      // Draw constellation lines\n      ctx.strokeStyle = getCachedColor(constellationLineColor, constellation.currentOpacity);\n      ctx.lineWidth = 0.5;\n      \n      // Enable glow effect\n      ctx.shadowColor = getCachedColor(constellationLineColor, constellation.currentOpacity * 0.5);\n      ctx.shadowBlur = 3;\n      \n      // Render each connection\n      ctx.beginPath();\n      for (const [fromIdx, toIdx] of constellation.connections) {\n        const fromPointIndex = constellation.points.indexOf(fromIdx);\n        const toPointIndex = constellation.points.indexOf(toIdx);\n        \n        if (fromPointIndex === -1 || toPointIndex === -1) continue;\n        \n        // Calculate positions based on offsets from center to maintain shape\n        const fromOffset = constellation.offsets[fromPointIndex];\n        const toOffset = constellation.offsets[toPointIndex];\n        \n        const fromX = constCenterX + fromOffset.x;\n        const fromY = constCenterY + fromOffset.y;\n        const toX = constCenterX + toOffset.x;\n        const toY = constCenterY + toOffset.y;\n        \n        ctx.moveTo(fromX, fromY);\n        ctx.lineTo(toX, toY);\n      }\n      ctx.stroke();\n      \n      // Reset shadow for better performance\n      ctx.shadowBlur = 0;\n      \n      // Draw constellation vertices with a subtle glow\n      ctx.fillStyle = getCachedColor(constellationVertexColor, constellation.currentOpacity);\n      \n      for (let i = 0; i < constellation.points.length; i++) {\n        const offset = constellation.offsets[i];\n        const x = constCenterX + offset.x;\n        const y = constCenterY + offset.y;\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 1, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n    \n    // Render stars\n    for (const star of stars) {\n      // Apply global movement to star position\n      const x = (star.x - globalOffsetX) % width;\n      const y = (star.y - globalOffsetY) % height;\n      \n      // Adjust for wrap-around\n      const renderX = x < 0 ? x + width : x;\n      const renderY = y < 0 ? y + height : y;\n      \n      // Skip if not visible\n      if (renderX < -10 || renderX > width + 10 || \n          renderY < -10 || renderY > height + 10) {\n        continue;\n      }\n      \n      // Draw star with glow\n      // Star glow\n      ctx.beginPath();\n      ctx.fillStyle = getCachedColor(starGlowColor, star.currentBrightness * 0.5);\n      ctx.arc(renderX, renderY, star.size * 1.5, 0, Math.PI * 2);\n      ctx.fill();\n      \n      // Star core\n      ctx.beginPath();\n      ctx.fillStyle = getCachedColor(starColor, star.currentBrightness);\n      ctx.arc(renderX, renderY, star.size * 0.6, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    \n    // Render twinkle effects\n    ctx.shadowColor = starGlowColor;\n    for (const twinkle of twinkleEffectsRef.current) {\n      const x = (twinkle.x - globalOffsetX) % width;\n      const y = (twinkle.y - globalOffsetY) % height;\n      \n      // Adjust for wrap-around\n      const renderX = x < 0 ? x + width : x;\n      const renderY = y < 0 ? y + height : y;\n      \n      // Skip if not visible\n      if (renderX < -10 || renderX > width + 10 || \n          renderY < -10 || renderY > height + 10) {\n        continue;\n      }\n      \n      // Draw twinkle with glow\n      ctx.shadowBlur = twinkle.size * 2 * twinkle.life;\n      \n      // Outer glow\n      ctx.beginPath();\n      ctx.fillStyle = getCachedColor(starGlowColor, twinkle.brightness * 0.4 * twinkle.life);\n      ctx.arc(renderX, renderY, twinkle.size * 1.5 * twinkle.life, 0, Math.PI * 2);\n      ctx.fill();\n      \n      // Inner bright core\n      ctx.beginPath();\n      ctx.fillStyle = getCachedColor(starColor, twinkle.brightness * twinkle.life);\n      ctx.arc(renderX, renderY, twinkle.size * 0.7 * twinkle.life, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    \n    // Render burst effects (golden particles)\n    ctx.shadowColor = burstColor;\n    for (const burst of burstEffectsRef.current) {\n      // Draw burst particle with gold color\n      ctx.shadowBlur = burst.size * 1.5 * burst.life;\n      \n      ctx.beginPath();\n      ctx.fillStyle = getCachedColor(burstColor, 0.7 * burst.life);\n      ctx.arc(burst.x, burst.y, burst.size * burst.life, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    \n    // Reset shadow\n    ctx.shadowBlur = 0;\n  };\n  \n  // Main animation handler\n  const handleAnimation = (deltaTime) => {\n    // Skip if component is not ready\n    if (!canvasRef.current || !isInitialized || \n        !dimensions.width || !dimensions.height) return;\n    \n    // Update positions\n    updatePositions(deltaTime);\n    \n    // Render the scene\n    renderScene();\n  };\n  \n  // Main animation loop\n  useEffect(() => {\n    if (!active || !isInitialized || !dimensions.width || !dimensions.height) {\n      return;\n    }\n    \n    // Start animation\n    animationFrameRef.current = requestAnimationFrame(timestamp => {\n      fpsLimiter(timestamp, handleAnimation);\n    });\n    \n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [active, isInitialized, dimensions]);\n  \n  // Apply reduced motion adjustments\n  const reducedMotionStyles = useMemo(() => {\n    if (prefersReducedMotion && respectReducedMotion) {\n      return {\n        animation: 'none',\n        transition: 'none'\n      };\n    }\n    return {};\n  }, [prefersReducedMotion, respectReducedMotion]);\n  \n  return (\n    <div \n      ref={containerRef}\n      style={{ \n        position: 'absolute',\n        top: 0, \n        left: 0, \n        width, \n        height,\n        overflow: 'hidden', \n        pointerEvents: 'none', \n        zIndex,\n        ...reducedMotionStyles,\n        // Hardware acceleration\n        transform: 'translateZ(0)',\n      }}\n      aria-hidden=\"true\"\n    >\n      <canvas \n        ref={canvasRef} \n        style={{ \n          position: 'absolute', \n          top: 0, \n          left: 0, \n          width: '100%', \n          height: '100%',\n          // Hardware acceleration\n          transform: 'translateZ(0)',\n        }} \n      />\n    </div>\n  );\n};\n\n/**\n * Gold-themed Stellar Background Preset\n */\nexport const GoldenStellarBackground = (props) => {\n  const goldenPreset = {\n    starDensity: 170,\n    starMaxSize: 1.8,\n    starMinSize: 0.4,\n    constellationCount: 4,\n    horizontalMovementSpeed: 0.04,\n    verticalMovementSpeed: 0.01,\n    starColor: 'rgba(255, 250, 240, 0.85)',\n    starGlowColor: 'rgba(255, 250, 220, 0.3)',\n    constellationLineColor: 'rgba(207, 181, 59, 0.15)',\n    constellationVertexColor: 'rgba(207, 181, 59, 0.4)',\n    burstColor: 'rgba(207, 181, 59, 0.7)'\n  };\n  \n  return <StellarBackground {...goldenPreset} {...props} />;\n};\n\nexport default StellarBackground;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}